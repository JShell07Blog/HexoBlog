{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1562566567584},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1562566567584},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1562566567584},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1562566567584},{"_id":"themes/next/.gitignore","hash":"515ef6dc5f0b6a692640857ecf5aecdb8781993d","modified":1562566567584},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1562566567584},{"_id":"themes/next/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1562566567584},{"_id":"themes/next/README.md","hash":"ca711f92e985183030de7b7fcc6efd9018c638b8","modified":1562566567584},{"_id":"themes/next/_config.yml","hash":"f5ab46c31808b0c3fbe348b256fe336d9f43abec","modified":1562566567584},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1562566567584},{"_id":"themes/next/bower.json","hash":"72d7f5ef565cca1da30ba64fc04075b9ac99e319","modified":1562566567584},{"_id":"themes/next/gulpfile.coffee","hash":"67eaf2515100971f6195b60eeebbfe5e8de895ab","modified":1562566567600},{"_id":"themes/next/package.json","hash":"735ace0b7fe3b1171c220c5424fcd4fe3aadd7f8","modified":1562566567647},{"_id":"themes/next/LICENSE.md","hash":"f0190c7d83a98464549a6b3a51bb206148d88e1b","modified":1562566567584},{"_id":"source/_posts/1002-And-1018.md.bp","hash":"9d4b2ec8dc59d320822e36d68f83b3396f557602","modified":1562566567553},{"_id":"source/_posts/C-UML.md","hash":"70f1d1e5fa7fd47a6ae3668d4704130f3927d689","modified":1565093504232},{"_id":"source/_posts/Better-Man.md","hash":"f19ff08f76811fb09848d6661c3fb961a5f2119a","modified":1562566567569},{"_id":"source/_posts/Debug-high-cpu-loading.md","hash":"a11f93d597663a48411e225ff5ae6caaceed4bee","modified":1562566567569},{"_id":"source/_posts/Design-Pattern-II.md","hash":"1bc66c931576e8ad02ab92437c8d56885d89ecce","modified":1562566567569},{"_id":"source/_posts/Design-Pattern-III.md","hash":"b57dc6bf195cf756f3aacddacf4887218d12eafd","modified":1562566567569},{"_id":"source/_posts/Design-Pattern-IV.md","hash":"1d675f476feb7fc9ce792813188752aed2a341be","modified":1562566567569},{"_id":"source/_posts/Design-Pattern.md","hash":"fc8d185725848a3e507158ab2a244987bb537dc1","modified":1562566567569},{"_id":"source/_posts/Docker.md","hash":"674c17fda59cbdfc8ba5397ac209653cb457de80","modified":1562566567569},{"_id":"source/_posts/Lighttpd support fcgi(python) and luci.md","hash":"605b67adac6aef574586546e6c85ec8ae0c97ab9","modified":1562566567569},{"_id":"source/_posts/Linux-Flash.md","hash":"5ecc91f86b04dca4e19df7ea402965dcc8147837","modified":1583908905025},{"_id":"source/_posts/TED-Notes.md","hash":"c8758a05d8eb4e74fb3b7fb4021d84feb9cac3e1","modified":1562566567569},{"_id":"source/_posts/WebRTC 如何避免拥塞.md","hash":"d66687597bc270ed8f5023434826a0edcaa09e0b","modified":1562566567569},{"_id":"source/_posts/WebRTC-Best-Relay-Network-Selection.md","hash":"f8bbb82a854e08d680c18bb012f6cf18fc48fb40","modified":1562566567569},{"_id":"source/_posts/WebRTC-Congestion-Control.md","hash":"c9fe4bbed4b51b5c1183bae2b57cde7f6cd0418a","modified":1562566567569},{"_id":"source/_posts/arm-generic-timer.md","hash":"3f39f7277cddbd2f01f0df5094c96a8b4a8eebbd","modified":1574994812535},{"_id":"source/_posts/arm_arm.md","hash":"258191840e08d0e80f0868842dcb58fde05d6c96","modified":1562566567569},{"_id":"source/_posts/boot-time-optimization.md","hash":"dd0a97e25cddebdceaacf3864d4cc3bcc287da66","modified":1586427865582},{"_id":"source/_posts/bootchart.md","hash":"2793dcd0a368becf5770f964bc90f54728468f3d","modified":1586427652077},{"_id":"source/_posts/bootloader.md","hash":"4018aaae32489c2cc9df1085ee681da0647e3e26","modified":1562566567569},{"_id":"source/_posts/buildbot.md","hash":"0551fe69949dd4fd1859c73e6d0b8b7074fa1063","modified":1562566567569},{"_id":"source/_posts/hello-world.md","hash":"2f2bb5aa855e2f0749c272ac496eb92e0ce17938","modified":1562566567569},{"_id":"source/_posts/bootgraph.md","hash":"bf2cb22618a08828763103c1d29e624d91b7a090","modified":1586427649914},{"_id":"source/_posts/hexo-add-search.md","hash":"5a94a4a37aee8061ff10e024ad60842e3837670e","modified":1562566567569},{"_id":"source/_posts/incr-zsh.md","hash":"b540cb94ac3ad4608b7d0b3ea047b08f49c7afff","modified":1562566567569},{"_id":"source/_posts/ipv6.md","hash":"adb0727f6351aac168fd89ed547ba629f81d0fa3","modified":1563761650381},{"_id":"source/_posts/kernel-crypto-II.md","hash":"b18cfb6073fee009510cd723ac155b4fbd063721","modified":1566811980682},{"_id":"source/_posts/kernel-crypto-III.md","hash":"89cef285caf4a31c06af121123a85ed28ee78a0b","modified":1566453108821},{"_id":"source/_posts/kernel-dma-mem.md","hash":"ae0fb2fc1a9b3a87e4ae59f59b967113425db5df","modified":1562566567569},{"_id":"source/_posts/kernel-mm-base.md","hash":"4713c3a08577604ccda8e2f196ca8187edea0f7b","modified":1583313262999},{"_id":"source/_posts/kernel-crypto-I.md","hash":"20c13775b9f06b3648d6c052fee85137635e00dc","modified":1565160784614},{"_id":"source/_posts/kernel-mm-cache.md","hash":"2f1e113ebf7c235894dceee3966f81d213cca227","modified":1584002678792},{"_id":"source/_posts/kernel-mtd.md","hash":"6508339e24f5e5a1bd88f35a4523d7a40c95726a","modified":1583895841588},{"_id":"source/_posts/kernel-source-code-online.md","hash":"61a63e41ecb4c68548f8da3942af5b03352bd4b3","modified":1566531828918},{"_id":"source/_posts/kernel-tickless-idle.md","hash":"45596ed4c159ac95554b3b2ec8cb6390cce2f56c","modified":1586944287832},{"_id":"source/_posts/kernel-timer-system.md","hash":"3d06d9ecc9bb48d27c9a029f2aa3380b193377dc","modified":1583908340832},{"_id":"source/_posts/kernel-tlb.md","hash":"5158ce60836f55fe7cebae5ad26d91c6d6ca491d","modified":1584003382775},{"_id":"source/_posts/kernel-tty.md","hash":"9b3862ab4f3fbbff9f4e1802f9dbbfeeeedc6570","modified":1581949516627},{"_id":"source/_posts/kernel-ubi.md","hash":"3829bc26112810ced9abbe66e7fc801d141e2198","modified":1574148539978},{"_id":"source/_posts/kernel-ubifs-design.md","hash":"3aadd6e1190160378a71a3dcd2760e52dd6bb64f","modified":1574153216930},{"_id":"source/_posts/kernel-virtual-addr-map.md","hash":"2b0d292c8c2436edd02e6d9d3c69eb866d97038d","modified":1565093562666},{"_id":"source/_posts/kernel-slub.md","hash":"41e3e8256aa5827f07d144e619359bce60148281","modified":1586944652176},{"_id":"source/_posts/kernel-zero-copy.md","hash":"15e3f9cca7608df6165f87cde7b9b9a2104e3453","modified":1566812710282},{"_id":"source/_posts/kernel_mm.md.bp","hash":"6e221d008477613f497190d8b1f0774b23f941b4","modified":1583461151862},{"_id":"source/_posts/measure-cpu-loading-by-proc-stat.md","hash":"d94771035a6a7db464b709a67f9040453fc88759","modified":1586512196200},{"_id":"source/_posts/more-coding-more-happy.md","hash":"7e3dc6d7663e15ef19d71d01d37bb17014808cbd","modified":1562566567569},{"_id":"source/_posts/openwrt-ssh.md","hash":"989b53e5a0c4faaec5a4ad39b03c2b316601ec13","modified":1562566567569},{"_id":"source/_posts/ssh-of-openwrt.md","hash":"e9ea08805777140f178bc859b171885dd61555d4","modified":1562566567569},{"_id":"source/_posts/the Siege webserver test tool.md","hash":"e5afde4ff2fbb94a74c220874dc8d5917affdc0e","modified":1562566567569},{"_id":"source/_posts/webrtc-directory-analyze.md","hash":"3f7f0a76bf2ded90bdad249f39c7f2abfba8b2bd","modified":1562566567569},{"_id":"source/_posts/webRTCDirectory.md","hash":"1c98e14b6be10d5b4524feb5a0f7cd29a48d88ac","modified":1562566567569},{"_id":"source/_posts/人性的弱点.md","hash":"9dce6b62fd6efaf95278e850b3314355c910c56c","modified":1568117035082},{"_id":"source/_posts/买车记录.md","hash":"6440620d124124a4e399829a13bb2ddb742ca60d","modified":1562566567569},{"_id":"source/_posts/大脑整理术.md","hash":"a8b2526fc3436bdb2d708c8b71d6f0cb524240de","modified":1581947813305},{"_id":"source/_posts/史蒂夫-乔布斯传.md","hash":"7b99fec2ad1632cde1bc5adf054d367fee215473","modified":1562566567569},{"_id":"source/_posts/学习索引.md","hash":"4cac5fc1d087a635cf9d466ed9f3cec081325b94","modified":1586945014445},{"_id":"source/_posts/年轻人如何独立思考.md","hash":"c95a5a6ab52852a51e2de3b8137ad679b7dc309a","modified":1562566567584},{"_id":"source/_posts/富甲美国：沃尔玛创始人山姆-沃尔顿自传.md","hash":"0815cb171a8306541b8023d289a798f40970267a","modified":1562566567569},{"_id":"source/_posts/快速阅读术.md","hash":"f4c7d0e7641828f8ed9538d2890a4dcdde1508d1","modified":1562566567584},{"_id":"source/_posts/我的读书.md","hash":"d4c37e0d744db38f8110715a926f9c29e97ad9dd","modified":1583400961690},{"_id":"source/_posts/把时间当做朋友听书笔记.md","hash":"e177a2052ea3cd763d30e0dc36d292e50f045e56","modified":1562566567584},{"_id":"source/_posts/挪威的森林.md","hash":"5344286c5c16ac68b9e55d49e5210a3ff18f5c8f","modified":1566906203980},{"_id":"source/_posts/敏捷软件开发原则与模式及实践.md","hash":"431cd4ea46ac72352a03d292c0d0f32c02f70c6c","modified":1562566567584},{"_id":"source/_posts/李开复自传.md","hash":"32724be2c0b89512d04841ff87a7ef6974bc124f","modified":1567135820315},{"_id":"source/_posts/程序员40岁后该如何发展.md","hash":"5562eac941ddbf2c8e7863de0a203b2fb9bc5287","modified":1575375866910},{"_id":"source/_posts/程序员未来的考虑.md","hash":"7394c2b4799fa9047fb2aff5846f8cb465532455","modified":1562566567584},{"_id":"source/_posts/穷查理宝典.md","hash":"397e67406dcf4f46a7d3e31c6b63a25e8d739ac6","modified":1582011664833},{"_id":"source/_posts/老子是癞蛤蟆书摘.md","hash":"d22e6d35e122a0d4b1e9c0f92532d3411bcb77d3","modified":1562566567584},{"_id":"source/_posts/褚时健传.md","hash":"5de009f87786cb50d11a3fe5ef048450c091ffbb","modified":1562566567584},{"_id":"source/_posts/财务自由之路.md","hash":"f9f6f398a449c06d515693714298164dd614ae08","modified":1562566567584},{"_id":"source/_posts/钱：7步创造终生收入.md","hash":"883616b12a1dd480d2c28dc09768bdebe879989c","modified":1562566567584},{"_id":"source/categories/index.md","hash":"05c979e55e3ec5fbf4b541c8905a2017ade23266","modified":1562566567584},{"_id":"source/tags/index.md","hash":"06db25f84a9c92d0eafaaf3ddda87f4528d4589b","modified":1562566567584},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"22f2ccc5522563b67c8663849fc1d6cbae93a8ff","modified":1562566567584},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"1e212fe229bd659726b4a3bcf4b5b14e0310ba3a","modified":1562566567584},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"869dcd36524e2c61ddd2315c1266edca7f0da6c9","modified":1562566567584},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"36201119490a04107c8179b10202548a9d0e5e60","modified":1562566567584},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1562566567584},{"_id":"themes/next/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1562566567584},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1562566567584},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"1dada3c3404445a00367882b8f97cdf092b7943d","modified":1562566567584},{"_id":"themes/next/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1562566567584},{"_id":"themes/next/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1562566567584},{"_id":"themes/next/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1562566567584},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"f2fd611a84dd6f9ed5395b63e187e29e9effbcd3","modified":1562566567584},{"_id":"themes/next/docs/LICENSE","hash":"5b702310012d480b40529fd10cf1872f687277a0","modified":1562566567600},{"_id":"themes/next/docs/MATH.md","hash":"34a46ca9a05b4570903beaadd4807e6759afb52e","modified":1562566567600},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1562566567600},{"_id":"themes/next/languages/de.yml","hash":"641e49587d41bb87e4d5932dc3d975754ded7953","modified":1562566567600},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1562566567600},{"_id":"themes/next/languages/fr.yml","hash":"ebcd1f188af8c3f5ef1f0923e794c839fbfae2d4","modified":1562566567600},{"_id":"themes/next/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1562566567600},{"_id":"themes/next/languages/id.yml","hash":"9709a4dbacc56a1571a96b139b872128d6959e90","modified":1562566567600},{"_id":"themes/next/languages/it.yml","hash":"4e3adeb10c0fa627935d69ae1783ce0894f5dee5","modified":1562566567600},{"_id":"themes/next/languages/ja.yml","hash":"7836f1de1f383d3a53770a03498cc39a37674f0c","modified":1562566567600},{"_id":"themes/next/languages/ko.yml","hash":"33e065ceb21590b8eb32430a69e76c2f057eb758","modified":1562566567600},{"_id":"themes/next/languages/nl.yml","hash":"060efc260c1c529469d739d97dcee79683e8f411","modified":1562566567600},{"_id":"themes/next/languages/pt-BR.yml","hash":"dc09e290e908744ca28e093dbdd859ca2a20290e","modified":1562566567600},{"_id":"themes/next/languages/pt.yml","hash":"53e2a52b9d5dc20c04080acd4f5b954e8699780f","modified":1562566567600},{"_id":"themes/next/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1562566567600},{"_id":"themes/next/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1562566567600},{"_id":"themes/next/languages/vi.yml","hash":"e2b3b18359ab41d58c64b2002acfedd60a7505a4","modified":1562566567616},{"_id":"themes/next/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1562566567616},{"_id":"themes/next/languages/zh-CN.yml","hash":"069f15da910d6f9756be448167c07ea5aa5dc346","modified":1562566567616},{"_id":"themes/next/layout/_layout.swig","hash":"4a3e7ebb0d4f88a64e919695aa4272221fe88347","modified":1562566567616},{"_id":"themes/next/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1562566567616},{"_id":"themes/next/layout/archive.swig","hash":"4b53070008775ecfd03953bd1b4adfcb0fabcaac","modified":1562566567647},{"_id":"themes/next/layout/category.swig","hash":"f0e3338bfa5efb205d2c28e635e9611f1fff3b55","modified":1562566567647},{"_id":"themes/next/layout/index.swig","hash":"9257f8c35b1eeb3dbc3eb8e7c791620d9ce931f3","modified":1562566567647},{"_id":"themes/next/layout/page.swig","hash":"9ddf40303f82e3db76d59dc82b6d4eadfed203c6","modified":1562566567647},{"_id":"themes/next/layout/post.swig","hash":"ce227737a6273c6ba729fa426418ec3f9722fdb4","modified":1562566567647},{"_id":"themes/next/layout/schedule.swig","hash":"d99b9eff0cff38caf095445f27c08aaf11a5b862","modified":1562566567647},{"_id":"themes/next/layout/tag.swig","hash":"7cda2822e50b9fee9848a6b81e6c2d1aca830aeb","modified":1562566567647},{"_id":"themes/next/scripts/helpers.js","hash":"c91522de30a85cd36b3547ad3446c34e4ba618ef","modified":1562566567647},{"_id":"themes/next/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1562566567647},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1562566567647},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1562566567740},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1562566567740},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1562566567740},{"_id":"source/_posts/arm_gic.md","hash":"2e22ae5e912f89c05e6899f6ab2c11afae158fb5","modified":1562566567569},{"_id":"source/_posts/.vscode/cscope_conf.json","hash":"a5d5a42368756598533f2c2cf0e1d7e78fee4acb","modified":1562566567553},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562566567725},{"_id":"source/_posts/arm_arm_part_B.md","hash":"2966effffb2ec7dc4660112a5ca4c4b461a0002c","modified":1562566567569},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1562566567600},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1562566567600},{"_id":"themes/next/docs/ru/README.md","hash":"a78a155885ce23f924cd194b8c69fe7f2ffea8d0","modified":1562566567600},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1562566567600},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"e771c5b745608c6fb5ae2fa1c06c61b3699627ec","modified":1562566567600},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"9b512cb820627fcc45c9f77c7a122aa99e021bd5","modified":1562566567600},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"f2a2d6e68c5f65e27303b40f5285a8a4a5adae4c","modified":1562566567600},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1562566567600},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1562566567600},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"7214fcd1b5830e62b3ac0836ad2d1b0fa391ae12","modified":1562566567600},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"4d68054b062b3c8404b146a155d9624d2d25dd9b","modified":1562566567600},{"_id":"themes/next/docs/zh-CN/README.md","hash":"a4d2c1f90d5bd1d54f92b39b47ff85b1fe8b4e81","modified":1562566567600},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"1ec7a0e9ac64b2c84aa1fd7ba2c662be1dbcb407","modified":1562566567600},{"_id":"themes/next/layout/_custom/head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1562566567616},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1562566567616},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1562566567616},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1562566567616},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"8ff97c3f4eb888207bdc50066053c97d890e0202","modified":1562566567616},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"e8dfb86eb62b9c2bc1435d6d1afa95d3b4c7b931","modified":1562566567616},{"_id":"themes/next/layout/_macro/post.swig","hash":"957ba3690dcac9b4f66270e3b13ea0116e14b9ef","modified":1562566567616},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56733f92352b891b0bb1baca293f68f6c8928b0b","modified":1562566567616},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"a9519b4f82aa516e516317d0447bf5c5c7ffb544","modified":1562566567616},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"7a9b687087793bf5e218cbc345214f927fa5601a","modified":1562566567616},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"27fb1d81151b9b79683e488579df19eee7e654d6","modified":1562566567631},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"f544e21883d249d5a341c684c97bd25831008f07","modified":1562566567631},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"f8c7e729ad6e72b4c705a2c5d5041589c2b4cc52","modified":1562566567631},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f134aeb8d5bee351e5277edb92ac694af314b75f","modified":1562566567631},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"4b48fdbfe3bf41ddeda4ff74c1ff17ab9f15c14e","modified":1562566567616},{"_id":"themes/next/layout/_partials/comments.swig","hash":"2e8c3df265e9ae38003d1321fb80fb3b12cb6a97","modified":1562566567616},{"_id":"themes/next/layout/_partials/footer.swig","hash":"215a6689bdb6a0fcf58ccb6c28e93d6864b7e00a","modified":1562566567616},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"206cbd6ac9ca6a219a8516f59beae25b3c770199","modified":1562566567616},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1562566567616},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"ed62ea83d3f2c9db2ea57bf23a7d765ed82504c2","modified":1562566567631},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"c62c37474c8de78cf34e54c6219b503ec28d9815","modified":1562566567647},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"53861f78a1fb52e96a43cf6909e1530dcf6cbff8","modified":1562566567647},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"736cb278fa09d3b4ed6f305b56353941ea918793","modified":1562566567647},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"debba9b7110f635204a15df148194d4c2fd2668b","modified":1562566567647},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"ccf0035086e14dcefa24c2907301edf4c37d5448","modified":1562566567647},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1562566567647},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1562566567647},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"a174d4a0c9188f9c4a2652f49bfa7a60ad0a83e3","modified":1562566567647},{"_id":"themes/next/scripts/tags/button.js","hash":"496e3846f353d253dad944b2ed8fdc4e02dcc28a","modified":1562566567647},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"5c87817385986748617fa87dee9cba654566adcd","modified":1562566567647},{"_id":"themes/next/scripts/tags/exturl.js","hash":"4f928ef9ad0ae8e3d766352b8861bc22f96de5d8","modified":1562566567662},{"_id":"themes/next/scripts/tags/full-image.js","hash":"2118895d2d5e379240b27399a6c988a74f25a427","modified":1562566567662},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"1f7bafba9cf3c94f5735873bd52e93ddcf37f8a2","modified":1562566567662},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"696157d4e4382fdbe29c674b0f4b433d47db449b","modified":1562566567662},{"_id":"themes/next/scripts/tags/label.js","hash":"d8bfb2974c6afef2c085642857b70b6569b4a097","modified":1562566567662},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"92c0ead5f503cfc4ee7c254ebfb00a2623fa1890","modified":1562566567662},{"_id":"themes/next/scripts/tags/note.js","hash":"1cec218c9fcaa8fb4144bf9d0b39babcaafac8d4","modified":1562566567662},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1562566567662},{"_id":"themes/next/source/css/main.styl","hash":"2a62e2a11e9cdcc69e538d856d6f9ce228a07c93","modified":1562566567725},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1562566567725},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1562566567725},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1562566567725},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1562566567725},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1562566567725},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1562566567725},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1562566567725},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1562566567725},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1562566567725},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1562566567725},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1562566567725},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1562566567725},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1562566567725},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1562566567725},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1562566567725},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1562566567725},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1562566567725},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1562566567725},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562566567631},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562566567631},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562566567694},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562566567694},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562566567694},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562566567709},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562566567709},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1562566567616},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"aab518204d3125e948796a9ba6b56b09cade2d92","modified":1562566567616},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"580e9d9c4d8783ee6200d845ae16c98979bf1ea3","modified":1562566567631},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1562566567631},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1562566567631},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1562566567616},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"0b8349710caf9691741a457aa746add35245048e","modified":1562566567616},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"09109a5c5a301e7cc5e3c7aec32b0164739fc7d4","modified":1562566567616},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"19050627bc23b0b2c2e65e7248c0f88468eb8ea5","modified":1562566567616},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1562566567616},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"f3ae3168801304af3d80ec3b84264e1d4201cb89","modified":1562566567616},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"3f11ae8e9084f39628cd2006931d39a2069b9dd6","modified":1562566567616},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"f6454c452b2e90a8c760321bce7e3dc6119b71fa","modified":1562566567616},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1562566567616},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1562566567616},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1562566567616},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1562566567631},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1562566567631},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1562566567631},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"c43f41b7f3c0743d1e673af2e787ea34a67fc9cb","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"d67d9a176a276cdab6f2bcb7eb3650fbca5459c4","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"cfc932c5db04fef64cc56d3ba0b8ddf3a15a63bd","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"7973b4741863362cd9d023216de4a43eb23dc227","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1562566567631},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1562566567631},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1562566567631},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"4a2d2269f23e90c1311bd867d22def0b4a092bf1","modified":1562566567631},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"292cdd1059b76d3d10486b71c99d9afb3e59ea44","modified":1562566567631},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"787d482d797c38e77d69629ebb88d45f972216b7","modified":1562566567631},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"18a58db53f1eef50462ee0065d4445b7fbb04fb5","modified":1562566567647},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"7cf0c589d95a2d1848266ffe2357e91c95d2e7f8","modified":1562566567647},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"de1fac9bb3f0cab88b1ed1950f76c7eb0037aeda","modified":1562566567647},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"ab181c036cda9656f87bb1a749e3e7cbc437f012","modified":1562566567647},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"30e9e55d9af2ced6e6b156a042026a8b480f0ab0","modified":1562566567647},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"860de4ce6fccc516d2f779a4b600a4214d8c18e2","modified":1562566567647},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"c0c2fd87e71f0beb542aa50c0bc875da5aa5c44b","modified":1562566567647},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1562566567647},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"71c897f9b107dd0de1b7f649633cf583c206a9db","modified":1562566567647},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1562566567647},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1562566567647},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1562566567694},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1562566567694},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"8aa98ae349908736ba43196c42498fd5bdeb780a","modified":1562566567694},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"4d6dd32dae6f0ea93d43c5cfa0106b6cb46c3b00","modified":1562566567694},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"8b5fc9e6621a5de04ae7d9ef117683c69965fb00","modified":1562566567709},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1562566567709},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"b89e68789e6dac24e00250528f4fc9ae8aa3599b","modified":1562566567709},{"_id":"themes/next/source/css/_variables/base.styl","hash":"534b9dec93f3e235c217b97314d4bf513fa3e5ba","modified":1562566567709},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1562566567725},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1562566567725},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"8e9ed6392620ba68726c0ade4868100d831daba8","modified":1562566567725},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1562566567725},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1562566567725},{"_id":"themes/next/source/js/src/motion.js","hash":"bea49fc6392bd38fb6f80d041d95d23051423aa2","modified":1562566567725},{"_id":"themes/next/source/js/src/post-details.js","hash":"02acfa1862d5e4345d6a7cee08841cc9e2fb0259","modified":1562566567725},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1562566567725},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1562566567725},{"_id":"themes/next/source/js/src/utils.js","hash":"bd22e8f524ba123b89ac7d10cdb2258ba7fe3fa5","modified":1562566567725},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1562566567740},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1562566567740},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1562566567740},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1562566567740},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6e076b5e183eedf425a445e99851f938789c3194","modified":1562566567647},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1562566567647},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1562566567678},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1562566567694},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"97bb39756e85f5b27bba7f43270105ad01d736c9","modified":1562566567694},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1562566567694},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1562566567694},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1562566567694},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1562566567694},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"52bc8ba71b91d954530b35dfc63b402a02b1321d","modified":1562566567694},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"c08eb379718fa5af267fd8c5fe9b926003c0c7c7","modified":1562566567694},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f3aa863adf972569b72f2df6bc6a914e7daace99","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa6c00fdaf8f0ca3b690a5a556671745fb67e2c9","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"2ccb9bdc309b7c1ef183a3dbb0a4621bec54a328","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"3cc7646583218d16925ced7b70865e63a901d4a7","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"b26f8a3394d8357a5bfd24d9f8bf62d7b4063ebb","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ab7eb1d66e300264a225feb6f8bed55683c96cdf","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"cc961108b12ab97d9216606ceb1cd1cd31ab20f0","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"df16dc995eb9ad498df2edcfc3e20528fc9aa133","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"be72740313a9a0477b8a22f62e4c8ffa6d23a2e5","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"a558803ca81cceae2bdc22c18ef638fcc023681b","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1562566567709},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1562566567725},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1562566567740},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7dd247c8869fdefb5a007045d00f3ef8ceecf300","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"3f3d2a43d1a326bad25b633c8ec9ddd87867224c","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"34f5ac3c1ed2dd31e9297cc4c0733e71bc2e252f","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"835c1340571bd6c4ec263c482cf13283fb047e49","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"630be616447a982413030e561bbd3a80ac14b120","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"ad4cae23c8e383f4fabc9a2a95bca6055020d22e","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1562566567662},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"317c9ceda655e9dc373ce8e7b71d20b794fce9a4","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"330c8884efb5612e7eb03986d87d29e8b0651974","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"82bc7fa5d38d98e98cc25f9a73189024fda25e63","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"adfd6d2d3b34adc4b476a0ea91e19020456a3b1a","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"1faeb3fca899df9d033e4e6ad9a4867cdce7ef9d","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"fa57ec9a6f1943c0558856dfba2d6b8faca0cd4d","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"debe322cc9e2688ecf38d0b6afcd6b71ad02fbd0","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"9e05a2232faabb41bcebb51d545d897a76f077da","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"94d76e6da600a36d80e2470326ebb6b3be447ccb","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"d79c051abb8ab7b5ee5da29a28587704fd5108f5","modified":1562566567678},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"f4d8144c22544bdb89787c14ab9d39578dae4b7c","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"acfdd76b1c90d2e384affb3d0006a39b524609d2","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"0b9c4140d7bc526553553552c3ed92da7c81e0b6","modified":1562566567694},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1562566567678},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1562566567709},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1562566567709},{"_id":"public/search.xml","hash":"19555a27465b6d3172640126afb5f1f1ee881f82","modified":1586945039237},{"_id":"public/categories/index.html","hash":"505ffaf51da6b10c015c93dbc7b65dbd7fb7d14b","modified":1586944368152},{"_id":"public/tags/index.html","hash":"b302db59ae3fc32f28ed00fc98b707212fcb8234","modified":1586944368182},{"_id":"public/2020/04/09/bootgraph/index.html","hash":"961843e7780a1972902b84ec6a06c0f9f14eb5c2","modified":1586944368182},{"_id":"public/2020/04/09/boot-time-optimization/index.html","hash":"7e3cdbab587f21d429c607432fe67fbec943997d","modified":1586944368182},{"_id":"public/2020/04/09/bootchart/index.html","hash":"3bdc01966cac14eb9f121714f79777abd702dc27","modified":1586944368182},{"_id":"public/2020/03/16/kernel-slub/index.html","hash":"3744022b35ad972c6b8a1872db87bd3814ddf099","modified":1586944684179},{"_id":"public/2020/03/04/kernel-mm-cache/index.html","hash":"64f1601608ecb52bb06cedbc94b2f29967569e9f","modified":1586944368183},{"_id":"public/2020/02/20/学习索引/index.html","hash":"9dd1ea3873b499677914605def8a722d05100ace","modified":1586945039322},{"_id":"public/2020/02/20/我的读书/index.html","hash":"eeccf3f1214b9a227958c6200703822437b545d3","modified":1586944368183},{"_id":"public/2020/02/17/kernel-tty/index.html","hash":"b12c7a986f8268e9247f1d7737b2baf255af11b0","modified":1586944368183},{"_id":"public/2019/11/28/kernel-timer-system/index.html","hash":"2abb6fbf87a23e3bb3da069b785ee74d61dbc28b","modified":1586944368183},{"_id":"public/2019/11/27/arm-generic-timer/index.html","hash":"a141919d867bff43b7438fc30f5f27a4e4c225c4","modified":1586944368183},{"_id":"public/2019/11/19/kernel-ubifs-design/index.html","hash":"44e73decc07dabba20222af1fceba3eb12e2bdd1","modified":1586944368183},{"_id":"public/2020/03/12/kernel-tlb/index.html","hash":"44f20c342f2cfd10aa7671c4428803f8dd0dea7b","modified":1586944368183},{"_id":"public/2019/09/05/人性的弱点/index.html","hash":"6d23abc1879965db1f30f5ae3b48e50fc6ee2ee0","modified":1586944368183},{"_id":"public/2020/03/04/kernel-mm-base/index.html","hash":"2cecc6eb415309574d54533e7b64f1830c240abb","modified":1586944368184},{"_id":"public/2019/08/28/李开复自传/index.html","hash":"929be05e2a6450fd1457cc5e55808935cccbd32a","modified":1586944368184},{"_id":"public/2019/08/27/穷查理宝典/index.html","hash":"e3457dc1b48767bd3789f647b92337ffd50c1c95","modified":1586944368184},{"_id":"public/2019/08/23/kernel-source-code-online/index.html","hash":"aa64dbcc8847d0802107c5e32e37bd68014c6761","modified":1586944368184},{"_id":"public/2019/08/21/kernel-zero-copy/index.html","hash":"7fba5c84d7a095440322f3474085b168535eba7e","modified":1586944368184},{"_id":"public/2019/08/07/kernel-crypto-III/index.html","hash":"9fe343b0e3f47b346856f7ea2a1468f668ed3358","modified":1586944368184},{"_id":"public/2019/08/06/kernel-crypto-II/index.html","hash":"3df6fdae884a61a3d007c8bcf46e2318eaada1e4","modified":1586944368184},{"_id":"public/2019/08/06/kernel-crypto-I/index.html","hash":"1d86abc59653d3bd10ca8e4966529eade741147d","modified":1586944368184},{"_id":"public/2020/04/10/measure-cpu-loading-by-proc-stat/index.html","hash":"da72b79602c54100ff71065345634c9dd64aa2a1","modified":1586944368184},{"_id":"public/2019/07/05/kernel-ubi/index.html","hash":"e101862bde7d8f8f3c7868e96ad51c40bedb97ce","modified":1586944368184},{"_id":"public/2019/08/27/挪威的森林/index.html","hash":"e8a901933a9a45eea32f0790fffa39c5743b6e08","modified":1586944368185},{"_id":"public/2019/07/04/hexo-add-search/index.html","hash":"62113867fc33c6db8c996b39816bbbb1373ec9f8","modified":1586944368185},{"_id":"public/2019/07/03/ipv6/index.html","hash":"c97246ddce7ff1641a0007b7f1201cfc1a4e0638","modified":1586944368185},{"_id":"public/2019/07/12/kernel-virtual-addr-map/index.html","hash":"589395b77be47c300db8c5c0b5ec8c9e27687436","modified":1586944368185},{"_id":"public/2019/07/02/buildbot/index.html","hash":"20935876eac2e16d12efecc0896652829bc2d22b","modified":1586944368185},{"_id":"public/2019/05/30/arm_arm_part_B/index.html","hash":"49d93a3ddb43ea28f0678d7045d5f0545f406e73","modified":1586944368185},{"_id":"public/2019/05/28/arm_arm/index.html","hash":"19d062afb5878952b2e70d8180a7005073dbad9a","modified":1586944368185},{"_id":"public/2019/05/12/钱：7步创造终生收入/index.html","hash":"20cc108c8142d3ac50688d598508bff00f82bb03","modified":1586944368185},{"_id":"public/2019/04/24/财务自由之路/index.html","hash":"3900c9c499948cb492b13bf4aa6d2b474ba98db5","modified":1586944368185},{"_id":"public/2019/04/20/arm_gic/index.html","hash":"32fa90caebc4f97e0bdb668cb14547437a2ea1c9","modified":1586944368186},{"_id":"public/2019/04/16/史蒂夫-乔布斯传/index.html","hash":"613bdad67332bf0371b27511d1dce9894e9167b8","modified":1586944368186},{"_id":"public/2019/04/15/富甲美国：沃尔玛创始人山姆-沃尔顿自传/index.html","hash":"c4cafeb1a480a0d4a5f770fd1176cefffca6937e","modified":1586944368186},{"_id":"public/2019/04/15/褚时健传/index.html","hash":"445ba2886e1fd0e696d2684d6f3d39a27feaa46c","modified":1586944368186},{"_id":"public/2019/04/15/快速阅读术/index.html","hash":"574f6e2788e7a7d557860e13f84f39d89e238479","modified":1586944368186},{"_id":"public/2019/01/28/Design-Pattern-IV/index.html","hash":"f8533455cf85b58a9b45b2c0deea3a71c92d580f","modified":1586944368186},{"_id":"public/2019/01/28/Design-Pattern-III/index.html","hash":"958a4f2b61ace6ee2c9621d9099d7fffd962e5b8","modified":1586944368186},{"_id":"public/2019/01/28/Design-Pattern-II/index.html","hash":"94f6cfa7a888012eef1569ecefc918eb025c34e7","modified":1586944368186},{"_id":"public/2018/11/26/大脑整理术/index.html","hash":"259e47272295187c392239709f7606672879d3e1","modified":1586944368186},{"_id":"public/2018/11/21/年轻人如何独立思考/index.html","hash":"4b7e8bc5da20b687103dc3bd6ca0b7ce363fe851","modified":1586944368186},{"_id":"public/2018/08/25/bootloader/index.html","hash":"bae29878f6e9d1f231f1bcd07d08be6acb47c637","modified":1586944368186},{"_id":"public/2018/08/22/Linux-Flash/index.html","hash":"3ed276c9f0fd8f72c3b453dadea50b68b729f642","modified":1586944368187},{"_id":"public/2018/08/01/Better-Man/index.html","hash":"928860c1f79d9b81b47fccba142e39e72883adef","modified":1586944368187},{"_id":"public/2018/07/12/Design-Pattern/index.html","hash":"71fd62bc5146774aef87660bc1dd19559190a2e0","modified":1586944368187},{"_id":"public/2018/06/22/WebRTC-Congestion-Control/index.html","hash":"f2236e41496d3dde9981aacbfe7cdb27fbaa6e89","modified":1586944368187},{"_id":"public/2018/06/22/WebRTC-Best-Relay-Network-Selection/index.html","hash":"aa1ccd682a3687d5df24d7e217373b39cc8ee96f","modified":1586944368187},{"_id":"public/2018/06/13/TED-Notes/index.html","hash":"f01dbf89e342caef134b134b38910623c4467bac","modified":1586944368187},{"_id":"public/2018/06/04/敏捷软件开发原则与模式及实践/index.html","hash":"ce3d739c4b1ff0b4f0f676da7f4c4a94dcbfd7c0","modified":1586944368187},{"_id":"public/2018/06/03/WebRTC 如何避免拥塞/index.html","hash":"8d348fd5c874ebd86d09c496cba1bebdaa9eaa4a","modified":1586944368187},{"_id":"public/2018/06/01/Docker/index.html","hash":"29d4291d9f41495df0ce7d51ce84aeb7398edb25","modified":1586944368187},{"_id":"public/2018/05/26/Debug-high-cpu-loading/index.html","hash":"6d8e311d5620d8eca91fb23d906a696f1132b8ea","modified":1586944368187},{"_id":"public/2018/05/08/买车记录/index.html","hash":"b73476347533d51621689f6bb14ecbf0b0975024","modified":1586944368187},{"_id":"public/2018/04/26/程序员未来的考虑/index.html","hash":"88bd477ae54c0a3823e76078087fc358fde8014d","modified":1586944368188},{"_id":"public/2018/04/26/老子是癞蛤蟆书摘/index.html","hash":"8d925d3a27436d03e7967749239498e124fb368f","modified":1586944368188},{"_id":"public/2018/04/15/把时间当做朋友听书笔记/index.html","hash":"1894d301496f82c6a01266675735e5d6aa99b633","modified":1586944368188},{"_id":"public/2017/12/25/more-coding-more-happy/index.html","hash":"59eecec25b7de204bdfa3d96cc9b5d36444ec2f7","modified":1586944368188},{"_id":"public/2017/12/14/C-UML/index.html","hash":"c036e27f8e5ddbf4ee4aeb71af709cfef0fcee1c","modified":1586944368188},{"_id":"public/2017/12/11/webrtc-directory-analyze/index.html","hash":"c07d4a675804f1bc3c4dd69cdc52ae7a7fd163bf","modified":1586944368188},{"_id":"public/2017/11/28/webRTCDirectory/index.html","hash":"d95379b6c19eb96403516ab1ac60ed28c274db68","modified":1586944368188},{"_id":"public/2017/09/04/openwrt-ssh/index.html","hash":"5a3775c6b8436b6fc01bb900d1c60ad1ae8b40b4","modified":1586944368188},{"_id":"public/2017/09/04/ssh-of-openwrt/index.html","hash":"62f044b8c8db10b4ef7fe5d7c25424a79f27a831","modified":1586944368188},{"_id":"public/2017/08/14/incr-zsh/index.html","hash":"7bce100294458425b70750926e80669f7fcb8f84","modified":1586944368188},{"_id":"public/2017/06/22/the Siege webserver test tool/index.html","hash":"3cf86c16f60a9a15137ca39a448be74a0bd1dd9e","modified":1586944368188},{"_id":"public/2017/06/20/Lighttpd support fcgi(python) and luci/index.html","hash":"d8d850d583d2fa1054958c62a4dd79c7aef974ab","modified":1586944368188},{"_id":"public/2017/06/14/hello-world/index.html","hash":"0fb4426de11985dac51f78246a767a2bc90c2050","modified":1586944368189},{"_id":"public/tags/UML/index.html","hash":"3963e2f662f32a4a1296772d0ec9cf4f2fe7decd","modified":1586944368189},{"_id":"public/tags/life/index.html","hash":"768cf9edff422b8f269d490c5d7cf4c7f51acfb8","modified":1586944368189},{"_id":"public/tags/Debug/index.html","hash":"24e895bb64175e2ff1417612382c978bd56b55eb","modified":1586944368189},{"_id":"public/tags/bookmarks/index.html","hash":"039c53ef4d69ed7fe171fac2b2af5d9148131484","modified":1586944368189},{"_id":"public/tags/bookmarks/page/2/index.html","hash":"4f691bfdb0501a1387c8eb575dffcc1c5eabdc05","modified":1586944368189},{"_id":"public/tags/program/index.html","hash":"188dad89eee4557b4736d548b06487f7077618ce","modified":1586944368189},{"_id":"public/tags/Docker/index.html","hash":"a19f483f2b906f530e06ba5cf988bdd44367695b","modified":1586944368189},{"_id":"public/tags/webserver/index.html","hash":"f91fb0b9b61dfdca77abfe2fb37a0c064ed6d986","modified":1586944368189},{"_id":"public/tags/flash/index.html","hash":"b4d4faf3be16b600244b45537159694bdc3e633e","modified":1586944368189},{"_id":"public/tags/kernel/index.html","hash":"7a7d5371d09836cc07b38ff2b86c3b9c1408f8d8","modified":1586944368189},{"_id":"public/tags/TED/index.html","hash":"57b780128fd4b979be4893d78a2291a1cca5c15f","modified":1586944368189},{"_id":"public/tags/WebRTC/index.html","hash":"7ad035f9c91e382f9784dc1db1640c5a7409b7dd","modified":1586944368189},{"_id":"public/tags/biterate-controller/index.html","hash":"f7a8adebf97547b25d08f38d557e02f6a2583538","modified":1586944368190},{"_id":"public/tags/congestion-control/index.html","hash":"f1350c4389b8534ea3d008534e96f8f449c8e743","modified":1586944368190},{"_id":"public/tags/arm/index.html","hash":"634a15a6d9f28e7327d6b59adfff1cbe09076901","modified":1586944368190},{"_id":"public/tags/boot-time/index.html","hash":"5a47be739f0d5595de3d3be46e34cc1d98ced9c2","modified":1586944368190},{"_id":"public/tags/optimization/index.html","hash":"8e87a75a74ef1ed95d03aeb435985d9a2c2b9f6b","modified":1586944368190},{"_id":"public/tags/spec/index.html","hash":"60a7f6f1195bb8fe3b11e16f5799575534db970b","modified":1586944368190},{"_id":"public/tags/bootloader/index.html","hash":"fd09c692046637c7e5b33c8f98154c2d7655a042","modified":1586944368190},{"_id":"public/tags/u-boot/index.html","hash":"8f21bd334afe4c20aae5cfcc23a3a1c409575f98","modified":1586944368190},{"_id":"public/tags/buildbot/index.html","hash":"9c690a64e1720bb1f280de8df4f3e55abec9269e","modified":1586944368190},{"_id":"public/tags/openwrt/index.html","hash":"6688d202aa2c5507bf9190171c2f2a624cadb73c","modified":1586944368190},{"_id":"public/tags/CI/index.html","hash":"5cd35e2d9aecf6cd39d33d4dd3cb7a841285fe14","modified":1586944368190},{"_id":"public/2020/04/15/kernel-tickless-idle/index.html","hash":"64f567f6ccf6683fc7a4210219d22297cb52e0b8","modified":1586944368310},{"_id":"public/tags/zsh/index.html","hash":"8f278ced7c8df78dc16b89bfcb8a1ab02d446934","modified":1586944368311},{"_id":"public/tags/hexo/index.html","hash":"3f94c9a3ca33631e12d6ad59be0606293d7a0cef","modified":1586944368311},{"_id":"public/tags/ipv6/index.html","hash":"64760c7880c637dc41ad4fa4452bebd770bedfb4","modified":1586944368311},{"_id":"public/tags/cryptographic/index.html","hash":"bbb31bc11710be11359ae3709a6cff67cdc58c0e","modified":1586944368311},{"_id":"public/tags/memory/index.html","hash":"b6071a341368dbce4fb23870fa06238ad4f0c29c","modified":1586944368312},{"_id":"public/tags/mm/index.html","hash":"78f55247cac4c32cab070c238ef5aca165bb0478","modified":1586944368312},{"_id":"public/tags/cache/index.html","hash":"51beb262af79c53dfc08e4f2640123c096ae3e27","modified":1586944368312},{"_id":"public/tags/timer/index.html","hash":"fd8e02c8ca76608335d5d173756d2c2afade8314","modified":1586944368312},{"_id":"public/tags/tlb/index.html","hash":"dd12648070a91fab2e5b4b8fb40e8e5e2915a4b4","modified":1586944368312},{"_id":"public/tags/tty/index.html","hash":"4ef9904cfb9647e30ad755a9d2b0834a19da6c97","modified":1586944368312},{"_id":"public/tags/mtd/index.html","hash":"cc8d9d2e2cf53831dbaf3984fa7495a1044d2484","modified":1586944368312},{"_id":"public/tags/ubi/index.html","hash":"65c4b793d7c7528310f0ec8fbaed619f6b896362","modified":1586944368312},{"_id":"public/tags/ubifs/index.html","hash":"04003e7535eec762c8ce579c6208c92d6ce92a1d","modified":1586944368312},{"_id":"public/tags/slub/index.html","hash":"ae9ad1115196159f5520a689324a1cb93c648801","modified":1586944368312},{"_id":"public/tags/cpu-loading/index.html","hash":"8bacca6decaffe8e1cc08dc9b1e86deff916ecd9","modified":1586944368313},{"_id":"public/tags/bookmarks-reading-notes/index.html","hash":"03cd0bb04fff671b6611e13a527034e3958d12e3","modified":1586944368313},{"_id":"public/tags/ssh/index.html","hash":"2238b651c303f57ca73b5b96fe0248cc6293d0e4","modified":1586944368313},{"_id":"public/tags/dropbear/index.html","hash":"b0b754a661083f63f6b1382ee9b20597ea73ff1c","modified":1586944368313},{"_id":"public/tags/Siege/index.html","hash":"22da33f2c0ea0bb682e90ded6dff9df29b7bbb00","modified":1586944368313},{"_id":"public/tags/Streaming/index.html","hash":"11c7bf5ab1e535b9bcfccbac06f12f8d20e72d21","modified":1586944368313},{"_id":"public/tags/programmer/index.html","hash":"f65b588b59eae6a731c6ccb9f0c3e3ba9b177bad","modified":1586944368313},{"_id":"public/tags/work-life/index.html","hash":"f9d82f325c7355dfead9d297371e33674744d5b5","modified":1586944368313},{"_id":"public/tags/GICv2/index.html","hash":"784deb93e1f2fec2a6dfe0d2902be9162300edcb","modified":1586944368313},{"_id":"public/archives/index.html","hash":"5e9cf20f0cf78c4fd547fd88bdd9866bf8a4daba","modified":1586944368313},{"_id":"public/archives/page/2/index.html","hash":"56b722e937ab48a69b7052376f6e6e0c02c42fa2","modified":1586944368313},{"_id":"public/archives/page/3/index.html","hash":"2253f6a93b43df12fdb1a1e68ea8da4d778db96d","modified":1586944368313},{"_id":"public/archives/page/4/index.html","hash":"4dc4cb20198fb2af70cd0cb010ba7adb4ae38e65","modified":1586944368314},{"_id":"public/archives/page/5/index.html","hash":"edb5ffe085a9cc3a9d4d444ba52a3e1de032d085","modified":1586944368314},{"_id":"public/archives/page/6/index.html","hash":"4035ae1524223a4474da79a75687ef42f84b3a23","modified":1586944368314},{"_id":"public/archives/page/7/index.html","hash":"017e0d61aa37fb528b2111273f98e25872af38a0","modified":1586944368314},{"_id":"public/archives/2017/index.html","hash":"4f450d78ced69913473277238736929b41616ea8","modified":1586944368314},{"_id":"public/2019/06/03/程序员40岁后该如何发展/index.html","hash":"d47453ef2ace97cb0065e7bc51cac437dbda612f","modified":1586944368314},{"_id":"public/archives/2017/06/index.html","hash":"7c3ae63a82b9f8ab6a38e33d7e189eee9f718637","modified":1586944368314},{"_id":"public/archives/2017/09/index.html","hash":"584cf2aa5f8c65acba6b3631c77b64b2883f5451","modified":1586944368314},{"_id":"public/2019/06/28/kernel-dma-mem/index.html","hash":"7949f15c753143a826f2a0d81c161b9be6f04ae0","modified":1586944368314},{"_id":"public/archives/2017/11/index.html","hash":"efbf3bf73badfb9f83b4bbc9730ee3b42ef8492d","modified":1586944368314},{"_id":"public/archives/2017/12/index.html","hash":"9f876536028b45e50a731814abe2629e480dc698","modified":1586944368315},{"_id":"public/archives/2018/index.html","hash":"f90adc80539b1fba7244af2f3ed978e728b277c3","modified":1586944368315},{"_id":"public/archives/2017/08/index.html","hash":"64873f5554cd99eb903f244734900d136e5a0e40","modified":1586944368315},{"_id":"public/2019/06/25/kernel-mtd/index.html","hash":"efb9194727a45f3477e03a6b45bfd7ac27714eb2","modified":1586944368315},{"_id":"public/archives/2018/page/2/index.html","hash":"ae5ed33380798f80ac9e66ed2ce68575e99a750b","modified":1586944368315},{"_id":"public/archives/2018/05/index.html","hash":"ac824145dd4b23cabc6fd7d7d59f77549bc9d0e7","modified":1586944368315},{"_id":"public/archives/2018/04/index.html","hash":"475a4cb0882ec7e20e6a7433b9dbf4013a5472fd","modified":1586944368315},{"_id":"public/archives/2018/07/index.html","hash":"4663f9805ccdd0c99411d298ba0cf2186e2c35fe","modified":1586944368315},{"_id":"public/archives/2018/11/index.html","hash":"48919547d990a194bf9fe00b3e6b692fdae42fa7","modified":1586944368315},{"_id":"public/archives/2019/index.html","hash":"fd0fec86485f58ef34e10f8e7230274cdf1a32e2","modified":1586944368315},{"_id":"public/archives/2019/page/2/index.html","hash":"59c794eb636929f10a7556090dbb7d8a15bb7fbc","modified":1586944368315},{"_id":"public/archives/2019/page/3/index.html","hash":"5ac97d28229b64c9f1078f65771e6579de333dcc","modified":1586944368315},{"_id":"public/archives/2019/page/4/index.html","hash":"8b4b3e30bb16a1b68a50549d561510c9c726678b","modified":1586944368316},{"_id":"public/archives/2019/01/index.html","hash":"66707809fc59b58473775b3dba92d2989bf64af1","modified":1586944368316},{"_id":"public/archives/2019/04/index.html","hash":"0f6948e35cdf34283d37cef0c79958533244db35","modified":1586944368316},{"_id":"public/archives/2019/05/index.html","hash":"206ffe093274bfd49de16cc695fab500d9bfeb20","modified":1586944368316},{"_id":"public/archives/2019/06/index.html","hash":"c8e8d0b0eed948f1a556c1ab47de7c3f686b4bc6","modified":1586944368316},{"_id":"public/archives/2018/08/index.html","hash":"90790e4b4a8d78016ebe64a21687f2ba736edbb2","modified":1586944368316},{"_id":"public/archives/2019/07/index.html","hash":"b8dd3e843e4c47c22420871f07f3c3d9b1284337","modified":1586944368316},{"_id":"public/archives/2019/09/index.html","hash":"92b216fb8bf54facad750f289acd386ed74e71e9","modified":1586944368316},{"_id":"public/archives/2019/08/index.html","hash":"fe843b66f2da8ad60a02691d2f842f6dd8252a5b","modified":1586944368316},{"_id":"public/archives/2020/index.html","hash":"8a8fa3cceeed73b73e1def651fe36f8fe881ca41","modified":1586944368316},{"_id":"public/archives/2020/page/2/index.html","hash":"3f5a81398cbc1177e50bc08d605ae670c81ad2f4","modified":1586944368316},{"_id":"public/archives/2018/06/index.html","hash":"932f30c0f225f4b2d4be59fbc7b6a9991c7d09a9","modified":1586944368316},{"_id":"public/archives/2019/11/index.html","hash":"8392630abea33ca9b7d4a0e682f9e23b68a24cf9","modified":1586944368317},{"_id":"public/archives/2020/02/index.html","hash":"6200d9a8c4f4ef8b4496c9e2ecf845c2728905ce","modified":1586944368317},{"_id":"public/archives/2020/03/index.html","hash":"67e721ff0af19c40b55fc12b7ba90d95b057f54e","modified":1586944368317},{"_id":"public/archives/2020/04/index.html","hash":"6dbfd9d8aab233c9340d1f078d8dc51dc4f9502f","modified":1586944368317},{"_id":"public/categories/UML/index.html","hash":"2beb40ec85e3bb80036e9ccd2fe8718f5ab7ea95","modified":1586944368317},{"_id":"public/categories/debug/index.html","hash":"1806ad9f21431f61fb9befa1160fd26990eff917","modified":1586944368317},{"_id":"public/categories/bookmarks/index.html","hash":"f65ad884a8cc72edeb4af99cc88f9efa4fec95cc","modified":1586944368317},{"_id":"public/categories/life/index.html","hash":"6dd9e0f8026e7521edc5d1f5ea1b57b07010bfe3","modified":1586944368317},{"_id":"public/categories/tools/index.html","hash":"0410d54b2a595ad53015629d869cf1c31a7aa051","modified":1586944368317},{"_id":"public/categories/openwrt/index.html","hash":"0d5ddba45d1d8f64f35b254c02e88d416121654c","modified":1586944368317},{"_id":"public/categories/bookmarks/page/2/index.html","hash":"0ff87e8cae5ca0a6cb0704cc9e91aab839b61f3e","modified":1586944368317},{"_id":"public/categories/drivers/index.html","hash":"6927b7a240bb3e78f34a8452c478b765d0ee02ac","modified":1586944368317},{"_id":"public/categories/WebRTC/index.html","hash":"fbb34fe934ba786c9bd92a959298afcdc37c0984","modified":1586944368317},{"_id":"public/categories/arm/index.html","hash":"5a793c8fbd084d35d77ae195ca4b0b87c245782e","modified":1586944368317},{"_id":"public/categories/bootloader/index.html","hash":"e2b7f9315f41faed551711376a9442335e9343e4","modified":1586944368318},{"_id":"public/categories/hexo/index.html","hash":"1ed7683eaa617067f0bf369f1f9c3cc645617713","modified":1586944368318},{"_id":"public/categories/ipv6/index.html","hash":"ca84d0eef2163af6562222997ae5b2f53535c35f","modified":1586944368318},{"_id":"public/categories/memory/index.html","hash":"561a53893a2097aaf1b097ff1f0bed84f6956ed2","modified":1586944368318},{"_id":"public/index.html","hash":"44404b6f5e0de8d2b7650fd54a4e8892ad61f9a3","modified":1586945039322},{"_id":"public/categories/CI/index.html","hash":"2c4419902696ea065896cbf3c5548dacdd1d2643","modified":1586944368318},{"_id":"public/page/2/index.html","hash":"096aeb165eb3ec7252c53df5bd81b080a25480cf","modified":1586944368318},{"_id":"public/page/3/index.html","hash":"7e5c88b265efe106e9db755aa2579336abe64719","modified":1586944368318},{"_id":"public/page/4/index.html","hash":"18d199001aee19f0b33a13daa5122692cc35a9e2","modified":1586944368318},{"_id":"public/page/6/index.html","hash":"e856f7d9094e500d197d0a370d203d1a6433e019","modified":1586944368318},{"_id":"public/categories/fs/index.html","hash":"34b49aa1ef381738c9fb6083619c0e317cc0a4d4","modified":1586944368318},{"_id":"public/page/5/index.html","hash":"aea6d8aab7dfb146b3d8ac150db8d608b4dbafb9","modified":1586944368318},{"_id":"public/categories/kernel/index.html","hash":"f8daaeb06ea18670c35496a9d34836eb06f2dc0e","modified":1586944368319},{"_id":"public/page/7/index.html","hash":"dae8602d7cdbd2ca00e36a2ac82450166165a544","modified":1586944368319},{"_id":"public/archives/page/8/index.html","hash":"cf1588cb9a411f3bc67f3e3eb118db424df704fc","modified":1586944368369},{"_id":"public/page/8/index.html","hash":"f2140ac285718e192dc33dd736569025790c4419","modified":1586944368369},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1586944368369},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1586944368369},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1586944368369},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1586944368369},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1586944368369},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1586944368369},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1586944368369},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1586944368369},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1586944368369},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1586944368370},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1586944368370},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1586944368370},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1586944368370},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1586944368370},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1586944368370},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1586944368370},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1586944368370},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1586944368370},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1586944369021},{"_id":"public/js/src/bootstrap.js","hash":"40de94fd18fcbd67a327d63b0d1e242a08aa5404","modified":1586944369021},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1586944369021},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1586944369021},{"_id":"public/js/src/motion.js","hash":"50e57f8acb6924c6999cdcc664ddd3f0730d2061","modified":1586944369021},{"_id":"public/js/src/post-details.js","hash":"d1333fb588d4521b4d1e9c69aef06e0ad1bf0b12","modified":1586944369021},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1586944369021},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1586944369022},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1586944369022},{"_id":"public/js/src/utils.js","hash":"254fe047031981ec772728703fa6e065ede838b0","modified":1586944369022},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1586944369022},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1586944369022},{"_id":"public/css/main.css","hash":"0868803eab5e404c95bae169149367cc88a5c4ef","modified":1586944369022},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1586944369022},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1586944369022},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1586944369022},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1586944369022}],"Category":[{"name":"UML","_id":"ck915p0ot0004zkgra02sxnhs"},{"name":"life","_id":"ck915p0oz0009zkgr5cp331f7"},{"name":"debug","_id":"ck915p0p5000fzkgrvuisvg6b"},{"name":"bookmarks","_id":"ck915p0p9000lzkgr82v65i4w"},{"name":"tools","_id":"ck915p0po0018zkgr3gf8lh7x"},{"name":"openwrt","_id":"ck915p0ps001hzkgrytgko452"},{"name":"drivers","_id":"ck915p0pw001nzkgrnh6lxav1"},{"name":"WebRTC","_id":"ck915p0pz001uzkgrc7188io0"},{"name":"arm","_id":"ck915p0qa002fzkgr3jinuj1s"},{"name":"bootloader","_id":"ck915p0qq0036zkgrsabtwmfb"},{"name":"CI","_id":"ck915p0qu003ezkgr5airqzmk"},{"name":"hexo","_id":"ck915p0qy003lzkgrebv4tvzs"},{"name":"ipv6","_id":"ck915p0r1003rzkgrak73u2nj"},{"name":"memory","_id":"ck915p0r7003yzkgrmp33xqlw"},{"name":"kernel","_id":"ck915p0rk004mzkgrmy8wrwz6"},{"name":"fs","_id":"ck915p0s00052zkgrxufpyo91"}],"Data":[],"Page":[{"title":"categories","date":"2017-08-16T15:10:44.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-08-16 23:10:44\ntype: categories\n---\n","updated":"2019-07-08T06:16:07.584Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck915p0op0001zkgrcilelna3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-08-16T15:12:14.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-08-16 23:12:14\ntype: tags\n---\n","updated":"2019-07-08T06:16:07.584Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck915p0os0003zkgrbriewq58","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++_UML","date":"2017-12-14T09:03:51.000Z","_content":"\n## 1. Basic \n### 1.1. Visibility\nThe C++ class has three visibility. \n\n- public, using \"+\"  \n- private, using \"-\"  \n- protected, using '#'  \n\nSee the base class examole:  \n![Base Class](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/C%2B%2B/C%2B%2B_BaseClass.png)\n\n<!-- more -->\n### 1.2. Class members\n- static members, using <u>underline</u>, like <u>static int member</u>\n- virtual functions, using **Italic** font, like ***virtual void functions()***\n\n## 2. Class Relationship\nThe C++ has these relationship:\n\n- Assocation \n- Dependency\n- Aggregation\n- Composition \n- Inheritance\n- Class template  \n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/C%2B%2B/C%2B%2B_ClassRelationship.png)\n\n### 2.1. Dependency\n可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。\n``` c++\nclass B {\n\tpublic:\n\t\tvoid display(class A* A) {A->display();}\n}\n```\n\n### 2.2. Assocation \n他体现的是两个类、或者类与接口之间语义级别的一种<font color=red>强依赖关系</font>，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的\n``` c++\nclass B\n{\npublic:\n    B(){}\n    void setA(A *A) { ptrA_ = A;}\n\nprivate/public:\n    A* ptrA_; \n}\n```\n### 2.3. Aggregation\n聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，__即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期。__\n``` c++\nclass B {\n\tpublic:\n\tprivate:\n\t\tvector<class A*> ptrclassA;\n}\n```\n### 2.4. Composition \n组合也是关联关系的一种特例，__他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合__，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。\n\n``` c++\nclass B {\n\tprivate:\n\t\tclass A a;\n}\n```\n\n总的来说，上述关系所表现的强弱程度依次为：__组合>聚合>关联>依赖__\n\n### 2.5. Inheritance\n\n``` c++\nclass A {\n\t//..\t\n};\n\nclass B: public A {\n\t//..\n}\n```\n\n### 2.6. Class template\n\n``` c++\ntemplate<class T>\nclass A {\n\t//...\n\tprivate:\n\tT var;\n};\n\nclass B {\n\t//..\n};\n\nA<B> a;\n```\n\n## 参看资料\n[继承、实现、依赖、关联、聚合、组合的联系与区别](https://www.cnblogs.com/jiqing9006/p/5915023.html)","source":"_posts/C-UML.md","raw":"---\ntitle: C++_UML\ndate: 2017-12-14 17:03:51\ntags:\n\t- UML\ncategories: UML\t\n---\n\n## 1. Basic \n### 1.1. Visibility\nThe C++ class has three visibility. \n\n- public, using \"+\"  \n- private, using \"-\"  \n- protected, using '#'  \n\nSee the base class examole:  \n![Base Class](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/C%2B%2B/C%2B%2B_BaseClass.png)\n\n<!-- more -->\n### 1.2. Class members\n- static members, using <u>underline</u>, like <u>static int member</u>\n- virtual functions, using **Italic** font, like ***virtual void functions()***\n\n## 2. Class Relationship\nThe C++ has these relationship:\n\n- Assocation \n- Dependency\n- Aggregation\n- Composition \n- Inheritance\n- Class template  \n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/C%2B%2B/C%2B%2B_ClassRelationship.png)\n\n### 2.1. Dependency\n可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。\n``` c++\nclass B {\n\tpublic:\n\t\tvoid display(class A* A) {A->display();}\n}\n```\n\n### 2.2. Assocation \n他体现的是两个类、或者类与接口之间语义级别的一种<font color=red>强依赖关系</font>，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的\n``` c++\nclass B\n{\npublic:\n    B(){}\n    void setA(A *A) { ptrA_ = A;}\n\nprivate/public:\n    A* ptrA_; \n}\n```\n### 2.3. Aggregation\n聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，__即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期。__\n``` c++\nclass B {\n\tpublic:\n\tprivate:\n\t\tvector<class A*> ptrclassA;\n}\n```\n### 2.4. Composition \n组合也是关联关系的一种特例，__他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合__，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。\n\n``` c++\nclass B {\n\tprivate:\n\t\tclass A a;\n}\n```\n\n总的来说，上述关系所表现的强弱程度依次为：__组合>聚合>关联>依赖__\n\n### 2.5. Inheritance\n\n``` c++\nclass A {\n\t//..\t\n};\n\nclass B: public A {\n\t//..\n}\n```\n\n### 2.6. Class template\n\n``` c++\ntemplate<class T>\nclass A {\n\t//...\n\tprivate:\n\tT var;\n};\n\nclass B {\n\t//..\n};\n\nA<B> a;\n```\n\n## 参看资料\n[继承、实现、依赖、关联、聚合、组合的联系与区别](https://www.cnblogs.com/jiqing9006/p/5915023.html)","slug":"C-UML","published":1,"updated":"2019-08-06T12:11:44.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0ok0000zkgrx3fwk7xk","content":"<h2 id=\"1-Basic\"><a href=\"#1-Basic\" class=\"headerlink\" title=\"1. Basic\"></a>1. Basic</h2><h3 id=\"1-1-Visibility\"><a href=\"#1-1-Visibility\" class=\"headerlink\" title=\"1.1. Visibility\"></a>1.1. Visibility</h3><p>The C++ class has three visibility. </p>\n<ul>\n<li>public, using “+”  </li>\n<li>private, using “-“  </li>\n<li>protected, using ‘#’  </li>\n</ul>\n<p>See the base class examole:<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/C%2B%2B/C%2B%2B_BaseClass.png\" alt=\"Base Class\"></p>\n<a id=\"more\"></a>\n<h3 id=\"1-2-Class-members\"><a href=\"#1-2-Class-members\" class=\"headerlink\" title=\"1.2. Class members\"></a>1.2. Class members</h3><ul>\n<li>static members, using <u>underline</u>, like <u>static int member</u></li>\n<li>virtual functions, using <strong>Italic</strong> font, like <strong><em>virtual void functions()</em></strong></li>\n</ul>\n<h2 id=\"2-Class-Relationship\"><a href=\"#2-Class-Relationship\" class=\"headerlink\" title=\"2. Class Relationship\"></a>2. Class Relationship</h2><p>The C++ has these relationship:</p>\n<ul>\n<li>Assocation </li>\n<li>Dependency</li>\n<li>Aggregation</li>\n<li>Composition </li>\n<li>Inheritance</li>\n<li>Class template  </li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/C%2B%2B/C%2B%2B_ClassRelationship.png\" alt=\"\"></p>\n<h3 id=\"2-1-Dependency\"><a href=\"#2-1-Dependency\" class=\"headerlink\" title=\"2.1. Dependency\"></a>2.1. Dependency</h3><p>可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(class A* A)</span> </span>&#123;A-&gt;display();&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-Assocation\"><a href=\"#2-2-Assocation\" class=\"headerlink\" title=\"2.2. Assocation\"></a>2.2. Assocation</h3><p>他体现的是两个类、或者类与接口之间语义级别的一种<font color=\"red\">强依赖关系</font>，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    B()&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setA</span><span class=\"params\">(A *A)</span> </span>&#123; ptrA_ = A;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>/<span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A* ptrA_; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-Aggregation\"><a href=\"#2-3-Aggregation\" class=\"headerlink\" title=\"2.3. Aggregation\"></a>2.3. Aggregation</h3><p>聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，<strong>即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;class A*&gt; ptrclassA;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-4-Composition\"><a href=\"#2-4-Composition\" class=\"headerlink\" title=\"2.4. Composition\"></a>2.4. Composition</h3><p>组合也是关联关系的一种特例，<strong>他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合</strong>，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">a</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总的来说，上述关系所表现的强弱程度依次为：<strong>组合&gt;聚合&gt;关联&gt;依赖</strong></p>\n<h3 id=\"2-5-Inheritance\"><a href=\"#2-5-Inheritance\" class=\"headerlink\" title=\"2.5. Inheritance\"></a>2.5. Inheritance</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//..\t</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span> <span class=\"keyword\">public</span> A &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-6-Class-template\"><a href=\"#2-6-Class-template\" class=\"headerlink\" title=\"2.6. Class template\"></a>2.6. Class template</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tT var;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">A&lt;B&gt; a;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://www.cnblogs.com/jiqing9006/p/5915023.html\" target=\"_blank\" rel=\"noopener\">继承、实现、依赖、关联、聚合、组合的联系与区别</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-Basic\"><a href=\"#1-Basic\" class=\"headerlink\" title=\"1. Basic\"></a>1. Basic</h2><h3 id=\"1-1-Visibility\"><a href=\"#1-1-Visibility\" class=\"headerlink\" title=\"1.1. Visibility\"></a>1.1. Visibility</h3><p>The C++ class has three visibility. </p>\n<ul>\n<li>public, using “+”  </li>\n<li>private, using “-“  </li>\n<li>protected, using ‘#’  </li>\n</ul>\n<p>See the base class examole:<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/C%2B%2B/C%2B%2B_BaseClass.png\" alt=\"Base Class\"></p>","more":"<h3 id=\"1-2-Class-members\"><a href=\"#1-2-Class-members\" class=\"headerlink\" title=\"1.2. Class members\"></a>1.2. Class members</h3><ul>\n<li>static members, using <u>underline</u>, like <u>static int member</u></li>\n<li>virtual functions, using <strong>Italic</strong> font, like <strong><em>virtual void functions()</em></strong></li>\n</ul>\n<h2 id=\"2-Class-Relationship\"><a href=\"#2-Class-Relationship\" class=\"headerlink\" title=\"2. Class Relationship\"></a>2. Class Relationship</h2><p>The C++ has these relationship:</p>\n<ul>\n<li>Assocation </li>\n<li>Dependency</li>\n<li>Aggregation</li>\n<li>Composition </li>\n<li>Inheritance</li>\n<li>Class template  </li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/C%2B%2B/C%2B%2B_ClassRelationship.png\" alt=\"\"></p>\n<h3 id=\"2-1-Dependency\"><a href=\"#2-1-Dependency\" class=\"headerlink\" title=\"2.1. Dependency\"></a>2.1. Dependency</h3><p>可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(class A* A)</span> </span>&#123;A-&gt;display();&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-Assocation\"><a href=\"#2-2-Assocation\" class=\"headerlink\" title=\"2.2. Assocation\"></a>2.2. Assocation</h3><p>他体现的是两个类、或者类与接口之间语义级别的一种<font color=\"red\">强依赖关系</font>，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    B()&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setA</span><span class=\"params\">(A *A)</span> </span>&#123; ptrA_ = A;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>/<span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A* ptrA_; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-Aggregation\"><a href=\"#2-3-Aggregation\" class=\"headerlink\" title=\"2.3. Aggregation\"></a>2.3. Aggregation</h3><p>聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，<strong>即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;class A*&gt; ptrclassA;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-4-Composition\"><a href=\"#2-4-Composition\" class=\"headerlink\" title=\"2.4. Composition\"></a>2.4. Composition</h3><p>组合也是关联关系的一种特例，<strong>他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合</strong>，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">a</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总的来说，上述关系所表现的强弱程度依次为：<strong>组合&gt;聚合&gt;关联&gt;依赖</strong></p>\n<h3 id=\"2-5-Inheritance\"><a href=\"#2-5-Inheritance\" class=\"headerlink\" title=\"2.5. Inheritance\"></a>2.5. Inheritance</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//..\t</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span> <span class=\"keyword\">public</span> A &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-6-Class-template\"><a href=\"#2-6-Class-template\" class=\"headerlink\" title=\"2.6. Class template\"></a>2.6. Class template</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tT var;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">A&lt;B&gt; a;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://www.cnblogs.com/jiqing9006/p/5915023.html\" target=\"_blank\" rel=\"noopener\">继承、实现、依赖、关联、聚合、组合的联系与区别</a></p>"},{"title":"Better_Man","date":"2018-08-01T15:54:54.000Z","top":true,"_content":"\n每天一碗鸡汤，强生健体 :)\n\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=46fc9b94b51c8701c2bbbab44616f54a/00e93901213fb80e136344a730d12f2eb938940b.jpg)\n\n[曾经的你 -- 网易云音乐](https://music.163.com/#/song?id=167975)\n\n<!--more-->\n\n记录看到能给予自己Power的词句，与未来的自己干杯。\n![了不起的盖茨比, 举杯](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1533150875649&di=4f13323ee04bec1e72b5bf74478d10bb&imgtype=0&src=http%3A%2F%2Fwww.cssn.cn%2Fst%2Fst_zpwht%2F201411%2FW020141123799706038347.png)\n\n## 品尝\n\n在孤独中跃迁\n\n这世界上唯一扛得住岁月摧残的东西，就是才华 -- [李安](https://baike.baidu.com/item/%E6%9D%8E%E5%AE%89/16812?fr=aladdin)\n\n## 态度\n\n顺境修力，逆境修心\n\n成功的哲学在于坚持得有多久\n\n我相信你是世界上最富有的人之一，拥有梦想、时间和人生无数种可能性\n\n把自己交给繁忙，得到的是踏实，却不是真实。 -- 《[无问西东](https://baike.baidu.com/item/%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C/1743189?fr=aladdin)》\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=b2fe4255c01349546a13e0363727f93d/d000baa1cd11728bab3176f6c3fcc3cec2fd2cc2.jpg)\n\n吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。 -- [荀子，《劝学》](https://baike.baidu.com/item/%E5%8A%9D%E5%AD%A6/1055?fr=aladdin)（有类似于，学而不思则罔,思而不学则怠。）\n\n只要努力了，一定会有结果。但结果也分好坏，这个结果不一定是你想要的。尽管如此，我们也不应该放弃改变，固步自封。\n\n别人贪婪的时候我恐惧，别人恐惧的时候我贪婪。 -- [沃伦·巴菲特](https://baike.baidu.com/item/%E6%B2%83%E4%BC%A6%C2%B7%E5%B7%B4%E8%8F%B2%E7%89%B9/472378?fromtitle=%E5%B7%B4%E8%8F%B2%E7%89%B9&fromid=215648&fr=aladdin)\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=64e7757bdb160924c828aa49b56e5e9f/1f178a82b9014a9024195490a2773912b31beefc.jpg)\n\n唯一真正的成功，是按自己的意思過上生活。-- [阮一峰 第15周分享](http://www.ruanyifeng.com/blog/2018/07/weekly-issue-15.html)\n\n如果一件事，我们仅仅因为害羞不去做，那么它更值得去做。\n\n人只是一根芦苇，是自然界最为脆弱的，但他却是一根会思考的芦苇。 -- [布莱士·帕斯卡](https://baike.baidu.com/item/%E5%B8%83%E8%8E%B1%E5%A3%AB%C2%B7%E5%B8%95%E6%96%AF%E5%8D%A1/8791342?fromtitle=%E5%B8%95%E6%96%AF%E5%8D%A1&fromid=5464)\n\n未经审视的人生是不值得过的。 -- [苏格拉底](https://baike.baidu.com/item/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95/12690?fr=aladdin)\n\n快速走向成熟有且只有一种方法：**主动进行大量有目的性的试错与学习。**\n\n不要因为没有草原，就忘记你是马。-- [朴树，No Fear In My Heart](https://baike.baidu.com/item/No%20Fear%20In%20My%20Heart/20864952?fr=aladdin)\n\n**改变能改变的，接受不能改变的。**\n\n[Ginga -- 网易云音乐](https://music.163.com/#/song?id=418532318)\n\n不能羞于承认你自己。\n别急于求成，一切水到渠成。\n要练就练强大的内心。 -- 《[传奇的诞生](https://baike.baidu.com/item/%E4%BC%A0%E5%A5%87%E7%9A%84%E8%AF%9E%E7%94%9F/22822757?fr=aladdin&fromtitle=%E8%B4%9D%E5%88%A9%EF%BC%9A%E4%BC%A0%E5%A5%87%E7%9A%84%E8%AF%9E%E7%94%9F&fromid=19874519)》\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike933%2C5%2C5%2C933%2C330/sign=01382c29bb003af359b7d4325443ad39/21a4462309f79052afc98b1e01f3d7ca7bcbd538.jpg)\n\n真正的方法，往往是那些简单明了，朴素的至理名言。但我们总是视而不见，去追求那些虚无缥缈的东西。我们需要做的，**是在年轻的时候，坚持学习，提升认知水平、培养分析和解决问题的能力，而不是天天琢磨出路在哪里！**\n\n容易的道路越走越困难，困难的道路越走越容易。\n\n一个人经常改变自己的看法，更可能得到正确的观点。世界变化太快，最聪明的人会不断修改自己对世界的理解，重新考虑哪些有定见的问题，不断用新的信息、想法挑战自己的思维方式，把自己的观点视为暂时的。 -- [杰夫·贝佐斯， 亚马逊](https://baike.baidu.com/item/%E6%9D%B0%E5%A4%AB%C2%B7%E8%B4%9D%E4%BD%90%E6%96%AF/8375177?fr=aladdin)\n\n败而坦然，胜而自然。 -- [李建](https://www.iqiyi.com/v_19rr579bo4.html)\n\n[知人者智，自知者明](https://baike.baidu.com/item/%E7%9F%A5%E4%BA%BA%E8%80%85%E6%99%BA%EF%BC%8C%E8%87%AA%E7%9F%A5%E8%80%85%E6%98%8E/4367682?fr=aladdin)\n\n>知人者智，知己者明。胜人者有力，胜己者强。知足者富，强行者有志，不失其所者久，死而不亡者寿。\n\n## 生活\n\n与其临渊羡鱼，不如退而结网\n\n在这个世道上能活下来的要么坚强，要么坚强\n\n明明是我们看错了世界，却说世界欺骗了我们。 -- [张小娴](https://baike.baidu.com/item/%E5%BC%A0%E5%B0%8F%E5%A8%B4/201628?fr=aladdin)\n\n**生活最沉重的负担不是生活，而是无聊**。 -- [罗曼.罗兰](https://baike.baidu.com/item/%E7%BD%97%E6%9B%BC%C2%B7%E7%BD%97%E5%85%B0/802941?fromtitle=%E7%BD%97%E6%9B%BC%E7%BD%97%E5%85%B0&fromid=1062483&fr=aladdin)\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=162842ab1f950a7b613846966bb809bc/4ec2d5628535e5ddbd31bc4274c6a7efce1b6209.jpg)\n\n生活一定要五颜六色，但绝不要乱七八糟。\n\n带给男人快速成熟的，往往是生活不经意的意外。\n\n哪有人天生会懂事，只不过见多了恶心的人。\n\n言念君子，温其如玉。 -- [《国风·秦风·小戎》](https://baike.baidu.com/item/%E5%9B%BD%E9%A3%8E%C2%B7%E7%A7%A6%E9%A3%8E%C2%B7%E5%B0%8F%E6%88%8E/2687122)\n\n这世界上，绝大部分人的人生，都是八个字 -- 比上不足，比下有余。没动力的时候往上看看，没希望的时候往下瞅瞅，日子就能过的很好。\n\n人生不是走斜坡，你持续走就可以走到巅峰；**人生像走阶梯，每一阶有每一阶的难点**，学物理有物理的难点，学漫画有漫画的难点，你没有克服难点，再怎么努力都是原地跳。所以当你克服难点，你跳上去就不会下来了。\n-- [《努力是没有用的》，蔡志忠](https://www.yuque.com/book-academy/share/shp7tu)\n\n>成功的人生是台阶式向上，而不是一条水平线。努力只是说明你拼命在走，跟你能不能向上走，关系不大。那些努力却没有结果的人，根本原因就在于，他一直走在平面上，没有走到更高的台阶。 \n\n>垂直方向的努力更有意义，水平方向的努力意义不大。你做完这件事后，再去挑战更难的事情，就有机会学会做两件事。-- [《每周分享第 21 期 》，阮一峰](http://www.ruanyifeng.com/blog/2018/09/weekly-issue-21.html)\n\n痛苦是财富，这话是扯谈，痛苦就是痛苦，**对痛苦的思考才是财富。** -- [没必要的苦，不值得经历](https://www.yuque.com/book-academy/share/paglv3)","source":"_posts/Better-Man.md","raw":"---\ntitle: Better_Man\ndate: 2018-08-01 23:54:54\ntags:\n    - life\ncategories: \n    - life\ntop: true\n---\n\n每天一碗鸡汤，强生健体 :)\n\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=46fc9b94b51c8701c2bbbab44616f54a/00e93901213fb80e136344a730d12f2eb938940b.jpg)\n\n[曾经的你 -- 网易云音乐](https://music.163.com/#/song?id=167975)\n\n<!--more-->\n\n记录看到能给予自己Power的词句，与未来的自己干杯。\n![了不起的盖茨比, 举杯](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1533150875649&di=4f13323ee04bec1e72b5bf74478d10bb&imgtype=0&src=http%3A%2F%2Fwww.cssn.cn%2Fst%2Fst_zpwht%2F201411%2FW020141123799706038347.png)\n\n## 品尝\n\n在孤独中跃迁\n\n这世界上唯一扛得住岁月摧残的东西，就是才华 -- [李安](https://baike.baidu.com/item/%E6%9D%8E%E5%AE%89/16812?fr=aladdin)\n\n## 态度\n\n顺境修力，逆境修心\n\n成功的哲学在于坚持得有多久\n\n我相信你是世界上最富有的人之一，拥有梦想、时间和人生无数种可能性\n\n把自己交给繁忙，得到的是踏实，却不是真实。 -- 《[无问西东](https://baike.baidu.com/item/%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C/1743189?fr=aladdin)》\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=b2fe4255c01349546a13e0363727f93d/d000baa1cd11728bab3176f6c3fcc3cec2fd2cc2.jpg)\n\n吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。 -- [荀子，《劝学》](https://baike.baidu.com/item/%E5%8A%9D%E5%AD%A6/1055?fr=aladdin)（有类似于，学而不思则罔,思而不学则怠。）\n\n只要努力了，一定会有结果。但结果也分好坏，这个结果不一定是你想要的。尽管如此，我们也不应该放弃改变，固步自封。\n\n别人贪婪的时候我恐惧，别人恐惧的时候我贪婪。 -- [沃伦·巴菲特](https://baike.baidu.com/item/%E6%B2%83%E4%BC%A6%C2%B7%E5%B7%B4%E8%8F%B2%E7%89%B9/472378?fromtitle=%E5%B7%B4%E8%8F%B2%E7%89%B9&fromid=215648&fr=aladdin)\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=64e7757bdb160924c828aa49b56e5e9f/1f178a82b9014a9024195490a2773912b31beefc.jpg)\n\n唯一真正的成功，是按自己的意思過上生活。-- [阮一峰 第15周分享](http://www.ruanyifeng.com/blog/2018/07/weekly-issue-15.html)\n\n如果一件事，我们仅仅因为害羞不去做，那么它更值得去做。\n\n人只是一根芦苇，是自然界最为脆弱的，但他却是一根会思考的芦苇。 -- [布莱士·帕斯卡](https://baike.baidu.com/item/%E5%B8%83%E8%8E%B1%E5%A3%AB%C2%B7%E5%B8%95%E6%96%AF%E5%8D%A1/8791342?fromtitle=%E5%B8%95%E6%96%AF%E5%8D%A1&fromid=5464)\n\n未经审视的人生是不值得过的。 -- [苏格拉底](https://baike.baidu.com/item/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95/12690?fr=aladdin)\n\n快速走向成熟有且只有一种方法：**主动进行大量有目的性的试错与学习。**\n\n不要因为没有草原，就忘记你是马。-- [朴树，No Fear In My Heart](https://baike.baidu.com/item/No%20Fear%20In%20My%20Heart/20864952?fr=aladdin)\n\n**改变能改变的，接受不能改变的。**\n\n[Ginga -- 网易云音乐](https://music.163.com/#/song?id=418532318)\n\n不能羞于承认你自己。\n别急于求成，一切水到渠成。\n要练就练强大的内心。 -- 《[传奇的诞生](https://baike.baidu.com/item/%E4%BC%A0%E5%A5%87%E7%9A%84%E8%AF%9E%E7%94%9F/22822757?fr=aladdin&fromtitle=%E8%B4%9D%E5%88%A9%EF%BC%9A%E4%BC%A0%E5%A5%87%E7%9A%84%E8%AF%9E%E7%94%9F&fromid=19874519)》\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike933%2C5%2C5%2C933%2C330/sign=01382c29bb003af359b7d4325443ad39/21a4462309f79052afc98b1e01f3d7ca7bcbd538.jpg)\n\n真正的方法，往往是那些简单明了，朴素的至理名言。但我们总是视而不见，去追求那些虚无缥缈的东西。我们需要做的，**是在年轻的时候，坚持学习，提升认知水平、培养分析和解决问题的能力，而不是天天琢磨出路在哪里！**\n\n容易的道路越走越困难，困难的道路越走越容易。\n\n一个人经常改变自己的看法，更可能得到正确的观点。世界变化太快，最聪明的人会不断修改自己对世界的理解，重新考虑哪些有定见的问题，不断用新的信息、想法挑战自己的思维方式，把自己的观点视为暂时的。 -- [杰夫·贝佐斯， 亚马逊](https://baike.baidu.com/item/%E6%9D%B0%E5%A4%AB%C2%B7%E8%B4%9D%E4%BD%90%E6%96%AF/8375177?fr=aladdin)\n\n败而坦然，胜而自然。 -- [李建](https://www.iqiyi.com/v_19rr579bo4.html)\n\n[知人者智，自知者明](https://baike.baidu.com/item/%E7%9F%A5%E4%BA%BA%E8%80%85%E6%99%BA%EF%BC%8C%E8%87%AA%E7%9F%A5%E8%80%85%E6%98%8E/4367682?fr=aladdin)\n\n>知人者智，知己者明。胜人者有力，胜己者强。知足者富，强行者有志，不失其所者久，死而不亡者寿。\n\n## 生活\n\n与其临渊羡鱼，不如退而结网\n\n在这个世道上能活下来的要么坚强，要么坚强\n\n明明是我们看错了世界，却说世界欺骗了我们。 -- [张小娴](https://baike.baidu.com/item/%E5%BC%A0%E5%B0%8F%E5%A8%B4/201628?fr=aladdin)\n\n**生活最沉重的负担不是生活，而是无聊**。 -- [罗曼.罗兰](https://baike.baidu.com/item/%E7%BD%97%E6%9B%BC%C2%B7%E7%BD%97%E5%85%B0/802941?fromtitle=%E7%BD%97%E6%9B%BC%E7%BD%97%E5%85%B0&fromid=1062483&fr=aladdin)\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=162842ab1f950a7b613846966bb809bc/4ec2d5628535e5ddbd31bc4274c6a7efce1b6209.jpg)\n\n生活一定要五颜六色，但绝不要乱七八糟。\n\n带给男人快速成熟的，往往是生活不经意的意外。\n\n哪有人天生会懂事，只不过见多了恶心的人。\n\n言念君子，温其如玉。 -- [《国风·秦风·小戎》](https://baike.baidu.com/item/%E5%9B%BD%E9%A3%8E%C2%B7%E7%A7%A6%E9%A3%8E%C2%B7%E5%B0%8F%E6%88%8E/2687122)\n\n这世界上，绝大部分人的人生，都是八个字 -- 比上不足，比下有余。没动力的时候往上看看，没希望的时候往下瞅瞅，日子就能过的很好。\n\n人生不是走斜坡，你持续走就可以走到巅峰；**人生像走阶梯，每一阶有每一阶的难点**，学物理有物理的难点，学漫画有漫画的难点，你没有克服难点，再怎么努力都是原地跳。所以当你克服难点，你跳上去就不会下来了。\n-- [《努力是没有用的》，蔡志忠](https://www.yuque.com/book-academy/share/shp7tu)\n\n>成功的人生是台阶式向上，而不是一条水平线。努力只是说明你拼命在走，跟你能不能向上走，关系不大。那些努力却没有结果的人，根本原因就在于，他一直走在平面上，没有走到更高的台阶。 \n\n>垂直方向的努力更有意义，水平方向的努力意义不大。你做完这件事后，再去挑战更难的事情，就有机会学会做两件事。-- [《每周分享第 21 期 》，阮一峰](http://www.ruanyifeng.com/blog/2018/09/weekly-issue-21.html)\n\n痛苦是财富，这话是扯谈，痛苦就是痛苦，**对痛苦的思考才是财富。** -- [没必要的苦，不值得经历](https://www.yuque.com/book-academy/share/paglv3)","slug":"Better-Man","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0oq0002zkgrs3leobbc","content":"<p>每天一碗鸡汤，强生健体 :)</p>\n<p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=46fc9b94b51c8701c2bbbab44616f54a/00e93901213fb80e136344a730d12f2eb938940b.jpg\" alt=\"\"></p>\n<p><a href=\"https://music.163.com/#/song?id=167975\" target=\"_blank\" rel=\"noopener\">曾经的你 – 网易云音乐</a></p>\n<a id=\"more\"></a>\n<p>记录看到能给予自己Power的词句，与未来的自己干杯。<br><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533150875649&amp;di=4f13323ee04bec1e72b5bf74478d10bb&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.cssn.cn%2Fst%2Fst_zpwht%2F201411%2FW020141123799706038347.png\" alt=\"了不起的盖茨比, 举杯\"></p>\n<h2 id=\"品尝\"><a href=\"#品尝\" class=\"headerlink\" title=\"品尝\"></a>品尝</h2><p>在孤独中跃迁</p>\n<p>这世界上唯一扛得住岁月摧残的东西，就是才华 – <a href=\"https://baike.baidu.com/item/%E6%9D%8E%E5%AE%89/16812?fr=aladdin\" target=\"_blank\" rel=\"noopener\">李安</a></p>\n<h2 id=\"态度\"><a href=\"#态度\" class=\"headerlink\" title=\"态度\"></a>态度</h2><p>顺境修力，逆境修心</p>\n<p>成功的哲学在于坚持得有多久</p>\n<p>我相信你是世界上最富有的人之一，拥有梦想、时间和人生无数种可能性</p>\n<p>把自己交给繁忙，得到的是踏实，却不是真实。 – 《<a href=\"https://baike.baidu.com/item/%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C/1743189?fr=aladdin\" target=\"_blank\" rel=\"noopener\">无问西东</a>》<br><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=b2fe4255c01349546a13e0363727f93d/d000baa1cd11728bab3176f6c3fcc3cec2fd2cc2.jpg\" alt=\"\"></p>\n<p>吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。 – <a href=\"https://baike.baidu.com/item/%E5%8A%9D%E5%AD%A6/1055?fr=aladdin\" target=\"_blank\" rel=\"noopener\">荀子，《劝学》</a>（有类似于，学而不思则罔,思而不学则怠。）</p>\n<p>只要努力了，一定会有结果。但结果也分好坏，这个结果不一定是你想要的。尽管如此，我们也不应该放弃改变，固步自封。</p>\n<p>别人贪婪的时候我恐惧，别人恐惧的时候我贪婪。 – <a href=\"https://baike.baidu.com/item/%E6%B2%83%E4%BC%A6%C2%B7%E5%B7%B4%E8%8F%B2%E7%89%B9/472378?fromtitle=%E5%B7%B4%E8%8F%B2%E7%89%B9&amp;fromid=215648&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">沃伦·巴菲特</a></p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=64e7757bdb160924c828aa49b56e5e9f/1f178a82b9014a9024195490a2773912b31beefc.jpg\" alt=\"\"></p>\n<p>唯一真正的成功，是按自己的意思過上生活。– <a href=\"http://www.ruanyifeng.com/blog/2018/07/weekly-issue-15.html\" target=\"_blank\" rel=\"noopener\">阮一峰 第15周分享</a></p>\n<p>如果一件事，我们仅仅因为害羞不去做，那么它更值得去做。</p>\n<p>人只是一根芦苇，是自然界最为脆弱的，但他却是一根会思考的芦苇。 – <a href=\"https://baike.baidu.com/item/%E5%B8%83%E8%8E%B1%E5%A3%AB%C2%B7%E5%B8%95%E6%96%AF%E5%8D%A1/8791342?fromtitle=%E5%B8%95%E6%96%AF%E5%8D%A1&amp;fromid=5464\" target=\"_blank\" rel=\"noopener\">布莱士·帕斯卡</a></p>\n<p>未经审视的人生是不值得过的。 – <a href=\"https://baike.baidu.com/item/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95/12690?fr=aladdin\" target=\"_blank\" rel=\"noopener\">苏格拉底</a></p>\n<p>快速走向成熟有且只有一种方法：<strong>主动进行大量有目的性的试错与学习。</strong></p>\n<p>不要因为没有草原，就忘记你是马。– <a href=\"https://baike.baidu.com/item/No%20Fear%20In%20My%20Heart/20864952?fr=aladdin\" target=\"_blank\" rel=\"noopener\">朴树，No Fear In My Heart</a></p>\n<p><strong>改变能改变的，接受不能改变的。</strong></p>\n<p><a href=\"https://music.163.com/#/song?id=418532318\" target=\"_blank\" rel=\"noopener\">Ginga – 网易云音乐</a></p>\n<p>不能羞于承认你自己。<br>别急于求成，一切水到渠成。<br>要练就练强大的内心。 – 《<a href=\"https://baike.baidu.com/item/%E4%BC%A0%E5%A5%87%E7%9A%84%E8%AF%9E%E7%94%9F/22822757?fr=aladdin&amp;fromtitle=%E8%B4%9D%E5%88%A9%EF%BC%9A%E4%BC%A0%E5%A5%87%E7%9A%84%E8%AF%9E%E7%94%9F&amp;fromid=19874519\" target=\"_blank\" rel=\"noopener\">传奇的诞生</a>》<br><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike933%2C5%2C5%2C933%2C330/sign=01382c29bb003af359b7d4325443ad39/21a4462309f79052afc98b1e01f3d7ca7bcbd538.jpg\" alt=\"\"></p>\n<p>真正的方法，往往是那些简单明了，朴素的至理名言。但我们总是视而不见，去追求那些虚无缥缈的东西。我们需要做的，<strong>是在年轻的时候，坚持学习，提升认知水平、培养分析和解决问题的能力，而不是天天琢磨出路在哪里！</strong></p>\n<p>容易的道路越走越困难，困难的道路越走越容易。</p>\n<p>一个人经常改变自己的看法，更可能得到正确的观点。世界变化太快，最聪明的人会不断修改自己对世界的理解，重新考虑哪些有定见的问题，不断用新的信息、想法挑战自己的思维方式，把自己的观点视为暂时的。 – <a href=\"https://baike.baidu.com/item/%E6%9D%B0%E5%A4%AB%C2%B7%E8%B4%9D%E4%BD%90%E6%96%AF/8375177?fr=aladdin\" target=\"_blank\" rel=\"noopener\">杰夫·贝佐斯， 亚马逊</a></p>\n<p>败而坦然，胜而自然。 – <a href=\"https://www.iqiyi.com/v_19rr579bo4.html\" target=\"_blank\" rel=\"noopener\">李建</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E7%9F%A5%E4%BA%BA%E8%80%85%E6%99%BA%EF%BC%8C%E8%87%AA%E7%9F%A5%E8%80%85%E6%98%8E/4367682?fr=aladdin\" target=\"_blank\" rel=\"noopener\">知人者智，自知者明</a></p>\n<blockquote>\n<p>知人者智，知己者明。胜人者有力，胜己者强。知足者富，强行者有志，不失其所者久，死而不亡者寿。</p>\n</blockquote>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>与其临渊羡鱼，不如退而结网</p>\n<p>在这个世道上能活下来的要么坚强，要么坚强</p>\n<p>明明是我们看错了世界，却说世界欺骗了我们。 – <a href=\"https://baike.baidu.com/item/%E5%BC%A0%E5%B0%8F%E5%A8%B4/201628?fr=aladdin\" target=\"_blank\" rel=\"noopener\">张小娴</a></p>\n<p><strong>生活最沉重的负担不是生活，而是无聊</strong>。 – <a href=\"https://baike.baidu.com/item/%E7%BD%97%E6%9B%BC%C2%B7%E7%BD%97%E5%85%B0/802941?fromtitle=%E7%BD%97%E6%9B%BC%E7%BD%97%E5%85%B0&amp;fromid=1062483&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">罗曼.罗兰</a><br><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=162842ab1f950a7b613846966bb809bc/4ec2d5628535e5ddbd31bc4274c6a7efce1b6209.jpg\" alt=\"\"></p>\n<p>生活一定要五颜六色，但绝不要乱七八糟。</p>\n<p>带给男人快速成熟的，往往是生活不经意的意外。</p>\n<p>哪有人天生会懂事，只不过见多了恶心的人。</p>\n<p>言念君子，温其如玉。 – <a href=\"https://baike.baidu.com/item/%E5%9B%BD%E9%A3%8E%C2%B7%E7%A7%A6%E9%A3%8E%C2%B7%E5%B0%8F%E6%88%8E/2687122\" target=\"_blank\" rel=\"noopener\">《国风·秦风·小戎》</a></p>\n<p>这世界上，绝大部分人的人生，都是八个字 – 比上不足，比下有余。没动力的时候往上看看，没希望的时候往下瞅瞅，日子就能过的很好。</p>\n<p>人生不是走斜坡，你持续走就可以走到巅峰；<strong>人生像走阶梯，每一阶有每一阶的难点</strong>，学物理有物理的难点，学漫画有漫画的难点，你没有克服难点，再怎么努力都是原地跳。所以当你克服难点，你跳上去就不会下来了。<br>– <a href=\"https://www.yuque.com/book-academy/share/shp7tu\" target=\"_blank\" rel=\"noopener\">《努力是没有用的》，蔡志忠</a></p>\n<blockquote>\n<p>成功的人生是台阶式向上，而不是一条水平线。努力只是说明你拼命在走，跟你能不能向上走，关系不大。那些努力却没有结果的人，根本原因就在于，他一直走在平面上，没有走到更高的台阶。 </p>\n</blockquote>\n<blockquote>\n<p>垂直方向的努力更有意义，水平方向的努力意义不大。你做完这件事后，再去挑战更难的事情，就有机会学会做两件事。– <a href=\"http://www.ruanyifeng.com/blog/2018/09/weekly-issue-21.html\" target=\"_blank\" rel=\"noopener\">《每周分享第 21 期 》，阮一峰</a></p>\n</blockquote>\n<p>痛苦是财富，这话是扯谈，痛苦就是痛苦，<strong>对痛苦的思考才是财富。</strong> – <a href=\"https://www.yuque.com/book-academy/share/paglv3\" target=\"_blank\" rel=\"noopener\">没必要的苦，不值得经历</a></p>\n","site":{"data":{}},"excerpt":"<p>每天一碗鸡汤，强生健体 :)</p>\n<p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=46fc9b94b51c8701c2bbbab44616f54a/00e93901213fb80e136344a730d12f2eb938940b.jpg\" alt=\"\"></p>\n<p><a href=\"https://music.163.com/#/song?id=167975\" target=\"_blank\" rel=\"noopener\">曾经的你 – 网易云音乐</a></p>","more":"<p>记录看到能给予自己Power的词句，与未来的自己干杯。<br><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533150875649&amp;di=4f13323ee04bec1e72b5bf74478d10bb&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.cssn.cn%2Fst%2Fst_zpwht%2F201411%2FW020141123799706038347.png\" alt=\"了不起的盖茨比, 举杯\"></p>\n<h2 id=\"品尝\"><a href=\"#品尝\" class=\"headerlink\" title=\"品尝\"></a>品尝</h2><p>在孤独中跃迁</p>\n<p>这世界上唯一扛得住岁月摧残的东西，就是才华 – <a href=\"https://baike.baidu.com/item/%E6%9D%8E%E5%AE%89/16812?fr=aladdin\" target=\"_blank\" rel=\"noopener\">李安</a></p>\n<h2 id=\"态度\"><a href=\"#态度\" class=\"headerlink\" title=\"态度\"></a>态度</h2><p>顺境修力，逆境修心</p>\n<p>成功的哲学在于坚持得有多久</p>\n<p>我相信你是世界上最富有的人之一，拥有梦想、时间和人生无数种可能性</p>\n<p>把自己交给繁忙，得到的是踏实，却不是真实。 – 《<a href=\"https://baike.baidu.com/item/%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C/1743189?fr=aladdin\" target=\"_blank\" rel=\"noopener\">无问西东</a>》<br><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=b2fe4255c01349546a13e0363727f93d/d000baa1cd11728bab3176f6c3fcc3cec2fd2cc2.jpg\" alt=\"\"></p>\n<p>吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。 – <a href=\"https://baike.baidu.com/item/%E5%8A%9D%E5%AD%A6/1055?fr=aladdin\" target=\"_blank\" rel=\"noopener\">荀子，《劝学》</a>（有类似于，学而不思则罔,思而不学则怠。）</p>\n<p>只要努力了，一定会有结果。但结果也分好坏，这个结果不一定是你想要的。尽管如此，我们也不应该放弃改变，固步自封。</p>\n<p>别人贪婪的时候我恐惧，别人恐惧的时候我贪婪。 – <a href=\"https://baike.baidu.com/item/%E6%B2%83%E4%BC%A6%C2%B7%E5%B7%B4%E8%8F%B2%E7%89%B9/472378?fromtitle=%E5%B7%B4%E8%8F%B2%E7%89%B9&amp;fromid=215648&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">沃伦·巴菲特</a></p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=64e7757bdb160924c828aa49b56e5e9f/1f178a82b9014a9024195490a2773912b31beefc.jpg\" alt=\"\"></p>\n<p>唯一真正的成功，是按自己的意思過上生活。– <a href=\"http://www.ruanyifeng.com/blog/2018/07/weekly-issue-15.html\" target=\"_blank\" rel=\"noopener\">阮一峰 第15周分享</a></p>\n<p>如果一件事，我们仅仅因为害羞不去做，那么它更值得去做。</p>\n<p>人只是一根芦苇，是自然界最为脆弱的，但他却是一根会思考的芦苇。 – <a href=\"https://baike.baidu.com/item/%E5%B8%83%E8%8E%B1%E5%A3%AB%C2%B7%E5%B8%95%E6%96%AF%E5%8D%A1/8791342?fromtitle=%E5%B8%95%E6%96%AF%E5%8D%A1&amp;fromid=5464\" target=\"_blank\" rel=\"noopener\">布莱士·帕斯卡</a></p>\n<p>未经审视的人生是不值得过的。 – <a href=\"https://baike.baidu.com/item/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95/12690?fr=aladdin\" target=\"_blank\" rel=\"noopener\">苏格拉底</a></p>\n<p>快速走向成熟有且只有一种方法：<strong>主动进行大量有目的性的试错与学习。</strong></p>\n<p>不要因为没有草原，就忘记你是马。– <a href=\"https://baike.baidu.com/item/No%20Fear%20In%20My%20Heart/20864952?fr=aladdin\" target=\"_blank\" rel=\"noopener\">朴树，No Fear In My Heart</a></p>\n<p><strong>改变能改变的，接受不能改变的。</strong></p>\n<p><a href=\"https://music.163.com/#/song?id=418532318\" target=\"_blank\" rel=\"noopener\">Ginga – 网易云音乐</a></p>\n<p>不能羞于承认你自己。<br>别急于求成，一切水到渠成。<br>要练就练强大的内心。 – 《<a href=\"https://baike.baidu.com/item/%E4%BC%A0%E5%A5%87%E7%9A%84%E8%AF%9E%E7%94%9F/22822757?fr=aladdin&amp;fromtitle=%E8%B4%9D%E5%88%A9%EF%BC%9A%E4%BC%A0%E5%A5%87%E7%9A%84%E8%AF%9E%E7%94%9F&amp;fromid=19874519\" target=\"_blank\" rel=\"noopener\">传奇的诞生</a>》<br><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike933%2C5%2C5%2C933%2C330/sign=01382c29bb003af359b7d4325443ad39/21a4462309f79052afc98b1e01f3d7ca7bcbd538.jpg\" alt=\"\"></p>\n<p>真正的方法，往往是那些简单明了，朴素的至理名言。但我们总是视而不见，去追求那些虚无缥缈的东西。我们需要做的，<strong>是在年轻的时候，坚持学习，提升认知水平、培养分析和解决问题的能力，而不是天天琢磨出路在哪里！</strong></p>\n<p>容易的道路越走越困难，困难的道路越走越容易。</p>\n<p>一个人经常改变自己的看法，更可能得到正确的观点。世界变化太快，最聪明的人会不断修改自己对世界的理解，重新考虑哪些有定见的问题，不断用新的信息、想法挑战自己的思维方式，把自己的观点视为暂时的。 – <a href=\"https://baike.baidu.com/item/%E6%9D%B0%E5%A4%AB%C2%B7%E8%B4%9D%E4%BD%90%E6%96%AF/8375177?fr=aladdin\" target=\"_blank\" rel=\"noopener\">杰夫·贝佐斯， 亚马逊</a></p>\n<p>败而坦然，胜而自然。 – <a href=\"https://www.iqiyi.com/v_19rr579bo4.html\" target=\"_blank\" rel=\"noopener\">李建</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E7%9F%A5%E4%BA%BA%E8%80%85%E6%99%BA%EF%BC%8C%E8%87%AA%E7%9F%A5%E8%80%85%E6%98%8E/4367682?fr=aladdin\" target=\"_blank\" rel=\"noopener\">知人者智，自知者明</a></p>\n<blockquote>\n<p>知人者智，知己者明。胜人者有力，胜己者强。知足者富，强行者有志，不失其所者久，死而不亡者寿。</p>\n</blockquote>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>与其临渊羡鱼，不如退而结网</p>\n<p>在这个世道上能活下来的要么坚强，要么坚强</p>\n<p>明明是我们看错了世界，却说世界欺骗了我们。 – <a href=\"https://baike.baidu.com/item/%E5%BC%A0%E5%B0%8F%E5%A8%B4/201628?fr=aladdin\" target=\"_blank\" rel=\"noopener\">张小娴</a></p>\n<p><strong>生活最沉重的负担不是生活，而是无聊</strong>。 – <a href=\"https://baike.baidu.com/item/%E7%BD%97%E6%9B%BC%C2%B7%E7%BD%97%E5%85%B0/802941?fromtitle=%E7%BD%97%E6%9B%BC%E7%BD%97%E5%85%B0&amp;fromid=1062483&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">罗曼.罗兰</a><br><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=162842ab1f950a7b613846966bb809bc/4ec2d5628535e5ddbd31bc4274c6a7efce1b6209.jpg\" alt=\"\"></p>\n<p>生活一定要五颜六色，但绝不要乱七八糟。</p>\n<p>带给男人快速成熟的，往往是生活不经意的意外。</p>\n<p>哪有人天生会懂事，只不过见多了恶心的人。</p>\n<p>言念君子，温其如玉。 – <a href=\"https://baike.baidu.com/item/%E5%9B%BD%E9%A3%8E%C2%B7%E7%A7%A6%E9%A3%8E%C2%B7%E5%B0%8F%E6%88%8E/2687122\" target=\"_blank\" rel=\"noopener\">《国风·秦风·小戎》</a></p>\n<p>这世界上，绝大部分人的人生，都是八个字 – 比上不足，比下有余。没动力的时候往上看看，没希望的时候往下瞅瞅，日子就能过的很好。</p>\n<p>人生不是走斜坡，你持续走就可以走到巅峰；<strong>人生像走阶梯，每一阶有每一阶的难点</strong>，学物理有物理的难点，学漫画有漫画的难点，你没有克服难点，再怎么努力都是原地跳。所以当你克服难点，你跳上去就不会下来了。<br>– <a href=\"https://www.yuque.com/book-academy/share/shp7tu\" target=\"_blank\" rel=\"noopener\">《努力是没有用的》，蔡志忠</a></p>\n<blockquote>\n<p>成功的人生是台阶式向上，而不是一条水平线。努力只是说明你拼命在走，跟你能不能向上走，关系不大。那些努力却没有结果的人，根本原因就在于，他一直走在平面上，没有走到更高的台阶。 </p>\n</blockquote>\n<blockquote>\n<p>垂直方向的努力更有意义，水平方向的努力意义不大。你做完这件事后，再去挑战更难的事情，就有机会学会做两件事。– <a href=\"http://www.ruanyifeng.com/blog/2018/09/weekly-issue-21.html\" target=\"_blank\" rel=\"noopener\">《每周分享第 21 期 》，阮一峰</a></p>\n</blockquote>\n<p>痛苦是财富，这话是扯谈，痛苦就是痛苦，<strong>对痛苦的思考才是财富。</strong> – <a href=\"https://www.yuque.com/book-academy/share/paglv3\" target=\"_blank\" rel=\"noopener\">没必要的苦，不值得经历</a></p>"},{"title":"Debug_high_cpu_loading","date":"2018-05-26T07:28:50.000Z","_content":"\n![](http://rdc.hundsun.com/portal/data/upload/201705/f_3c65934a804b2cd6ec6dab02ccb33457.png)\n\n<!--more-->\n\n追查问题，主要是在：\n\n- 浮现问题\n- 缩小范围\n- 猜测，修正及验证\n\n我们这里使用如下测试代码演示：\n\n``` c\n#include <stdio.h>\n#include <sys/epoll.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n#include <unistd.h>\n#define MAX_MONITOR_FILES 4\n\nvoid main()\n{\n  int e_fd, fd;\n  struct epoll_event event, rdy_event[MAX_MONITOR_FILES];\n\n  if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n      perror(\"socket\");\n      goto out1;\n  }\n\n  if ((e_fd = epoll_create(MAX_MONITOR_FILES)) == -1) {\n    perror(\"epoll_create\");\n    goto out2;\n  }\n\n  event.events = EPOLLIN;\n  if((epoll_ctl(e_fd, EPOLL_CTL_ADD, fd, &event)) == -1) {\n    perror(\"epoll_ctl\");\n    goto out3;\n  }\n\n  int n, j;\n  while(1) {\n    n = epoll_wait(e_fd, rdy_event, MAX_MONITOR_FILES, 0);\n    if(n == -1) {\n      perror(\"epoll_wait\");\n    }else if(n == 0) {\n      //timeout, skip\n    }\n\n    for(j=0; j<n; j++) {\n      //read it out\n    }\n  }\n\nout3:\n        close(e_fd);\nout2:\n        close(fd);\nout1:\n        return;\n}\n```\n\n## 进程\n我们通常可以使用top 命令查看到某一个进程占用了较高的CPU Loading。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/top_process.png)\n\n## 线程\n可以通过`top -H -p <pid>` 命令具体查看`<pid>` 进程的子线程占用CPU Loading的情况。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/top_thread.png)\n\n这里是单独一个进程，是以这里只是单单出现一个。\n\n## 函数\n在定位到某一个线程之后，我们需要继续定位到某一个函数或者命令导致了CPU 占用过高。\n`strace -p <pid>` 命令能帮助查找到具体的函数。\n`pstack <pid>`, `trace -p <tid>`等命令也能给予我们一些启示。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/strace_process.png)\n\n## 参考资源\n[Linux下某个进程CPU占用率高分析方法](http://www.linuxeye.com/Linux/1843.html)\n[一次服务器CPU占用率高的定位分析](https://www.jianshu.com/p/e680d4e6d4ae)\n[超全整理！Linux性能分析工具汇总合集](https://blog.csdn.net/tiantangyouzui/article/details/72231590)","source":"_posts/Debug-high-cpu-loading.md","raw":"---\ntitle: Debug_high_cpu_loading\ndate: 2018-05-26 15:28:50\ntags: Debug\ncategories: debug\n---\n\n![](http://rdc.hundsun.com/portal/data/upload/201705/f_3c65934a804b2cd6ec6dab02ccb33457.png)\n\n<!--more-->\n\n追查问题，主要是在：\n\n- 浮现问题\n- 缩小范围\n- 猜测，修正及验证\n\n我们这里使用如下测试代码演示：\n\n``` c\n#include <stdio.h>\n#include <sys/epoll.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n#include <unistd.h>\n#define MAX_MONITOR_FILES 4\n\nvoid main()\n{\n  int e_fd, fd;\n  struct epoll_event event, rdy_event[MAX_MONITOR_FILES];\n\n  if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n      perror(\"socket\");\n      goto out1;\n  }\n\n  if ((e_fd = epoll_create(MAX_MONITOR_FILES)) == -1) {\n    perror(\"epoll_create\");\n    goto out2;\n  }\n\n  event.events = EPOLLIN;\n  if((epoll_ctl(e_fd, EPOLL_CTL_ADD, fd, &event)) == -1) {\n    perror(\"epoll_ctl\");\n    goto out3;\n  }\n\n  int n, j;\n  while(1) {\n    n = epoll_wait(e_fd, rdy_event, MAX_MONITOR_FILES, 0);\n    if(n == -1) {\n      perror(\"epoll_wait\");\n    }else if(n == 0) {\n      //timeout, skip\n    }\n\n    for(j=0; j<n; j++) {\n      //read it out\n    }\n  }\n\nout3:\n        close(e_fd);\nout2:\n        close(fd);\nout1:\n        return;\n}\n```\n\n## 进程\n我们通常可以使用top 命令查看到某一个进程占用了较高的CPU Loading。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/top_process.png)\n\n## 线程\n可以通过`top -H -p <pid>` 命令具体查看`<pid>` 进程的子线程占用CPU Loading的情况。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/top_thread.png)\n\n这里是单独一个进程，是以这里只是单单出现一个。\n\n## 函数\n在定位到某一个线程之后，我们需要继续定位到某一个函数或者命令导致了CPU 占用过高。\n`strace -p <pid>` 命令能帮助查找到具体的函数。\n`pstack <pid>`, `trace -p <tid>`等命令也能给予我们一些启示。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/strace_process.png)\n\n## 参考资源\n[Linux下某个进程CPU占用率高分析方法](http://www.linuxeye.com/Linux/1843.html)\n[一次服务器CPU占用率高的定位分析](https://www.jianshu.com/p/e680d4e6d4ae)\n[超全整理！Linux性能分析工具汇总合集](https://blog.csdn.net/tiantangyouzui/article/details/72231590)","slug":"Debug-high-cpu-loading","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0ov0006zkgractdnipk","content":"<p><img src=\"http://rdc.hundsun.com/portal/data/upload/201705/f_3c65934a804b2cd6ec6dab02ccb33457.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>追查问题，主要是在：</p>\n<ul>\n<li>浮现问题</li>\n<li>缩小范围</li>\n<li>猜测，修正及验证</li>\n</ul>\n<p>我们这里使用如下测试代码演示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_MONITOR_FILES 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> e_fd, fd;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">event</span>, <span class=\"title\">rdy_event</span>[<span class=\"title\">MAX_MONITOR_FILES</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      perror(<span class=\"string\">\"socket\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> out1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((e_fd = epoll_create(MAX_MONITOR_FILES)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"epoll_create\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> out2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  event.events = EPOLLIN;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>((epoll_ctl(e_fd, EPOLL_CTL_ADD, fd, &amp;event)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"epoll_ctl\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> out3;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> n, j;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    n = epoll_wait(e_fd, rdy_event, MAX_MONITOR_FILES, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      perror(<span class=\"string\">\"epoll_wait\"</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//timeout, skip</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//read it out</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">out3:</span><br><span class=\"line\">        close(e_fd);</span><br><span class=\"line\">out2:</span><br><span class=\"line\">        close(fd);</span><br><span class=\"line\">out1:</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>我们通常可以使用top 命令查看到某一个进程占用了较高的CPU Loading。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/top_process.png\" alt=\"\"></p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>可以通过<code>top -H -p &lt;pid&gt;</code> 命令具体查看<code>&lt;pid&gt;</code> 进程的子线程占用CPU Loading的情况。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/top_thread.png\" alt=\"\"></p>\n<p>这里是单独一个进程，是以这里只是单单出现一个。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>在定位到某一个线程之后，我们需要继续定位到某一个函数或者命令导致了CPU 占用过高。<br><code>strace -p &lt;pid&gt;</code> 命令能帮助查找到具体的函数。<br><code>pstack &lt;pid&gt;</code>, <code>trace -p &lt;tid&gt;</code>等命令也能给予我们一些启示。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/strace_process.png\" alt=\"\"></p>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><p><a href=\"http://www.linuxeye.com/Linux/1843.html\" target=\"_blank\" rel=\"noopener\">Linux下某个进程CPU占用率高分析方法</a><br><a href=\"https://www.jianshu.com/p/e680d4e6d4ae\" target=\"_blank\" rel=\"noopener\">一次服务器CPU占用率高的定位分析</a><br><a href=\"https://blog.csdn.net/tiantangyouzui/article/details/72231590\" target=\"_blank\" rel=\"noopener\">超全整理！Linux性能分析工具汇总合集</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://rdc.hundsun.com/portal/data/upload/201705/f_3c65934a804b2cd6ec6dab02ccb33457.png\" alt=\"\"></p>","more":"<p>追查问题，主要是在：</p>\n<ul>\n<li>浮现问题</li>\n<li>缩小范围</li>\n<li>猜测，修正及验证</li>\n</ul>\n<p>我们这里使用如下测试代码演示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_MONITOR_FILES 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> e_fd, fd;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">event</span>, <span class=\"title\">rdy_event</span>[<span class=\"title\">MAX_MONITOR_FILES</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      perror(<span class=\"string\">\"socket\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> out1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((e_fd = epoll_create(MAX_MONITOR_FILES)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"epoll_create\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> out2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  event.events = EPOLLIN;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>((epoll_ctl(e_fd, EPOLL_CTL_ADD, fd, &amp;event)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"epoll_ctl\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> out3;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> n, j;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    n = epoll_wait(e_fd, rdy_event, MAX_MONITOR_FILES, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      perror(<span class=\"string\">\"epoll_wait\"</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//timeout, skip</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//read it out</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">out3:</span><br><span class=\"line\">        close(e_fd);</span><br><span class=\"line\">out2:</span><br><span class=\"line\">        close(fd);</span><br><span class=\"line\">out1:</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>我们通常可以使用top 命令查看到某一个进程占用了较高的CPU Loading。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/top_process.png\" alt=\"\"></p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>可以通过<code>top -H -p &lt;pid&gt;</code> 命令具体查看<code>&lt;pid&gt;</code> 进程的子线程占用CPU Loading的情况。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/top_thread.png\" alt=\"\"></p>\n<p>这里是单独一个进程，是以这里只是单单出现一个。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>在定位到某一个线程之后，我们需要继续定位到某一个函数或者命令导致了CPU 占用过高。<br><code>strace -p &lt;pid&gt;</code> 命令能帮助查找到具体的函数。<br><code>pstack &lt;pid&gt;</code>, <code>trace -p &lt;tid&gt;</code>等命令也能给予我们一些启示。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/cpu_high_loading/strace_process.png\" alt=\"\"></p>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><p><a href=\"http://www.linuxeye.com/Linux/1843.html\" target=\"_blank\" rel=\"noopener\">Linux下某个进程CPU占用率高分析方法</a><br><a href=\"https://www.jianshu.com/p/e680d4e6d4ae\" target=\"_blank\" rel=\"noopener\">一次服务器CPU占用率高的定位分析</a><br><a href=\"https://blog.csdn.net/tiantangyouzui/article/details/72231590\" target=\"_blank\" rel=\"noopener\">超全整理！Linux性能分析工具汇总合集</a></p>"},{"title":"Design_Pattern_II","date":"2019-01-28T10:03:48.000Z","_content":"\n## 1. 创建模式（Creational Patterns）\n### 1.1. 工厂模式（Factory)\n**目的**：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n**优点**: 扩展性高，并且屏蔽具体的实现。\n**缺点**: 每增加一个产品时，都需要实现具体类和对象实现工厂。\n\n```c++\n\nclass Shape\n{\n    public:\n        virtual void draw() {};\n};\n\nclass Circle: public Shape\n{\n    public:\n        void draw() { /* ... */ };\n};\n\nclass Square: public Shape\n{\n    public:\n        void draw() { /* ... */ };\n};\n\nclass ShapeFactory\n{\n    public:\n    class Shape * GetShape(string type) {\n        if(type.compare(\"CIRCLE\") == 0)\n            return new Circle();\n        else if(type.compare(\"SQUARE\") == 0)\n            return new Square();\n        else \n            return null;\n    }\n}\n\nvoid main()\n{\n    class ShapeFactory shapeFactory = new ShapeFactory();\n\n    class Shape *shape1, shape2;\n    \n    shape1 = shapeFactory.GetShape(\"CIRCLE\");\n    shape1->draw();\n\n    shape2 = shapeFactory.GetShape(\"SQUARE\");\n    shape2->draw();\n\n    delete shape1;\n    delete shape2;\n}\n```\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Factory_Pattern.png)\n\n<!--more-->\n\n### 1.2. 抽象工厂模式（Abstract Factory)\n**目的**：超级工厂又称为其他工厂的工厂，它提供了一种创建对象的最佳方式。\n\n**优点**: 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\n**缺点**: 产品族扩展困难。既要在抽象的creator 里修改，又要实现具体的代码。\n\n虚基类的感觉。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/AbstractFactory_Pattern.png)\n\nAbstrctFactory 与Factory 区别在于：AbstractFactory 模式是为了创建**一组**（有多类）相关或依赖的对象，Factory模式是为**一类**对象提供接口。\n\n### 1.3. 单例模式(Singleton)\n**意图**：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n**缺点**：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n创建唯一的变量（对象）\n\n[Singleton mode image]\n\n```c++\nclass Singleton\n{\n    public:\n        static Singleton * Instance()\n        {\n            if(_instance == 0)\n                _instance = new Singleton();\n\n            return _instance;\n        }\n    protected:\n        Singleton();\n    private:\n        static Singleton * _instance;\n}\n```\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Singleton_Pattern.png)\n\n注：Singleton 不可以被实例化（保证唯一一个），因此我们将它的构造函数声明为protected或private。\n\n### 1.3. 建造者模式（Builder）\n**意图**：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n\n**优点**： \n    - 建造者独立，易扩展\n    - 便于控制细节风险\n\n**缺点**： \n    - 产品必须有共同点，范围有限制\n    - 如内部变化复杂，会有很多的建造类\n\n![Builder](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Builder_Pattern.png)\n\n注：\nBuilder 与AbstractFactory 在功能上相似，都用来创建复杂的对象。Builder 是通过的**相同的创建过程获取不同的结果**，而AbstractFactory 强调为多个相互依赖的对象提供一个统一的接口。另外，AbstractFactory 是立即返回，Builder是在一系列动作后返回对象。\n\n\n### 1.4. 原型模式(Prototype)\n原型模式是用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。\n**优点**：  \n    - 性能提高      \n    - 逃避构造函数的约束    \n\n**缺点**：  \n    - 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候    \n    - 必须实现 clone() 接口 \n\n```c++\nclass BaseA\n{\n    public:\n    BaseA(){};\n    BaseA(const BaseA &A) //c++ 拷贝函数，深拷贝是指重新分配类里面的指针\n    {\n        member = A.member;\n    }\n\n    BaseA * Clone()\n    {\n        return new BaseA(*this);\n    }\n\n    private:\n    int member;\n}\n\nvoid main()\n{\n    BaseA *p1 = new BaseA();\n    BaseA *p2 = p1->Clone();\n}\n```\n[C++ 拷贝构造函数(深拷贝，浅拷贝)](https://www.cnblogs.com/BlueTzar/articles/1223313.html)","source":"_posts/Design-Pattern-II.md","raw":"---\ntitle: Design_Pattern_II\ndate: 2019-01-28 18:03:48\ntags: \n - bookmarks\n - program\ncategories: bookmarks\n---\n\n## 1. 创建模式（Creational Patterns）\n### 1.1. 工厂模式（Factory)\n**目的**：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n**优点**: 扩展性高，并且屏蔽具体的实现。\n**缺点**: 每增加一个产品时，都需要实现具体类和对象实现工厂。\n\n```c++\n\nclass Shape\n{\n    public:\n        virtual void draw() {};\n};\n\nclass Circle: public Shape\n{\n    public:\n        void draw() { /* ... */ };\n};\n\nclass Square: public Shape\n{\n    public:\n        void draw() { /* ... */ };\n};\n\nclass ShapeFactory\n{\n    public:\n    class Shape * GetShape(string type) {\n        if(type.compare(\"CIRCLE\") == 0)\n            return new Circle();\n        else if(type.compare(\"SQUARE\") == 0)\n            return new Square();\n        else \n            return null;\n    }\n}\n\nvoid main()\n{\n    class ShapeFactory shapeFactory = new ShapeFactory();\n\n    class Shape *shape1, shape2;\n    \n    shape1 = shapeFactory.GetShape(\"CIRCLE\");\n    shape1->draw();\n\n    shape2 = shapeFactory.GetShape(\"SQUARE\");\n    shape2->draw();\n\n    delete shape1;\n    delete shape2;\n}\n```\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Factory_Pattern.png)\n\n<!--more-->\n\n### 1.2. 抽象工厂模式（Abstract Factory)\n**目的**：超级工厂又称为其他工厂的工厂，它提供了一种创建对象的最佳方式。\n\n**优点**: 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\n**缺点**: 产品族扩展困难。既要在抽象的creator 里修改，又要实现具体的代码。\n\n虚基类的感觉。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/AbstractFactory_Pattern.png)\n\nAbstrctFactory 与Factory 区别在于：AbstractFactory 模式是为了创建**一组**（有多类）相关或依赖的对象，Factory模式是为**一类**对象提供接口。\n\n### 1.3. 单例模式(Singleton)\n**意图**：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n**缺点**：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n创建唯一的变量（对象）\n\n[Singleton mode image]\n\n```c++\nclass Singleton\n{\n    public:\n        static Singleton * Instance()\n        {\n            if(_instance == 0)\n                _instance = new Singleton();\n\n            return _instance;\n        }\n    protected:\n        Singleton();\n    private:\n        static Singleton * _instance;\n}\n```\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Singleton_Pattern.png)\n\n注：Singleton 不可以被实例化（保证唯一一个），因此我们将它的构造函数声明为protected或private。\n\n### 1.3. 建造者模式（Builder）\n**意图**：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n\n**优点**： \n    - 建造者独立，易扩展\n    - 便于控制细节风险\n\n**缺点**： \n    - 产品必须有共同点，范围有限制\n    - 如内部变化复杂，会有很多的建造类\n\n![Builder](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Builder_Pattern.png)\n\n注：\nBuilder 与AbstractFactory 在功能上相似，都用来创建复杂的对象。Builder 是通过的**相同的创建过程获取不同的结果**，而AbstractFactory 强调为多个相互依赖的对象提供一个统一的接口。另外，AbstractFactory 是立即返回，Builder是在一系列动作后返回对象。\n\n\n### 1.4. 原型模式(Prototype)\n原型模式是用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。\n**优点**：  \n    - 性能提高      \n    - 逃避构造函数的约束    \n\n**缺点**：  \n    - 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候    \n    - 必须实现 clone() 接口 \n\n```c++\nclass BaseA\n{\n    public:\n    BaseA(){};\n    BaseA(const BaseA &A) //c++ 拷贝函数，深拷贝是指重新分配类里面的指针\n    {\n        member = A.member;\n    }\n\n    BaseA * Clone()\n    {\n        return new BaseA(*this);\n    }\n\n    private:\n    int member;\n}\n\nvoid main()\n{\n    BaseA *p1 = new BaseA();\n    BaseA *p2 = p1->Clone();\n}\n```\n[C++ 拷贝构造函数(深拷贝，浅拷贝)](https://www.cnblogs.com/BlueTzar/articles/1223313.html)","slug":"Design-Pattern-II","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0ox0007zkgrtvr32g4w","content":"<h2 id=\"1-创建模式（Creational-Patterns）\"><a href=\"#1-创建模式（Creational-Patterns）\" class=\"headerlink\" title=\"1. 创建模式（Creational Patterns）\"></a>1. 创建模式（Creational Patterns）</h2><h3 id=\"1-1-工厂模式（Factory\"><a href=\"#1-1-工厂模式（Factory\" class=\"headerlink\" title=\"1.1. 工厂模式（Factory)\"></a>1.1. 工厂模式（Factory)</h3><p><strong>目的</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>优点</strong>: 扩展性高，并且屏蔽具体的实现。<br><strong>缺点</strong>: 每增加一个产品时，都需要实现具体类和对象实现工厂。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span>:</span> <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span>:</span> <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeFactory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">class Shape * <span class=\"title\">GetShape</span><span class=\"params\">(<span class=\"built_in\">string</span> type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(type.compare(<span class=\"string\">\"CIRCLE\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Circle();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(type.compare(<span class=\"string\">\"SQUARE\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Square();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeFactory</span> <span class=\"title\">shapeFactory</span> = <span class=\"title\">new</span> <span class=\"title\">ShapeFactory</span>();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> *<span class=\"title\">shape1</span>, <span class=\"title\">shape2</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    shape1 = shapeFactory.GetShape(<span class=\"string\">\"CIRCLE\"</span>);</span><br><span class=\"line\">    shape1-&gt;draw();</span><br><span class=\"line\"></span><br><span class=\"line\">    shape2 = shapeFactory.GetShape(<span class=\"string\">\"SQUARE\"</span>);</span><br><span class=\"line\">    shape2-&gt;draw();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> shape1;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> shape2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Factory_Pattern.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"1-2-抽象工厂模式（Abstract-Factory\"><a href=\"#1-2-抽象工厂模式（Abstract-Factory\" class=\"headerlink\" title=\"1.2. 抽象工厂模式（Abstract Factory)\"></a>1.2. 抽象工厂模式（Abstract Factory)</h3><p><strong>目的</strong>：超级工厂又称为其他工厂的工厂，它提供了一种创建对象的最佳方式。</p>\n<p><strong>优点</strong>: 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br><strong>缺点</strong>: 产品族扩展困难。既要在抽象的creator 里修改，又要实现具体的代码。</p>\n<p>虚基类的感觉。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/AbstractFactory_Pattern.png\" alt=\"\"></p>\n<p>AbstrctFactory 与Factory 区别在于：AbstractFactory 模式是为了创建<strong>一组</strong>（有多类）相关或依赖的对象，Factory模式是为<strong>一类</strong>对象提供接口。</p>\n<h3 id=\"1-3-单例模式-Singleton\"><a href=\"#1-3-单例模式-Singleton\" class=\"headerlink\" title=\"1.3. 单例模式(Singleton)\"></a>1.3. 单例模式(Singleton)</h3><p><strong>意图</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>缺点</strong>：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br>创建唯一的变量（对象）</p>\n<p>[Singleton mode image]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">static</span> Singleton * <span class=\"title\">Instance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(_instance == <span class=\"number\">0</span>)</span><br><span class=\"line\">                _instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> _instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        Singleton();</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Singleton * _instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Singleton_Pattern.png\" alt=\"\"></p>\n<p>注：Singleton 不可以被实例化（保证唯一一个），因此我们将它的构造函数声明为protected或private。</p>\n<h3 id=\"1-3-建造者模式（Builder）\"><a href=\"#1-3-建造者模式（Builder）\" class=\"headerlink\" title=\"1.3. 建造者模式（Builder）\"></a>1.3. 建造者模式（Builder）</h3><p><strong>意图</strong>：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>\n<p><strong>优点</strong>： </p>\n<pre><code>- 建造者独立，易扩展\n- 便于控制细节风险\n</code></pre><p><strong>缺点</strong>： </p>\n<pre><code>- 产品必须有共同点，范围有限制\n- 如内部变化复杂，会有很多的建造类\n</code></pre><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Builder_Pattern.png\" alt=\"Builder\"></p>\n<p>注：<br>Builder 与AbstractFactory 在功能上相似，都用来创建复杂的对象。Builder 是通过的<strong>相同的创建过程获取不同的结果</strong>，而AbstractFactory 强调为多个相互依赖的对象提供一个统一的接口。另外，AbstractFactory 是立即返回，Builder是在一系列动作后返回对象。</p>\n<h3 id=\"1-4-原型模式-Prototype\"><a href=\"#1-4-原型模式-Prototype\" class=\"headerlink\" title=\"1.4. 原型模式(Prototype)\"></a>1.4. 原型模式(Prototype)</h3><p>原型模式是用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。<br><strong>优点</strong>：  </p>\n<pre><code>- 性能提高      \n- 逃避构造函数的约束    \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候    \n- 必须实现 clone() 接口 \n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseA</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    BaseA()&#123;&#125;;</span><br><span class=\"line\">    BaseA(<span class=\"keyword\">const</span> BaseA &amp;A) <span class=\"comment\">//c++ 拷贝函数，深拷贝是指重新分配类里面的指针</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        member = A.member;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">BaseA * <span class=\"title\">Clone</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BaseA(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> member;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    BaseA *p1 = <span class=\"keyword\">new</span> BaseA();</span><br><span class=\"line\">    BaseA *p2 = p1-&gt;Clone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.cnblogs.com/BlueTzar/articles/1223313.html\" target=\"_blank\" rel=\"noopener\">C++ 拷贝构造函数(深拷贝，浅拷贝)</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-创建模式（Creational-Patterns）\"><a href=\"#1-创建模式（Creational-Patterns）\" class=\"headerlink\" title=\"1. 创建模式（Creational Patterns）\"></a>1. 创建模式（Creational Patterns）</h2><h3 id=\"1-1-工厂模式（Factory\"><a href=\"#1-1-工厂模式（Factory\" class=\"headerlink\" title=\"1.1. 工厂模式（Factory)\"></a>1.1. 工厂模式（Factory)</h3><p><strong>目的</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>优点</strong>: 扩展性高，并且屏蔽具体的实现。<br><strong>缺点</strong>: 每增加一个产品时，都需要实现具体类和对象实现工厂。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span>:</span> <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span>:</span> <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeFactory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">class Shape * <span class=\"title\">GetShape</span><span class=\"params\">(<span class=\"built_in\">string</span> type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(type.compare(<span class=\"string\">\"CIRCLE\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Circle();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(type.compare(<span class=\"string\">\"SQUARE\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Square();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeFactory</span> <span class=\"title\">shapeFactory</span> = <span class=\"title\">new</span> <span class=\"title\">ShapeFactory</span>();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> *<span class=\"title\">shape1</span>, <span class=\"title\">shape2</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    shape1 = shapeFactory.GetShape(<span class=\"string\">\"CIRCLE\"</span>);</span><br><span class=\"line\">    shape1-&gt;draw();</span><br><span class=\"line\"></span><br><span class=\"line\">    shape2 = shapeFactory.GetShape(<span class=\"string\">\"SQUARE\"</span>);</span><br><span class=\"line\">    shape2-&gt;draw();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> shape1;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> shape2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Factory_Pattern.png\" alt=\"\"></p>","more":"<h3 id=\"1-2-抽象工厂模式（Abstract-Factory\"><a href=\"#1-2-抽象工厂模式（Abstract-Factory\" class=\"headerlink\" title=\"1.2. 抽象工厂模式（Abstract Factory)\"></a>1.2. 抽象工厂模式（Abstract Factory)</h3><p><strong>目的</strong>：超级工厂又称为其他工厂的工厂，它提供了一种创建对象的最佳方式。</p>\n<p><strong>优点</strong>: 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br><strong>缺点</strong>: 产品族扩展困难。既要在抽象的creator 里修改，又要实现具体的代码。</p>\n<p>虚基类的感觉。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/AbstractFactory_Pattern.png\" alt=\"\"></p>\n<p>AbstrctFactory 与Factory 区别在于：AbstractFactory 模式是为了创建<strong>一组</strong>（有多类）相关或依赖的对象，Factory模式是为<strong>一类</strong>对象提供接口。</p>\n<h3 id=\"1-3-单例模式-Singleton\"><a href=\"#1-3-单例模式-Singleton\" class=\"headerlink\" title=\"1.3. 单例模式(Singleton)\"></a>1.3. 单例模式(Singleton)</h3><p><strong>意图</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>缺点</strong>：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br>创建唯一的变量（对象）</p>\n<p>[Singleton mode image]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">static</span> Singleton * <span class=\"title\">Instance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(_instance == <span class=\"number\">0</span>)</span><br><span class=\"line\">                _instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> _instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        Singleton();</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Singleton * _instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Singleton_Pattern.png\" alt=\"\"></p>\n<p>注：Singleton 不可以被实例化（保证唯一一个），因此我们将它的构造函数声明为protected或private。</p>\n<h3 id=\"1-3-建造者模式（Builder）\"><a href=\"#1-3-建造者模式（Builder）\" class=\"headerlink\" title=\"1.3. 建造者模式（Builder）\"></a>1.3. 建造者模式（Builder）</h3><p><strong>意图</strong>：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>\n<p><strong>优点</strong>： </p>\n<pre><code>- 建造者独立，易扩展\n- 便于控制细节风险\n</code></pre><p><strong>缺点</strong>： </p>\n<pre><code>- 产品必须有共同点，范围有限制\n- 如内部变化复杂，会有很多的建造类\n</code></pre><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern/Builder_Pattern.png\" alt=\"Builder\"></p>\n<p>注：<br>Builder 与AbstractFactory 在功能上相似，都用来创建复杂的对象。Builder 是通过的<strong>相同的创建过程获取不同的结果</strong>，而AbstractFactory 强调为多个相互依赖的对象提供一个统一的接口。另外，AbstractFactory 是立即返回，Builder是在一系列动作后返回对象。</p>\n<h3 id=\"1-4-原型模式-Prototype\"><a href=\"#1-4-原型模式-Prototype\" class=\"headerlink\" title=\"1.4. 原型模式(Prototype)\"></a>1.4. 原型模式(Prototype)</h3><p>原型模式是用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。<br><strong>优点</strong>：  </p>\n<pre><code>- 性能提高      \n- 逃避构造函数的约束    \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候    \n- 必须实现 clone() 接口 \n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseA</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    BaseA()&#123;&#125;;</span><br><span class=\"line\">    BaseA(<span class=\"keyword\">const</span> BaseA &amp;A) <span class=\"comment\">//c++ 拷贝函数，深拷贝是指重新分配类里面的指针</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        member = A.member;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">BaseA * <span class=\"title\">Clone</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BaseA(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> member;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    BaseA *p1 = <span class=\"keyword\">new</span> BaseA();</span><br><span class=\"line\">    BaseA *p2 = p1-&gt;Clone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.cnblogs.com/BlueTzar/articles/1223313.html\" target=\"_blank\" rel=\"noopener\">C++ 拷贝构造函数(深拷贝，浅拷贝)</a></p>"},{"title":"Design_Pattern_III","date":"2019-01-28T11:15:09.000Z","_content":"\n## 1.结构型模式\n### 1.1. 桥接模式(Bridge)\n桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。\n其实围绕的本质还是面向对象的原则：松耦合(Compling)， 高内聚（Cohesion）。\n\n![FixMe image of Bridge](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Bridge_Pattern.png)\n\n<!--more-->\n\n### 1.2. 适配器模式（Adapter）\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。\n**通过继承或依赖（推荐）可以实现适配器模式**\n**优点**： \n    - 可以让任何两个没有关联的类一起运行\n    - 提高了类的复用\n\n**缺点**： 过多地使用适配器，会让系统非常零乱，不易整体进行把握\n\n![FixMe image of Adapters](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Adapter_Pattern_1.png)\n\n![FixMe image of Adapters](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Adapter_Pattern_2.png)\n\n### 1.3. 装饰器模式(Decorator)\n主要思想使用装饰器类中含有基类指针，我们就可以使用装饰类去修饰多个子类（面向对象的多态特性）。Decorator采用组合方式取得毕采用继承方式更好的效果。\n\n![FixMe Decorator image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Decorator_Pattern.png)\n\n### 1.4. 组合模式（Composite)\nComposite 模式于Decorate 模式有着类似的结构图。**但是Composite模式旨在构造类（重在表示），而Decorate模式重在不生成子类即可给对象添加职责（重在修饰）。** \n\n### 1.5. 享元模式（Flyweight）\n享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。\n\n在C++ 中使用STL Vector容器，提供共享对象的仓库。\n**关键代码**：用 HashMap 存储这些对象（JAVA）, C++ 用STL Vector。\n\n**优点**：大大减少对象的创建，降低系统的内存，使效率提高。\n\n**缺点**：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。\n\n### 1.6. 外观模式（Facade）\n外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。\n\n**关键代码**：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。\n\n**优点**：  \n    - 减少系统相互依赖  \n    - 提高灵活性    \n    - 提高了安全性  \n    - \n**缺点**：  \n    - 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适  \n\n![FixMe Facade Pattern Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Facade_Pattern.png)\n\n### 1.7.代理模式(Proxy)\n在代理模式中，一个类代表另一个类的功能。为其他对象提供一种代理以控制对这个对象的访问。比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问, 我们可以在访问此对象时加上一个对此对象的访问层。\n使用到了C++的多态的特性。\n\n![FixMe Proxy Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Proxy_Pattern.png)\n","source":"_posts/Design-Pattern-III.md","raw":"---\ntitle: Design_Pattern_III\ndate: 2019-01-28 19:15:09\ntags: \n - bookmarks\n - program\ncategories: bookmarks\n---\n\n## 1.结构型模式\n### 1.1. 桥接模式(Bridge)\n桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。\n其实围绕的本质还是面向对象的原则：松耦合(Compling)， 高内聚（Cohesion）。\n\n![FixMe image of Bridge](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Bridge_Pattern.png)\n\n<!--more-->\n\n### 1.2. 适配器模式（Adapter）\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。\n**通过继承或依赖（推荐）可以实现适配器模式**\n**优点**： \n    - 可以让任何两个没有关联的类一起运行\n    - 提高了类的复用\n\n**缺点**： 过多地使用适配器，会让系统非常零乱，不易整体进行把握\n\n![FixMe image of Adapters](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Adapter_Pattern_1.png)\n\n![FixMe image of Adapters](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Adapter_Pattern_2.png)\n\n### 1.3. 装饰器模式(Decorator)\n主要思想使用装饰器类中含有基类指针，我们就可以使用装饰类去修饰多个子类（面向对象的多态特性）。Decorator采用组合方式取得毕采用继承方式更好的效果。\n\n![FixMe Decorator image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Decorator_Pattern.png)\n\n### 1.4. 组合模式（Composite)\nComposite 模式于Decorate 模式有着类似的结构图。**但是Composite模式旨在构造类（重在表示），而Decorate模式重在不生成子类即可给对象添加职责（重在修饰）。** \n\n### 1.5. 享元模式（Flyweight）\n享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。\n\n在C++ 中使用STL Vector容器，提供共享对象的仓库。\n**关键代码**：用 HashMap 存储这些对象（JAVA）, C++ 用STL Vector。\n\n**优点**：大大减少对象的创建，降低系统的内存，使效率提高。\n\n**缺点**：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。\n\n### 1.6. 外观模式（Facade）\n外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。\n\n**关键代码**：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。\n\n**优点**：  \n    - 减少系统相互依赖  \n    - 提高灵活性    \n    - 提高了安全性  \n    - \n**缺点**：  \n    - 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适  \n\n![FixMe Facade Pattern Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Facade_Pattern.png)\n\n### 1.7.代理模式(Proxy)\n在代理模式中，一个类代表另一个类的功能。为其他对象提供一种代理以控制对这个对象的访问。比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问, 我们可以在访问此对象时加上一个对此对象的访问层。\n使用到了C++的多态的特性。\n\n![FixMe Proxy Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Proxy_Pattern.png)\n","slug":"Design-Pattern-III","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0oy0008zkgrbawfdlgh","content":"<h2 id=\"1-结构型模式\"><a href=\"#1-结构型模式\" class=\"headerlink\" title=\"1.结构型模式\"></a>1.结构型模式</h2><h3 id=\"1-1-桥接模式-Bridge\"><a href=\"#1-1-桥接模式-Bridge\" class=\"headerlink\" title=\"1.1. 桥接模式(Bridge)\"></a>1.1. 桥接模式(Bridge)</h3><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>其实围绕的本质还是面向对象的原则：松耦合(Compling)， 高内聚（Cohesion）。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Bridge_Pattern.png\" alt=\"FixMe image of Bridge\"></p>\n<a id=\"more\"></a>\n<h3 id=\"1-2-适配器模式（Adapter）\"><a href=\"#1-2-适配器模式（Adapter）\" class=\"headerlink\" title=\"1.2. 适配器模式（Adapter）\"></a>1.2. 适配器模式（Adapter）</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。<br><strong>通过继承或依赖（推荐）可以实现适配器模式</strong><br><strong>优点</strong>： </p>\n<pre><code>- 可以让任何两个没有关联的类一起运行\n- 提高了类的复用\n</code></pre><p><strong>缺点</strong>： 过多地使用适配器，会让系统非常零乱，不易整体进行把握</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Adapter_Pattern_1.png\" alt=\"FixMe image of Adapters\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Adapter_Pattern_2.png\" alt=\"FixMe image of Adapters\"></p>\n<h3 id=\"1-3-装饰器模式-Decorator\"><a href=\"#1-3-装饰器模式-Decorator\" class=\"headerlink\" title=\"1.3. 装饰器模式(Decorator)\"></a>1.3. 装饰器模式(Decorator)</h3><p>主要思想使用装饰器类中含有基类指针，我们就可以使用装饰类去修饰多个子类（面向对象的多态特性）。Decorator采用组合方式取得毕采用继承方式更好的效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Decorator_Pattern.png\" alt=\"FixMe Decorator image\"></p>\n<h3 id=\"1-4-组合模式（Composite\"><a href=\"#1-4-组合模式（Composite\" class=\"headerlink\" title=\"1.4. 组合模式（Composite)\"></a>1.4. 组合模式（Composite)</h3><p>Composite 模式于Decorate 模式有着类似的结构图。<strong>但是Composite模式旨在构造类（重在表示），而Decorate模式重在不生成子类即可给对象添加职责（重在修饰）。</strong> </p>\n<h3 id=\"1-5-享元模式（Flyweight）\"><a href=\"#1-5-享元模式（Flyweight）\" class=\"headerlink\" title=\"1.5. 享元模式（Flyweight）\"></a>1.5. 享元模式（Flyweight）</h3><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。</p>\n<p>在C++ 中使用STL Vector容器，提供共享对象的仓库。<br><strong>关键代码</strong>：用 HashMap 存储这些对象（JAVA）, C++ 用STL Vector。</p>\n<p><strong>优点</strong>：大大减少对象的创建，降低系统的内存，使效率提高。</p>\n<p><strong>缺点</strong>：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>\n<h3 id=\"1-6-外观模式（Facade）\"><a href=\"#1-6-外观模式（Facade）\" class=\"headerlink\" title=\"1.6. 外观模式（Facade）\"></a>1.6. 外观模式（Facade）</h3><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p>\n<p><strong>关键代码</strong>：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p>\n<p><strong>优点</strong>：  </p>\n<pre><code>- 减少系统相互依赖  \n- 提高灵活性    \n- 提高了安全性  \n- \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适  \n</code></pre><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Facade_Pattern.png\" alt=\"FixMe Facade Pattern Image\"></p>\n<h3 id=\"1-7-代理模式-Proxy\"><a href=\"#1-7-代理模式-Proxy\" class=\"headerlink\" title=\"1.7.代理模式(Proxy)\"></a>1.7.代理模式(Proxy)</h3><p>在代理模式中，一个类代表另一个类的功能。为其他对象提供一种代理以控制对这个对象的访问。比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问, 我们可以在访问此对象时加上一个对此对象的访问层。<br>使用到了C++的多态的特性。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Proxy_Pattern.png\" alt=\"FixMe Proxy Image\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-结构型模式\"><a href=\"#1-结构型模式\" class=\"headerlink\" title=\"1.结构型模式\"></a>1.结构型模式</h2><h3 id=\"1-1-桥接模式-Bridge\"><a href=\"#1-1-桥接模式-Bridge\" class=\"headerlink\" title=\"1.1. 桥接模式(Bridge)\"></a>1.1. 桥接模式(Bridge)</h3><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>其实围绕的本质还是面向对象的原则：松耦合(Compling)， 高内聚（Cohesion）。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Bridge_Pattern.png\" alt=\"FixMe image of Bridge\"></p>","more":"<h3 id=\"1-2-适配器模式（Adapter）\"><a href=\"#1-2-适配器模式（Adapter）\" class=\"headerlink\" title=\"1.2. 适配器模式（Adapter）\"></a>1.2. 适配器模式（Adapter）</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。<br><strong>通过继承或依赖（推荐）可以实现适配器模式</strong><br><strong>优点</strong>： </p>\n<pre><code>- 可以让任何两个没有关联的类一起运行\n- 提高了类的复用\n</code></pre><p><strong>缺点</strong>： 过多地使用适配器，会让系统非常零乱，不易整体进行把握</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Adapter_Pattern_1.png\" alt=\"FixMe image of Adapters\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Adapter_Pattern_2.png\" alt=\"FixMe image of Adapters\"></p>\n<h3 id=\"1-3-装饰器模式-Decorator\"><a href=\"#1-3-装饰器模式-Decorator\" class=\"headerlink\" title=\"1.3. 装饰器模式(Decorator)\"></a>1.3. 装饰器模式(Decorator)</h3><p>主要思想使用装饰器类中含有基类指针，我们就可以使用装饰类去修饰多个子类（面向对象的多态特性）。Decorator采用组合方式取得毕采用继承方式更好的效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Decorator_Pattern.png\" alt=\"FixMe Decorator image\"></p>\n<h3 id=\"1-4-组合模式（Composite\"><a href=\"#1-4-组合模式（Composite\" class=\"headerlink\" title=\"1.4. 组合模式（Composite)\"></a>1.4. 组合模式（Composite)</h3><p>Composite 模式于Decorate 模式有着类似的结构图。<strong>但是Composite模式旨在构造类（重在表示），而Decorate模式重在不生成子类即可给对象添加职责（重在修饰）。</strong> </p>\n<h3 id=\"1-5-享元模式（Flyweight）\"><a href=\"#1-5-享元模式（Flyweight）\" class=\"headerlink\" title=\"1.5. 享元模式（Flyweight）\"></a>1.5. 享元模式（Flyweight）</h3><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。</p>\n<p>在C++ 中使用STL Vector容器，提供共享对象的仓库。<br><strong>关键代码</strong>：用 HashMap 存储这些对象（JAVA）, C++ 用STL Vector。</p>\n<p><strong>优点</strong>：大大减少对象的创建，降低系统的内存，使效率提高。</p>\n<p><strong>缺点</strong>：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>\n<h3 id=\"1-6-外观模式（Facade）\"><a href=\"#1-6-外观模式（Facade）\" class=\"headerlink\" title=\"1.6. 外观模式（Facade）\"></a>1.6. 外观模式（Facade）</h3><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p>\n<p><strong>关键代码</strong>：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p>\n<p><strong>优点</strong>：  </p>\n<pre><code>- 减少系统相互依赖  \n- 提高灵活性    \n- 提高了安全性  \n- \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适  \n</code></pre><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Facade_Pattern.png\" alt=\"FixMe Facade Pattern Image\"></p>\n<h3 id=\"1-7-代理模式-Proxy\"><a href=\"#1-7-代理模式-Proxy\" class=\"headerlink\" title=\"1.7.代理模式(Proxy)\"></a>1.7.代理模式(Proxy)</h3><p>在代理模式中，一个类代表另一个类的功能。为其他对象提供一种代理以控制对这个对象的访问。比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问, 我们可以在访问此对象时加上一个对此对象的访问层。<br>使用到了C++的多态的特性。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern/Proxy_Pattern.png\" alt=\"FixMe Proxy Image\"></p>"},{"title":"Design_Pattern_IV","date":"2019-01-28T11:21:28.000Z","_content":"\n## 1. 行为模式\n### 1.1. 模板模式（Template）\n在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。\n**将通用算法（逻辑）封装起来，而将算法细节让子类实现（多态）**。\n\n```c++\nclass AbstractClass\n{\n    public:\n        virtual ~AbstractClass();\n        void TemplatMethod();\n    protected:\n        virtual void Operation1() = 0;\n        virtual void Operation2() = 0;\n}\n\nclass ConcreteClass1: public AbstractClass\n{\n    public:\n        ConcreteClass1();\n        ~ConcreteClass1();\n    protected:\n        void Operation1() {cout<<\"ConcreteClass1 Operation1\"<<endl;}\n        void Operation2(){cout<<\"ConcreteClass1 Operation1\"<<endl;}\n}\n\nclass ConcreteClass2: public AbstractClass\n{\n    public:\n        ConcreteClass2();\n        ~ConcreteClass2();\n    protected:\n        void Operation1() {cout<<\"ConcreteClass2 Operation1\"<<endl;}\n        void Operation2(){cout<<\"ConcreteClass2 Operation1\"<<endl;}\n}\n\nvoid main()\n{\n    AbstractClass * c1 = new ConcreteClass1();\n    AbstractClass * c2 = new ConcreteClass2();\n\n    c1->TemplateMethod();\n    c2->TemplateMethod();\n\n    delete c1;\n    delete c2;\n}\n\n```\n\n<!--more-->\n\n### 1.2.策略模式（Strategy)\n在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。\n\nStrategy 与Template 模式类似，但是Strategy 是将逻辑（算法）封装到一个类中，并采取组合的方式解决。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Strategy_Pattern.png)\n\n**面向对象的设计中有一条很重要的原则就是：优先使用（对象）组合，而非类继承（favorComposition Over Inheritance)。**\n\n### 1.3.状态模式（state）\n将状态与逻辑实现分离，当一个操作中要维护大量的switch case分支语句，并且这些分支依赖于对象的状态。\n\nstate 与 strategy 比较类似，但是两者的关注点不同， state 在于状态的改变， strategy 在于算法逻辑的解藕。\n\n![FixMe state pattern image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/State_Pattern.png)\n\n### 1.4.观察者模式（Observer)\n**观察者模式可以说是应用最多。影响最广的模式之一**。当一个对象被修改时，则会自动通知它的依赖对象。 \n\n**解决问题**： 建立一个一（Subject）对多（observer）的依赖关系，当“一”变化时，“多”也能同步改变。\n\n**优点**：  \n    - 观察者和被观察者是抽象耦合的      \n    - 建立一套触发机制  \n\n**缺点**：  \n    - 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间   \n    - 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。  \n\n我们通过在Context 中的list 或者Vector 维持一组观察者（observer），在Context 更新时，调用Notify()函数，再使用C++的多态，调用到子类的Update（）函数。\n\n![FixMe Add Observer Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Observer_Pattern.png)\n\n### 1.5.备忘录模式（Memento）\n备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。 \n\n**应用实例**： \n    - 后悔药  \n    - 打游戏时的存档  \n    - Windows 里的 ctri + z  \n    - IE 中的后退  \n    - 数据库的事务管理  \n\n**缺点**：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。\n\n注： 申明Originator 为Memento类的友元类，以便可以访问Memento 的私有成员。Originator 通过Memento 类来备份还原。\n\n![FixMe Add Memento Pattern Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Memento_Pattern.png)\n\n### 1.6.中介者模式（Mediator）\n中介者模式是一种**很有用并且很常用的类**，用来降低多个对象和类之间的通信复杂性。将多对多的通信转化为一对多的通信。\n\nMediator 可以有解藕特性，通过Mediator，各个Colleague 就不必维护各自通信的对象和协议。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Mediator_Pattern.png)\n\n### 1.7. 命令模式（Command）\n请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 \n\n![FixMe Add Command Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Command_Pattern.png)\n\n### 1.8. 访问者模式(Visitor)\n我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。\n\n![FixMe Add Visitor Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Visitor_Pattern.png)\n\n\n### 1.9. 责任链模式(Chain of Responsibility)\n在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。\n职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。\n\n**优点**：  \n    - 降低耦合度,它将请求的发送者和接收者解耦   \n    - 简化了对象。使得对象不需要知道链的结构  \n    - 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任  \n\n**缺点**：  \n    - 不能保证请求一定被接收    \n    - 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用  \n\n![FixMe add Chain of resbonsibility Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Chain_of_Responsibility_Pattern.png)\n\n每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。通过SetNextLogger（）设定下一个记录器。\n\n### 1.10.迭代器模式（Iterator）\n迭代器模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。把在元素之间游走的责任交给迭代器，而不是聚合对象。我们可以使用STL中预定义好的Iterator（Vector,set）等。\n\n\n### 1.11.解释器模式（Interpreter）\n解释器模式提供了评估语言的语法或表达式的方式,对于一些固定文法构建一个解释句子的解释器。\n\n**优点**：  \n    - 可扩展性比较好，灵活  \n    - 增加了新的解释表达式的方式    \n\n**缺点**：  \n    - 可利用场景比较少  \n    - 对于复杂的文法比较难维护  \n    - 解释器模式会引起类膨胀    \n    - 解释器模式采用递归调用方法。\n\n\n![FixMe add Interpreter Pattern Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Interpreter_Pattern.png)\n\n","source":"_posts/Design-Pattern-IV.md","raw":"---\ntitle: Design_Pattern_IV\ndate: 2019-01-28 19:21:28\ntags: \n - bookmarks\n - program\ncategories: bookmarks\n---\n\n## 1. 行为模式\n### 1.1. 模板模式（Template）\n在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。\n**将通用算法（逻辑）封装起来，而将算法细节让子类实现（多态）**。\n\n```c++\nclass AbstractClass\n{\n    public:\n        virtual ~AbstractClass();\n        void TemplatMethod();\n    protected:\n        virtual void Operation1() = 0;\n        virtual void Operation2() = 0;\n}\n\nclass ConcreteClass1: public AbstractClass\n{\n    public:\n        ConcreteClass1();\n        ~ConcreteClass1();\n    protected:\n        void Operation1() {cout<<\"ConcreteClass1 Operation1\"<<endl;}\n        void Operation2(){cout<<\"ConcreteClass1 Operation1\"<<endl;}\n}\n\nclass ConcreteClass2: public AbstractClass\n{\n    public:\n        ConcreteClass2();\n        ~ConcreteClass2();\n    protected:\n        void Operation1() {cout<<\"ConcreteClass2 Operation1\"<<endl;}\n        void Operation2(){cout<<\"ConcreteClass2 Operation1\"<<endl;}\n}\n\nvoid main()\n{\n    AbstractClass * c1 = new ConcreteClass1();\n    AbstractClass * c2 = new ConcreteClass2();\n\n    c1->TemplateMethod();\n    c2->TemplateMethod();\n\n    delete c1;\n    delete c2;\n}\n\n```\n\n<!--more-->\n\n### 1.2.策略模式（Strategy)\n在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。\n\nStrategy 与Template 模式类似，但是Strategy 是将逻辑（算法）封装到一个类中，并采取组合的方式解决。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Strategy_Pattern.png)\n\n**面向对象的设计中有一条很重要的原则就是：优先使用（对象）组合，而非类继承（favorComposition Over Inheritance)。**\n\n### 1.3.状态模式（state）\n将状态与逻辑实现分离，当一个操作中要维护大量的switch case分支语句，并且这些分支依赖于对象的状态。\n\nstate 与 strategy 比较类似，但是两者的关注点不同， state 在于状态的改变， strategy 在于算法逻辑的解藕。\n\n![FixMe state pattern image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/State_Pattern.png)\n\n### 1.4.观察者模式（Observer)\n**观察者模式可以说是应用最多。影响最广的模式之一**。当一个对象被修改时，则会自动通知它的依赖对象。 \n\n**解决问题**： 建立一个一（Subject）对多（observer）的依赖关系，当“一”变化时，“多”也能同步改变。\n\n**优点**：  \n    - 观察者和被观察者是抽象耦合的      \n    - 建立一套触发机制  \n\n**缺点**：  \n    - 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间   \n    - 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。  \n\n我们通过在Context 中的list 或者Vector 维持一组观察者（observer），在Context 更新时，调用Notify()函数，再使用C++的多态，调用到子类的Update（）函数。\n\n![FixMe Add Observer Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Observer_Pattern.png)\n\n### 1.5.备忘录模式（Memento）\n备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。 \n\n**应用实例**： \n    - 后悔药  \n    - 打游戏时的存档  \n    - Windows 里的 ctri + z  \n    - IE 中的后退  \n    - 数据库的事务管理  \n\n**缺点**：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。\n\n注： 申明Originator 为Memento类的友元类，以便可以访问Memento 的私有成员。Originator 通过Memento 类来备份还原。\n\n![FixMe Add Memento Pattern Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Memento_Pattern.png)\n\n### 1.6.中介者模式（Mediator）\n中介者模式是一种**很有用并且很常用的类**，用来降低多个对象和类之间的通信复杂性。将多对多的通信转化为一对多的通信。\n\nMediator 可以有解藕特性，通过Mediator，各个Colleague 就不必维护各自通信的对象和协议。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Mediator_Pattern.png)\n\n### 1.7. 命令模式（Command）\n请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 \n\n![FixMe Add Command Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Command_Pattern.png)\n\n### 1.8. 访问者模式(Visitor)\n我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。\n\n![FixMe Add Visitor Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Visitor_Pattern.png)\n\n\n### 1.9. 责任链模式(Chain of Responsibility)\n在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。\n职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。\n\n**优点**：  \n    - 降低耦合度,它将请求的发送者和接收者解耦   \n    - 简化了对象。使得对象不需要知道链的结构  \n    - 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任  \n\n**缺点**：  \n    - 不能保证请求一定被接收    \n    - 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用  \n\n![FixMe add Chain of resbonsibility Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Chain_of_Responsibility_Pattern.png)\n\n每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。通过SetNextLogger（）设定下一个记录器。\n\n### 1.10.迭代器模式（Iterator）\n迭代器模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。把在元素之间游走的责任交给迭代器，而不是聚合对象。我们可以使用STL中预定义好的Iterator（Vector,set）等。\n\n\n### 1.11.解释器模式（Interpreter）\n解释器模式提供了评估语言的语法或表达式的方式,对于一些固定文法构建一个解释句子的解释器。\n\n**优点**：  \n    - 可扩展性比较好，灵活  \n    - 增加了新的解释表达式的方式    \n\n**缺点**：  \n    - 可利用场景比较少  \n    - 对于复杂的文法比较难维护  \n    - 解释器模式会引起类膨胀    \n    - 解释器模式采用递归调用方法。\n\n\n![FixMe add Interpreter Pattern Image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Interpreter_Pattern.png)\n\n","slug":"Design-Pattern-IV","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0p1000czkgrp3ci9jeg","content":"<h2 id=\"1-行为模式\"><a href=\"#1-行为模式\" class=\"headerlink\" title=\"1. 行为模式\"></a>1. 行为模式</h2><h3 id=\"1-1-模板模式（Template）\"><a href=\"#1-1-模板模式（Template）\" class=\"headerlink\" title=\"1.1. 模板模式（Template）\"></a>1.1. 模板模式（Template）</h3><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。<br><strong>将通用算法（逻辑）封装起来，而将算法细节让子类实现（多态）</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractClass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">virtual</span> ~AbstractClass();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TemplatMethod</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteClass1</span>:</span> <span class=\"keyword\">public</span> AbstractClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        ConcreteClass1();</span><br><span class=\"line\">        ~ConcreteClass1();</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"ConcreteClass1 Operation1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"ConcreteClass1 Operation1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteClass2</span>:</span> <span class=\"keyword\">public</span> AbstractClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        ConcreteClass2();</span><br><span class=\"line\">        ~ConcreteClass2();</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"ConcreteClass2 Operation1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"ConcreteClass2 Operation1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AbstractClass * c1 = <span class=\"keyword\">new</span> ConcreteClass1();</span><br><span class=\"line\">    AbstractClass * c2 = <span class=\"keyword\">new</span> ConcreteClass2();</span><br><span class=\"line\"></span><br><span class=\"line\">    c1-&gt;TemplateMethod();</span><br><span class=\"line\">    c2-&gt;TemplateMethod();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> c1;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> c2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"1-2-策略模式（Strategy\"><a href=\"#1-2-策略模式（Strategy\" class=\"headerlink\" title=\"1.2.策略模式（Strategy)\"></a>1.2.策略模式（Strategy)</h3><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</p>\n<p>Strategy 与Template 模式类似，但是Strategy 是将逻辑（算法）封装到一个类中，并采取组合的方式解决。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Strategy_Pattern.png\" alt=\"\"></p>\n<p><strong>面向对象的设计中有一条很重要的原则就是：优先使用（对象）组合，而非类继承（favorComposition Over Inheritance)。</strong></p>\n<h3 id=\"1-3-状态模式（state）\"><a href=\"#1-3-状态模式（state）\" class=\"headerlink\" title=\"1.3.状态模式（state）\"></a>1.3.状态模式（state）</h3><p>将状态与逻辑实现分离，当一个操作中要维护大量的switch case分支语句，并且这些分支依赖于对象的状态。</p>\n<p>state 与 strategy 比较类似，但是两者的关注点不同， state 在于状态的改变， strategy 在于算法逻辑的解藕。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/State_Pattern.png\" alt=\"FixMe state pattern image\"></p>\n<h3 id=\"1-4-观察者模式（Observer\"><a href=\"#1-4-观察者模式（Observer\" class=\"headerlink\" title=\"1.4.观察者模式（Observer)\"></a>1.4.观察者模式（Observer)</h3><p><strong>观察者模式可以说是应用最多。影响最广的模式之一</strong>。当一个对象被修改时，则会自动通知它的依赖对象。 </p>\n<p><strong>解决问题</strong>： 建立一个一（Subject）对多（observer）的依赖关系，当“一”变化时，“多”也能同步改变。</p>\n<p><strong>优点</strong>：  </p>\n<pre><code>- 观察者和被观察者是抽象耦合的      \n- 建立一套触发机制  \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间   \n- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。  \n</code></pre><p>我们通过在Context 中的list 或者Vector 维持一组观察者（observer），在Context 更新时，调用Notify()函数，再使用C++的多态，调用到子类的Update（）函数。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Observer_Pattern.png\" alt=\"FixMe Add Observer Image\"></p>\n<h3 id=\"1-5-备忘录模式（Memento）\"><a href=\"#1-5-备忘录模式（Memento）\" class=\"headerlink\" title=\"1.5.备忘录模式（Memento）\"></a>1.5.备忘录模式（Memento）</h3><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。 </p>\n<p><strong>应用实例</strong>： </p>\n<pre><code>- 后悔药  \n- 打游戏时的存档  \n- Windows 里的 ctri + z  \n- IE 中的后退  \n- 数据库的事务管理  \n</code></pre><p><strong>缺点</strong>：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>\n<p>注： 申明Originator 为Memento类的友元类，以便可以访问Memento 的私有成员。Originator 通过Memento 类来备份还原。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Memento_Pattern.png\" alt=\"FixMe Add Memento Pattern Image\"></p>\n<h3 id=\"1-6-中介者模式（Mediator）\"><a href=\"#1-6-中介者模式（Mediator）\" class=\"headerlink\" title=\"1.6.中介者模式（Mediator）\"></a>1.6.中介者模式（Mediator）</h3><p>中介者模式是一种<strong>很有用并且很常用的类</strong>，用来降低多个对象和类之间的通信复杂性。将多对多的通信转化为一对多的通信。</p>\n<p>Mediator 可以有解藕特性，通过Mediator，各个Colleague 就不必维护各自通信的对象和协议。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Mediator_Pattern.png\" alt=\"\"></p>\n<h3 id=\"1-7-命令模式（Command）\"><a href=\"#1-7-命令模式（Command）\" class=\"headerlink\" title=\"1.7. 命令模式（Command）\"></a>1.7. 命令模式（Command）</h3><p>请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 </p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Command_Pattern.png\" alt=\"FixMe Add Command Image\"></p>\n<h3 id=\"1-8-访问者模式-Visitor\"><a href=\"#1-8-访问者模式-Visitor\" class=\"headerlink\" title=\"1.8. 访问者模式(Visitor)\"></a>1.8. 访问者模式(Visitor)</h3><p>我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Visitor_Pattern.png\" alt=\"FixMe Add Visitor Image\"></p>\n<h3 id=\"1-9-责任链模式-Chain-of-Responsibility\"><a href=\"#1-9-责任链模式-Chain-of-Responsibility\" class=\"headerlink\" title=\"1.9. 责任链模式(Chain of Responsibility)\"></a>1.9. 责任链模式(Chain of Responsibility)</h3><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>\n<p><strong>优点</strong>：  </p>\n<pre><code>- 降低耦合度,它将请求的发送者和接收者解耦   \n- 简化了对象。使得对象不需要知道链的结构  \n- 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任  \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 不能保证请求一定被接收    \n- 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用  \n</code></pre><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Chain_of_Responsibility_Pattern.png\" alt=\"FixMe add Chain of resbonsibility Image\"></p>\n<p>每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。通过SetNextLogger（）设定下一个记录器。</p>\n<h3 id=\"1-10-迭代器模式（Iterator）\"><a href=\"#1-10-迭代器模式（Iterator）\" class=\"headerlink\" title=\"1.10.迭代器模式（Iterator）\"></a>1.10.迭代器模式（Iterator）</h3><p>迭代器模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。把在元素之间游走的责任交给迭代器，而不是聚合对象。我们可以使用STL中预定义好的Iterator（Vector,set）等。</p>\n<h3 id=\"1-11-解释器模式（Interpreter）\"><a href=\"#1-11-解释器模式（Interpreter）\" class=\"headerlink\" title=\"1.11.解释器模式（Interpreter）\"></a>1.11.解释器模式（Interpreter）</h3><p>解释器模式提供了评估语言的语法或表达式的方式,对于一些固定文法构建一个解释句子的解释器。</p>\n<p><strong>优点</strong>：  </p>\n<pre><code>- 可扩展性比较好，灵活  \n- 增加了新的解释表达式的方式    \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 可利用场景比较少  \n- 对于复杂的文法比较难维护  \n- 解释器模式会引起类膨胀    \n- 解释器模式采用递归调用方法。\n</code></pre><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Interpreter_Pattern.png\" alt=\"FixMe add Interpreter Pattern Image\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-行为模式\"><a href=\"#1-行为模式\" class=\"headerlink\" title=\"1. 行为模式\"></a>1. 行为模式</h2><h3 id=\"1-1-模板模式（Template）\"><a href=\"#1-1-模板模式（Template）\" class=\"headerlink\" title=\"1.1. 模板模式（Template）\"></a>1.1. 模板模式（Template）</h3><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。<br><strong>将通用算法（逻辑）封装起来，而将算法细节让子类实现（多态）</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractClass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">virtual</span> ~AbstractClass();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TemplatMethod</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteClass1</span>:</span> <span class=\"keyword\">public</span> AbstractClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        ConcreteClass1();</span><br><span class=\"line\">        ~ConcreteClass1();</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"ConcreteClass1 Operation1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"ConcreteClass1 Operation1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteClass2</span>:</span> <span class=\"keyword\">public</span> AbstractClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        ConcreteClass2();</span><br><span class=\"line\">        ~ConcreteClass2();</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"ConcreteClass2 Operation1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"ConcreteClass2 Operation1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AbstractClass * c1 = <span class=\"keyword\">new</span> ConcreteClass1();</span><br><span class=\"line\">    AbstractClass * c2 = <span class=\"keyword\">new</span> ConcreteClass2();</span><br><span class=\"line\"></span><br><span class=\"line\">    c1-&gt;TemplateMethod();</span><br><span class=\"line\">    c2-&gt;TemplateMethod();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> c1;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> c2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"1-2-策略模式（Strategy\"><a href=\"#1-2-策略模式（Strategy\" class=\"headerlink\" title=\"1.2.策略模式（Strategy)\"></a>1.2.策略模式（Strategy)</h3><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</p>\n<p>Strategy 与Template 模式类似，但是Strategy 是将逻辑（算法）封装到一个类中，并采取组合的方式解决。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Strategy_Pattern.png\" alt=\"\"></p>\n<p><strong>面向对象的设计中有一条很重要的原则就是：优先使用（对象）组合，而非类继承（favorComposition Over Inheritance)。</strong></p>\n<h3 id=\"1-3-状态模式（state）\"><a href=\"#1-3-状态模式（state）\" class=\"headerlink\" title=\"1.3.状态模式（state）\"></a>1.3.状态模式（state）</h3><p>将状态与逻辑实现分离，当一个操作中要维护大量的switch case分支语句，并且这些分支依赖于对象的状态。</p>\n<p>state 与 strategy 比较类似，但是两者的关注点不同， state 在于状态的改变， strategy 在于算法逻辑的解藕。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/State_Pattern.png\" alt=\"FixMe state pattern image\"></p>\n<h3 id=\"1-4-观察者模式（Observer\"><a href=\"#1-4-观察者模式（Observer\" class=\"headerlink\" title=\"1.4.观察者模式（Observer)\"></a>1.4.观察者模式（Observer)</h3><p><strong>观察者模式可以说是应用最多。影响最广的模式之一</strong>。当一个对象被修改时，则会自动通知它的依赖对象。 </p>\n<p><strong>解决问题</strong>： 建立一个一（Subject）对多（observer）的依赖关系，当“一”变化时，“多”也能同步改变。</p>\n<p><strong>优点</strong>：  </p>\n<pre><code>- 观察者和被观察者是抽象耦合的      \n- 建立一套触发机制  \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间   \n- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。  \n</code></pre><p>我们通过在Context 中的list 或者Vector 维持一组观察者（observer），在Context 更新时，调用Notify()函数，再使用C++的多态，调用到子类的Update（）函数。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Observer_Pattern.png\" alt=\"FixMe Add Observer Image\"></p>\n<h3 id=\"1-5-备忘录模式（Memento）\"><a href=\"#1-5-备忘录模式（Memento）\" class=\"headerlink\" title=\"1.5.备忘录模式（Memento）\"></a>1.5.备忘录模式（Memento）</h3><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。 </p>\n<p><strong>应用实例</strong>： </p>\n<pre><code>- 后悔药  \n- 打游戏时的存档  \n- Windows 里的 ctri + z  \n- IE 中的后退  \n- 数据库的事务管理  \n</code></pre><p><strong>缺点</strong>：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>\n<p>注： 申明Originator 为Memento类的友元类，以便可以访问Memento 的私有成员。Originator 通过Memento 类来备份还原。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Memento_Pattern.png\" alt=\"FixMe Add Memento Pattern Image\"></p>\n<h3 id=\"1-6-中介者模式（Mediator）\"><a href=\"#1-6-中介者模式（Mediator）\" class=\"headerlink\" title=\"1.6.中介者模式（Mediator）\"></a>1.6.中介者模式（Mediator）</h3><p>中介者模式是一种<strong>很有用并且很常用的类</strong>，用来降低多个对象和类之间的通信复杂性。将多对多的通信转化为一对多的通信。</p>\n<p>Mediator 可以有解藕特性，通过Mediator，各个Colleague 就不必维护各自通信的对象和协议。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Mediator_Pattern.png\" alt=\"\"></p>\n<h3 id=\"1-7-命令模式（Command）\"><a href=\"#1-7-命令模式（Command）\" class=\"headerlink\" title=\"1.7. 命令模式（Command）\"></a>1.7. 命令模式（Command）</h3><p>请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 </p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Command_Pattern.png\" alt=\"FixMe Add Command Image\"></p>\n<h3 id=\"1-8-访问者模式-Visitor\"><a href=\"#1-8-访问者模式-Visitor\" class=\"headerlink\" title=\"1.8. 访问者模式(Visitor)\"></a>1.8. 访问者模式(Visitor)</h3><p>我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Visitor_Pattern.png\" alt=\"FixMe Add Visitor Image\"></p>\n<h3 id=\"1-9-责任链模式-Chain-of-Responsibility\"><a href=\"#1-9-责任链模式-Chain-of-Responsibility\" class=\"headerlink\" title=\"1.9. 责任链模式(Chain of Responsibility)\"></a>1.9. 责任链模式(Chain of Responsibility)</h3><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>\n<p><strong>优点</strong>：  </p>\n<pre><code>- 降低耦合度,它将请求的发送者和接收者解耦   \n- 简化了对象。使得对象不需要知道链的结构  \n- 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任  \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 不能保证请求一定被接收    \n- 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用  \n</code></pre><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Chain_of_Responsibility_Pattern.png\" alt=\"FixMe add Chain of resbonsibility Image\"></p>\n<p>每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。通过SetNextLogger（）设定下一个记录器。</p>\n<h3 id=\"1-10-迭代器模式（Iterator）\"><a href=\"#1-10-迭代器模式（Iterator）\" class=\"headerlink\" title=\"1.10.迭代器模式（Iterator）\"></a>1.10.迭代器模式（Iterator）</h3><p>迭代器模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。把在元素之间游走的责任交给迭代器，而不是聚合对象。我们可以使用STL中预定义好的Iterator（Vector,set）等。</p>\n<h3 id=\"1-11-解释器模式（Interpreter）\"><a href=\"#1-11-解释器模式（Interpreter）\" class=\"headerlink\" title=\"1.11.解释器模式（Interpreter）\"></a>1.11.解释器模式（Interpreter）</h3><p>解释器模式提供了评估语言的语法或表达式的方式,对于一些固定文法构建一个解释句子的解释器。</p>\n<p><strong>优点</strong>：  </p>\n<pre><code>- 可扩展性比较好，灵活  \n- 增加了新的解释表达式的方式    \n</code></pre><p><strong>缺点</strong>：  </p>\n<pre><code>- 可利用场景比较少  \n- 对于复杂的文法比较难维护  \n- 解释器模式会引起类膨胀    \n- 解释器模式采用递归调用方法。\n</code></pre><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPattern/Interpreter_Pattern.png\" alt=\"FixMe add Interpreter Pattern Image\"></p>"},{"title":"Design_Pattern","date":"2018-07-12T11:45:14.000Z","_content":"\n## 背景\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=970418febc003af359b7d4325443ad39/4a36acaf2edda3ccdd0e40d70be93901203f925b.jpg)\n设计模式(design pattern)， 是在这1994年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：[设计模式 - 可复用的面向对象软件元素](https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80/7600072?fr=aladdin)） 的书提出。主要基于：\n- 对接口编程而不是对实现编程\n- 优先使用对象组合而不是继承\n\n面向对象系统的分析和设计实际上追求的就是两点,一是高内聚(Cohesion),而是低耦合(Coupling)。\n\n<!--more-->\n\n## 1. 设计模式鸟览\n常见设计模式有23种。大体可以分为三大类：\n- 创建模式（Creational Patterns）\n- 结构型模式(Structural Patterns)\n- 行为型模式（Behavioral Patterns)\n\n当然，还有J2EE设计模式。\n\n模式 | 描述\n:-: | :-\n创建模式 | 这些设计模式提供了一种在创建对象的同时**隐藏创建逻辑**的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。\n结构型模式 | 这些设计模式**关注类和对象的组合**。继承的概念被用来组合接口和定义组合对象**获得新功能**的方式。\n行为型模式 | 这些设计模式特别**关注对象之间的通信**。\nJ2EE 模式 | 这些设计模式特别**关注表示层**。这些模式是由 Sun Java Center 鉴定的。\n\n**创建模式（Creational Patterns）**\n\n![Creational Patterns](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern.png)\n\n**结构型模式(Structural Patterns)**\n\n![Structural Patterns](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern.png)\n\n**行为型模式（Behavioral Patterns)**\n\n![Behavioral Patterns](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPatternpng.png)\n\n**J2EE设计模式**\n\n![J2EE设计模式](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/J2EEPattern.png)\n\n## Ref.\nhttp://www.runoob.com/design-pattern/design-pattern-tutorial.html","source":"_posts/Design-Pattern.md","raw":"---\ntitle: Design_Pattern\ndate: 2018-07-12 19:45:14\ntags: \n - bookmarks\n - program\ncategories: bookmarks\n---\n\n## 背景\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=970418febc003af359b7d4325443ad39/4a36acaf2edda3ccdd0e40d70be93901203f925b.jpg)\n设计模式(design pattern)， 是在这1994年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：[设计模式 - 可复用的面向对象软件元素](https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80/7600072?fr=aladdin)） 的书提出。主要基于：\n- 对接口编程而不是对实现编程\n- 优先使用对象组合而不是继承\n\n面向对象系统的分析和设计实际上追求的就是两点,一是高内聚(Cohesion),而是低耦合(Coupling)。\n\n<!--more-->\n\n## 1. 设计模式鸟览\n常见设计模式有23种。大体可以分为三大类：\n- 创建模式（Creational Patterns）\n- 结构型模式(Structural Patterns)\n- 行为型模式（Behavioral Patterns)\n\n当然，还有J2EE设计模式。\n\n模式 | 描述\n:-: | :-\n创建模式 | 这些设计模式提供了一种在创建对象的同时**隐藏创建逻辑**的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。\n结构型模式 | 这些设计模式**关注类和对象的组合**。继承的概念被用来组合接口和定义组合对象**获得新功能**的方式。\n行为型模式 | 这些设计模式特别**关注对象之间的通信**。\nJ2EE 模式 | 这些设计模式特别**关注表示层**。这些模式是由 Sun Java Center 鉴定的。\n\n**创建模式（Creational Patterns）**\n\n![Creational Patterns](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern.png)\n\n**结构型模式(Structural Patterns)**\n\n![Structural Patterns](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern.png)\n\n**行为型模式（Behavioral Patterns)**\n\n![Behavioral Patterns](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPatternpng.png)\n\n**J2EE设计模式**\n\n![J2EE设计模式](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/J2EEPattern.png)\n\n## Ref.\nhttp://www.runoob.com/design-pattern/design-pattern-tutorial.html","slug":"Design-Pattern","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0p3000dzkgrfxx395av","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=970418febc003af359b7d4325443ad39/4a36acaf2edda3ccdd0e40d70be93901203f925b.jpg\" alt=\"\"><br>设计模式(design pattern)， 是在这1994年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：<a href=\"https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80/7600072?fr=aladdin\" target=\"_blank\" rel=\"noopener\">设计模式 - 可复用的面向对象软件元素</a>） 的书提出。主要基于：</p>\n<ul>\n<li>对接口编程而不是对实现编程</li>\n<li>优先使用对象组合而不是继承</li>\n</ul>\n<p>面向对象系统的分析和设计实际上追求的就是两点,一是高内聚(Cohesion),而是低耦合(Coupling)。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-设计模式鸟览\"><a href=\"#1-设计模式鸟览\" class=\"headerlink\" title=\"1. 设计模式鸟览\"></a>1. 设计模式鸟览</h2><p>常见设计模式有23种。大体可以分为三大类：</p>\n<ul>\n<li>创建模式（Creational Patterns）</li>\n<li>结构型模式(Structural Patterns)</li>\n<li>行为型模式（Behavioral Patterns)</li>\n</ul>\n<p>当然，还有J2EE设计模式。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模式</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">创建模式</td>\n<td style=\"text-align:left\">这些设计模式提供了一种在创建对象的同时<strong>隐藏创建逻辑</strong>的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">结构型模式</td>\n<td style=\"text-align:left\">这些设计模式<strong>关注类和对象的组合</strong>。继承的概念被用来组合接口和定义组合对象<strong>获得新功能</strong>的方式。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">行为型模式</td>\n<td style=\"text-align:left\">这些设计模式特别<strong>关注对象之间的通信</strong>。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">J2EE 模式</td>\n<td style=\"text-align:left\">这些设计模式特别<strong>关注表示层</strong>。这些模式是由 Sun Java Center 鉴定的。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>创建模式（Creational Patterns）</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern.png\" alt=\"Creational Patterns\"></p>\n<p><strong>结构型模式(Structural Patterns)</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern.png\" alt=\"Structural Patterns\"></p>\n<p><strong>行为型模式（Behavioral Patterns)</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPatternpng.png\" alt=\"Behavioral Patterns\"></p>\n<p><strong>J2EE设计模式</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/J2EEPattern.png\" alt=\"J2EE设计模式\"></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref.\"></a>Ref.</h2><p><a href=\"http://www.runoob.com/design-pattern/design-pattern-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=970418febc003af359b7d4325443ad39/4a36acaf2edda3ccdd0e40d70be93901203f925b.jpg\" alt=\"\"><br>设计模式(design pattern)， 是在这1994年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：<a href=\"https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80/7600072?fr=aladdin\" target=\"_blank\" rel=\"noopener\">设计模式 - 可复用的面向对象软件元素</a>） 的书提出。主要基于：</p>\n<ul>\n<li>对接口编程而不是对实现编程</li>\n<li>优先使用对象组合而不是继承</li>\n</ul>\n<p>面向对象系统的分析和设计实际上追求的就是两点,一是高内聚(Cohesion),而是低耦合(Coupling)。</p>","more":"<h2 id=\"1-设计模式鸟览\"><a href=\"#1-设计模式鸟览\" class=\"headerlink\" title=\"1. 设计模式鸟览\"></a>1. 设计模式鸟览</h2><p>常见设计模式有23种。大体可以分为三大类：</p>\n<ul>\n<li>创建模式（Creational Patterns）</li>\n<li>结构型模式(Structural Patterns)</li>\n<li>行为型模式（Behavioral Patterns)</li>\n</ul>\n<p>当然，还有J2EE设计模式。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模式</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">创建模式</td>\n<td style=\"text-align:left\">这些设计模式提供了一种在创建对象的同时<strong>隐藏创建逻辑</strong>的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">结构型模式</td>\n<td style=\"text-align:left\">这些设计模式<strong>关注类和对象的组合</strong>。继承的概念被用来组合接口和定义组合对象<strong>获得新功能</strong>的方式。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">行为型模式</td>\n<td style=\"text-align:left\">这些设计模式特别<strong>关注对象之间的通信</strong>。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">J2EE 模式</td>\n<td style=\"text-align:left\">这些设计模式特别<strong>关注表示层</strong>。这些模式是由 Sun Java Center 鉴定的。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>创建模式（Creational Patterns）</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/CreationalPattern.png\" alt=\"Creational Patterns\"></p>\n<p><strong>结构型模式(Structural Patterns)</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/StructuralPattern.png\" alt=\"Structural Patterns\"></p>\n<p><strong>行为型模式（Behavioral Patterns)</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/BehavioralPatternpng.png\" alt=\"Behavioral Patterns\"></p>\n<p><strong>J2EE设计模式</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/DesignPattern/J2EEPattern.png\" alt=\"J2EE设计模式\"></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref.\"></a>Ref.</h2><p><a href=\"http://www.runoob.com/design-pattern/design-pattern-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>"},{"title":"Docker 简单介绍","date":"2018-06-01T11:59:25.000Z","_content":"\n# Docker\n\n## 1. Docker 背景\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2dc9b7759a8fa0ec6bca6c5f47fe328b/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n### 1.1. Docker 是什么\n\nDocker 是 [PaaS](https://baike.baidu.com/item/PaaS) 提供商 dotCloud 开源的一个基于 [LXC](https://baike.baidu.com/item/LXC) (LXC 其并不是一套[硬件虚拟化方法](http://en.wikipedia.org/wiki/Platform_virtualization) 无法归属到全虚拟化、部分虚拟化和半虚拟化中的任意一个，而是一个[操作系统级虚拟化](http://en.wikipedia.org/wiki/Operating_system-level_virtualization)方)的**高级容器引擎**，源代码托管在 [Github](https://baike.baidu.com/item/Github) 上, 基于[go语言](https://baike.baidu.com/item/go%E8%AF%AD%E8%A8%80)并遵从Apache2.0协议开源。\n\n**Docker** 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux 容器解决方案。\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f451b09fa38b87d6444fa34d6661435d/203fb80e7bec54e7719c18b0bb389b504fc26a2f.jpg)\n\n<!--more-->\n\n有人以通俗的方式说明:\n\n> Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。  \n> \n> Docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。Docker就是集装箱。\n\n### 1.2. Docker 的用途\n\n- 快捷部署软件环境\n\n- 以低效耗实现应用资源隔离\n\n- 微服务架构组建（多个Docker 镜像之间组合使用）\n\n- web应用的自动化打包和发布\n\n国内有应用于Docker技术的公司[DaoCloud](http://www.daocloud.io) , [云雀](http://www.alauda.cn)等\n\n## 2. Docker 基础\n\n## 2.1. 术语\n\n- Docker镜像\n\n  > 镜像是Docker 容器运行时的只读模板，每一个镜像由一系列的层（layers）组成。当我们修改镜像时，新的层被创建并透明覆盖之前的层，Docker使用UnionFS 来将这些层连贯到文件系统。\n\n- Docker仓库\n\n  > 类似github， Docker 镜像管理库，Docker官方[Docker Hub](https://hub.docker.com/explore/), 上面有很火镜像资源，如：\n  > \n  > ![Nginx](https://hub.docker.com/public/images/official/nginx.png)\n  > \n  > ![](https://hub.docker.com/public/images/official/httpd.png)\n  > \n  > ![](https://hub.docker.com/public/images/official/ubuntu.png)\n\n- Docker容器\n\n  > 容器都是从镜像建立的，Docker容器和文件夹类似，容器包含了应用运行所需的环境和数据等。Docker容器可以运行、开始、停止、移动和删除。镜像是只读的，当Docker 运行容器时，它会在镜像顶层添加一个可读写的层。\n\n# 2.2. 组件\n\nDocker 采用的是客户端/服务端(C/S)架构模式。Docker客户端和守护进程之间通过socket或者RESTful API进行通信。\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=9f1b2701eddde711f3df4ba4c686a57e/a50f4bfbfbedab644936dac4ff36afc379311e69.jpg)\n\n| 子项         | 说明                                                                       |\n|:---------- | ------------------------------------------------------------------------ |\n| Docker守护进程 | 建立、运行、发布你的Docker容器，处理所有的Docker 请求，管理所有容器。                                |\n| Docker客服端  | Docker客户端，实际上是`docker`的二进制程序，是主要的用户与Docker交互方式。它接收用户指令并且与背后的Docker守护进程通信 |\n\n## 2.3. 技术基础\n\n### 2.3.1. namespace\n\nLXC所实现的隔离性主要是来自kernel的namespace, 其中`pid`, `net`, `ipc`, `mnt`, `uts` 等namespace将container的进程, 网络, 消息, 文件系统和hostname 隔离开。\n\n| NameSpace(ns)  | Function                                                                                                                                                                                                                                                                                                                          |\n| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| pid namespace  | 具有如下特征： <br><ul><li> 每个namespace中的pid是有自己的pid=1的进程(类似`/sbin/init`进程) </li><li>个namespace中的进程只能影响自己的同一个namespace或子namespace中的进程 </li><li>因为`/proc`包含正在运行的进程，因此在container中的`pseudo-filesystem`的/proc目录只能看到自己namespace中的进程</li><li>因为namespace允许嵌套，父namespace可以影响子namespace的进程，所以子namespace的进程可以在父namespace中看到，但是具有不同的pid </li></ul> |\n| net namespace  | 有了 `pid` namespace, 每个namespace中的pid能够相互隔离，但是网络端口还是共享host的端口。网络隔离是通过`net`namespace实现的， 每个`net` namespace有独立的 network devices, IP addresses, IP routing tables, `/proc/net` 目录。这样每个container的网络就能隔离开来。 LXC在此基础上有5种网络类型，docker默认采用veth的方式将container中的虚拟网卡同host上的一个docker bridge连接在一起。                                               |\n| ipc namespace  | container中进程交互还是采用linux常见的进程间交互方法(interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同VM不同，container 的进程间交互实际上还是host上具有相同pid namespace中的进程间交互，因此需要在IPC资源申请时加入namespace信息 - 每个IPC资源有一个唯一的 32bit ID。                                                                                                                           |\n| mnt namespace  | 类似`chroot`，将一个进程放到一个特定的目录执行。`mnt` namespace允许不同namespace的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同`chroot`不同，每个namespace中的container在`/proc/mounts`的信息只包含所在namespace的mount point。                                                                                                                                            |\n| uts namespace  | UTS(\"UNIX Time-sharing System\") namespace允许每个container拥有独立的hostname和domain name, 使其在网络上可以被视作一个独立的节点而非Host上的一个进程。                                                                                                                                                                                                                  |\n| user namespace | 每个container可以有不同的 user 和 group id, 也就是说可以以container内部的用户在container内部执行程序而非Host上的用户                                                                                                                                                                                                                                                |\n\n有了以上6种namespace从进程、网络、IPC、文件系统、UTS和用户角度的隔离，一个container就可以对外展现出一个独立计算机的能力，并且不同container从OS层面实现了隔离。 然而不同namespace之间资源还是相互竞争的，仍然需要类似`ulimit`来管理每个container所能使用的资源 - LXC 采用的是`cgroup`。\n\n### 2.3.2. Control Groups(cgroups)\n\n**cgroups** 实现了对资源的配额和度量。 **cgroups**  的使用非常简单，提供类似文件的接口，在 `/cgroup`目录下新建一个文件夹即可新建一个group，在此文件夹中新建**task**文件，并将pid写入该文件，即可实现对该进程的资源控制。\n我们主要关心cgroups可以限制哪些资源，即有哪些subsystem是我们关心。\n\n**`cpu`**: 在cgroup中，并不能像硬件虚拟化方案一样能够定义CPU能力，但是能够定义CPU轮转的优先级，因此具有较高CPU优先级的进程会更可能得到CPU运算。 通过将参数写入**cpu.shares**,即可定义改cgroup的CPU优先级 - 这里是一个相对权重，而非绝对值。当然在cpu这个subsystem中还有其他可配置项，手册中有详细说明。\n\n**`cpusets`** : cpusets 定义了有几个CPU可以被这个group使用，或者哪几个CPU可以供这个group使用。在某些场景下，单CPU绑定可以防止多核间缓存切换，从而提高效率\n\n**`memory`** : 内存相关的限制\n\n**`blkio`** : block IO相关的统计和限制，byte/operation统计和限制(IOPS等)，读写速度限制等，但是这里主要统计的都是同步IO\n\n**`net_cls`**， **`cpuacct`** , **`devices`** , **`freezer`** 等其他可管理项。\n\n### 2.3.3. LinuX Containers(LXC)\n\n借助于namespace的隔离机制和cgroup限额功能，LXC提供了一套统一的API和工具来建立和管理container, LXC利用了如下 kernel 的features:\n\n- Kernel namespaces (ipc, uts, mount, pid, network and user)\n- Apparmor and SELinux profiles\n- Seccomp policies\n- Chroots (using pivot_root)\n- Kernel capabilities\n- Control groups (cgroups)\n\nLXC 向用户屏蔽了以上 kernel 接口的细节, 提供了如下的组件大大简化了用户的开发和使用工作:\n\n- The liblxc library\n- Several language bindings (python3, lua and Go)\n- A set of standard tools to control the containers\n- Container templates\n\n### 2.3.4. AUFS\n\nDocker对container的使用基本是建立在LXC基础之上的，然而LXC存在的问题是难以通过标准化的模板制作、重建、复制和移动 container。VM虚拟化可以采用image和snapshot 实现复制、重建以及移动的功能。docker0.7中引入了storage driver, 支持AUFS, VFS, device mapper, 也为BTRFS以及ZFS引入提供了可能。 但除了AUFS都未经过dotcloud的线上使用。\n\nAUFS (AnotherUnionFS) 是一种 `Union FS`。AUFS支持为每一个成员目录(AKA branch)设定'readonly', 'readwrite' 和 'whiteout-able' 权限,\n\n典型的Linux启动到运行需要两个FS - bootfs + rootfs。\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=fb52a2bc700e0cf3b4fa46a96b2f997a/9358d109b3de9c82ba58f6216e81800a19d8435a.jpg)\n\n\n\n典型的Linux在启动后，首先将 rootfs 置为 readonly, 进行一系列检查, 然后将其切换为 \"readwrite\" 供用户使用。在docker中，起初也是将 rootfs 以readonly方式加载并检查，然而接下来利用 union mount 的将一个 readwrite 文件系统挂载在 readonly 的rootfs之上，并且允许再次将下层的 file system设定为readonly 并且向上叠加, 这样一组readonly和一个writeable的结构构成一个container的运行目录, 每一个被称作一个Layer。如下图:\n\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=2a7eeea18594a4c21e2eef796f9d70b0/54fbb2fb43166d22b3bc1a3a442309f79152d251.jpg)得益于AUFS的特性, 每一个对readonly层文件/目录的修改都只会存在于上层的writeable层中。这样由于不存在竞争, 多个container可以共享readonly的layer。 所以docker将readonly的层称作\"**image**\"`- 对于container而言整个rootfs都是read-write的，但事实上所有的修改都写入最上层的writeable层中, image不保存用户状态，可以用于模板、重建和复制。\n\n由此可见，采用AUFS作为docker的container的文件系统，能够提供如下好处:\n\n1. 节省存储空间 \\- 多个container可以共享base image存储\n\n2. 快速部署 \\- 如果要部署多个container，base image可以避免多次拷贝\n\n3. 内存更省 \\- 因为多个container共享base image, 以及OS的disk缓存机制，多个container中的进程命中缓存内容的几率大大增加\n\n4. 升级更方便 \\- 相比于 copy-on-write 类型的FS，base-image也是可以挂载为可writeable的，可以通过更新base image而一次性更新其之上的container\n\n5. 允许在不更改base-image的同时修改其目录中的文件 - 所有写操作都发生在最上层的writeable层中，这样可以大大增加base image能共享的文件内容。\n\n### 参考资源:\n\n[Docker 百度百科](https://baike.baidu.com/item/Docker/13344470?fr=aladdin)\n\n[Docker Org Docs](https://docs.docker.com/)\n\n[Docker 入门教程](http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html)\n[Docker 微服务教程](http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html)\n\n[一小时Docker教程](https://blog.csphere.cn/archives/22)\n\n[Docker Getting Start: Related Knowledge](http://tiewei.github.io/cloud/Docker-Getting-Start/)\n\n[非常详细的 Docker 学习笔记](https://blog.csdn.net/zjin_hua/article/details/52041757)\n\n[docker 中文](http://www.docker.org.cn/book/Docker/what-is-Docker-16.html)\n\n[Docker资源](http://www.docker.org.cn/page/resources.html)\n\n[如何通俗解释Docker是什么？](https://www.zhihu.com/question/28300645)\n","source":"_posts/Docker.md","raw":"---\ntitle: Docker 简单介绍\ndate: 2018-06-01 19:59:25\ntags: Docker\ncategories: tools\n---\n\n# Docker\n\n## 1. Docker 背景\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2dc9b7759a8fa0ec6bca6c5f47fe328b/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n### 1.1. Docker 是什么\n\nDocker 是 [PaaS](https://baike.baidu.com/item/PaaS) 提供商 dotCloud 开源的一个基于 [LXC](https://baike.baidu.com/item/LXC) (LXC 其并不是一套[硬件虚拟化方法](http://en.wikipedia.org/wiki/Platform_virtualization) 无法归属到全虚拟化、部分虚拟化和半虚拟化中的任意一个，而是一个[操作系统级虚拟化](http://en.wikipedia.org/wiki/Operating_system-level_virtualization)方)的**高级容器引擎**，源代码托管在 [Github](https://baike.baidu.com/item/Github) 上, 基于[go语言](https://baike.baidu.com/item/go%E8%AF%AD%E8%A8%80)并遵从Apache2.0协议开源。\n\n**Docker** 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux 容器解决方案。\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f451b09fa38b87d6444fa34d6661435d/203fb80e7bec54e7719c18b0bb389b504fc26a2f.jpg)\n\n<!--more-->\n\n有人以通俗的方式说明:\n\n> Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。  \n> \n> Docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。Docker就是集装箱。\n\n### 1.2. Docker 的用途\n\n- 快捷部署软件环境\n\n- 以低效耗实现应用资源隔离\n\n- 微服务架构组建（多个Docker 镜像之间组合使用）\n\n- web应用的自动化打包和发布\n\n国内有应用于Docker技术的公司[DaoCloud](http://www.daocloud.io) , [云雀](http://www.alauda.cn)等\n\n## 2. Docker 基础\n\n## 2.1. 术语\n\n- Docker镜像\n\n  > 镜像是Docker 容器运行时的只读模板，每一个镜像由一系列的层（layers）组成。当我们修改镜像时，新的层被创建并透明覆盖之前的层，Docker使用UnionFS 来将这些层连贯到文件系统。\n\n- Docker仓库\n\n  > 类似github， Docker 镜像管理库，Docker官方[Docker Hub](https://hub.docker.com/explore/), 上面有很火镜像资源，如：\n  > \n  > ![Nginx](https://hub.docker.com/public/images/official/nginx.png)\n  > \n  > ![](https://hub.docker.com/public/images/official/httpd.png)\n  > \n  > ![](https://hub.docker.com/public/images/official/ubuntu.png)\n\n- Docker容器\n\n  > 容器都是从镜像建立的，Docker容器和文件夹类似，容器包含了应用运行所需的环境和数据等。Docker容器可以运行、开始、停止、移动和删除。镜像是只读的，当Docker 运行容器时，它会在镜像顶层添加一个可读写的层。\n\n# 2.2. 组件\n\nDocker 采用的是客户端/服务端(C/S)架构模式。Docker客户端和守护进程之间通过socket或者RESTful API进行通信。\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=9f1b2701eddde711f3df4ba4c686a57e/a50f4bfbfbedab644936dac4ff36afc379311e69.jpg)\n\n| 子项         | 说明                                                                       |\n|:---------- | ------------------------------------------------------------------------ |\n| Docker守护进程 | 建立、运行、发布你的Docker容器，处理所有的Docker 请求，管理所有容器。                                |\n| Docker客服端  | Docker客户端，实际上是`docker`的二进制程序，是主要的用户与Docker交互方式。它接收用户指令并且与背后的Docker守护进程通信 |\n\n## 2.3. 技术基础\n\n### 2.3.1. namespace\n\nLXC所实现的隔离性主要是来自kernel的namespace, 其中`pid`, `net`, `ipc`, `mnt`, `uts` 等namespace将container的进程, 网络, 消息, 文件系统和hostname 隔离开。\n\n| NameSpace(ns)  | Function                                                                                                                                                                                                                                                                                                                          |\n| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| pid namespace  | 具有如下特征： <br><ul><li> 每个namespace中的pid是有自己的pid=1的进程(类似`/sbin/init`进程) </li><li>个namespace中的进程只能影响自己的同一个namespace或子namespace中的进程 </li><li>因为`/proc`包含正在运行的进程，因此在container中的`pseudo-filesystem`的/proc目录只能看到自己namespace中的进程</li><li>因为namespace允许嵌套，父namespace可以影响子namespace的进程，所以子namespace的进程可以在父namespace中看到，但是具有不同的pid </li></ul> |\n| net namespace  | 有了 `pid` namespace, 每个namespace中的pid能够相互隔离，但是网络端口还是共享host的端口。网络隔离是通过`net`namespace实现的， 每个`net` namespace有独立的 network devices, IP addresses, IP routing tables, `/proc/net` 目录。这样每个container的网络就能隔离开来。 LXC在此基础上有5种网络类型，docker默认采用veth的方式将container中的虚拟网卡同host上的一个docker bridge连接在一起。                                               |\n| ipc namespace  | container中进程交互还是采用linux常见的进程间交互方法(interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同VM不同，container 的进程间交互实际上还是host上具有相同pid namespace中的进程间交互，因此需要在IPC资源申请时加入namespace信息 - 每个IPC资源有一个唯一的 32bit ID。                                                                                                                           |\n| mnt namespace  | 类似`chroot`，将一个进程放到一个特定的目录执行。`mnt` namespace允许不同namespace的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同`chroot`不同，每个namespace中的container在`/proc/mounts`的信息只包含所在namespace的mount point。                                                                                                                                            |\n| uts namespace  | UTS(\"UNIX Time-sharing System\") namespace允许每个container拥有独立的hostname和domain name, 使其在网络上可以被视作一个独立的节点而非Host上的一个进程。                                                                                                                                                                                                                  |\n| user namespace | 每个container可以有不同的 user 和 group id, 也就是说可以以container内部的用户在container内部执行程序而非Host上的用户                                                                                                                                                                                                                                                |\n\n有了以上6种namespace从进程、网络、IPC、文件系统、UTS和用户角度的隔离，一个container就可以对外展现出一个独立计算机的能力，并且不同container从OS层面实现了隔离。 然而不同namespace之间资源还是相互竞争的，仍然需要类似`ulimit`来管理每个container所能使用的资源 - LXC 采用的是`cgroup`。\n\n### 2.3.2. Control Groups(cgroups)\n\n**cgroups** 实现了对资源的配额和度量。 **cgroups**  的使用非常简单，提供类似文件的接口，在 `/cgroup`目录下新建一个文件夹即可新建一个group，在此文件夹中新建**task**文件，并将pid写入该文件，即可实现对该进程的资源控制。\n我们主要关心cgroups可以限制哪些资源，即有哪些subsystem是我们关心。\n\n**`cpu`**: 在cgroup中，并不能像硬件虚拟化方案一样能够定义CPU能力，但是能够定义CPU轮转的优先级，因此具有较高CPU优先级的进程会更可能得到CPU运算。 通过将参数写入**cpu.shares**,即可定义改cgroup的CPU优先级 - 这里是一个相对权重，而非绝对值。当然在cpu这个subsystem中还有其他可配置项，手册中有详细说明。\n\n**`cpusets`** : cpusets 定义了有几个CPU可以被这个group使用，或者哪几个CPU可以供这个group使用。在某些场景下，单CPU绑定可以防止多核间缓存切换，从而提高效率\n\n**`memory`** : 内存相关的限制\n\n**`blkio`** : block IO相关的统计和限制，byte/operation统计和限制(IOPS等)，读写速度限制等，但是这里主要统计的都是同步IO\n\n**`net_cls`**， **`cpuacct`** , **`devices`** , **`freezer`** 等其他可管理项。\n\n### 2.3.3. LinuX Containers(LXC)\n\n借助于namespace的隔离机制和cgroup限额功能，LXC提供了一套统一的API和工具来建立和管理container, LXC利用了如下 kernel 的features:\n\n- Kernel namespaces (ipc, uts, mount, pid, network and user)\n- Apparmor and SELinux profiles\n- Seccomp policies\n- Chroots (using pivot_root)\n- Kernel capabilities\n- Control groups (cgroups)\n\nLXC 向用户屏蔽了以上 kernel 接口的细节, 提供了如下的组件大大简化了用户的开发和使用工作:\n\n- The liblxc library\n- Several language bindings (python3, lua and Go)\n- A set of standard tools to control the containers\n- Container templates\n\n### 2.3.4. AUFS\n\nDocker对container的使用基本是建立在LXC基础之上的，然而LXC存在的问题是难以通过标准化的模板制作、重建、复制和移动 container。VM虚拟化可以采用image和snapshot 实现复制、重建以及移动的功能。docker0.7中引入了storage driver, 支持AUFS, VFS, device mapper, 也为BTRFS以及ZFS引入提供了可能。 但除了AUFS都未经过dotcloud的线上使用。\n\nAUFS (AnotherUnionFS) 是一种 `Union FS`。AUFS支持为每一个成员目录(AKA branch)设定'readonly', 'readwrite' 和 'whiteout-able' 权限,\n\n典型的Linux启动到运行需要两个FS - bootfs + rootfs。\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=fb52a2bc700e0cf3b4fa46a96b2f997a/9358d109b3de9c82ba58f6216e81800a19d8435a.jpg)\n\n\n\n典型的Linux在启动后，首先将 rootfs 置为 readonly, 进行一系列检查, 然后将其切换为 \"readwrite\" 供用户使用。在docker中，起初也是将 rootfs 以readonly方式加载并检查，然而接下来利用 union mount 的将一个 readwrite 文件系统挂载在 readonly 的rootfs之上，并且允许再次将下层的 file system设定为readonly 并且向上叠加, 这样一组readonly和一个writeable的结构构成一个container的运行目录, 每一个被称作一个Layer。如下图:\n\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=2a7eeea18594a4c21e2eef796f9d70b0/54fbb2fb43166d22b3bc1a3a442309f79152d251.jpg)得益于AUFS的特性, 每一个对readonly层文件/目录的修改都只会存在于上层的writeable层中。这样由于不存在竞争, 多个container可以共享readonly的layer。 所以docker将readonly的层称作\"**image**\"`- 对于container而言整个rootfs都是read-write的，但事实上所有的修改都写入最上层的writeable层中, image不保存用户状态，可以用于模板、重建和复制。\n\n由此可见，采用AUFS作为docker的container的文件系统，能够提供如下好处:\n\n1. 节省存储空间 \\- 多个container可以共享base image存储\n\n2. 快速部署 \\- 如果要部署多个container，base image可以避免多次拷贝\n\n3. 内存更省 \\- 因为多个container共享base image, 以及OS的disk缓存机制，多个container中的进程命中缓存内容的几率大大增加\n\n4. 升级更方便 \\- 相比于 copy-on-write 类型的FS，base-image也是可以挂载为可writeable的，可以通过更新base image而一次性更新其之上的container\n\n5. 允许在不更改base-image的同时修改其目录中的文件 - 所有写操作都发生在最上层的writeable层中，这样可以大大增加base image能共享的文件内容。\n\n### 参考资源:\n\n[Docker 百度百科](https://baike.baidu.com/item/Docker/13344470?fr=aladdin)\n\n[Docker Org Docs](https://docs.docker.com/)\n\n[Docker 入门教程](http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html)\n[Docker 微服务教程](http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html)\n\n[一小时Docker教程](https://blog.csphere.cn/archives/22)\n\n[Docker Getting Start: Related Knowledge](http://tiewei.github.io/cloud/Docker-Getting-Start/)\n\n[非常详细的 Docker 学习笔记](https://blog.csdn.net/zjin_hua/article/details/52041757)\n\n[docker 中文](http://www.docker.org.cn/book/Docker/what-is-Docker-16.html)\n\n[Docker资源](http://www.docker.org.cn/page/resources.html)\n\n[如何通俗解释Docker是什么？](https://www.zhihu.com/question/28300645)\n","slug":"Docker","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0p6000hzkgrs2tn06t7","content":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"1-Docker-背景\"><a href=\"#1-Docker-背景\" class=\"headerlink\" title=\"1. Docker 背景\"></a>1. Docker 背景</h2><p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2dc9b7759a8fa0ec6bca6c5f47fe328b/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"\"></p>\n<h3 id=\"1-1-Docker-是什么\"><a href=\"#1-1-Docker-是什么\" class=\"headerlink\" title=\"1.1. Docker 是什么\"></a>1.1. Docker 是什么</h3><p>Docker 是 <a href=\"https://baike.baidu.com/item/PaaS\" target=\"_blank\" rel=\"noopener\">PaaS</a> 提供商 dotCloud 开源的一个基于 <a href=\"https://baike.baidu.com/item/LXC\" target=\"_blank\" rel=\"noopener\">LXC</a> (LXC 其并不是一套<a href=\"http://en.wikipedia.org/wiki/Platform_virtualization\" target=\"_blank\" rel=\"noopener\">硬件虚拟化方法</a> 无法归属到全虚拟化、部分虚拟化和半虚拟化中的任意一个，而是一个<a href=\"http://en.wikipedia.org/wiki/Operating_system-level_virtualization\" target=\"_blank\" rel=\"noopener\">操作系统级虚拟化</a>方)的<strong>高级容器引擎</strong>，源代码托管在 <a href=\"https://baike.baidu.com/item/Github\" target=\"_blank\" rel=\"noopener\">Github</a> 上, 基于<a href=\"https://baike.baidu.com/item/go%E8%AF%AD%E8%A8%80\" target=\"_blank\" rel=\"noopener\">go语言</a>并遵从Apache2.0协议开源。</p>\n<p><strong>Docker</strong> 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux 容器解决方案。</p>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f451b09fa38b87d6444fa34d6661435d/203fb80e7bec54e7719c18b0bb389b504fc26a2f.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>有人以通俗的方式说明:</p>\n<blockquote>\n<p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。  </p>\n<p>Docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。Docker就是集装箱。</p>\n</blockquote>\n<h3 id=\"1-2-Docker-的用途\"><a href=\"#1-2-Docker-的用途\" class=\"headerlink\" title=\"1.2. Docker 的用途\"></a>1.2. Docker 的用途</h3><ul>\n<li><p>快捷部署软件环境</p>\n</li>\n<li><p>以低效耗实现应用资源隔离</p>\n</li>\n<li><p>微服务架构组建（多个Docker 镜像之间组合使用）</p>\n</li>\n<li><p>web应用的自动化打包和发布</p>\n</li>\n</ul>\n<p>国内有应用于Docker技术的公司<a href=\"http://www.daocloud.io\" target=\"_blank\" rel=\"noopener\">DaoCloud</a> , <a href=\"http://www.alauda.cn\" target=\"_blank\" rel=\"noopener\">云雀</a>等</p>\n<h2 id=\"2-Docker-基础\"><a href=\"#2-Docker-基础\" class=\"headerlink\" title=\"2. Docker 基础\"></a>2. Docker 基础</h2><h2 id=\"2-1-术语\"><a href=\"#2-1-术语\" class=\"headerlink\" title=\"2.1. 术语\"></a>2.1. 术语</h2><ul>\n<li><p>Docker镜像</p>\n<blockquote>\n<p>镜像是Docker 容器运行时的只读模板，每一个镜像由一系列的层（layers）组成。当我们修改镜像时，新的层被创建并透明覆盖之前的层，Docker使用UnionFS 来将这些层连贯到文件系统。</p>\n</blockquote>\n</li>\n<li><p>Docker仓库</p>\n<blockquote>\n<p>类似github， Docker 镜像管理库，Docker官方<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>, 上面有很火镜像资源，如：</p>\n<p><img src=\"https://hub.docker.com/public/images/official/nginx.png\" alt=\"Nginx\"></p>\n<p><img src=\"https://hub.docker.com/public/images/official/httpd.png\" alt=\"\"></p>\n<p><img src=\"https://hub.docker.com/public/images/official/ubuntu.png\" alt=\"\"></p>\n</blockquote>\n</li>\n<li><p>Docker容器</p>\n<blockquote>\n<p>容器都是从镜像建立的，Docker容器和文件夹类似，容器包含了应用运行所需的环境和数据等。Docker容器可以运行、开始、停止、移动和删除。镜像是只读的，当Docker 运行容器时，它会在镜像顶层添加一个可读写的层。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"2-2-组件\"><a href=\"#2-2-组件\" class=\"headerlink\" title=\"2.2. 组件\"></a>2.2. 组件</h1><p>Docker 采用的是客户端/服务端(C/S)架构模式。Docker客户端和守护进程之间通过socket或者RESTful API进行通信。</p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=9f1b2701eddde711f3df4ba4c686a57e/a50f4bfbfbedab644936dac4ff36afc379311e69.jpg\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Docker守护进程</td>\n<td>建立、运行、发布你的Docker容器，处理所有的Docker 请求，管理所有容器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Docker客服端</td>\n<td>Docker客户端，实际上是<code>docker</code>的二进制程序，是主要的用户与Docker交互方式。它接收用户指令并且与背后的Docker守护进程通信</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-3-技术基础\"><a href=\"#2-3-技术基础\" class=\"headerlink\" title=\"2.3. 技术基础\"></a>2.3. 技术基础</h2><h3 id=\"2-3-1-namespace\"><a href=\"#2-3-1-namespace\" class=\"headerlink\" title=\"2.3.1. namespace\"></a>2.3.1. namespace</h3><p>LXC所实现的隔离性主要是来自kernel的namespace, 其中<code>pid</code>, <code>net</code>, <code>ipc</code>, <code>mnt</code>, <code>uts</code> 等namespace将container的进程, 网络, 消息, 文件系统和hostname 隔离开。</p>\n<table>\n<thead>\n<tr>\n<th>NameSpace(ns)</th>\n<th>Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pid namespace</td>\n<td>具有如下特征： <br><ul><li> 每个namespace中的pid是有自己的pid=1的进程(类似<code>/sbin/init</code>进程) </li><li>个namespace中的进程只能影响自己的同一个namespace或子namespace中的进程 </li><li>因为<code>/proc</code>包含正在运行的进程，因此在container中的<code>pseudo-filesystem</code>的/proc目录只能看到自己namespace中的进程</li><li>因为namespace允许嵌套，父namespace可以影响子namespace的进程，所以子namespace的进程可以在父namespace中看到，但是具有不同的pid </li></ul></td>\n</tr>\n<tr>\n<td>net namespace</td>\n<td>有了 <code>pid</code> namespace, 每个namespace中的pid能够相互隔离，但是网络端口还是共享host的端口。网络隔离是通过<code>net</code>namespace实现的， 每个<code>net</code> namespace有独立的 network devices, IP addresses, IP routing tables, <code>/proc/net</code> 目录。这样每个container的网络就能隔离开来。 LXC在此基础上有5种网络类型，docker默认采用veth的方式将container中的虚拟网卡同host上的一个docker bridge连接在一起。</td>\n</tr>\n<tr>\n<td>ipc namespace</td>\n<td>container中进程交互还是采用linux常见的进程间交互方法(interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同VM不同，container 的进程间交互实际上还是host上具有相同pid namespace中的进程间交互，因此需要在IPC资源申请时加入namespace信息 - 每个IPC资源有一个唯一的 32bit ID。</td>\n</tr>\n<tr>\n<td>mnt namespace</td>\n<td>类似<code>chroot</code>，将一个进程放到一个特定的目录执行。<code>mnt</code> namespace允许不同namespace的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同<code>chroot</code>不同，每个namespace中的container在<code>/proc/mounts</code>的信息只包含所在namespace的mount point。</td>\n</tr>\n<tr>\n<td>uts namespace</td>\n<td>UTS(“UNIX Time-sharing System”) namespace允许每个container拥有独立的hostname和domain name, 使其在网络上可以被视作一个独立的节点而非Host上的一个进程。</td>\n</tr>\n<tr>\n<td>user namespace</td>\n<td>每个container可以有不同的 user 和 group id, 也就是说可以以container内部的用户在container内部执行程序而非Host上的用户</td>\n</tr>\n</tbody>\n</table>\n<p>有了以上6种namespace从进程、网络、IPC、文件系统、UTS和用户角度的隔离，一个container就可以对外展现出一个独立计算机的能力，并且不同container从OS层面实现了隔离。 然而不同namespace之间资源还是相互竞争的，仍然需要类似<code>ulimit</code>来管理每个container所能使用的资源 - LXC 采用的是<code>cgroup</code>。</p>\n<h3 id=\"2-3-2-Control-Groups-cgroups\"><a href=\"#2-3-2-Control-Groups-cgroups\" class=\"headerlink\" title=\"2.3.2. Control Groups(cgroups)\"></a>2.3.2. Control Groups(cgroups)</h3><p><strong>cgroups</strong> 实现了对资源的配额和度量。 <strong>cgroups</strong>  的使用非常简单，提供类似文件的接口，在 <code>/cgroup</code>目录下新建一个文件夹即可新建一个group，在此文件夹中新建<strong>task</strong>文件，并将pid写入该文件，即可实现对该进程的资源控制。<br>我们主要关心cgroups可以限制哪些资源，即有哪些subsystem是我们关心。</p>\n<p><strong><code>cpu</code></strong>: 在cgroup中，并不能像硬件虚拟化方案一样能够定义CPU能力，但是能够定义CPU轮转的优先级，因此具有较高CPU优先级的进程会更可能得到CPU运算。 通过将参数写入<strong>cpu.shares</strong>,即可定义改cgroup的CPU优先级 - 这里是一个相对权重，而非绝对值。当然在cpu这个subsystem中还有其他可配置项，手册中有详细说明。</p>\n<p><strong><code>cpusets</code></strong> : cpusets 定义了有几个CPU可以被这个group使用，或者哪几个CPU可以供这个group使用。在某些场景下，单CPU绑定可以防止多核间缓存切换，从而提高效率</p>\n<p><strong><code>memory</code></strong> : 内存相关的限制</p>\n<p><strong><code>blkio</code></strong> : block IO相关的统计和限制，byte/operation统计和限制(IOPS等)，读写速度限制等，但是这里主要统计的都是同步IO</p>\n<p><strong><code>net_cls</code></strong>， <strong><code>cpuacct</code></strong> , <strong><code>devices</code></strong> , <strong><code>freezer</code></strong> 等其他可管理项。</p>\n<h3 id=\"2-3-3-LinuX-Containers-LXC\"><a href=\"#2-3-3-LinuX-Containers-LXC\" class=\"headerlink\" title=\"2.3.3. LinuX Containers(LXC)\"></a>2.3.3. LinuX Containers(LXC)</h3><p>借助于namespace的隔离机制和cgroup限额功能，LXC提供了一套统一的API和工具来建立和管理container, LXC利用了如下 kernel 的features:</p>\n<ul>\n<li>Kernel namespaces (ipc, uts, mount, pid, network and user)</li>\n<li>Apparmor and SELinux profiles</li>\n<li>Seccomp policies</li>\n<li>Chroots (using pivot_root)</li>\n<li>Kernel capabilities</li>\n<li>Control groups (cgroups)</li>\n</ul>\n<p>LXC 向用户屏蔽了以上 kernel 接口的细节, 提供了如下的组件大大简化了用户的开发和使用工作:</p>\n<ul>\n<li>The liblxc library</li>\n<li>Several language bindings (python3, lua and Go)</li>\n<li>A set of standard tools to control the containers</li>\n<li>Container templates</li>\n</ul>\n<h3 id=\"2-3-4-AUFS\"><a href=\"#2-3-4-AUFS\" class=\"headerlink\" title=\"2.3.4. AUFS\"></a>2.3.4. AUFS</h3><p>Docker对container的使用基本是建立在LXC基础之上的，然而LXC存在的问题是难以通过标准化的模板制作、重建、复制和移动 container。VM虚拟化可以采用image和snapshot 实现复制、重建以及移动的功能。docker0.7中引入了storage driver, 支持AUFS, VFS, device mapper, 也为BTRFS以及ZFS引入提供了可能。 但除了AUFS都未经过dotcloud的线上使用。</p>\n<p>AUFS (AnotherUnionFS) 是一种 <code>Union FS</code>。AUFS支持为每一个成员目录(AKA branch)设定’readonly’, ‘readwrite’ 和 ‘whiteout-able’ 权限,</p>\n<p>典型的Linux启动到运行需要两个FS - bootfs + rootfs。</p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=fb52a2bc700e0cf3b4fa46a96b2f997a/9358d109b3de9c82ba58f6216e81800a19d8435a.jpg\" alt=\"\"></p>\n<p>典型的Linux在启动后，首先将 rootfs 置为 readonly, 进行一系列检查, 然后将其切换为 “readwrite” 供用户使用。在docker中，起初也是将 rootfs 以readonly方式加载并检查，然而接下来利用 union mount 的将一个 readwrite 文件系统挂载在 readonly 的rootfs之上，并且允许再次将下层的 file system设定为readonly 并且向上叠加, 这样一组readonly和一个writeable的结构构成一个container的运行目录, 每一个被称作一个Layer。如下图:</p>\n<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=2a7eeea18594a4c21e2eef796f9d70b0/54fbb2fb43166d22b3bc1a3a442309f79152d251.jpg\" alt=\"\">得益于AUFS的特性, 每一个对readonly层文件/目录的修改都只会存在于上层的writeable层中。这样由于不存在竞争, 多个container可以共享readonly的layer。 所以docker将readonly的层称作”<strong>image</strong>“`- 对于container而言整个rootfs都是read-write的，但事实上所有的修改都写入最上层的writeable层中, image不保存用户状态，可以用于模板、重建和复制。</p>\n<p>由此可见，采用AUFS作为docker的container的文件系统，能够提供如下好处:</p>\n<ol>\n<li><p>节省存储空间 - 多个container可以共享base image存储</p>\n</li>\n<li><p>快速部署 - 如果要部署多个container，base image可以避免多次拷贝</p>\n</li>\n<li><p>内存更省 - 因为多个container共享base image, 以及OS的disk缓存机制，多个container中的进程命中缓存内容的几率大大增加</p>\n</li>\n<li><p>升级更方便 - 相比于 copy-on-write 类型的FS，base-image也是可以挂载为可writeable的，可以通过更新base image而一次性更新其之上的container</p>\n</li>\n<li><p>允许在不更改base-image的同时修改其目录中的文件 - 所有写操作都发生在最上层的writeable层中，这样可以大大增加base image能共享的文件内容。</p>\n</li>\n</ol>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源:\"></a>参考资源:</h3><p><a href=\"https://baike.baidu.com/item/Docker/13344470?fr=aladdin\" target=\"_blank\" rel=\"noopener\">Docker 百度百科</a></p>\n<p><a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker Org Docs</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\" target=\"_blank\" rel=\"noopener\">Docker 入门教程</a><br><a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html\" target=\"_blank\" rel=\"noopener\">Docker 微服务教程</a></p>\n<p><a href=\"https://blog.csphere.cn/archives/22\" target=\"_blank\" rel=\"noopener\">一小时Docker教程</a></p>\n<p><a href=\"http://tiewei.github.io/cloud/Docker-Getting-Start/\" target=\"_blank\" rel=\"noopener\">Docker Getting Start: Related Knowledge</a></p>\n<p><a href=\"https://blog.csdn.net/zjin_hua/article/details/52041757\" target=\"_blank\" rel=\"noopener\">非常详细的 Docker 学习笔记</a></p>\n<p><a href=\"http://www.docker.org.cn/book/Docker/what-is-Docker-16.html\" target=\"_blank\" rel=\"noopener\">docker 中文</a></p>\n<p><a href=\"http://www.docker.org.cn/page/resources.html\" target=\"_blank\" rel=\"noopener\">Docker资源</a></p>\n<p><a href=\"https://www.zhihu.com/question/28300645\" target=\"_blank\" rel=\"noopener\">如何通俗解释Docker是什么？</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"1-Docker-背景\"><a href=\"#1-Docker-背景\" class=\"headerlink\" title=\"1. Docker 背景\"></a>1. Docker 背景</h2><p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2dc9b7759a8fa0ec6bca6c5f47fe328b/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"\"></p>\n<h3 id=\"1-1-Docker-是什么\"><a href=\"#1-1-Docker-是什么\" class=\"headerlink\" title=\"1.1. Docker 是什么\"></a>1.1. Docker 是什么</h3><p>Docker 是 <a href=\"https://baike.baidu.com/item/PaaS\" target=\"_blank\" rel=\"noopener\">PaaS</a> 提供商 dotCloud 开源的一个基于 <a href=\"https://baike.baidu.com/item/LXC\" target=\"_blank\" rel=\"noopener\">LXC</a> (LXC 其并不是一套<a href=\"http://en.wikipedia.org/wiki/Platform_virtualization\" target=\"_blank\" rel=\"noopener\">硬件虚拟化方法</a> 无法归属到全虚拟化、部分虚拟化和半虚拟化中的任意一个，而是一个<a href=\"http://en.wikipedia.org/wiki/Operating_system-level_virtualization\" target=\"_blank\" rel=\"noopener\">操作系统级虚拟化</a>方)的<strong>高级容器引擎</strong>，源代码托管在 <a href=\"https://baike.baidu.com/item/Github\" target=\"_blank\" rel=\"noopener\">Github</a> 上, 基于<a href=\"https://baike.baidu.com/item/go%E8%AF%AD%E8%A8%80\" target=\"_blank\" rel=\"noopener\">go语言</a>并遵从Apache2.0协议开源。</p>\n<p><strong>Docker</strong> 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux 容器解决方案。</p>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f451b09fa38b87d6444fa34d6661435d/203fb80e7bec54e7719c18b0bb389b504fc26a2f.jpg\" alt=\"\"></p>","more":"<p>有人以通俗的方式说明:</p>\n<blockquote>\n<p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。  </p>\n<p>Docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。Docker就是集装箱。</p>\n</blockquote>\n<h3 id=\"1-2-Docker-的用途\"><a href=\"#1-2-Docker-的用途\" class=\"headerlink\" title=\"1.2. Docker 的用途\"></a>1.2. Docker 的用途</h3><ul>\n<li><p>快捷部署软件环境</p>\n</li>\n<li><p>以低效耗实现应用资源隔离</p>\n</li>\n<li><p>微服务架构组建（多个Docker 镜像之间组合使用）</p>\n</li>\n<li><p>web应用的自动化打包和发布</p>\n</li>\n</ul>\n<p>国内有应用于Docker技术的公司<a href=\"http://www.daocloud.io\" target=\"_blank\" rel=\"noopener\">DaoCloud</a> , <a href=\"http://www.alauda.cn\" target=\"_blank\" rel=\"noopener\">云雀</a>等</p>\n<h2 id=\"2-Docker-基础\"><a href=\"#2-Docker-基础\" class=\"headerlink\" title=\"2. Docker 基础\"></a>2. Docker 基础</h2><h2 id=\"2-1-术语\"><a href=\"#2-1-术语\" class=\"headerlink\" title=\"2.1. 术语\"></a>2.1. 术语</h2><ul>\n<li><p>Docker镜像</p>\n<blockquote>\n<p>镜像是Docker 容器运行时的只读模板，每一个镜像由一系列的层（layers）组成。当我们修改镜像时，新的层被创建并透明覆盖之前的层，Docker使用UnionFS 来将这些层连贯到文件系统。</p>\n</blockquote>\n</li>\n<li><p>Docker仓库</p>\n<blockquote>\n<p>类似github， Docker 镜像管理库，Docker官方<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>, 上面有很火镜像资源，如：</p>\n<p><img src=\"https://hub.docker.com/public/images/official/nginx.png\" alt=\"Nginx\"></p>\n<p><img src=\"https://hub.docker.com/public/images/official/httpd.png\" alt=\"\"></p>\n<p><img src=\"https://hub.docker.com/public/images/official/ubuntu.png\" alt=\"\"></p>\n</blockquote>\n</li>\n<li><p>Docker容器</p>\n<blockquote>\n<p>容器都是从镜像建立的，Docker容器和文件夹类似，容器包含了应用运行所需的环境和数据等。Docker容器可以运行、开始、停止、移动和删除。镜像是只读的，当Docker 运行容器时，它会在镜像顶层添加一个可读写的层。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"2-2-组件\"><a href=\"#2-2-组件\" class=\"headerlink\" title=\"2.2. 组件\"></a>2.2. 组件</h1><p>Docker 采用的是客户端/服务端(C/S)架构模式。Docker客户端和守护进程之间通过socket或者RESTful API进行通信。</p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=9f1b2701eddde711f3df4ba4c686a57e/a50f4bfbfbedab644936dac4ff36afc379311e69.jpg\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Docker守护进程</td>\n<td>建立、运行、发布你的Docker容器，处理所有的Docker 请求，管理所有容器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Docker客服端</td>\n<td>Docker客户端，实际上是<code>docker</code>的二进制程序，是主要的用户与Docker交互方式。它接收用户指令并且与背后的Docker守护进程通信</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-3-技术基础\"><a href=\"#2-3-技术基础\" class=\"headerlink\" title=\"2.3. 技术基础\"></a>2.3. 技术基础</h2><h3 id=\"2-3-1-namespace\"><a href=\"#2-3-1-namespace\" class=\"headerlink\" title=\"2.3.1. namespace\"></a>2.3.1. namespace</h3><p>LXC所实现的隔离性主要是来自kernel的namespace, 其中<code>pid</code>, <code>net</code>, <code>ipc</code>, <code>mnt</code>, <code>uts</code> 等namespace将container的进程, 网络, 消息, 文件系统和hostname 隔离开。</p>\n<table>\n<thead>\n<tr>\n<th>NameSpace(ns)</th>\n<th>Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pid namespace</td>\n<td>具有如下特征： <br><ul><li> 每个namespace中的pid是有自己的pid=1的进程(类似<code>/sbin/init</code>进程) </li><li>个namespace中的进程只能影响自己的同一个namespace或子namespace中的进程 </li><li>因为<code>/proc</code>包含正在运行的进程，因此在container中的<code>pseudo-filesystem</code>的/proc目录只能看到自己namespace中的进程</li><li>因为namespace允许嵌套，父namespace可以影响子namespace的进程，所以子namespace的进程可以在父namespace中看到，但是具有不同的pid </li></ul></td>\n</tr>\n<tr>\n<td>net namespace</td>\n<td>有了 <code>pid</code> namespace, 每个namespace中的pid能够相互隔离，但是网络端口还是共享host的端口。网络隔离是通过<code>net</code>namespace实现的， 每个<code>net</code> namespace有独立的 network devices, IP addresses, IP routing tables, <code>/proc/net</code> 目录。这样每个container的网络就能隔离开来。 LXC在此基础上有5种网络类型，docker默认采用veth的方式将container中的虚拟网卡同host上的一个docker bridge连接在一起。</td>\n</tr>\n<tr>\n<td>ipc namespace</td>\n<td>container中进程交互还是采用linux常见的进程间交互方法(interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同VM不同，container 的进程间交互实际上还是host上具有相同pid namespace中的进程间交互，因此需要在IPC资源申请时加入namespace信息 - 每个IPC资源有一个唯一的 32bit ID。</td>\n</tr>\n<tr>\n<td>mnt namespace</td>\n<td>类似<code>chroot</code>，将一个进程放到一个特定的目录执行。<code>mnt</code> namespace允许不同namespace的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同<code>chroot</code>不同，每个namespace中的container在<code>/proc/mounts</code>的信息只包含所在namespace的mount point。</td>\n</tr>\n<tr>\n<td>uts namespace</td>\n<td>UTS(“UNIX Time-sharing System”) namespace允许每个container拥有独立的hostname和domain name, 使其在网络上可以被视作一个独立的节点而非Host上的一个进程。</td>\n</tr>\n<tr>\n<td>user namespace</td>\n<td>每个container可以有不同的 user 和 group id, 也就是说可以以container内部的用户在container内部执行程序而非Host上的用户</td>\n</tr>\n</tbody>\n</table>\n<p>有了以上6种namespace从进程、网络、IPC、文件系统、UTS和用户角度的隔离，一个container就可以对外展现出一个独立计算机的能力，并且不同container从OS层面实现了隔离。 然而不同namespace之间资源还是相互竞争的，仍然需要类似<code>ulimit</code>来管理每个container所能使用的资源 - LXC 采用的是<code>cgroup</code>。</p>\n<h3 id=\"2-3-2-Control-Groups-cgroups\"><a href=\"#2-3-2-Control-Groups-cgroups\" class=\"headerlink\" title=\"2.3.2. Control Groups(cgroups)\"></a>2.3.2. Control Groups(cgroups)</h3><p><strong>cgroups</strong> 实现了对资源的配额和度量。 <strong>cgroups</strong>  的使用非常简单，提供类似文件的接口，在 <code>/cgroup</code>目录下新建一个文件夹即可新建一个group，在此文件夹中新建<strong>task</strong>文件，并将pid写入该文件，即可实现对该进程的资源控制。<br>我们主要关心cgroups可以限制哪些资源，即有哪些subsystem是我们关心。</p>\n<p><strong><code>cpu</code></strong>: 在cgroup中，并不能像硬件虚拟化方案一样能够定义CPU能力，但是能够定义CPU轮转的优先级，因此具有较高CPU优先级的进程会更可能得到CPU运算。 通过将参数写入<strong>cpu.shares</strong>,即可定义改cgroup的CPU优先级 - 这里是一个相对权重，而非绝对值。当然在cpu这个subsystem中还有其他可配置项，手册中有详细说明。</p>\n<p><strong><code>cpusets</code></strong> : cpusets 定义了有几个CPU可以被这个group使用，或者哪几个CPU可以供这个group使用。在某些场景下，单CPU绑定可以防止多核间缓存切换，从而提高效率</p>\n<p><strong><code>memory</code></strong> : 内存相关的限制</p>\n<p><strong><code>blkio</code></strong> : block IO相关的统计和限制，byte/operation统计和限制(IOPS等)，读写速度限制等，但是这里主要统计的都是同步IO</p>\n<p><strong><code>net_cls</code></strong>， <strong><code>cpuacct</code></strong> , <strong><code>devices</code></strong> , <strong><code>freezer</code></strong> 等其他可管理项。</p>\n<h3 id=\"2-3-3-LinuX-Containers-LXC\"><a href=\"#2-3-3-LinuX-Containers-LXC\" class=\"headerlink\" title=\"2.3.3. LinuX Containers(LXC)\"></a>2.3.3. LinuX Containers(LXC)</h3><p>借助于namespace的隔离机制和cgroup限额功能，LXC提供了一套统一的API和工具来建立和管理container, LXC利用了如下 kernel 的features:</p>\n<ul>\n<li>Kernel namespaces (ipc, uts, mount, pid, network and user)</li>\n<li>Apparmor and SELinux profiles</li>\n<li>Seccomp policies</li>\n<li>Chroots (using pivot_root)</li>\n<li>Kernel capabilities</li>\n<li>Control groups (cgroups)</li>\n</ul>\n<p>LXC 向用户屏蔽了以上 kernel 接口的细节, 提供了如下的组件大大简化了用户的开发和使用工作:</p>\n<ul>\n<li>The liblxc library</li>\n<li>Several language bindings (python3, lua and Go)</li>\n<li>A set of standard tools to control the containers</li>\n<li>Container templates</li>\n</ul>\n<h3 id=\"2-3-4-AUFS\"><a href=\"#2-3-4-AUFS\" class=\"headerlink\" title=\"2.3.4. AUFS\"></a>2.3.4. AUFS</h3><p>Docker对container的使用基本是建立在LXC基础之上的，然而LXC存在的问题是难以通过标准化的模板制作、重建、复制和移动 container。VM虚拟化可以采用image和snapshot 实现复制、重建以及移动的功能。docker0.7中引入了storage driver, 支持AUFS, VFS, device mapper, 也为BTRFS以及ZFS引入提供了可能。 但除了AUFS都未经过dotcloud的线上使用。</p>\n<p>AUFS (AnotherUnionFS) 是一种 <code>Union FS</code>。AUFS支持为每一个成员目录(AKA branch)设定’readonly’, ‘readwrite’ 和 ‘whiteout-able’ 权限,</p>\n<p>典型的Linux启动到运行需要两个FS - bootfs + rootfs。</p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=fb52a2bc700e0cf3b4fa46a96b2f997a/9358d109b3de9c82ba58f6216e81800a19d8435a.jpg\" alt=\"\"></p>\n<p>典型的Linux在启动后，首先将 rootfs 置为 readonly, 进行一系列检查, 然后将其切换为 “readwrite” 供用户使用。在docker中，起初也是将 rootfs 以readonly方式加载并检查，然而接下来利用 union mount 的将一个 readwrite 文件系统挂载在 readonly 的rootfs之上，并且允许再次将下层的 file system设定为readonly 并且向上叠加, 这样一组readonly和一个writeable的结构构成一个container的运行目录, 每一个被称作一个Layer。如下图:</p>\n<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=2a7eeea18594a4c21e2eef796f9d70b0/54fbb2fb43166d22b3bc1a3a442309f79152d251.jpg\" alt=\"\">得益于AUFS的特性, 每一个对readonly层文件/目录的修改都只会存在于上层的writeable层中。这样由于不存在竞争, 多个container可以共享readonly的layer。 所以docker将readonly的层称作”<strong>image</strong>“`- 对于container而言整个rootfs都是read-write的，但事实上所有的修改都写入最上层的writeable层中, image不保存用户状态，可以用于模板、重建和复制。</p>\n<p>由此可见，采用AUFS作为docker的container的文件系统，能够提供如下好处:</p>\n<ol>\n<li><p>节省存储空间 - 多个container可以共享base image存储</p>\n</li>\n<li><p>快速部署 - 如果要部署多个container，base image可以避免多次拷贝</p>\n</li>\n<li><p>内存更省 - 因为多个container共享base image, 以及OS的disk缓存机制，多个container中的进程命中缓存内容的几率大大增加</p>\n</li>\n<li><p>升级更方便 - 相比于 copy-on-write 类型的FS，base-image也是可以挂载为可writeable的，可以通过更新base image而一次性更新其之上的container</p>\n</li>\n<li><p>允许在不更改base-image的同时修改其目录中的文件 - 所有写操作都发生在最上层的writeable层中，这样可以大大增加base image能共享的文件内容。</p>\n</li>\n</ol>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源:\"></a>参考资源:</h3><p><a href=\"https://baike.baidu.com/item/Docker/13344470?fr=aladdin\" target=\"_blank\" rel=\"noopener\">Docker 百度百科</a></p>\n<p><a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker Org Docs</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\" target=\"_blank\" rel=\"noopener\">Docker 入门教程</a><br><a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html\" target=\"_blank\" rel=\"noopener\">Docker 微服务教程</a></p>\n<p><a href=\"https://blog.csphere.cn/archives/22\" target=\"_blank\" rel=\"noopener\">一小时Docker教程</a></p>\n<p><a href=\"http://tiewei.github.io/cloud/Docker-Getting-Start/\" target=\"_blank\" rel=\"noopener\">Docker Getting Start: Related Knowledge</a></p>\n<p><a href=\"https://blog.csdn.net/zjin_hua/article/details/52041757\" target=\"_blank\" rel=\"noopener\">非常详细的 Docker 学习笔记</a></p>\n<p><a href=\"http://www.docker.org.cn/book/Docker/what-is-Docker-16.html\" target=\"_blank\" rel=\"noopener\">docker 中文</a></p>\n<p><a href=\"http://www.docker.org.cn/page/resources.html\" target=\"_blank\" rel=\"noopener\">Docker资源</a></p>\n<p><a href=\"https://www.zhihu.com/question/28300645\" target=\"_blank\" rel=\"noopener\">如何通俗解释Docker是什么？</a></p>"},{"title":"Lighttpd Support FastCGI (python) and LUCI(OpenWrt)","date":"2017-06-20T02:56:27.000Z","_content":"\n# 1.Backgroud  \nWe need to use lighttpd as webserver to servive two web page:  \n\n- FastCGI (python bottle web micro framework)  \n- LUCI (openwrt's cgi-bin/luci, which is CGI)\n\n\n# 2. Support LUCI\nAfter we study OpenWrt wiki docs, we know how to make lighttpd support luci.\nTwo key steps:  \n\n- enable lighttpd's \"mod_cgi\" module  \n- tell lighttpd all requests to \"cgi-bin/luci\" will send to lua, lighttpd ignore them\n\n``` bash\n# Ensure we have to enable mod_cgi, which is in conf.d\n# server.modules += ( \"mod_cgi\" )\n#\n# detail see openwrt org doc: https://wiki.openwrt.org/doc/howto/luci.on.lighttpd\n# \n# wang.kai@sunmedia.com.cn\n\n# tell lighttpd to process requests using lua\ncgi.assign += ( \"cgi-bin/luci\" => \"\" ) \n```\nDetail see OpenWrt Wiki about [LuCI on lighttpd](https://wiki.openwrt.org/doc/howto/luci.on.lighttpd?s[]=lighttpd)\n\n<!-- more -->\n\n# 3. Support FastCGI\nThe lighttpd fastcgi configuration like this:\n\n``` bash\n# Ensure mod_fastcgi mod_rewrite  have been enabled, some modules will be enabled\n# in conf.d, BSP3's configuration will have effect on this.\n#\n# Server.modules += ( \n#\t\t\"mod_fastcgi\",\n#\t\t\"mod_rewrite\",\n# \t\t)\n# wang.kai@sunmedia.com.cn\n\nvar.webapp_path = \"/usr/share/httpstation\"\nvar.webapp_fcgi = \"main.py\"\n\nfastcgi.server = (\n\t\"/python_entry\" => (\n\t\t\"icatchtek\" => (\n\t\t\t\"bin-path\" => webapp_path + \"/\" + webapp_fcgi,\n\t\t\t\"socket\" => \"/tmp/httpstation-fcgi.socket\",\n\t\t\t\"max-procs\" => 1,\n\t\t\t\"check-local\" => \"disable\",\n\t\t)\n\t),\n)\n\n# [Note]\n# Python request will send to \"/python_entry\" + \"$1\", except:\n# 1. document.domain + \"/cgi-bin/luci\"\n# 2. document.domain + \"/luci-static\"\nurl.rewrite-once = (\n\t\"^(/(?!(cgi|luci-static)).*)\" => \"/python_entry\" + \"$1\",\n)\n```\n\n## 3.1. fcgi server  \nWe need to tell lighttpd:  \n\n- \"bin-path\"     : where lighttpd will startup executable file\n- \"socket\"       : fast cgi use socket send/receive msg\n- \"check-local\"  : Whether check file is existed in \"server.document-root\"\n- \"max-procs\"    : lighttpd support multiple process (optional)  \n\nLighttpd docs about FastCGI <http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI>\n\n## 3.2. URL Redirect\nBecause lighttpd support two web pages, we need to do something make url access ok.  \n### 3.2.1. Bottle Python Redirect\nIf fastcgi server work well, we need to add \"/python_entry\". For example, we access \"172.28.52.152/home\" should be \"172.28.52.152/python_entry\". We use \"mod_rewrite\" module to avoid this embarrassed situation. This module will pre-process URL before we really access it.   \n\n### 3.2.2. LUCI Redirect\nWe need to keep luci access like \"cgi-bin/luci\" and \"luci-static\"(which is used for js, css, etc resource files). So we use:  \n``` bash\n# [Note]\n# Python request will send to \"/python_entry\" + \"$1\", except:\n# 1. document.domain + \"/cgi-bin/luci\"\n# 2. document.domain + \"/luci-static\"\nurl.rewrite-once = (\n\t\"^(/(?!(cgi|luci-static)).*)\" => \"/python_entry\" + \"$1\",\n)\n```\n\n*** How to represent \"except xxx\" ?***  \nIn Reluar Expression, we use \"**?!**\" to express except. So next regular expression is except begin with \"cgi\" or \"luci-staic\".\n>^(/(?!(cgi|luci-static)).*)\n\n\n","source":"_posts/Lighttpd support fcgi(python) and luci.md","raw":"---\ntitle: Lighttpd Support FastCGI (python) and LUCI(OpenWrt)\ndate: 2017-06-20 10:56:27\ntags:\n\t- webserver\ncategories: openwrt\n---\n\n# 1.Backgroud  \nWe need to use lighttpd as webserver to servive two web page:  \n\n- FastCGI (python bottle web micro framework)  \n- LUCI (openwrt's cgi-bin/luci, which is CGI)\n\n\n# 2. Support LUCI\nAfter we study OpenWrt wiki docs, we know how to make lighttpd support luci.\nTwo key steps:  \n\n- enable lighttpd's \"mod_cgi\" module  \n- tell lighttpd all requests to \"cgi-bin/luci\" will send to lua, lighttpd ignore them\n\n``` bash\n# Ensure we have to enable mod_cgi, which is in conf.d\n# server.modules += ( \"mod_cgi\" )\n#\n# detail see openwrt org doc: https://wiki.openwrt.org/doc/howto/luci.on.lighttpd\n# \n# wang.kai@sunmedia.com.cn\n\n# tell lighttpd to process requests using lua\ncgi.assign += ( \"cgi-bin/luci\" => \"\" ) \n```\nDetail see OpenWrt Wiki about [LuCI on lighttpd](https://wiki.openwrt.org/doc/howto/luci.on.lighttpd?s[]=lighttpd)\n\n<!-- more -->\n\n# 3. Support FastCGI\nThe lighttpd fastcgi configuration like this:\n\n``` bash\n# Ensure mod_fastcgi mod_rewrite  have been enabled, some modules will be enabled\n# in conf.d, BSP3's configuration will have effect on this.\n#\n# Server.modules += ( \n#\t\t\"mod_fastcgi\",\n#\t\t\"mod_rewrite\",\n# \t\t)\n# wang.kai@sunmedia.com.cn\n\nvar.webapp_path = \"/usr/share/httpstation\"\nvar.webapp_fcgi = \"main.py\"\n\nfastcgi.server = (\n\t\"/python_entry\" => (\n\t\t\"icatchtek\" => (\n\t\t\t\"bin-path\" => webapp_path + \"/\" + webapp_fcgi,\n\t\t\t\"socket\" => \"/tmp/httpstation-fcgi.socket\",\n\t\t\t\"max-procs\" => 1,\n\t\t\t\"check-local\" => \"disable\",\n\t\t)\n\t),\n)\n\n# [Note]\n# Python request will send to \"/python_entry\" + \"$1\", except:\n# 1. document.domain + \"/cgi-bin/luci\"\n# 2. document.domain + \"/luci-static\"\nurl.rewrite-once = (\n\t\"^(/(?!(cgi|luci-static)).*)\" => \"/python_entry\" + \"$1\",\n)\n```\n\n## 3.1. fcgi server  \nWe need to tell lighttpd:  \n\n- \"bin-path\"     : where lighttpd will startup executable file\n- \"socket\"       : fast cgi use socket send/receive msg\n- \"check-local\"  : Whether check file is existed in \"server.document-root\"\n- \"max-procs\"    : lighttpd support multiple process (optional)  \n\nLighttpd docs about FastCGI <http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI>\n\n## 3.2. URL Redirect\nBecause lighttpd support two web pages, we need to do something make url access ok.  \n### 3.2.1. Bottle Python Redirect\nIf fastcgi server work well, we need to add \"/python_entry\". For example, we access \"172.28.52.152/home\" should be \"172.28.52.152/python_entry\". We use \"mod_rewrite\" module to avoid this embarrassed situation. This module will pre-process URL before we really access it.   \n\n### 3.2.2. LUCI Redirect\nWe need to keep luci access like \"cgi-bin/luci\" and \"luci-static\"(which is used for js, css, etc resource files). So we use:  \n``` bash\n# [Note]\n# Python request will send to \"/python_entry\" + \"$1\", except:\n# 1. document.domain + \"/cgi-bin/luci\"\n# 2. document.domain + \"/luci-static\"\nurl.rewrite-once = (\n\t\"^(/(?!(cgi|luci-static)).*)\" => \"/python_entry\" + \"$1\",\n)\n```\n\n*** How to represent \"except xxx\" ?***  \nIn Reluar Expression, we use \"**?!**\" to express except. So next regular expression is except begin with \"cgi\" or \"luci-staic\".\n>^(/(?!(cgi|luci-static)).*)\n\n\n","slug":"Lighttpd support fcgi(python) and luci","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0p7000jzkgrvid9jyub","content":"<h1 id=\"1-Backgroud\"><a href=\"#1-Backgroud\" class=\"headerlink\" title=\"1.Backgroud\"></a>1.Backgroud</h1><p>We need to use lighttpd as webserver to servive two web page:  </p>\n<ul>\n<li>FastCGI (python bottle web micro framework)  </li>\n<li>LUCI (openwrt’s cgi-bin/luci, which is CGI)</li>\n</ul>\n<h1 id=\"2-Support-LUCI\"><a href=\"#2-Support-LUCI\" class=\"headerlink\" title=\"2. Support LUCI\"></a>2. Support LUCI</h1><p>After we study OpenWrt wiki docs, we know how to make lighttpd support luci.<br>Two key steps:  </p>\n<ul>\n<li>enable lighttpd’s “mod_cgi” module  </li>\n<li>tell lighttpd all requests to “cgi-bin/luci” will send to lua, lighttpd ignore them</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Ensure we have to enable mod_cgi, which is in conf.d</span></span><br><span class=\"line\"><span class=\"comment\"># server.modules += ( \"mod_cgi\" )</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># detail see openwrt org doc: https://wiki.openwrt.org/doc/howto/luci.on.lighttpd</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># wang.kai@sunmedia.com.cn</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># tell lighttpd to process requests using lua</span></span><br><span class=\"line\">cgi.assign += ( <span class=\"string\">\"cgi-bin/luci\"</span> =&gt; <span class=\"string\">\"\"</span> )</span><br></pre></td></tr></table></figure>\n<p>Detail see OpenWrt Wiki about <a href=\"https://wiki.openwrt.org/doc/howto/luci.on.lighttpd?s[]=lighttpd\" target=\"_blank\" rel=\"noopener\">LuCI on lighttpd</a></p>\n<a id=\"more\"></a>\n<h1 id=\"3-Support-FastCGI\"><a href=\"#3-Support-FastCGI\" class=\"headerlink\" title=\"3. Support FastCGI\"></a>3. Support FastCGI</h1><p>The lighttpd fastcgi configuration like this:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Ensure mod_fastcgi mod_rewrite  have been enabled, some modules will be enabled</span></span><br><span class=\"line\"><span class=\"comment\"># in conf.d, BSP3's configuration will have effect on this.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Server.modules += ( </span></span><br><span class=\"line\"><span class=\"comment\">#\t\t\"mod_fastcgi\",</span></span><br><span class=\"line\"><span class=\"comment\">#\t\t\"mod_rewrite\",</span></span><br><span class=\"line\"><span class=\"comment\"># \t\t)</span></span><br><span class=\"line\"><span class=\"comment\"># wang.kai@sunmedia.com.cn</span></span><br><span class=\"line\"></span><br><span class=\"line\">var.webapp_path = <span class=\"string\">\"/usr/share/httpstation\"</span></span><br><span class=\"line\">var.webapp_fcgi = <span class=\"string\">\"main.py\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">fastcgi.server = (</span><br><span class=\"line\">\t<span class=\"string\">\"/python_entry\"</span> =&gt; (</span><br><span class=\"line\">\t\t<span class=\"string\">\"icatchtek\"</span> =&gt; (</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"bin-path\"</span> =&gt; webapp_path + <span class=\"string\">\"/\"</span> + webapp_fcgi,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"socket\"</span> =&gt; <span class=\"string\">\"/tmp/httpstation-fcgi.socket\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"max-procs\"</span> =&gt; 1,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"check-local\"</span> =&gt; <span class=\"string\">\"disable\"</span>,</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t),</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># [Note]</span></span><br><span class=\"line\"><span class=\"comment\"># Python request will send to \"/python_entry\" + \"$1\", except:</span></span><br><span class=\"line\"><span class=\"comment\"># 1. document.domain + \"/cgi-bin/luci\"</span></span><br><span class=\"line\"><span class=\"comment\"># 2. document.domain + \"/luci-static\"</span></span><br><span class=\"line\">url.rewrite-once = (</span><br><span class=\"line\">\t<span class=\"string\">\"^(/(?!(cgi|luci-static)).*)\"</span> =&gt; <span class=\"string\">\"/python_entry\"</span> + <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-1-fcgi-server\"><a href=\"#3-1-fcgi-server\" class=\"headerlink\" title=\"3.1. fcgi server\"></a>3.1. fcgi server</h2><p>We need to tell lighttpd:  </p>\n<ul>\n<li>“bin-path”     : where lighttpd will startup executable file</li>\n<li>“socket”       : fast cgi use socket send/receive msg</li>\n<li>“check-local”  : Whether check file is existed in “server.document-root”</li>\n<li>“max-procs”    : lighttpd support multiple process (optional)  </li>\n</ul>\n<p>Lighttpd docs about FastCGI <a href=\"http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI\" target=\"_blank\" rel=\"noopener\">http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI</a></p>\n<h2 id=\"3-2-URL-Redirect\"><a href=\"#3-2-URL-Redirect\" class=\"headerlink\" title=\"3.2. URL Redirect\"></a>3.2. URL Redirect</h2><p>Because lighttpd support two web pages, we need to do something make url access ok.  </p>\n<h3 id=\"3-2-1-Bottle-Python-Redirect\"><a href=\"#3-2-1-Bottle-Python-Redirect\" class=\"headerlink\" title=\"3.2.1. Bottle Python Redirect\"></a>3.2.1. Bottle Python Redirect</h3><p>If fastcgi server work well, we need to add “/python_entry”. For example, we access “172.28.52.152/home” should be “172.28.52.152/python_entry”. We use “mod_rewrite” module to avoid this embarrassed situation. This module will pre-process URL before we really access it.   </p>\n<h3 id=\"3-2-2-LUCI-Redirect\"><a href=\"#3-2-2-LUCI-Redirect\" class=\"headerlink\" title=\"3.2.2. LUCI Redirect\"></a>3.2.2. LUCI Redirect</h3><p>We need to keep luci access like “cgi-bin/luci” and “luci-static”(which is used for js, css, etc resource files). So we use:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># [Note]</span></span><br><span class=\"line\"><span class=\"comment\"># Python request will send to \"/python_entry\" + \"$1\", except:</span></span><br><span class=\"line\"><span class=\"comment\"># 1. document.domain + \"/cgi-bin/luci\"</span></span><br><span class=\"line\"><span class=\"comment\"># 2. document.domain + \"/luci-static\"</span></span><br><span class=\"line\">url.rewrite-once = (</span><br><span class=\"line\">\t<span class=\"string\">\"^(/(?!(cgi|luci-static)).*)\"</span> =&gt; <span class=\"string\">\"/python_entry\"</span> + <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><strong><em> How to represent “except xxx” ?</em></strong><br>In Reluar Expression, we use “<strong>?!</strong>“ to express except. So next regular expression is except begin with “cgi” or “luci-staic”.</p>\n<blockquote>\n<p>^(/(?!(cgi|luci-static)).*)</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Backgroud\"><a href=\"#1-Backgroud\" class=\"headerlink\" title=\"1.Backgroud\"></a>1.Backgroud</h1><p>We need to use lighttpd as webserver to servive two web page:  </p>\n<ul>\n<li>FastCGI (python bottle web micro framework)  </li>\n<li>LUCI (openwrt’s cgi-bin/luci, which is CGI)</li>\n</ul>\n<h1 id=\"2-Support-LUCI\"><a href=\"#2-Support-LUCI\" class=\"headerlink\" title=\"2. Support LUCI\"></a>2. Support LUCI</h1><p>After we study OpenWrt wiki docs, we know how to make lighttpd support luci.<br>Two key steps:  </p>\n<ul>\n<li>enable lighttpd’s “mod_cgi” module  </li>\n<li>tell lighttpd all requests to “cgi-bin/luci” will send to lua, lighttpd ignore them</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Ensure we have to enable mod_cgi, which is in conf.d</span></span><br><span class=\"line\"><span class=\"comment\"># server.modules += ( \"mod_cgi\" )</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># detail see openwrt org doc: https://wiki.openwrt.org/doc/howto/luci.on.lighttpd</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># wang.kai@sunmedia.com.cn</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># tell lighttpd to process requests using lua</span></span><br><span class=\"line\">cgi.assign += ( <span class=\"string\">\"cgi-bin/luci\"</span> =&gt; <span class=\"string\">\"\"</span> )</span><br></pre></td></tr></table></figure>\n<p>Detail see OpenWrt Wiki about <a href=\"https://wiki.openwrt.org/doc/howto/luci.on.lighttpd?s[]=lighttpd\" target=\"_blank\" rel=\"noopener\">LuCI on lighttpd</a></p>","more":"<h1 id=\"3-Support-FastCGI\"><a href=\"#3-Support-FastCGI\" class=\"headerlink\" title=\"3. Support FastCGI\"></a>3. Support FastCGI</h1><p>The lighttpd fastcgi configuration like this:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Ensure mod_fastcgi mod_rewrite  have been enabled, some modules will be enabled</span></span><br><span class=\"line\"><span class=\"comment\"># in conf.d, BSP3's configuration will have effect on this.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Server.modules += ( </span></span><br><span class=\"line\"><span class=\"comment\">#\t\t\"mod_fastcgi\",</span></span><br><span class=\"line\"><span class=\"comment\">#\t\t\"mod_rewrite\",</span></span><br><span class=\"line\"><span class=\"comment\"># \t\t)</span></span><br><span class=\"line\"><span class=\"comment\"># wang.kai@sunmedia.com.cn</span></span><br><span class=\"line\"></span><br><span class=\"line\">var.webapp_path = <span class=\"string\">\"/usr/share/httpstation\"</span></span><br><span class=\"line\">var.webapp_fcgi = <span class=\"string\">\"main.py\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">fastcgi.server = (</span><br><span class=\"line\">\t<span class=\"string\">\"/python_entry\"</span> =&gt; (</span><br><span class=\"line\">\t\t<span class=\"string\">\"icatchtek\"</span> =&gt; (</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"bin-path\"</span> =&gt; webapp_path + <span class=\"string\">\"/\"</span> + webapp_fcgi,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"socket\"</span> =&gt; <span class=\"string\">\"/tmp/httpstation-fcgi.socket\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"max-procs\"</span> =&gt; 1,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"check-local\"</span> =&gt; <span class=\"string\">\"disable\"</span>,</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t),</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># [Note]</span></span><br><span class=\"line\"><span class=\"comment\"># Python request will send to \"/python_entry\" + \"$1\", except:</span></span><br><span class=\"line\"><span class=\"comment\"># 1. document.domain + \"/cgi-bin/luci\"</span></span><br><span class=\"line\"><span class=\"comment\"># 2. document.domain + \"/luci-static\"</span></span><br><span class=\"line\">url.rewrite-once = (</span><br><span class=\"line\">\t<span class=\"string\">\"^(/(?!(cgi|luci-static)).*)\"</span> =&gt; <span class=\"string\">\"/python_entry\"</span> + <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-1-fcgi-server\"><a href=\"#3-1-fcgi-server\" class=\"headerlink\" title=\"3.1. fcgi server\"></a>3.1. fcgi server</h2><p>We need to tell lighttpd:  </p>\n<ul>\n<li>“bin-path”     : where lighttpd will startup executable file</li>\n<li>“socket”       : fast cgi use socket send/receive msg</li>\n<li>“check-local”  : Whether check file is existed in “server.document-root”</li>\n<li>“max-procs”    : lighttpd support multiple process (optional)  </li>\n</ul>\n<p>Lighttpd docs about FastCGI <a href=\"http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI\" target=\"_blank\" rel=\"noopener\">http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI</a></p>\n<h2 id=\"3-2-URL-Redirect\"><a href=\"#3-2-URL-Redirect\" class=\"headerlink\" title=\"3.2. URL Redirect\"></a>3.2. URL Redirect</h2><p>Because lighttpd support two web pages, we need to do something make url access ok.  </p>\n<h3 id=\"3-2-1-Bottle-Python-Redirect\"><a href=\"#3-2-1-Bottle-Python-Redirect\" class=\"headerlink\" title=\"3.2.1. Bottle Python Redirect\"></a>3.2.1. Bottle Python Redirect</h3><p>If fastcgi server work well, we need to add “/python_entry”. For example, we access “172.28.52.152/home” should be “172.28.52.152/python_entry”. We use “mod_rewrite” module to avoid this embarrassed situation. This module will pre-process URL before we really access it.   </p>\n<h3 id=\"3-2-2-LUCI-Redirect\"><a href=\"#3-2-2-LUCI-Redirect\" class=\"headerlink\" title=\"3.2.2. LUCI Redirect\"></a>3.2.2. LUCI Redirect</h3><p>We need to keep luci access like “cgi-bin/luci” and “luci-static”(which is used for js, css, etc resource files). So we use:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># [Note]</span></span><br><span class=\"line\"><span class=\"comment\"># Python request will send to \"/python_entry\" + \"$1\", except:</span></span><br><span class=\"line\"><span class=\"comment\"># 1. document.domain + \"/cgi-bin/luci\"</span></span><br><span class=\"line\"><span class=\"comment\"># 2. document.domain + \"/luci-static\"</span></span><br><span class=\"line\">url.rewrite-once = (</span><br><span class=\"line\">\t<span class=\"string\">\"^(/(?!(cgi|luci-static)).*)\"</span> =&gt; <span class=\"string\">\"/python_entry\"</span> + <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><strong><em> How to represent “except xxx” ?</em></strong><br>In Reluar Expression, we use “<strong>?!</strong>“ to express except. So next regular expression is except begin with “cgi” or “luci-staic”.</p>\n<blockquote>\n<p>^(/(?!(cgi|luci-static)).*)</p>\n</blockquote>"},{"title":"Linux_Flash","date":"2018-08-22T14:20:13.000Z","_content":"\n## 1. Flash\n闪存（Flash Memory）是非易失性长寿命存储器，是电子可擦除只读存储器（EEPROM）的变种，而闪存的大部分芯片需要块擦除。\n\n![MOS管插图](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MOS%E7%AE%A1.png)\n\n<!--more-->\n\n注：\n>N型半导体即自由电子浓度远大于空穴浓度的杂质半导体。(对于锗、硅类半导体材料，掺杂Ⅴ族元素(磷、砷等)\nP型半导体即空穴浓度远大于自由电子浓度的杂质半导体。在纯净的硅晶体中掺入三价元素（如硼）\n\n常见的Flash有:  \n- NOR Flash\n- NAND Flash\n\n|                | NOR Flash                     | NAND Flash                               |\n| :------------: | :---------------------------- | :--------------------------------------- |\n|     读速度     | 快                            | 较快                                     |\n| 单字节编程时间 | 快                            | 慢                                       |\n| 多字节编程时间 | 慢                            | 快                                       |\n|      寿命      | 十万次                        | 百万次                                   |\n|    I/O 端口    | SRAM 接口，有足够地址引脚寻址 | 8个复用PIN 脚传送控制、地址、数据        |\n|      功耗      | 高                            | 低，需要额外RAM                          |\n|    应用市场    | 1~16MB                        | 大容量                                   |\n|      特点      | 程序可在芯片内运行            | 成本低，高存储密度，较快的写入和擦除速度 |\n\n两者更详细的比较可以通过Flash 厂商的datasheet 查看。\n\n`Large Page Nand Flash`\n![Large Page Nand](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Large_Page_Nand.png)\n\n注：Spare Area 常常可以存储BBT(Bad Block Table), ECC, 逻辑映射表等信息。\n\nNand Flash 硬件特性：\n- R/W 最小单位，Page\n- 擦除最小单位，Block\n- 擦除的含义是将整块都擦除为0xFF\n- 写操作前，必须先擦除，然后再写\n\n## 2. Linux MTD\n\n![MTD Structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Linux_MTD_Structure.png)\n\n常见MTD 分区为：\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Common_Partitions.png)\n\n## 3. Operation\nFlash 常见的操作有Read, Erase, Write, WP(Write Protect)\n\n`MTD Read Flow`\n![MTD_Read_Flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Read_Flow.png)\n\n使用多并口时， SPI 会用到WP#， HOLD# 等管脚。\nStandard SPI: SCLK, CS#, SI, SO\nDual SPI: SCLK, CS#, IO0(SI), IO1(SO)\nQuad SPI: SCLK, CS#, IO0(SI), IO1(SO), IO2(WP#), IO3(HOLD#)\n\n在SPI 接口上可能会有如下形式的Read：\n- Page Read\n- Page Read to cache\n- page from cache\n- fast read from cache\n- read from cache X2\n- read from cache X4\n- read from cache dual IO\n- read from cache quad IO\n\nSPI Nand Read 时序一般为：\n1. 13H(page read to cache)\n2. 0FH(get features coomand to read the status)\n3. 03H/OBH (read from cache), 3BH/6BH(read from cache x2/x4), BBH/EBH(Read from cache dual/quad IO)\n\nspi_nand_read_from_cache\n![spi_nand_read_from_cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache.png)\n\nspi_nand_read_to_cache\n![spi_nand_read_to_cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_to_cache.png)\n\nspi_nand_read_from_cache_x4\n![spi_nand_read_from_cache_x4](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache_x4.png)\n\nspi_nand_read_from_cache_quad_io\n![spi_nand_read_from_cache_quad_io](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache_quad_io.png)\n<br>\n\n`MTD Write Flow`\n![MTD_Write_Flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Write_Flow.png)\n\n在SPI Nand Flash 上的时序图流程一般为：\n1. 02H (PROGRAM LOAD)/32H (PROGRAM LOAD x4)\n2. 06H (WRITE ENABLE)\n3. 10H (PROGRAM EXECUTE)\n4. 0FH (GET FEATURE command to read the status)\n\nprogram load 是设定addr， 并将write data 加载到cache register（一般超过PAGE SIZE 如2K+oob 的数据会被ignore），打开WE#，在program execute 命令才执行。\n\n`WP(Write Protect)`\n一般Flash 还具备block 相关指令。\n\n|    指令     | 说明                                 |\n| :---------: | :----------------------------------- |\n|    block    | 对某一区域Flash 进行写保护，不能写入 |\n|  un-block   | 解除block 限制                       |\n| block down  |\n| lock status | 查看状态                             |\n\n可能每个Flash 芯片厂商有所不同, 例如Giga SPI Nand Flash block, 通过SET Features，来控制block\n![giga_spi_nand_block](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/giga_spi_nand_block.png)\n\n`Erase`\nNand Flash 的erase 只能是Block(常见为64/128K) Erase。而Nor Flash 可以是Sector（一般4K） 或Block（32/64K） Erase。\n\n## 4. Bad Block\nNand Flash 工艺不能保证Memory Cell在其生命周期中保持性能的可靠性，使用寿命一般100万次。\n\n坏块一般分为：\n\n- 固有坏块：生产中就有（芯片原厂将每个坏块第一个Page的spare area某个字节标记为非0xFF）\n- 使用坏块：存储寿命（program/erase 错误，将block标记为坏块）\n\n当然，也有伪坏块。芯片在才做过程中可能由于电压不稳定等因素导致Program、Erase错误，标记的坏块也可能是好的。解决办法是，retry 一次，然后查看状态。\n\n`坏块的特性`\n\nPage Program与Block Erase操作失败，会反映到Status Register。\n\n`避免坏块策略`\n\n**Wear-Leveling(损益均衡)技术**\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Wear_Leveling.png)\n\n**Buffer Cache**\n类似于UBIFS 都会带有buffer cache，以及压缩，以此来尽量降低对I/O的操作。\n\n`应对坏块`\n\n为了保证数据正确性的R/W，我们使用BBT（Bad Block Table）。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/BBT.png)\n\n## Reference\n[gd5f1gq4xfxxh_v1.2_20190510](https://www.gigadevice.com/datasheet/gd5f1gq4xfxxh/)\n[gd25b127d_v1.4_20180725](https://www.gigadevice.com/datasheet/gd25b127d/)\n\n\n","source":"_posts/Linux-Flash.md","raw":"---\ntitle: Linux_Flash\ndate: 2018-08-22 22:20:13\ntags:\n    - flash\n    - kernel\ncategories:\n    - drivers\n---\n\n## 1. Flash\n闪存（Flash Memory）是非易失性长寿命存储器，是电子可擦除只读存储器（EEPROM）的变种，而闪存的大部分芯片需要块擦除。\n\n![MOS管插图](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MOS%E7%AE%A1.png)\n\n<!--more-->\n\n注：\n>N型半导体即自由电子浓度远大于空穴浓度的杂质半导体。(对于锗、硅类半导体材料，掺杂Ⅴ族元素(磷、砷等)\nP型半导体即空穴浓度远大于自由电子浓度的杂质半导体。在纯净的硅晶体中掺入三价元素（如硼）\n\n常见的Flash有:  \n- NOR Flash\n- NAND Flash\n\n|                | NOR Flash                     | NAND Flash                               |\n| :------------: | :---------------------------- | :--------------------------------------- |\n|     读速度     | 快                            | 较快                                     |\n| 单字节编程时间 | 快                            | 慢                                       |\n| 多字节编程时间 | 慢                            | 快                                       |\n|      寿命      | 十万次                        | 百万次                                   |\n|    I/O 端口    | SRAM 接口，有足够地址引脚寻址 | 8个复用PIN 脚传送控制、地址、数据        |\n|      功耗      | 高                            | 低，需要额外RAM                          |\n|    应用市场    | 1~16MB                        | 大容量                                   |\n|      特点      | 程序可在芯片内运行            | 成本低，高存储密度，较快的写入和擦除速度 |\n\n两者更详细的比较可以通过Flash 厂商的datasheet 查看。\n\n`Large Page Nand Flash`\n![Large Page Nand](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Large_Page_Nand.png)\n\n注：Spare Area 常常可以存储BBT(Bad Block Table), ECC, 逻辑映射表等信息。\n\nNand Flash 硬件特性：\n- R/W 最小单位，Page\n- 擦除最小单位，Block\n- 擦除的含义是将整块都擦除为0xFF\n- 写操作前，必须先擦除，然后再写\n\n## 2. Linux MTD\n\n![MTD Structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Linux_MTD_Structure.png)\n\n常见MTD 分区为：\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Common_Partitions.png)\n\n## 3. Operation\nFlash 常见的操作有Read, Erase, Write, WP(Write Protect)\n\n`MTD Read Flow`\n![MTD_Read_Flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Read_Flow.png)\n\n使用多并口时， SPI 会用到WP#， HOLD# 等管脚。\nStandard SPI: SCLK, CS#, SI, SO\nDual SPI: SCLK, CS#, IO0(SI), IO1(SO)\nQuad SPI: SCLK, CS#, IO0(SI), IO1(SO), IO2(WP#), IO3(HOLD#)\n\n在SPI 接口上可能会有如下形式的Read：\n- Page Read\n- Page Read to cache\n- page from cache\n- fast read from cache\n- read from cache X2\n- read from cache X4\n- read from cache dual IO\n- read from cache quad IO\n\nSPI Nand Read 时序一般为：\n1. 13H(page read to cache)\n2. 0FH(get features coomand to read the status)\n3. 03H/OBH (read from cache), 3BH/6BH(read from cache x2/x4), BBH/EBH(Read from cache dual/quad IO)\n\nspi_nand_read_from_cache\n![spi_nand_read_from_cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache.png)\n\nspi_nand_read_to_cache\n![spi_nand_read_to_cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_to_cache.png)\n\nspi_nand_read_from_cache_x4\n![spi_nand_read_from_cache_x4](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache_x4.png)\n\nspi_nand_read_from_cache_quad_io\n![spi_nand_read_from_cache_quad_io](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache_quad_io.png)\n<br>\n\n`MTD Write Flow`\n![MTD_Write_Flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Write_Flow.png)\n\n在SPI Nand Flash 上的时序图流程一般为：\n1. 02H (PROGRAM LOAD)/32H (PROGRAM LOAD x4)\n2. 06H (WRITE ENABLE)\n3. 10H (PROGRAM EXECUTE)\n4. 0FH (GET FEATURE command to read the status)\n\nprogram load 是设定addr， 并将write data 加载到cache register（一般超过PAGE SIZE 如2K+oob 的数据会被ignore），打开WE#，在program execute 命令才执行。\n\n`WP(Write Protect)`\n一般Flash 还具备block 相关指令。\n\n|    指令     | 说明                                 |\n| :---------: | :----------------------------------- |\n|    block    | 对某一区域Flash 进行写保护，不能写入 |\n|  un-block   | 解除block 限制                       |\n| block down  |\n| lock status | 查看状态                             |\n\n可能每个Flash 芯片厂商有所不同, 例如Giga SPI Nand Flash block, 通过SET Features，来控制block\n![giga_spi_nand_block](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/giga_spi_nand_block.png)\n\n`Erase`\nNand Flash 的erase 只能是Block(常见为64/128K) Erase。而Nor Flash 可以是Sector（一般4K） 或Block（32/64K） Erase。\n\n## 4. Bad Block\nNand Flash 工艺不能保证Memory Cell在其生命周期中保持性能的可靠性，使用寿命一般100万次。\n\n坏块一般分为：\n\n- 固有坏块：生产中就有（芯片原厂将每个坏块第一个Page的spare area某个字节标记为非0xFF）\n- 使用坏块：存储寿命（program/erase 错误，将block标记为坏块）\n\n当然，也有伪坏块。芯片在才做过程中可能由于电压不稳定等因素导致Program、Erase错误，标记的坏块也可能是好的。解决办法是，retry 一次，然后查看状态。\n\n`坏块的特性`\n\nPage Program与Block Erase操作失败，会反映到Status Register。\n\n`避免坏块策略`\n\n**Wear-Leveling(损益均衡)技术**\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Wear_Leveling.png)\n\n**Buffer Cache**\n类似于UBIFS 都会带有buffer cache，以及压缩，以此来尽量降低对I/O的操作。\n\n`应对坏块`\n\n为了保证数据正确性的R/W，我们使用BBT（Bad Block Table）。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/BBT.png)\n\n## Reference\n[gd5f1gq4xfxxh_v1.2_20190510](https://www.gigadevice.com/datasheet/gd5f1gq4xfxxh/)\n[gd25b127d_v1.4_20180725](https://www.gigadevice.com/datasheet/gd25b127d/)\n\n\n","slug":"Linux-Flash","published":1,"updated":"2020-03-11T06:41:45.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0p9000nzkgry3ykjz24","content":"<h2 id=\"1-Flash\"><a href=\"#1-Flash\" class=\"headerlink\" title=\"1. Flash\"></a>1. Flash</h2><p>闪存（Flash Memory）是非易失性长寿命存储器，是电子可擦除只读存储器（EEPROM）的变种，而闪存的大部分芯片需要块擦除。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MOS%E7%AE%A1.png\" alt=\"MOS管插图\"></p>\n<a id=\"more\"></a>\n<p>注：</p>\n<blockquote>\n<p>N型半导体即自由电子浓度远大于空穴浓度的杂质半导体。(对于锗、硅类半导体材料，掺杂Ⅴ族元素(磷、砷等)<br>P型半导体即空穴浓度远大于自由电子浓度的杂质半导体。在纯净的硅晶体中掺入三价元素（如硼）</p>\n</blockquote>\n<p>常见的Flash有:  </p>\n<ul>\n<li>NOR Flash</li>\n<li>NAND Flash</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:left\">NOR Flash</th>\n<th style=\"text-align:left\">NAND Flash</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">读速度</td>\n<td style=\"text-align:left\">快</td>\n<td style=\"text-align:left\">较快</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">单字节编程时间</td>\n<td style=\"text-align:left\">快</td>\n<td style=\"text-align:left\">慢</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">多字节编程时间</td>\n<td style=\"text-align:left\">慢</td>\n<td style=\"text-align:left\">快</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">寿命</td>\n<td style=\"text-align:left\">十万次</td>\n<td style=\"text-align:left\">百万次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">I/O 端口</td>\n<td style=\"text-align:left\">SRAM 接口，有足够地址引脚寻址</td>\n<td style=\"text-align:left\">8个复用PIN 脚传送控制、地址、数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">功耗</td>\n<td style=\"text-align:left\">高</td>\n<td style=\"text-align:left\">低，需要额外RAM</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">应用市场</td>\n<td style=\"text-align:left\">1~16MB</td>\n<td style=\"text-align:left\">大容量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">特点</td>\n<td style=\"text-align:left\">程序可在芯片内运行</td>\n<td style=\"text-align:left\">成本低，高存储密度，较快的写入和擦除速度</td>\n</tr>\n</tbody>\n</table>\n<p>两者更详细的比较可以通过Flash 厂商的datasheet 查看。</p>\n<p><code>Large Page Nand Flash</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Large_Page_Nand.png\" alt=\"Large Page Nand\"></p>\n<p>注：Spare Area 常常可以存储BBT(Bad Block Table), ECC, 逻辑映射表等信息。</p>\n<p>Nand Flash 硬件特性：</p>\n<ul>\n<li>R/W 最小单位，Page</li>\n<li>擦除最小单位，Block</li>\n<li>擦除的含义是将整块都擦除为0xFF</li>\n<li>写操作前，必须先擦除，然后再写</li>\n</ul>\n<h2 id=\"2-Linux-MTD\"><a href=\"#2-Linux-MTD\" class=\"headerlink\" title=\"2. Linux MTD\"></a>2. Linux MTD</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Linux_MTD_Structure.png\" alt=\"MTD Structure\"></p>\n<p>常见MTD 分区为：</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Common_Partitions.png\" alt=\"\"></p>\n<h2 id=\"3-Operation\"><a href=\"#3-Operation\" class=\"headerlink\" title=\"3. Operation\"></a>3. Operation</h2><p>Flash 常见的操作有Read, Erase, Write, WP(Write Protect)</p>\n<p><code>MTD Read Flow</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Read_Flow.png\" alt=\"MTD_Read_Flow\"></p>\n<p>使用多并口时， SPI 会用到WP#， HOLD# 等管脚。<br>Standard SPI: SCLK, CS#, SI, SO<br>Dual SPI: SCLK, CS#, IO0(SI), IO1(SO)<br>Quad SPI: SCLK, CS#, IO0(SI), IO1(SO), IO2(WP#), IO3(HOLD#)</p>\n<p>在SPI 接口上可能会有如下形式的Read：</p>\n<ul>\n<li>Page Read</li>\n<li>Page Read to cache</li>\n<li>page from cache</li>\n<li>fast read from cache</li>\n<li>read from cache X2</li>\n<li>read from cache X4</li>\n<li>read from cache dual IO</li>\n<li>read from cache quad IO</li>\n</ul>\n<p>SPI Nand Read 时序一般为：</p>\n<ol>\n<li>13H(page read to cache)</li>\n<li>0FH(get features coomand to read the status)</li>\n<li>03H/OBH (read from cache), 3BH/6BH(read from cache x2/x4), BBH/EBH(Read from cache dual/quad IO)</li>\n</ol>\n<p>spi_nand_read_from_cache<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache.png\" alt=\"spi_nand_read_from_cache\"></p>\n<p>spi_nand_read_to_cache<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_to_cache.png\" alt=\"spi_nand_read_to_cache\"></p>\n<p>spi_nand_read_from_cache_x4<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache_x4.png\" alt=\"spi_nand_read_from_cache_x4\"></p>\n<p>spi_nand_read_from_cache_quad_io<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache_quad_io.png\" alt=\"spi_nand_read_from_cache_quad_io\"><br><br></p>\n<p><code>MTD Write Flow</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Write_Flow.png\" alt=\"MTD_Write_Flow\"></p>\n<p>在SPI Nand Flash 上的时序图流程一般为：</p>\n<ol>\n<li>02H (PROGRAM LOAD)/32H (PROGRAM LOAD x4)</li>\n<li>06H (WRITE ENABLE)</li>\n<li>10H (PROGRAM EXECUTE)</li>\n<li>0FH (GET FEATURE command to read the status)</li>\n</ol>\n<p>program load 是设定addr， 并将write data 加载到cache register（一般超过PAGE SIZE 如2K+oob 的数据会被ignore），打开WE#，在program execute 命令才执行。</p>\n<p><code>WP(Write Protect)</code><br>一般Flash 还具备block 相关指令。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">block</td>\n<td style=\"text-align:left\">对某一区域Flash 进行写保护，不能写入</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">un-block</td>\n<td style=\"text-align:left\">解除block 限制</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">block down</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">lock status</td>\n<td style=\"text-align:left\">查看状态</td>\n</tr>\n</tbody>\n</table>\n<p>可能每个Flash 芯片厂商有所不同, 例如Giga SPI Nand Flash block, 通过SET Features，来控制block<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/giga_spi_nand_block.png\" alt=\"giga_spi_nand_block\"></p>\n<p><code>Erase</code><br>Nand Flash 的erase 只能是Block(常见为64/128K) Erase。而Nor Flash 可以是Sector（一般4K） 或Block（32/64K） Erase。</p>\n<h2 id=\"4-Bad-Block\"><a href=\"#4-Bad-Block\" class=\"headerlink\" title=\"4. Bad Block\"></a>4. Bad Block</h2><p>Nand Flash 工艺不能保证Memory Cell在其生命周期中保持性能的可靠性，使用寿命一般100万次。</p>\n<p>坏块一般分为：</p>\n<ul>\n<li>固有坏块：生产中就有（芯片原厂将每个坏块第一个Page的spare area某个字节标记为非0xFF）</li>\n<li>使用坏块：存储寿命（program/erase 错误，将block标记为坏块）</li>\n</ul>\n<p>当然，也有伪坏块。芯片在才做过程中可能由于电压不稳定等因素导致Program、Erase错误，标记的坏块也可能是好的。解决办法是，retry 一次，然后查看状态。</p>\n<p><code>坏块的特性</code></p>\n<p>Page Program与Block Erase操作失败，会反映到Status Register。</p>\n<p><code>避免坏块策略</code></p>\n<p><strong>Wear-Leveling(损益均衡)技术</strong><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Wear_Leveling.png\" alt=\"\"></p>\n<p><strong>Buffer Cache</strong><br>类似于UBIFS 都会带有buffer cache，以及压缩，以此来尽量降低对I/O的操作。</p>\n<p><code>应对坏块</code></p>\n<p>为了保证数据正确性的R/W，我们使用BBT（Bad Block Table）。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/BBT.png\" alt=\"\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.gigadevice.com/datasheet/gd5f1gq4xfxxh/\" target=\"_blank\" rel=\"noopener\">gd5f1gq4xfxxh_v1.2_20190510</a><br><a href=\"https://www.gigadevice.com/datasheet/gd25b127d/\" target=\"_blank\" rel=\"noopener\">gd25b127d_v1.4_20180725</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-Flash\"><a href=\"#1-Flash\" class=\"headerlink\" title=\"1. Flash\"></a>1. Flash</h2><p>闪存（Flash Memory）是非易失性长寿命存储器，是电子可擦除只读存储器（EEPROM）的变种，而闪存的大部分芯片需要块擦除。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MOS%E7%AE%A1.png\" alt=\"MOS管插图\"></p>","more":"<p>注：</p>\n<blockquote>\n<p>N型半导体即自由电子浓度远大于空穴浓度的杂质半导体。(对于锗、硅类半导体材料，掺杂Ⅴ族元素(磷、砷等)<br>P型半导体即空穴浓度远大于自由电子浓度的杂质半导体。在纯净的硅晶体中掺入三价元素（如硼）</p>\n</blockquote>\n<p>常见的Flash有:  </p>\n<ul>\n<li>NOR Flash</li>\n<li>NAND Flash</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:left\">NOR Flash</th>\n<th style=\"text-align:left\">NAND Flash</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">读速度</td>\n<td style=\"text-align:left\">快</td>\n<td style=\"text-align:left\">较快</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">单字节编程时间</td>\n<td style=\"text-align:left\">快</td>\n<td style=\"text-align:left\">慢</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">多字节编程时间</td>\n<td style=\"text-align:left\">慢</td>\n<td style=\"text-align:left\">快</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">寿命</td>\n<td style=\"text-align:left\">十万次</td>\n<td style=\"text-align:left\">百万次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">I/O 端口</td>\n<td style=\"text-align:left\">SRAM 接口，有足够地址引脚寻址</td>\n<td style=\"text-align:left\">8个复用PIN 脚传送控制、地址、数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">功耗</td>\n<td style=\"text-align:left\">高</td>\n<td style=\"text-align:left\">低，需要额外RAM</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">应用市场</td>\n<td style=\"text-align:left\">1~16MB</td>\n<td style=\"text-align:left\">大容量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">特点</td>\n<td style=\"text-align:left\">程序可在芯片内运行</td>\n<td style=\"text-align:left\">成本低，高存储密度，较快的写入和擦除速度</td>\n</tr>\n</tbody>\n</table>\n<p>两者更详细的比较可以通过Flash 厂商的datasheet 查看。</p>\n<p><code>Large Page Nand Flash</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Large_Page_Nand.png\" alt=\"Large Page Nand\"></p>\n<p>注：Spare Area 常常可以存储BBT(Bad Block Table), ECC, 逻辑映射表等信息。</p>\n<p>Nand Flash 硬件特性：</p>\n<ul>\n<li>R/W 最小单位，Page</li>\n<li>擦除最小单位，Block</li>\n<li>擦除的含义是将整块都擦除为0xFF</li>\n<li>写操作前，必须先擦除，然后再写</li>\n</ul>\n<h2 id=\"2-Linux-MTD\"><a href=\"#2-Linux-MTD\" class=\"headerlink\" title=\"2. Linux MTD\"></a>2. Linux MTD</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Linux_MTD_Structure.png\" alt=\"MTD Structure\"></p>\n<p>常见MTD 分区为：</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Common_Partitions.png\" alt=\"\"></p>\n<h2 id=\"3-Operation\"><a href=\"#3-Operation\" class=\"headerlink\" title=\"3. Operation\"></a>3. Operation</h2><p>Flash 常见的操作有Read, Erase, Write, WP(Write Protect)</p>\n<p><code>MTD Read Flow</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Read_Flow.png\" alt=\"MTD_Read_Flow\"></p>\n<p>使用多并口时， SPI 会用到WP#， HOLD# 等管脚。<br>Standard SPI: SCLK, CS#, SI, SO<br>Dual SPI: SCLK, CS#, IO0(SI), IO1(SO)<br>Quad SPI: SCLK, CS#, IO0(SI), IO1(SO), IO2(WP#), IO3(HOLD#)</p>\n<p>在SPI 接口上可能会有如下形式的Read：</p>\n<ul>\n<li>Page Read</li>\n<li>Page Read to cache</li>\n<li>page from cache</li>\n<li>fast read from cache</li>\n<li>read from cache X2</li>\n<li>read from cache X4</li>\n<li>read from cache dual IO</li>\n<li>read from cache quad IO</li>\n</ul>\n<p>SPI Nand Read 时序一般为：</p>\n<ol>\n<li>13H(page read to cache)</li>\n<li>0FH(get features coomand to read the status)</li>\n<li>03H/OBH (read from cache), 3BH/6BH(read from cache x2/x4), BBH/EBH(Read from cache dual/quad IO)</li>\n</ol>\n<p>spi_nand_read_from_cache<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache.png\" alt=\"spi_nand_read_from_cache\"></p>\n<p>spi_nand_read_to_cache<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_to_cache.png\" alt=\"spi_nand_read_to_cache\"></p>\n<p>spi_nand_read_from_cache_x4<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache_x4.png\" alt=\"spi_nand_read_from_cache_x4\"></p>\n<p>spi_nand_read_from_cache_quad_io<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/spi_nand_read_from_cache_quad_io.png\" alt=\"spi_nand_read_from_cache_quad_io\"><br><br></p>\n<p><code>MTD Write Flow</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/MTD_Write_Flow.png\" alt=\"MTD_Write_Flow\"></p>\n<p>在SPI Nand Flash 上的时序图流程一般为：</p>\n<ol>\n<li>02H (PROGRAM LOAD)/32H (PROGRAM LOAD x4)</li>\n<li>06H (WRITE ENABLE)</li>\n<li>10H (PROGRAM EXECUTE)</li>\n<li>0FH (GET FEATURE command to read the status)</li>\n</ol>\n<p>program load 是设定addr， 并将write data 加载到cache register（一般超过PAGE SIZE 如2K+oob 的数据会被ignore），打开WE#，在program execute 命令才执行。</p>\n<p><code>WP(Write Protect)</code><br>一般Flash 还具备block 相关指令。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">block</td>\n<td style=\"text-align:left\">对某一区域Flash 进行写保护，不能写入</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">un-block</td>\n<td style=\"text-align:left\">解除block 限制</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">block down</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">lock status</td>\n<td style=\"text-align:left\">查看状态</td>\n</tr>\n</tbody>\n</table>\n<p>可能每个Flash 芯片厂商有所不同, 例如Giga SPI Nand Flash block, 通过SET Features，来控制block<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/giga_spi_nand_block.png\" alt=\"giga_spi_nand_block\"></p>\n<p><code>Erase</code><br>Nand Flash 的erase 只能是Block(常见为64/128K) Erase。而Nor Flash 可以是Sector（一般4K） 或Block（32/64K） Erase。</p>\n<h2 id=\"4-Bad-Block\"><a href=\"#4-Bad-Block\" class=\"headerlink\" title=\"4. Bad Block\"></a>4. Bad Block</h2><p>Nand Flash 工艺不能保证Memory Cell在其生命周期中保持性能的可靠性，使用寿命一般100万次。</p>\n<p>坏块一般分为：</p>\n<ul>\n<li>固有坏块：生产中就有（芯片原厂将每个坏块第一个Page的spare area某个字节标记为非0xFF）</li>\n<li>使用坏块：存储寿命（program/erase 错误，将block标记为坏块）</li>\n</ul>\n<p>当然，也有伪坏块。芯片在才做过程中可能由于电压不稳定等因素导致Program、Erase错误，标记的坏块也可能是好的。解决办法是，retry 一次，然后查看状态。</p>\n<p><code>坏块的特性</code></p>\n<p>Page Program与Block Erase操作失败，会反映到Status Register。</p>\n<p><code>避免坏块策略</code></p>\n<p><strong>Wear-Leveling(损益均衡)技术</strong><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/Wear_Leveling.png\" alt=\"\"></p>\n<p><strong>Buffer Cache</strong><br>类似于UBIFS 都会带有buffer cache，以及压缩，以此来尽量降低对I/O的操作。</p>\n<p><code>应对坏块</code></p>\n<p>为了保证数据正确性的R/W，我们使用BBT（Bad Block Table）。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/Linux_Flash/BBT.png\" alt=\"\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.gigadevice.com/datasheet/gd5f1gq4xfxxh/\" target=\"_blank\" rel=\"noopener\">gd5f1gq4xfxxh_v1.2_20190510</a><br><a href=\"https://www.gigadevice.com/datasheet/gd25b127d/\" target=\"_blank\" rel=\"noopener\">gd25b127d_v1.4_20180725</a></p>"},{"title":"TED_Notes","date":"2018-06-13T15:21:49.000Z","_content":"\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=23f2f937dcb44aed4d43b6b6d275ec64/2fdda3cc7cd98d10a403f64c273fb80e7aec90fc.jpg)\n\n[TED](https://baike.baidu.com/item/TED/8095?fr=aladdin) 总是有些让你惊艳的话语。让我们去Keep it.\n\n[TED: Ideas worth spreading](https://www.ted.com/)\n\n[TED 网易公开课](https://open.163.com/ted/)\n\n<!--more-->\n\n## 1. 如何有效地学习\n\n[TED 视频：如何有效地学习](https://www.bilibili.com/video/av10821708)\n\n- 关闭其他影响注意力的事物，例如手机、电脑等\n- 初始时慢，建立正确的行为\n- 有针对性训练薄弱部分\n- 合理计划休息、训练\n\n## 2. 提高自信\n\n[TED 视频： 如何提升自信](https://www.bilibili.com/video/av10969854)\n\n- 重复、重复、重复（一万小时定律，陈平安练百万拳《剑来》）\n- 意识影响行为，自我积极暗示\n- 适时地称赞自己认为做的好的点\n- 远离拖自己后腿的人\n- 自信的人对别人的反馈有一套自己的理解（乐观应对事务）\n\n## 3. 提高记忆力\n\n[TED 视频：如何用记忆宫殿提高记忆力](https://www.bilibili.com/video/av18762228/?spm_id_from=333.788.videocard.1)\n\n- 赋予意义，将需要记忆的事物与有意义的东西联系起来\n- 每个人都有较强的视觉与空间能力\n- 越疯狂、古怪、奇葩的影像越容易记忆\n- 将影像放置与熟悉的空间中\n- 不在于细节，在于“主题句”（希娜词[topos](http://fanyi.baidu.com/?aldtype=85#en/zh/topos)）\n\n## 4. 克服拖延症\n\n[TED 视频：你有拖延症吗？](https://www.bilibili.com/video/av4190492?from=search&seid=16410944344139641233)\n\n每个人大脑中都有两个生物：\n1. 理性决策人\n2. 及时行乐的猴子（它活在当下，没有过去的记忆，也没有未来的概念。只关注于：简单和开心）\n\n![](https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/b0FcrsazQ2aAq51n9WwV_P-brain-1.jpg)\n\n有一个东西可以吓跑及时行乐的猴子，慌乱怪 -- Deadline。\n![](https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/CFiZzySeCV1Ono5MHsFQ_PM.jpg)\n\n![](https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/miGxfYeKRsq860qbKvbR_PM-Scare-3.jpg)\n\n`解决方法`：\n\n1. 人生一辈子的时间格子并不多，可能我们就过了1/3。\n![](https://upload-images.jianshu.io/upload_images/564259-0da4dc34d3474f4f?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n2. 有战胜拖延症的信心，不要让及时行乐的猴子习惯性的获胜\n\n3. 计划\n- 优先级\n- 目标清晰，反对模糊\n- 便于管理的小目标\n\n4. 行动\n![](https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/11/fmuafMrTh62aDFGZv940_dark-woods.jpg)\n\n关键点在于：**放下手里一切不重要的事情，屏蔽一切干扰，并且马上开始工作**，但这是最难的一部分，及时行乐的猴子反抗最激烈。\n\n>在执行任务的时候一旦有了进展，你的成就感和自尊心都会得到增强。猴子以低自尊为动力，如果你获得了成就感，那么猴子这之后就得到了一个香蕉作为奖励，就不那么难以控制了。\n\n>你需要向自己证明自己可以做到，而不是告诉自己明天自己大概可以完成任务。直到你向自己证明了这一点，你永远都不相信自己有能力做到更好，有能力改变自己。\n\n**中文版**：\n[人为什么会拖延 - Wait But Why](https://waitbutwhy.com/cn/%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%8B%96%E5%BB%B6)\n[如何打败拖延症 - Wait But Why](https://waitbutwhy.com/cn/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87)\n\n**英文版**：\n[Why Procrastinators Procrastinate - Wait But Why](https://waitbutwhy.com/2013/10/why-procrastinators-procrastinate.html)\n[How to Beat Procrastination - Wait But Why](https://waitbutwhy.com/2013/11/how-to-beat-procrastination.html)\n\n\n[你的人生其实只有900个格子](http://www.360doc.com/content/15/0331/21/5320383_459650672.shtml)\n\n[你是怎么变得自律的--知乎](https://www.zhihu.com/question/284206141)","source":"_posts/TED-Notes.md","raw":"---\ntitle: TED_Notes\ndate: 2018-06-13 23:21:49\ntags: TED\ncategories: life\n---\n\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=23f2f937dcb44aed4d43b6b6d275ec64/2fdda3cc7cd98d10a403f64c273fb80e7aec90fc.jpg)\n\n[TED](https://baike.baidu.com/item/TED/8095?fr=aladdin) 总是有些让你惊艳的话语。让我们去Keep it.\n\n[TED: Ideas worth spreading](https://www.ted.com/)\n\n[TED 网易公开课](https://open.163.com/ted/)\n\n<!--more-->\n\n## 1. 如何有效地学习\n\n[TED 视频：如何有效地学习](https://www.bilibili.com/video/av10821708)\n\n- 关闭其他影响注意力的事物，例如手机、电脑等\n- 初始时慢，建立正确的行为\n- 有针对性训练薄弱部分\n- 合理计划休息、训练\n\n## 2. 提高自信\n\n[TED 视频： 如何提升自信](https://www.bilibili.com/video/av10969854)\n\n- 重复、重复、重复（一万小时定律，陈平安练百万拳《剑来》）\n- 意识影响行为，自我积极暗示\n- 适时地称赞自己认为做的好的点\n- 远离拖自己后腿的人\n- 自信的人对别人的反馈有一套自己的理解（乐观应对事务）\n\n## 3. 提高记忆力\n\n[TED 视频：如何用记忆宫殿提高记忆力](https://www.bilibili.com/video/av18762228/?spm_id_from=333.788.videocard.1)\n\n- 赋予意义，将需要记忆的事物与有意义的东西联系起来\n- 每个人都有较强的视觉与空间能力\n- 越疯狂、古怪、奇葩的影像越容易记忆\n- 将影像放置与熟悉的空间中\n- 不在于细节，在于“主题句”（希娜词[topos](http://fanyi.baidu.com/?aldtype=85#en/zh/topos)）\n\n## 4. 克服拖延症\n\n[TED 视频：你有拖延症吗？](https://www.bilibili.com/video/av4190492?from=search&seid=16410944344139641233)\n\n每个人大脑中都有两个生物：\n1. 理性决策人\n2. 及时行乐的猴子（它活在当下，没有过去的记忆，也没有未来的概念。只关注于：简单和开心）\n\n![](https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/b0FcrsazQ2aAq51n9WwV_P-brain-1.jpg)\n\n有一个东西可以吓跑及时行乐的猴子，慌乱怪 -- Deadline。\n![](https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/CFiZzySeCV1Ono5MHsFQ_PM.jpg)\n\n![](https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/miGxfYeKRsq860qbKvbR_PM-Scare-3.jpg)\n\n`解决方法`：\n\n1. 人生一辈子的时间格子并不多，可能我们就过了1/3。\n![](https://upload-images.jianshu.io/upload_images/564259-0da4dc34d3474f4f?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n2. 有战胜拖延症的信心，不要让及时行乐的猴子习惯性的获胜\n\n3. 计划\n- 优先级\n- 目标清晰，反对模糊\n- 便于管理的小目标\n\n4. 行动\n![](https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/11/fmuafMrTh62aDFGZv940_dark-woods.jpg)\n\n关键点在于：**放下手里一切不重要的事情，屏蔽一切干扰，并且马上开始工作**，但这是最难的一部分，及时行乐的猴子反抗最激烈。\n\n>在执行任务的时候一旦有了进展，你的成就感和自尊心都会得到增强。猴子以低自尊为动力，如果你获得了成就感，那么猴子这之后就得到了一个香蕉作为奖励，就不那么难以控制了。\n\n>你需要向自己证明自己可以做到，而不是告诉自己明天自己大概可以完成任务。直到你向自己证明了这一点，你永远都不相信自己有能力做到更好，有能力改变自己。\n\n**中文版**：\n[人为什么会拖延 - Wait But Why](https://waitbutwhy.com/cn/%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%8B%96%E5%BB%B6)\n[如何打败拖延症 - Wait But Why](https://waitbutwhy.com/cn/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87)\n\n**英文版**：\n[Why Procrastinators Procrastinate - Wait But Why](https://waitbutwhy.com/2013/10/why-procrastinators-procrastinate.html)\n[How to Beat Procrastination - Wait But Why](https://waitbutwhy.com/2013/11/how-to-beat-procrastination.html)\n\n\n[你的人生其实只有900个格子](http://www.360doc.com/content/15/0331/21/5320383_459650672.shtml)\n\n[你是怎么变得自律的--知乎](https://www.zhihu.com/question/284206141)","slug":"TED-Notes","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pa000pzkgrvfz43gtn","content":"<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=23f2f937dcb44aed4d43b6b6d275ec64/2fdda3cc7cd98d10a403f64c273fb80e7aec90fc.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/TED/8095?fr=aladdin\" target=\"_blank\" rel=\"noopener\">TED</a> 总是有些让你惊艳的话语。让我们去Keep it.</p>\n<p><a href=\"https://www.ted.com/\" target=\"_blank\" rel=\"noopener\">TED: Ideas worth spreading</a></p>\n<p><a href=\"https://open.163.com/ted/\" target=\"_blank\" rel=\"noopener\">TED 网易公开课</a></p>\n<a id=\"more\"></a>\n<h2 id=\"1-如何有效地学习\"><a href=\"#1-如何有效地学习\" class=\"headerlink\" title=\"1. 如何有效地学习\"></a>1. 如何有效地学习</h2><p><a href=\"https://www.bilibili.com/video/av10821708\" target=\"_blank\" rel=\"noopener\">TED 视频：如何有效地学习</a></p>\n<ul>\n<li>关闭其他影响注意力的事物，例如手机、电脑等</li>\n<li>初始时慢，建立正确的行为</li>\n<li>有针对性训练薄弱部分</li>\n<li>合理计划休息、训练</li>\n</ul>\n<h2 id=\"2-提高自信\"><a href=\"#2-提高自信\" class=\"headerlink\" title=\"2. 提高自信\"></a>2. 提高自信</h2><p><a href=\"https://www.bilibili.com/video/av10969854\" target=\"_blank\" rel=\"noopener\">TED 视频： 如何提升自信</a></p>\n<ul>\n<li>重复、重复、重复（一万小时定律，陈平安练百万拳《剑来》）</li>\n<li>意识影响行为，自我积极暗示</li>\n<li>适时地称赞自己认为做的好的点</li>\n<li>远离拖自己后腿的人</li>\n<li>自信的人对别人的反馈有一套自己的理解（乐观应对事务）</li>\n</ul>\n<h2 id=\"3-提高记忆力\"><a href=\"#3-提高记忆力\" class=\"headerlink\" title=\"3. 提高记忆力\"></a>3. 提高记忆力</h2><p><a href=\"https://www.bilibili.com/video/av18762228/?spm_id_from=333.788.videocard.1\" target=\"_blank\" rel=\"noopener\">TED 视频：如何用记忆宫殿提高记忆力</a></p>\n<ul>\n<li>赋予意义，将需要记忆的事物与有意义的东西联系起来</li>\n<li>每个人都有较强的视觉与空间能力</li>\n<li>越疯狂、古怪、奇葩的影像越容易记忆</li>\n<li>将影像放置与熟悉的空间中</li>\n<li>不在于细节，在于“主题句”（希娜词<a href=\"http://fanyi.baidu.com/?aldtype=85#en/zh/topos\" target=\"_blank\" rel=\"noopener\">topos</a>）</li>\n</ul>\n<h2 id=\"4-克服拖延症\"><a href=\"#4-克服拖延症\" class=\"headerlink\" title=\"4. 克服拖延症\"></a>4. 克服拖延症</h2><p><a href=\"https://www.bilibili.com/video/av4190492?from=search&amp;seid=16410944344139641233\" target=\"_blank\" rel=\"noopener\">TED 视频：你有拖延症吗？</a></p>\n<p>每个人大脑中都有两个生物：</p>\n<ol>\n<li>理性决策人</li>\n<li>及时行乐的猴子（它活在当下，没有过去的记忆，也没有未来的概念。只关注于：简单和开心）</li>\n</ol>\n<p><img src=\"https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/b0FcrsazQ2aAq51n9WwV_P-brain-1.jpg\" alt=\"\"></p>\n<p>有一个东西可以吓跑及时行乐的猴子，慌乱怪 – Deadline。<br><img src=\"https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/CFiZzySeCV1Ono5MHsFQ_PM.jpg\" alt=\"\"></p>\n<p><img src=\"https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/miGxfYeKRsq860qbKvbR_PM-Scare-3.jpg\" alt=\"\"></p>\n<p><code>解决方法</code>：</p>\n<ol>\n<li><p>人生一辈子的时间格子并不多，可能我们就过了1/3。<br><img src=\"https://upload-images.jianshu.io/upload_images/564259-0da4dc34d3474f4f?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"\"></p>\n</li>\n<li><p>有战胜拖延症的信心，不要让及时行乐的猴子习惯性的获胜</p>\n</li>\n<li><p>计划</p>\n</li>\n</ol>\n<ul>\n<li>优先级</li>\n<li>目标清晰，反对模糊</li>\n<li>便于管理的小目标</li>\n</ul>\n<ol start=\"4\">\n<li>行动<br><img src=\"https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/11/fmuafMrTh62aDFGZv940_dark-woods.jpg\" alt=\"\"></li>\n</ol>\n<p>关键点在于：<strong>放下手里一切不重要的事情，屏蔽一切干扰，并且马上开始工作</strong>，但这是最难的一部分，及时行乐的猴子反抗最激烈。</p>\n<blockquote>\n<p>在执行任务的时候一旦有了进展，你的成就感和自尊心都会得到增强。猴子以低自尊为动力，如果你获得了成就感，那么猴子这之后就得到了一个香蕉作为奖励，就不那么难以控制了。</p>\n</blockquote>\n<blockquote>\n<p>你需要向自己证明自己可以做到，而不是告诉自己明天自己大概可以完成任务。直到你向自己证明了这一点，你永远都不相信自己有能力做到更好，有能力改变自己。</p>\n</blockquote>\n<p><strong>中文版</strong>：<br><a href=\"https://waitbutwhy.com/cn/%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%8B%96%E5%BB%B6\" target=\"_blank\" rel=\"noopener\">人为什么会拖延 - Wait But Why</a><br><a href=\"https://waitbutwhy.com/cn/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87\" target=\"_blank\" rel=\"noopener\">如何打败拖延症 - Wait But Why</a></p>\n<p><strong>英文版</strong>：<br><a href=\"https://waitbutwhy.com/2013/10/why-procrastinators-procrastinate.html\" target=\"_blank\" rel=\"noopener\">Why Procrastinators Procrastinate - Wait But Why</a><br><a href=\"https://waitbutwhy.com/2013/11/how-to-beat-procrastination.html\" target=\"_blank\" rel=\"noopener\">How to Beat Procrastination - Wait But Why</a></p>\n<p><a href=\"http://www.360doc.com/content/15/0331/21/5320383_459650672.shtml\" target=\"_blank\" rel=\"noopener\">你的人生其实只有900个格子</a></p>\n<p><a href=\"https://www.zhihu.com/question/284206141\" target=\"_blank\" rel=\"noopener\">你是怎么变得自律的–知乎</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=23f2f937dcb44aed4d43b6b6d275ec64/2fdda3cc7cd98d10a403f64c273fb80e7aec90fc.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/TED/8095?fr=aladdin\" target=\"_blank\" rel=\"noopener\">TED</a> 总是有些让你惊艳的话语。让我们去Keep it.</p>\n<p><a href=\"https://www.ted.com/\" target=\"_blank\" rel=\"noopener\">TED: Ideas worth spreading</a></p>\n<p><a href=\"https://open.163.com/ted/\" target=\"_blank\" rel=\"noopener\">TED 网易公开课</a></p>","more":"<h2 id=\"1-如何有效地学习\"><a href=\"#1-如何有效地学习\" class=\"headerlink\" title=\"1. 如何有效地学习\"></a>1. 如何有效地学习</h2><p><a href=\"https://www.bilibili.com/video/av10821708\" target=\"_blank\" rel=\"noopener\">TED 视频：如何有效地学习</a></p>\n<ul>\n<li>关闭其他影响注意力的事物，例如手机、电脑等</li>\n<li>初始时慢，建立正确的行为</li>\n<li>有针对性训练薄弱部分</li>\n<li>合理计划休息、训练</li>\n</ul>\n<h2 id=\"2-提高自信\"><a href=\"#2-提高自信\" class=\"headerlink\" title=\"2. 提高自信\"></a>2. 提高自信</h2><p><a href=\"https://www.bilibili.com/video/av10969854\" target=\"_blank\" rel=\"noopener\">TED 视频： 如何提升自信</a></p>\n<ul>\n<li>重复、重复、重复（一万小时定律，陈平安练百万拳《剑来》）</li>\n<li>意识影响行为，自我积极暗示</li>\n<li>适时地称赞自己认为做的好的点</li>\n<li>远离拖自己后腿的人</li>\n<li>自信的人对别人的反馈有一套自己的理解（乐观应对事务）</li>\n</ul>\n<h2 id=\"3-提高记忆力\"><a href=\"#3-提高记忆力\" class=\"headerlink\" title=\"3. 提高记忆力\"></a>3. 提高记忆力</h2><p><a href=\"https://www.bilibili.com/video/av18762228/?spm_id_from=333.788.videocard.1\" target=\"_blank\" rel=\"noopener\">TED 视频：如何用记忆宫殿提高记忆力</a></p>\n<ul>\n<li>赋予意义，将需要记忆的事物与有意义的东西联系起来</li>\n<li>每个人都有较强的视觉与空间能力</li>\n<li>越疯狂、古怪、奇葩的影像越容易记忆</li>\n<li>将影像放置与熟悉的空间中</li>\n<li>不在于细节，在于“主题句”（希娜词<a href=\"http://fanyi.baidu.com/?aldtype=85#en/zh/topos\" target=\"_blank\" rel=\"noopener\">topos</a>）</li>\n</ul>\n<h2 id=\"4-克服拖延症\"><a href=\"#4-克服拖延症\" class=\"headerlink\" title=\"4. 克服拖延症\"></a>4. 克服拖延症</h2><p><a href=\"https://www.bilibili.com/video/av4190492?from=search&amp;seid=16410944344139641233\" target=\"_blank\" rel=\"noopener\">TED 视频：你有拖延症吗？</a></p>\n<p>每个人大脑中都有两个生物：</p>\n<ol>\n<li>理性决策人</li>\n<li>及时行乐的猴子（它活在当下，没有过去的记忆，也没有未来的概念。只关注于：简单和开心）</li>\n</ol>\n<p><img src=\"https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/b0FcrsazQ2aAq51n9WwV_P-brain-1.jpg\" alt=\"\"></p>\n<p>有一个东西可以吓跑及时行乐的猴子，慌乱怪 – Deadline。<br><img src=\"https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/CFiZzySeCV1Ono5MHsFQ_PM.jpg\" alt=\"\"></p>\n<p><img src=\"https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/10/miGxfYeKRsq860qbKvbR_PM-Scare-3.jpg\" alt=\"\"></p>\n<p><code>解决方法</code>：</p>\n<ol>\n<li><p>人生一辈子的时间格子并不多，可能我们就过了1/3。<br><img src=\"https://upload-images.jianshu.io/upload_images/564259-0da4dc34d3474f4f?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"\"></p>\n</li>\n<li><p>有战胜拖延症的信心，不要让及时行乐的猴子习惯性的获胜</p>\n</li>\n<li><p>计划</p>\n</li>\n</ol>\n<ul>\n<li>优先级</li>\n<li>目标清晰，反对模糊</li>\n<li>便于管理的小目标</li>\n</ul>\n<ol start=\"4\">\n<li>行动<br><img src=\"https://28oa9i1t08037ue3m1l0i861-wpengine.netdna-ssl.com/wp-content/uploads/2013/11/fmuafMrTh62aDFGZv940_dark-woods.jpg\" alt=\"\"></li>\n</ol>\n<p>关键点在于：<strong>放下手里一切不重要的事情，屏蔽一切干扰，并且马上开始工作</strong>，但这是最难的一部分，及时行乐的猴子反抗最激烈。</p>\n<blockquote>\n<p>在执行任务的时候一旦有了进展，你的成就感和自尊心都会得到增强。猴子以低自尊为动力，如果你获得了成就感，那么猴子这之后就得到了一个香蕉作为奖励，就不那么难以控制了。</p>\n</blockquote>\n<blockquote>\n<p>你需要向自己证明自己可以做到，而不是告诉自己明天自己大概可以完成任务。直到你向自己证明了这一点，你永远都不相信自己有能力做到更好，有能力改变自己。</p>\n</blockquote>\n<p><strong>中文版</strong>：<br><a href=\"https://waitbutwhy.com/cn/%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%8B%96%E5%BB%B6\" target=\"_blank\" rel=\"noopener\">人为什么会拖延 - Wait But Why</a><br><a href=\"https://waitbutwhy.com/cn/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87\" target=\"_blank\" rel=\"noopener\">如何打败拖延症 - Wait But Why</a></p>\n<p><strong>英文版</strong>：<br><a href=\"https://waitbutwhy.com/2013/10/why-procrastinators-procrastinate.html\" target=\"_blank\" rel=\"noopener\">Why Procrastinators Procrastinate - Wait But Why</a><br><a href=\"https://waitbutwhy.com/2013/11/how-to-beat-procrastination.html\" target=\"_blank\" rel=\"noopener\">How to Beat Procrastination - Wait But Why</a></p>\n<p><a href=\"http://www.360doc.com/content/15/0331/21/5320383_459650672.shtml\" target=\"_blank\" rel=\"noopener\">你的人生其实只有900个格子</a></p>\n<p><a href=\"https://www.zhihu.com/question/284206141\" target=\"_blank\" rel=\"noopener\">你是怎么变得自律的–知乎</a></p>"},{"title":"WebRTC 如何避免拥塞？","date":"2018-06-03T11:59:25.000Z","_content":"\n## WebRTC 如何避免拥塞？\n\n### 1. WebRTC 网络传输背景\n\n#### 1.1. WebRTC && 多数直播\n\n**大多数视频直播平台**\n\n| 子项   | 说明                                                                      |\n|:---- |:----------------------------------------------------------------------- |\n| 传输协议 | RTMP（Real Time MEssaging Protocol)                                      |\n| 优点   | 使用RTMP， 其基于TCP传输，跟flash等流媒体服务支持比较好，同时CDN支持良好                            |\n| 缺点   | 直播音视频数据量大，实时性要求比较高，TCP的重传机制和拥塞机制不适用于实时传输。传输控制依赖于TCP本身协议控制机制，网络成本较大不够灵活。 |\n\n音视频对网络丢包有一定程度天然容忍性（常见优酷，爱奇艺都有缓冲）。使用UDP传输是不错到选择。\n\n<!--more-->\n\n**webRTC**\n\n| 子项   | 说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n|:---- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| 传输协议 | RTP: 针对流媒体传输的基础协议，定义Internet上传输音视频数据包。 <br> RTCP：负责流媒体到传输质量保证，提供流量控制和拥塞控制等机制。![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=57e79b5fb0de9c82b268f1dd0de8eb6f/4bed2e738bd4b31c42beebdd84d6277f9f2ff8d2.jpg)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| 优点   | 包括ICE、STUN、TURN等信令交互、网络大洞（P2P)，主流浏览器支持（chrome, firefox,opera, safari,edge等）<br> ![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=54395c9081d4b31cf03c93bdbfed4042/2cf5e0fe9925bc3142b4464b54df8db1ca137073.jpg) ![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=bb31c6af3812b31bc36cca2bb61a3674/54fbb2fb43166d2287f64f7c472309f79152d251.jpg)![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=1db5f93247c2d562f208d7ebdf2af7d2/f9198618367adab4ee604c1183d4b31c8701e434.jpg)![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=5838ca994410b912bfc1f1f8fbc69b3e/500fd9f9d72a6059b0046c382b34349b033bbaf8.jpg)![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=37f66727093387449cc5287a6934bec4/d53f8794a4c27d1e13c902b31ed5ad6edcc438dd.jpg) |\n\n### 2. WebRTC 处理\n\n#### 2.1. NACK\n\nNACK( negative acknowledge character)， 就是否定应答。与之对应的是TCP中的ACK( acknowledge character)。\n\n> 在TCP中，接收端对于收到的包都要进行应答即发送ACK包，发送端通过接受ACK包，来确定发送的包已经被成功接收，以此来保证网络包的传输可靠。\n\nRTP协议不保证传输的可靠性，所以接收端也就不会发送ACK包。如果这个包比较重要，可以给对端发送NACK包，来告诉这个包我没有收到，你如果‘还有’的话，就给我重新发送一遍（Retransmission）。\n\n前面说到的丢包，都加了引号，这个“丢包”，有可能是真的丢了，也有可能是顺序乱了。我们知道网络包的到达，有时候不是一定严格按照包序到达的，我收到了很多较新的包了，某个旧的包还没有收到，我就认为它丢了，也没准儿一会儿它又到了。怎么判断“丢包”呢？ 我们通过：\n\n1. **乱序的偏移来决定发起重传**\n\n2. **根据预计到达时间已经超过一定时间了来发起重传 (一般是等待一个rtt＋jitter的时长)。**\n\n更多丢包判断参见如下连接：[WebRTC中丢包重传NACK实现分析](https://www.jianshu.com/p/a7f6ec0c9273)\n\n#### 2.2. 前向纠错编码( FEC )\n\nFEC（Forward Error Correction，前向纠错码），通过增加冗余来增强容错性到一种方法。如果没有FEC，接受端发现丢包时，需要通过发送NACK 来发起重传，但重传会影响延时性。\n\n- FEC则是在发送端增加冗余数据，接受端在数据丢失到情况下可以重建丢失的数据。\n\n- 增加FEC冗余数据占据了有效带宽\n\n上面两点涉及到取舍，冗余的数据与减少丢包导致的延时。不过，FEC到冗余度是可以根据网络状况动态调整。\n\n#### 2.3. 抖动缓冲( Jitterbuffer )\n\n网络传输中总是存在着抖动，导致网络包不是均匀顺序到达，WebRTC利用一个缓冲区，进行等待与排序，这就是jitterbuffer。他能动态根据网络情况调整缓冲区的大小。\n\n主流的实时音视频框架基本都会实现jitterbuffer功能，诸如WebRTC、doubango等。WebRTC的jitterbuffer按照功能分类的话，可以分为jitter和buffer。\n\n`jitterbuffer = jitter + buffer`\n\n\n\n`buffer`\n\nbuffer主要对**丢包、乱序、延时到达等异常**情况进行处理，还会和NACK、FEC（前向纠错码）、FIR(关键帧请求))等QOS（质量服务）相互配合。\n\n![](http://www.ucpaas.com/u/allimg/1706/8-1F602094T0135.jpg)\n\nbuffer 主要分为如下几种type：\n\n- freeframes\n\n- incompleteframes\n\n- decodableframes\n\n| type             | remark                                                                                                                                                                                                                                                                         |\n| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| freeframes       | 新到的数据包会根据时间戳在incompleteframes 和decodableframes 中寻找，相同放置到相应队列，否则从freeframes弹出空frame                                                                                                                                                                                             |\n| incompleteframes | 至少有一个数据包，帧数据不完整                                                                                                                                                                                                                                                                |\n| decodableframes  | 可解码，此队列中有decodable和complete 状态。complete 状态帧可被解码线程取出解码，完成后将buffer 重新push 到freeframes 队列。<br><br> decodable会根据decode\\_error\\_mode 有不同的规则，QOS的不同策略会设置不同的decode\\_error\\_mode ，包含kNoErrors、kSelectiveErrors以及kWithErrors。decode\\_error\\_mode 就决定了解码线程从buffer中取出来的帧是否包含错误，即当前帧是否有丢包。 |\n\njitterbuffer与QOS策略联系紧密，比如，incompleteframes和decodable队列清除一些frame之后，需要FIR（关键帧请求），根据包序号检测到丢包之后要NACK（丢包重传）等。\n\n\n\n`jitter`\n\n网络延迟带来的抖动会让音视频的播放不平稳，如音频的颤音，视频的忽快忽慢。那么如何对抗jitter呢？增加延时。\n\njitter主要根据当前帧的大小和延时评估出**jitterdelay**，再结合**decode delay、render delay以及音视频同步延时，得到render time**，来控制**平稳的渲染视频帧**。\n\n![](http://www.ucpaas.com/u/allimg/1706/8-1F602094Z4a1.jpg)\n\n其中:\n\n- freeDelayMS: 两笔RTP1, RTP2 之间时间差\n\n- frameSizeBytes: 当前帧数据大小\n\n- incompleteFrame: 是否微完整帧\n\n- UpdateEstimate: 用卡尔曼滤波对帧间延迟进行滤波（具体算法这里不进行讨论）\n\n在得到jitterdelay之后，通过jitterdelay+ decodedelay +renderdelay，再确保大于音视频同步的延时，加上当前系统时间得到rendertime，这样就可以控制播放时间。控制播放，也就间接控制了buffer的大小。\n\n当然，仅仅通过动态的jitterbuffer 是无法完全解决网络拥塞的问题，根本上还是应该调整发送的码率。\n\n#### 2.4. 带宽自适应\n\n带宽自适应是指在音视频的收发过程中，根据网络带宽的变化，自动的来调整发送码率，来适应带宽的变化。在带宽足够的情况下，增加帧率和码率，提高音视频的质量，带来更好的通信体验。在带宽不足的情况下，主动降低码率或者帧率，保证通信的流畅性和可用性，也是带来更好的通信体验。\n\n带宽自适应的核心：**如何准确的估计带宽**。WebRTC在实现带宽自适应时采用了Google提出一个称为REMB（Receiver Estimated Max Bitrate，最大接收带宽估计）的带宽估计算法。\n\n大致算法是：\n\n- 接受端维护状态机（根据丢包率或延时情况）\n\n- 根据丢包率或延时情况修改remb 值\n\n- 将remb 值通过RTCP 发送给发送端\n\n- 发送端根据remb 值调整码率\n\n补充：[码流 / 码率 / 比特率 / 帧速率 / 分辨率 / 高清的区别](https://blog.csdn.net/xiangjai/article/details/44238005)\n\n### 参考资源:\n\n[webrtc 中到网络反馈于控制](https://blog.csdn.net/mantis_1984/article/details/53572822)\n\n[WebRTC视频JitterBuff](https://blog.csdn.net/u012635648/article/details/72953237)\n","source":"_posts/WebRTC 如何避免拥塞.md","raw":"---\ntitle: WebRTC 如何避免拥塞？\ndate: 2018-06-03 19:59:25\ntags: WebRTC\ncategories: WebRTC\n---\n\n## WebRTC 如何避免拥塞？\n\n### 1. WebRTC 网络传输背景\n\n#### 1.1. WebRTC && 多数直播\n\n**大多数视频直播平台**\n\n| 子项   | 说明                                                                      |\n|:---- |:----------------------------------------------------------------------- |\n| 传输协议 | RTMP（Real Time MEssaging Protocol)                                      |\n| 优点   | 使用RTMP， 其基于TCP传输，跟flash等流媒体服务支持比较好，同时CDN支持良好                            |\n| 缺点   | 直播音视频数据量大，实时性要求比较高，TCP的重传机制和拥塞机制不适用于实时传输。传输控制依赖于TCP本身协议控制机制，网络成本较大不够灵活。 |\n\n音视频对网络丢包有一定程度天然容忍性（常见优酷，爱奇艺都有缓冲）。使用UDP传输是不错到选择。\n\n<!--more-->\n\n**webRTC**\n\n| 子项   | 说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n|:---- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| 传输协议 | RTP: 针对流媒体传输的基础协议，定义Internet上传输音视频数据包。 <br> RTCP：负责流媒体到传输质量保证，提供流量控制和拥塞控制等机制。![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=57e79b5fb0de9c82b268f1dd0de8eb6f/4bed2e738bd4b31c42beebdd84d6277f9f2ff8d2.jpg)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| 优点   | 包括ICE、STUN、TURN等信令交互、网络大洞（P2P)，主流浏览器支持（chrome, firefox,opera, safari,edge等）<br> ![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=54395c9081d4b31cf03c93bdbfed4042/2cf5e0fe9925bc3142b4464b54df8db1ca137073.jpg) ![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=bb31c6af3812b31bc36cca2bb61a3674/54fbb2fb43166d2287f64f7c472309f79152d251.jpg)![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=1db5f93247c2d562f208d7ebdf2af7d2/f9198618367adab4ee604c1183d4b31c8701e434.jpg)![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=5838ca994410b912bfc1f1f8fbc69b3e/500fd9f9d72a6059b0046c382b34349b033bbaf8.jpg)![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=37f66727093387449cc5287a6934bec4/d53f8794a4c27d1e13c902b31ed5ad6edcc438dd.jpg) |\n\n### 2. WebRTC 处理\n\n#### 2.1. NACK\n\nNACK( negative acknowledge character)， 就是否定应答。与之对应的是TCP中的ACK( acknowledge character)。\n\n> 在TCP中，接收端对于收到的包都要进行应答即发送ACK包，发送端通过接受ACK包，来确定发送的包已经被成功接收，以此来保证网络包的传输可靠。\n\nRTP协议不保证传输的可靠性，所以接收端也就不会发送ACK包。如果这个包比较重要，可以给对端发送NACK包，来告诉这个包我没有收到，你如果‘还有’的话，就给我重新发送一遍（Retransmission）。\n\n前面说到的丢包，都加了引号，这个“丢包”，有可能是真的丢了，也有可能是顺序乱了。我们知道网络包的到达，有时候不是一定严格按照包序到达的，我收到了很多较新的包了，某个旧的包还没有收到，我就认为它丢了，也没准儿一会儿它又到了。怎么判断“丢包”呢？ 我们通过：\n\n1. **乱序的偏移来决定发起重传**\n\n2. **根据预计到达时间已经超过一定时间了来发起重传 (一般是等待一个rtt＋jitter的时长)。**\n\n更多丢包判断参见如下连接：[WebRTC中丢包重传NACK实现分析](https://www.jianshu.com/p/a7f6ec0c9273)\n\n#### 2.2. 前向纠错编码( FEC )\n\nFEC（Forward Error Correction，前向纠错码），通过增加冗余来增强容错性到一种方法。如果没有FEC，接受端发现丢包时，需要通过发送NACK 来发起重传，但重传会影响延时性。\n\n- FEC则是在发送端增加冗余数据，接受端在数据丢失到情况下可以重建丢失的数据。\n\n- 增加FEC冗余数据占据了有效带宽\n\n上面两点涉及到取舍，冗余的数据与减少丢包导致的延时。不过，FEC到冗余度是可以根据网络状况动态调整。\n\n#### 2.3. 抖动缓冲( Jitterbuffer )\n\n网络传输中总是存在着抖动，导致网络包不是均匀顺序到达，WebRTC利用一个缓冲区，进行等待与排序，这就是jitterbuffer。他能动态根据网络情况调整缓冲区的大小。\n\n主流的实时音视频框架基本都会实现jitterbuffer功能，诸如WebRTC、doubango等。WebRTC的jitterbuffer按照功能分类的话，可以分为jitter和buffer。\n\n`jitterbuffer = jitter + buffer`\n\n\n\n`buffer`\n\nbuffer主要对**丢包、乱序、延时到达等异常**情况进行处理，还会和NACK、FEC（前向纠错码）、FIR(关键帧请求))等QOS（质量服务）相互配合。\n\n![](http://www.ucpaas.com/u/allimg/1706/8-1F602094T0135.jpg)\n\nbuffer 主要分为如下几种type：\n\n- freeframes\n\n- incompleteframes\n\n- decodableframes\n\n| type             | remark                                                                                                                                                                                                                                                                         |\n| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| freeframes       | 新到的数据包会根据时间戳在incompleteframes 和decodableframes 中寻找，相同放置到相应队列，否则从freeframes弹出空frame                                                                                                                                                                                             |\n| incompleteframes | 至少有一个数据包，帧数据不完整                                                                                                                                                                                                                                                                |\n| decodableframes  | 可解码，此队列中有decodable和complete 状态。complete 状态帧可被解码线程取出解码，完成后将buffer 重新push 到freeframes 队列。<br><br> decodable会根据decode\\_error\\_mode 有不同的规则，QOS的不同策略会设置不同的decode\\_error\\_mode ，包含kNoErrors、kSelectiveErrors以及kWithErrors。decode\\_error\\_mode 就决定了解码线程从buffer中取出来的帧是否包含错误，即当前帧是否有丢包。 |\n\njitterbuffer与QOS策略联系紧密，比如，incompleteframes和decodable队列清除一些frame之后，需要FIR（关键帧请求），根据包序号检测到丢包之后要NACK（丢包重传）等。\n\n\n\n`jitter`\n\n网络延迟带来的抖动会让音视频的播放不平稳，如音频的颤音，视频的忽快忽慢。那么如何对抗jitter呢？增加延时。\n\njitter主要根据当前帧的大小和延时评估出**jitterdelay**，再结合**decode delay、render delay以及音视频同步延时，得到render time**，来控制**平稳的渲染视频帧**。\n\n![](http://www.ucpaas.com/u/allimg/1706/8-1F602094Z4a1.jpg)\n\n其中:\n\n- freeDelayMS: 两笔RTP1, RTP2 之间时间差\n\n- frameSizeBytes: 当前帧数据大小\n\n- incompleteFrame: 是否微完整帧\n\n- UpdateEstimate: 用卡尔曼滤波对帧间延迟进行滤波（具体算法这里不进行讨论）\n\n在得到jitterdelay之后，通过jitterdelay+ decodedelay +renderdelay，再确保大于音视频同步的延时，加上当前系统时间得到rendertime，这样就可以控制播放时间。控制播放，也就间接控制了buffer的大小。\n\n当然，仅仅通过动态的jitterbuffer 是无法完全解决网络拥塞的问题，根本上还是应该调整发送的码率。\n\n#### 2.4. 带宽自适应\n\n带宽自适应是指在音视频的收发过程中，根据网络带宽的变化，自动的来调整发送码率，来适应带宽的变化。在带宽足够的情况下，增加帧率和码率，提高音视频的质量，带来更好的通信体验。在带宽不足的情况下，主动降低码率或者帧率，保证通信的流畅性和可用性，也是带来更好的通信体验。\n\n带宽自适应的核心：**如何准确的估计带宽**。WebRTC在实现带宽自适应时采用了Google提出一个称为REMB（Receiver Estimated Max Bitrate，最大接收带宽估计）的带宽估计算法。\n\n大致算法是：\n\n- 接受端维护状态机（根据丢包率或延时情况）\n\n- 根据丢包率或延时情况修改remb 值\n\n- 将remb 值通过RTCP 发送给发送端\n\n- 发送端根据remb 值调整码率\n\n补充：[码流 / 码率 / 比特率 / 帧速率 / 分辨率 / 高清的区别](https://blog.csdn.net/xiangjai/article/details/44238005)\n\n### 参考资源:\n\n[webrtc 中到网络反馈于控制](https://blog.csdn.net/mantis_1984/article/details/53572822)\n\n[WebRTC视频JitterBuff](https://blog.csdn.net/u012635648/article/details/72953237)\n","slug":"WebRTC 如何避免拥塞","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pc000tzkgrzwroo02y","content":"<h2 id=\"WebRTC-如何避免拥塞？\"><a href=\"#WebRTC-如何避免拥塞？\" class=\"headerlink\" title=\"WebRTC 如何避免拥塞？\"></a>WebRTC 如何避免拥塞？</h2><h3 id=\"1-WebRTC-网络传输背景\"><a href=\"#1-WebRTC-网络传输背景\" class=\"headerlink\" title=\"1. WebRTC 网络传输背景\"></a>1. WebRTC 网络传输背景</h3><h4 id=\"1-1-WebRTC-amp-amp-多数直播\"><a href=\"#1-1-WebRTC-amp-amp-多数直播\" class=\"headerlink\" title=\"1.1. WebRTC &amp;&amp; 多数直播\"></a>1.1. WebRTC &amp;&amp; 多数直播</h4><p><strong>大多数视频直播平台</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">传输协议</td>\n<td style=\"text-align:left\">RTMP（Real Time MEssaging Protocol)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">优点</td>\n<td style=\"text-align:left\">使用RTMP， 其基于TCP传输，跟flash等流媒体服务支持比较好，同时CDN支持良好</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">缺点</td>\n<td style=\"text-align:left\">直播音视频数据量大，实时性要求比较高，TCP的重传机制和拥塞机制不适用于实时传输。传输控制依赖于TCP本身协议控制机制，网络成本较大不够灵活。</td>\n</tr>\n</tbody>\n</table>\n<p>音视频对网络丢包有一定程度天然容忍性（常见优酷，爱奇艺都有缓冲）。使用UDP传输是不错到选择。</p>\n<a id=\"more\"></a>\n<p><strong>webRTC</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">传输协议</td>\n<td style=\"text-align:left\">RTP: 针对流媒体传输的基础协议，定义Internet上传输音视频数据包。 <br> RTCP：负责流媒体到传输质量保证，提供流量控制和拥塞控制等机制。<img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=57e79b5fb0de9c82b268f1dd0de8eb6f/4bed2e738bd4b31c42beebdd84d6277f9f2ff8d2.jpg\" alt=\"\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">优点</td>\n<td style=\"text-align:left\">包括ICE、STUN、TURN等信令交互、网络大洞（P2P)，主流浏览器支持（chrome, firefox,opera, safari,edge等）<br> <img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=54395c9081d4b31cf03c93bdbfed4042/2cf5e0fe9925bc3142b4464b54df8db1ca137073.jpg\" alt=\"\"> <img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=bb31c6af3812b31bc36cca2bb61a3674/54fbb2fb43166d2287f64f7c472309f79152d251.jpg\" alt=\"\"><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=1db5f93247c2d562f208d7ebdf2af7d2/f9198618367adab4ee604c1183d4b31c8701e434.jpg\" alt=\"\"><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=5838ca994410b912bfc1f1f8fbc69b3e/500fd9f9d72a6059b0046c382b34349b033bbaf8.jpg\" alt=\"\"><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=37f66727093387449cc5287a6934bec4/d53f8794a4c27d1e13c902b31ed5ad6edcc438dd.jpg\" alt=\"\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-WebRTC-处理\"><a href=\"#2-WebRTC-处理\" class=\"headerlink\" title=\"2. WebRTC 处理\"></a>2. WebRTC 处理</h3><h4 id=\"2-1-NACK\"><a href=\"#2-1-NACK\" class=\"headerlink\" title=\"2.1. NACK\"></a>2.1. NACK</h4><p>NACK( negative acknowledge character)， 就是否定应答。与之对应的是TCP中的ACK( acknowledge character)。</p>\n<blockquote>\n<p>在TCP中，接收端对于收到的包都要进行应答即发送ACK包，发送端通过接受ACK包，来确定发送的包已经被成功接收，以此来保证网络包的传输可靠。</p>\n</blockquote>\n<p>RTP协议不保证传输的可靠性，所以接收端也就不会发送ACK包。如果这个包比较重要，可以给对端发送NACK包，来告诉这个包我没有收到，你如果‘还有’的话，就给我重新发送一遍（Retransmission）。</p>\n<p>前面说到的丢包，都加了引号，这个“丢包”，有可能是真的丢了，也有可能是顺序乱了。我们知道网络包的到达，有时候不是一定严格按照包序到达的，我收到了很多较新的包了，某个旧的包还没有收到，我就认为它丢了，也没准儿一会儿它又到了。怎么判断“丢包”呢？ 我们通过：</p>\n<ol>\n<li><p><strong>乱序的偏移来决定发起重传</strong></p>\n</li>\n<li><p><strong>根据预计到达时间已经超过一定时间了来发起重传 (一般是等待一个rtt＋jitter的时长)。</strong></p>\n</li>\n</ol>\n<p>更多丢包判断参见如下连接：<a href=\"https://www.jianshu.com/p/a7f6ec0c9273\" target=\"_blank\" rel=\"noopener\">WebRTC中丢包重传NACK实现分析</a></p>\n<h4 id=\"2-2-前向纠错编码-FEC\"><a href=\"#2-2-前向纠错编码-FEC\" class=\"headerlink\" title=\"2.2. 前向纠错编码( FEC )\"></a>2.2. 前向纠错编码( FEC )</h4><p>FEC（Forward Error Correction，前向纠错码），通过增加冗余来增强容错性到一种方法。如果没有FEC，接受端发现丢包时，需要通过发送NACK 来发起重传，但重传会影响延时性。</p>\n<ul>\n<li><p>FEC则是在发送端增加冗余数据，接受端在数据丢失到情况下可以重建丢失的数据。</p>\n</li>\n<li><p>增加FEC冗余数据占据了有效带宽</p>\n</li>\n</ul>\n<p>上面两点涉及到取舍，冗余的数据与减少丢包导致的延时。不过，FEC到冗余度是可以根据网络状况动态调整。</p>\n<h4 id=\"2-3-抖动缓冲-Jitterbuffer\"><a href=\"#2-3-抖动缓冲-Jitterbuffer\" class=\"headerlink\" title=\"2.3. 抖动缓冲( Jitterbuffer )\"></a>2.3. 抖动缓冲( Jitterbuffer )</h4><p>网络传输中总是存在着抖动，导致网络包不是均匀顺序到达，WebRTC利用一个缓冲区，进行等待与排序，这就是jitterbuffer。他能动态根据网络情况调整缓冲区的大小。</p>\n<p>主流的实时音视频框架基本都会实现jitterbuffer功能，诸如WebRTC、doubango等。WebRTC的jitterbuffer按照功能分类的话，可以分为jitter和buffer。</p>\n<p><code>jitterbuffer = jitter + buffer</code></p>\n<p><code>buffer</code></p>\n<p>buffer主要对<strong>丢包、乱序、延时到达等异常</strong>情况进行处理，还会和NACK、FEC（前向纠错码）、FIR(关键帧请求))等QOS（质量服务）相互配合。</p>\n<p><img src=\"http://www.ucpaas.com/u/allimg/1706/8-1F602094T0135.jpg\" alt=\"\"></p>\n<p>buffer 主要分为如下几种type：</p>\n<ul>\n<li><p>freeframes</p>\n</li>\n<li><p>incompleteframes</p>\n</li>\n<li><p>decodableframes</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>type</th>\n<th>remark</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>freeframes</td>\n<td>新到的数据包会根据时间戳在incompleteframes 和decodableframes 中寻找，相同放置到相应队列，否则从freeframes弹出空frame</td>\n</tr>\n<tr>\n<td>incompleteframes</td>\n<td>至少有一个数据包，帧数据不完整</td>\n</tr>\n<tr>\n<td>decodableframes</td>\n<td>可解码，此队列中有decodable和complete 状态。complete 状态帧可被解码线程取出解码，完成后将buffer 重新push 到freeframes 队列。<br><br> decodable会根据decode_error_mode 有不同的规则，QOS的不同策略会设置不同的decode_error_mode ，包含kNoErrors、kSelectiveErrors以及kWithErrors。decode_error_mode 就决定了解码线程从buffer中取出来的帧是否包含错误，即当前帧是否有丢包。</td>\n</tr>\n</tbody>\n</table>\n<p>jitterbuffer与QOS策略联系紧密，比如，incompleteframes和decodable队列清除一些frame之后，需要FIR（关键帧请求），根据包序号检测到丢包之后要NACK（丢包重传）等。</p>\n<p><code>jitter</code></p>\n<p>网络延迟带来的抖动会让音视频的播放不平稳，如音频的颤音，视频的忽快忽慢。那么如何对抗jitter呢？增加延时。</p>\n<p>jitter主要根据当前帧的大小和延时评估出<strong>jitterdelay</strong>，再结合<strong>decode delay、render delay以及音视频同步延时，得到render time</strong>，来控制<strong>平稳的渲染视频帧</strong>。</p>\n<p><img src=\"http://www.ucpaas.com/u/allimg/1706/8-1F602094Z4a1.jpg\" alt=\"\"></p>\n<p>其中:</p>\n<ul>\n<li><p>freeDelayMS: 两笔RTP1, RTP2 之间时间差</p>\n</li>\n<li><p>frameSizeBytes: 当前帧数据大小</p>\n</li>\n<li><p>incompleteFrame: 是否微完整帧</p>\n</li>\n<li><p>UpdateEstimate: 用卡尔曼滤波对帧间延迟进行滤波（具体算法这里不进行讨论）</p>\n</li>\n</ul>\n<p>在得到jitterdelay之后，通过jitterdelay+ decodedelay +renderdelay，再确保大于音视频同步的延时，加上当前系统时间得到rendertime，这样就可以控制播放时间。控制播放，也就间接控制了buffer的大小。</p>\n<p>当然，仅仅通过动态的jitterbuffer 是无法完全解决网络拥塞的问题，根本上还是应该调整发送的码率。</p>\n<h4 id=\"2-4-带宽自适应\"><a href=\"#2-4-带宽自适应\" class=\"headerlink\" title=\"2.4. 带宽自适应\"></a>2.4. 带宽自适应</h4><p>带宽自适应是指在音视频的收发过程中，根据网络带宽的变化，自动的来调整发送码率，来适应带宽的变化。在带宽足够的情况下，增加帧率和码率，提高音视频的质量，带来更好的通信体验。在带宽不足的情况下，主动降低码率或者帧率，保证通信的流畅性和可用性，也是带来更好的通信体验。</p>\n<p>带宽自适应的核心：<strong>如何准确的估计带宽</strong>。WebRTC在实现带宽自适应时采用了Google提出一个称为REMB（Receiver Estimated Max Bitrate，最大接收带宽估计）的带宽估计算法。</p>\n<p>大致算法是：</p>\n<ul>\n<li><p>接受端维护状态机（根据丢包率或延时情况）</p>\n</li>\n<li><p>根据丢包率或延时情况修改remb 值</p>\n</li>\n<li><p>将remb 值通过RTCP 发送给发送端</p>\n</li>\n<li><p>发送端根据remb 值调整码率</p>\n</li>\n</ul>\n<p>补充：<a href=\"https://blog.csdn.net/xiangjai/article/details/44238005\" target=\"_blank\" rel=\"noopener\">码流 / 码率 / 比特率 / 帧速率 / 分辨率 / 高清的区别</a></p>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源:\"></a>参考资源:</h3><p><a href=\"https://blog.csdn.net/mantis_1984/article/details/53572822\" target=\"_blank\" rel=\"noopener\">webrtc 中到网络反馈于控制</a></p>\n<p><a href=\"https://blog.csdn.net/u012635648/article/details/72953237\" target=\"_blank\" rel=\"noopener\">WebRTC视频JitterBuff</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"WebRTC-如何避免拥塞？\"><a href=\"#WebRTC-如何避免拥塞？\" class=\"headerlink\" title=\"WebRTC 如何避免拥塞？\"></a>WebRTC 如何避免拥塞？</h2><h3 id=\"1-WebRTC-网络传输背景\"><a href=\"#1-WebRTC-网络传输背景\" class=\"headerlink\" title=\"1. WebRTC 网络传输背景\"></a>1. WebRTC 网络传输背景</h3><h4 id=\"1-1-WebRTC-amp-amp-多数直播\"><a href=\"#1-1-WebRTC-amp-amp-多数直播\" class=\"headerlink\" title=\"1.1. WebRTC &amp;&amp; 多数直播\"></a>1.1. WebRTC &amp;&amp; 多数直播</h4><p><strong>大多数视频直播平台</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">传输协议</td>\n<td style=\"text-align:left\">RTMP（Real Time MEssaging Protocol)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">优点</td>\n<td style=\"text-align:left\">使用RTMP， 其基于TCP传输，跟flash等流媒体服务支持比较好，同时CDN支持良好</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">缺点</td>\n<td style=\"text-align:left\">直播音视频数据量大，实时性要求比较高，TCP的重传机制和拥塞机制不适用于实时传输。传输控制依赖于TCP本身协议控制机制，网络成本较大不够灵活。</td>\n</tr>\n</tbody>\n</table>\n<p>音视频对网络丢包有一定程度天然容忍性（常见优酷，爱奇艺都有缓冲）。使用UDP传输是不错到选择。</p>","more":"<p><strong>webRTC</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">传输协议</td>\n<td style=\"text-align:left\">RTP: 针对流媒体传输的基础协议，定义Internet上传输音视频数据包。 <br> RTCP：负责流媒体到传输质量保证，提供流量控制和拥塞控制等机制。<img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=57e79b5fb0de9c82b268f1dd0de8eb6f/4bed2e738bd4b31c42beebdd84d6277f9f2ff8d2.jpg\" alt=\"\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">优点</td>\n<td style=\"text-align:left\">包括ICE、STUN、TURN等信令交互、网络大洞（P2P)，主流浏览器支持（chrome, firefox,opera, safari,edge等）<br> <img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=54395c9081d4b31cf03c93bdbfed4042/2cf5e0fe9925bc3142b4464b54df8db1ca137073.jpg\" alt=\"\"> <img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=bb31c6af3812b31bc36cca2bb61a3674/54fbb2fb43166d2287f64f7c472309f79152d251.jpg\" alt=\"\"><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=1db5f93247c2d562f208d7ebdf2af7d2/f9198618367adab4ee604c1183d4b31c8701e434.jpg\" alt=\"\"><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=5838ca994410b912bfc1f1f8fbc69b3e/500fd9f9d72a6059b0046c382b34349b033bbaf8.jpg\" alt=\"\"><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=37f66727093387449cc5287a6934bec4/d53f8794a4c27d1e13c902b31ed5ad6edcc438dd.jpg\" alt=\"\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-WebRTC-处理\"><a href=\"#2-WebRTC-处理\" class=\"headerlink\" title=\"2. WebRTC 处理\"></a>2. WebRTC 处理</h3><h4 id=\"2-1-NACK\"><a href=\"#2-1-NACK\" class=\"headerlink\" title=\"2.1. NACK\"></a>2.1. NACK</h4><p>NACK( negative acknowledge character)， 就是否定应答。与之对应的是TCP中的ACK( acknowledge character)。</p>\n<blockquote>\n<p>在TCP中，接收端对于收到的包都要进行应答即发送ACK包，发送端通过接受ACK包，来确定发送的包已经被成功接收，以此来保证网络包的传输可靠。</p>\n</blockquote>\n<p>RTP协议不保证传输的可靠性，所以接收端也就不会发送ACK包。如果这个包比较重要，可以给对端发送NACK包，来告诉这个包我没有收到，你如果‘还有’的话，就给我重新发送一遍（Retransmission）。</p>\n<p>前面说到的丢包，都加了引号，这个“丢包”，有可能是真的丢了，也有可能是顺序乱了。我们知道网络包的到达，有时候不是一定严格按照包序到达的，我收到了很多较新的包了，某个旧的包还没有收到，我就认为它丢了，也没准儿一会儿它又到了。怎么判断“丢包”呢？ 我们通过：</p>\n<ol>\n<li><p><strong>乱序的偏移来决定发起重传</strong></p>\n</li>\n<li><p><strong>根据预计到达时间已经超过一定时间了来发起重传 (一般是等待一个rtt＋jitter的时长)。</strong></p>\n</li>\n</ol>\n<p>更多丢包判断参见如下连接：<a href=\"https://www.jianshu.com/p/a7f6ec0c9273\" target=\"_blank\" rel=\"noopener\">WebRTC中丢包重传NACK实现分析</a></p>\n<h4 id=\"2-2-前向纠错编码-FEC\"><a href=\"#2-2-前向纠错编码-FEC\" class=\"headerlink\" title=\"2.2. 前向纠错编码( FEC )\"></a>2.2. 前向纠错编码( FEC )</h4><p>FEC（Forward Error Correction，前向纠错码），通过增加冗余来增强容错性到一种方法。如果没有FEC，接受端发现丢包时，需要通过发送NACK 来发起重传，但重传会影响延时性。</p>\n<ul>\n<li><p>FEC则是在发送端增加冗余数据，接受端在数据丢失到情况下可以重建丢失的数据。</p>\n</li>\n<li><p>增加FEC冗余数据占据了有效带宽</p>\n</li>\n</ul>\n<p>上面两点涉及到取舍，冗余的数据与减少丢包导致的延时。不过，FEC到冗余度是可以根据网络状况动态调整。</p>\n<h4 id=\"2-3-抖动缓冲-Jitterbuffer\"><a href=\"#2-3-抖动缓冲-Jitterbuffer\" class=\"headerlink\" title=\"2.3. 抖动缓冲( Jitterbuffer )\"></a>2.3. 抖动缓冲( Jitterbuffer )</h4><p>网络传输中总是存在着抖动，导致网络包不是均匀顺序到达，WebRTC利用一个缓冲区，进行等待与排序，这就是jitterbuffer。他能动态根据网络情况调整缓冲区的大小。</p>\n<p>主流的实时音视频框架基本都会实现jitterbuffer功能，诸如WebRTC、doubango等。WebRTC的jitterbuffer按照功能分类的话，可以分为jitter和buffer。</p>\n<p><code>jitterbuffer = jitter + buffer</code></p>\n<p><code>buffer</code></p>\n<p>buffer主要对<strong>丢包、乱序、延时到达等异常</strong>情况进行处理，还会和NACK、FEC（前向纠错码）、FIR(关键帧请求))等QOS（质量服务）相互配合。</p>\n<p><img src=\"http://www.ucpaas.com/u/allimg/1706/8-1F602094T0135.jpg\" alt=\"\"></p>\n<p>buffer 主要分为如下几种type：</p>\n<ul>\n<li><p>freeframes</p>\n</li>\n<li><p>incompleteframes</p>\n</li>\n<li><p>decodableframes</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>type</th>\n<th>remark</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>freeframes</td>\n<td>新到的数据包会根据时间戳在incompleteframes 和decodableframes 中寻找，相同放置到相应队列，否则从freeframes弹出空frame</td>\n</tr>\n<tr>\n<td>incompleteframes</td>\n<td>至少有一个数据包，帧数据不完整</td>\n</tr>\n<tr>\n<td>decodableframes</td>\n<td>可解码，此队列中有decodable和complete 状态。complete 状态帧可被解码线程取出解码，完成后将buffer 重新push 到freeframes 队列。<br><br> decodable会根据decode_error_mode 有不同的规则，QOS的不同策略会设置不同的decode_error_mode ，包含kNoErrors、kSelectiveErrors以及kWithErrors。decode_error_mode 就决定了解码线程从buffer中取出来的帧是否包含错误，即当前帧是否有丢包。</td>\n</tr>\n</tbody>\n</table>\n<p>jitterbuffer与QOS策略联系紧密，比如，incompleteframes和decodable队列清除一些frame之后，需要FIR（关键帧请求），根据包序号检测到丢包之后要NACK（丢包重传）等。</p>\n<p><code>jitter</code></p>\n<p>网络延迟带来的抖动会让音视频的播放不平稳，如音频的颤音，视频的忽快忽慢。那么如何对抗jitter呢？增加延时。</p>\n<p>jitter主要根据当前帧的大小和延时评估出<strong>jitterdelay</strong>，再结合<strong>decode delay、render delay以及音视频同步延时，得到render time</strong>，来控制<strong>平稳的渲染视频帧</strong>。</p>\n<p><img src=\"http://www.ucpaas.com/u/allimg/1706/8-1F602094Z4a1.jpg\" alt=\"\"></p>\n<p>其中:</p>\n<ul>\n<li><p>freeDelayMS: 两笔RTP1, RTP2 之间时间差</p>\n</li>\n<li><p>frameSizeBytes: 当前帧数据大小</p>\n</li>\n<li><p>incompleteFrame: 是否微完整帧</p>\n</li>\n<li><p>UpdateEstimate: 用卡尔曼滤波对帧间延迟进行滤波（具体算法这里不进行讨论）</p>\n</li>\n</ul>\n<p>在得到jitterdelay之后，通过jitterdelay+ decodedelay +renderdelay，再确保大于音视频同步的延时，加上当前系统时间得到rendertime，这样就可以控制播放时间。控制播放，也就间接控制了buffer的大小。</p>\n<p>当然，仅仅通过动态的jitterbuffer 是无法完全解决网络拥塞的问题，根本上还是应该调整发送的码率。</p>\n<h4 id=\"2-4-带宽自适应\"><a href=\"#2-4-带宽自适应\" class=\"headerlink\" title=\"2.4. 带宽自适应\"></a>2.4. 带宽自适应</h4><p>带宽自适应是指在音视频的收发过程中，根据网络带宽的变化，自动的来调整发送码率，来适应带宽的变化。在带宽足够的情况下，增加帧率和码率，提高音视频的质量，带来更好的通信体验。在带宽不足的情况下，主动降低码率或者帧率，保证通信的流畅性和可用性，也是带来更好的通信体验。</p>\n<p>带宽自适应的核心：<strong>如何准确的估计带宽</strong>。WebRTC在实现带宽自适应时采用了Google提出一个称为REMB（Receiver Estimated Max Bitrate，最大接收带宽估计）的带宽估计算法。</p>\n<p>大致算法是：</p>\n<ul>\n<li><p>接受端维护状态机（根据丢包率或延时情况）</p>\n</li>\n<li><p>根据丢包率或延时情况修改remb 值</p>\n</li>\n<li><p>将remb 值通过RTCP 发送给发送端</p>\n</li>\n<li><p>发送端根据remb 值调整码率</p>\n</li>\n</ul>\n<p>补充：<a href=\"https://blog.csdn.net/xiangjai/article/details/44238005\" target=\"_blank\" rel=\"noopener\">码流 / 码率 / 比特率 / 帧速率 / 分辨率 / 高清的区别</a></p>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源:\"></a>参考资源:</h3><p><a href=\"https://blog.csdn.net/mantis_1984/article/details/53572822\" target=\"_blank\" rel=\"noopener\">webrtc 中到网络反馈于控制</a></p>\n<p><a href=\"https://blog.csdn.net/u012635648/article/details/72953237\" target=\"_blank\" rel=\"noopener\">WebRTC视频JitterBuff</a></p>"},{"title":"WebRTC_Best_Relay_Network_Selection","date":"2018-06-22T02:04:39.000Z","_content":"\n## 1. Prepare\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Sort_Itself.png)\n\n<!--more-->\n\nLocal 端与remote 连接前，local 端会收取本地的SDP、Candidate。Candidate 其包含了一些网络信息，类似于\n\n```json\n{\n   \"candidate\" : \"candidate:3724402988 1 udp 41885695 172.28.28.24 51570 typ relay raddr 101.206.166.96 rport 23166 generation 0 ufrag 8B5q network-id 3 network-cost 50\",\n   \"id\" : \"sdparta_0\",\n   \"label\" : 0,\n   \"type\" : \"candidate\"\n}\n```\n\n收集到的Candidates，会依据：\n\n- IPv6 > IPv4\n\n- UDP > TCP\n\n以上的准则进行自我的排序准备动作。\n\n## 2. Connection\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Get_Candidate.png)\n\n在收到remote端的candidate后，会进行如下动作：\n\n| 序号  | 动作                                                                                                                                                                                                                                                                                  |\n| --- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1   | 将新收到的candidate网络与local 端的每一个candidate都创建一个connection                                                                                                                                                                                                                                |\n| 2   | 将connection 连接对，更新到预备队列中并且排序。排序的依据是：1）**writable, receiving**; 2) **estimated latency is lowest**;                                                                                                                                                                                  |\n| 3   | MaybeSwitchSelectedConnection()，可能现在到达的remote candidate 是在有了选择连接之后，如果新到的remote candidate 更好，则将此candidate 替换selected_。那怎样是好的呢？1)**wirtable、receiving、connected states**; 2)**nomination state**; 3) **last data received time**; 4)**lower cost、higher priority**;5)**rtt(往返时间间隔)**; |\n| 4   | 开始尝试stun ping 动作                                                                                                                                                                                                                                                                    |\n| 5   | 从之前拍寻过的队列中选择下一个后背ping item。当然，这里也是有些策略：1)**unpinged connections have priority over pinged ones**; 2)**select best connections from every network, the one with the earliest last-ping-sent time**                                                                                   |\n\n## 3. Selection\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Get_Ping_Response.png)\n\n在收到stun ping的响应之后，我们可以理解为，这条线路是通的。\n\n\n","source":"_posts/WebRTC-Best-Relay-Network-Selection.md","raw":"---\n\ntitle: WebRTC_Best_Relay_Network_Selection\ndate: 2018-06-22 10:04:39\ntags:\n    - WebRTC\ncategories: WebRTC    \n---\n\n## 1. Prepare\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Sort_Itself.png)\n\n<!--more-->\n\nLocal 端与remote 连接前，local 端会收取本地的SDP、Candidate。Candidate 其包含了一些网络信息，类似于\n\n```json\n{\n   \"candidate\" : \"candidate:3724402988 1 udp 41885695 172.28.28.24 51570 typ relay raddr 101.206.166.96 rport 23166 generation 0 ufrag 8B5q network-id 3 network-cost 50\",\n   \"id\" : \"sdparta_0\",\n   \"label\" : 0,\n   \"type\" : \"candidate\"\n}\n```\n\n收集到的Candidates，会依据：\n\n- IPv6 > IPv4\n\n- UDP > TCP\n\n以上的准则进行自我的排序准备动作。\n\n## 2. Connection\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Get_Candidate.png)\n\n在收到remote端的candidate后，会进行如下动作：\n\n| 序号  | 动作                                                                                                                                                                                                                                                                                  |\n| --- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1   | 将新收到的candidate网络与local 端的每一个candidate都创建一个connection                                                                                                                                                                                                                                |\n| 2   | 将connection 连接对，更新到预备队列中并且排序。排序的依据是：1）**writable, receiving**; 2) **estimated latency is lowest**;                                                                                                                                                                                  |\n| 3   | MaybeSwitchSelectedConnection()，可能现在到达的remote candidate 是在有了选择连接之后，如果新到的remote candidate 更好，则将此candidate 替换selected_。那怎样是好的呢？1)**wirtable、receiving、connected states**; 2)**nomination state**; 3) **last data received time**; 4)**lower cost、higher priority**;5)**rtt(往返时间间隔)**; |\n| 4   | 开始尝试stun ping 动作                                                                                                                                                                                                                                                                    |\n| 5   | 从之前拍寻过的队列中选择下一个后背ping item。当然，这里也是有些策略：1)**unpinged connections have priority over pinged ones**; 2)**select best connections from every network, the one with the earliest last-ping-sent time**                                                                                   |\n\n## 3. Selection\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Get_Ping_Response.png)\n\n在收到stun ping的响应之后，我们可以理解为，这条线路是通的。\n\n\n","slug":"WebRTC-Best-Relay-Network-Selection","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pf000uzkgr3nbs1ux5","content":"<h2 id=\"1-Prepare\"><a href=\"#1-Prepare\" class=\"headerlink\" title=\"1. Prepare\"></a>1. Prepare</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Sort_Itself.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>Local 端与remote 连接前，local 端会收取本地的SDP、Candidate。Candidate 其包含了一些网络信息，类似于</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"candidate\"</span> : <span class=\"string\">\"candidate:3724402988 1 udp 41885695 172.28.28.24 51570 typ relay raddr 101.206.166.96 rport 23166 generation 0 ufrag 8B5q network-id 3 network-cost 50\"</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"id\"</span> : <span class=\"string\">\"sdparta_0\"</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"label\"</span> : <span class=\"number\">0</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"type\"</span> : <span class=\"string\">\"candidate\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>收集到的Candidates，会依据：</p>\n<ul>\n<li><p>IPv6 &gt; IPv4</p>\n</li>\n<li><p>UDP &gt; TCP</p>\n</li>\n</ul>\n<p>以上的准则进行自我的排序准备动作。</p>\n<h2 id=\"2-Connection\"><a href=\"#2-Connection\" class=\"headerlink\" title=\"2. Connection\"></a>2. Connection</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Get_Candidate.png\" alt=\"\"></p>\n<p>在收到remote端的candidate后，会进行如下动作：</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>动作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>将新收到的candidate网络与local 端的每一个candidate都创建一个connection</td>\n</tr>\n<tr>\n<td>2</td>\n<td>将connection 连接对，更新到预备队列中并且排序。排序的依据是：1）<strong>writable, receiving</strong>; 2) <strong>estimated latency is lowest</strong>;</td>\n</tr>\n<tr>\n<td>3</td>\n<td>MaybeSwitchSelectedConnection()，可能现在到达的remote candidate 是在有了选择连接之后，如果新到的remote candidate 更好，则将此candidate 替换selected_。那怎样是好的呢？1)<strong>wirtable、receiving、connected states</strong>; 2)<strong>nomination state</strong>; 3) <strong>last data received time</strong>; 4)<strong>lower cost、higher priority</strong>;5)<strong>rtt(往返时间间隔)</strong>;</td>\n</tr>\n<tr>\n<td>4</td>\n<td>开始尝试stun ping 动作</td>\n</tr>\n<tr>\n<td>5</td>\n<td>从之前拍寻过的队列中选择下一个后背ping item。当然，这里也是有些策略：1)<strong>unpinged connections have priority over pinged ones</strong>; 2)<strong>select best connections from every network, the one with the earliest last-ping-sent time</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-Selection\"><a href=\"#3-Selection\" class=\"headerlink\" title=\"3. Selection\"></a>3. Selection</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Get_Ping_Response.png\" alt=\"\"></p>\n<p>在收到stun ping的响应之后，我们可以理解为，这条线路是通的。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-Prepare\"><a href=\"#1-Prepare\" class=\"headerlink\" title=\"1. Prepare\"></a>1. Prepare</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Sort_Itself.png\" alt=\"\"></p>","more":"<p>Local 端与remote 连接前，local 端会收取本地的SDP、Candidate。Candidate 其包含了一些网络信息，类似于</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"candidate\"</span> : <span class=\"string\">\"candidate:3724402988 1 udp 41885695 172.28.28.24 51570 typ relay raddr 101.206.166.96 rport 23166 generation 0 ufrag 8B5q network-id 3 network-cost 50\"</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"id\"</span> : <span class=\"string\">\"sdparta_0\"</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"label\"</span> : <span class=\"number\">0</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"type\"</span> : <span class=\"string\">\"candidate\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>收集到的Candidates，会依据：</p>\n<ul>\n<li><p>IPv6 &gt; IPv4</p>\n</li>\n<li><p>UDP &gt; TCP</p>\n</li>\n</ul>\n<p>以上的准则进行自我的排序准备动作。</p>\n<h2 id=\"2-Connection\"><a href=\"#2-Connection\" class=\"headerlink\" title=\"2. Connection\"></a>2. Connection</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Get_Candidate.png\" alt=\"\"></p>\n<p>在收到remote端的candidate后，会进行如下动作：</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>动作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>将新收到的candidate网络与local 端的每一个candidate都创建一个connection</td>\n</tr>\n<tr>\n<td>2</td>\n<td>将connection 连接对，更新到预备队列中并且排序。排序的依据是：1）<strong>writable, receiving</strong>; 2) <strong>estimated latency is lowest</strong>;</td>\n</tr>\n<tr>\n<td>3</td>\n<td>MaybeSwitchSelectedConnection()，可能现在到达的remote candidate 是在有了选择连接之后，如果新到的remote candidate 更好，则将此candidate 替换selected_。那怎样是好的呢？1)<strong>wirtable、receiving、connected states</strong>; 2)<strong>nomination state</strong>; 3) <strong>last data received time</strong>; 4)<strong>lower cost、higher priority</strong>;5)<strong>rtt(往返时间间隔)</strong>;</td>\n</tr>\n<tr>\n<td>4</td>\n<td>开始尝试stun ping 动作</td>\n</tr>\n<tr>\n<td>5</td>\n<td>从之前拍寻过的队列中选择下一个后背ping item。当然，这里也是有些策略：1)<strong>unpinged connections have priority over pinged ones</strong>; 2)<strong>select best connections from every network, the one with the earliest last-ping-sent time</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-Selection\"><a href=\"#3-Selection\" class=\"headerlink\" title=\"3. Selection\"></a>3. Selection</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/RelayNetworkSelection/WebRTC_Best_Relay_Network_Get_Ping_Response.png\" alt=\"\"></p>\n<p>在收到stun ping的响应之后，我们可以理解为，这条线路是通的。</p>"},{"title":"WebRTC_Congestion_Control","date":"2018-06-22T02:56:27.000Z","_content":"\n## 1. Congestion Class Relationship\n\n### 1.1. Congestion Class\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Class.png)\n\n<!--more-->\n\n### 1.2. Biterate Controller\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Bitrate_Controller_Class.png)\n\n## 2. Congestion Control Flow\n\n### 2.1. Biterate Controller\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Bitrate_Controller_Flow.png)\n\n### 2.2. Congestion Control\n\n#### 2.2.1. Send Side\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Send_Side.png)\n\n#### 2.2.2. Receive Side\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Receive_Side.png)","source":"_posts/WebRTC-Congestion-Control.md","raw":"---\ntitle: WebRTC_Congestion_Control\ndate: 2018-06-22 10:56:27\ntags:\n    - WebRTC\n    - biterate controller\n    - congestion control\ncategories: WebRTC    \n---\n\n## 1. Congestion Class Relationship\n\n### 1.1. Congestion Class\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Class.png)\n\n<!--more-->\n\n### 1.2. Biterate Controller\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Bitrate_Controller_Class.png)\n\n## 2. Congestion Control Flow\n\n### 2.1. Biterate Controller\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Bitrate_Controller_Flow.png)\n\n### 2.2. Congestion Control\n\n#### 2.2.1. Send Side\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Send_Side.png)\n\n#### 2.2.2. Receive Side\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Receive_Side.png)","slug":"WebRTC-Congestion-Control","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0ph000xzkgru8c0tv88","content":"<h2 id=\"1-Congestion-Class-Relationship\"><a href=\"#1-Congestion-Class-Relationship\" class=\"headerlink\" title=\"1. Congestion Class Relationship\"></a>1. Congestion Class Relationship</h2><h3 id=\"1-1-Congestion-Class\"><a href=\"#1-1-Congestion-Class\" class=\"headerlink\" title=\"1.1. Congestion Class\"></a>1.1. Congestion Class</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Class.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"1-2-Biterate-Controller\"><a href=\"#1-2-Biterate-Controller\" class=\"headerlink\" title=\"1.2. Biterate Controller\"></a>1.2. Biterate Controller</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Bitrate_Controller_Class.png\" alt=\"\"></p>\n<h2 id=\"2-Congestion-Control-Flow\"><a href=\"#2-Congestion-Control-Flow\" class=\"headerlink\" title=\"2. Congestion Control Flow\"></a>2. Congestion Control Flow</h2><h3 id=\"2-1-Biterate-Controller\"><a href=\"#2-1-Biterate-Controller\" class=\"headerlink\" title=\"2.1. Biterate Controller\"></a>2.1. Biterate Controller</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Bitrate_Controller_Flow.png\" alt=\"\"></p>\n<h3 id=\"2-2-Congestion-Control\"><a href=\"#2-2-Congestion-Control\" class=\"headerlink\" title=\"2.2. Congestion Control\"></a>2.2. Congestion Control</h3><h4 id=\"2-2-1-Send-Side\"><a href=\"#2-2-1-Send-Side\" class=\"headerlink\" title=\"2.2.1. Send Side\"></a>2.2.1. Send Side</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Send_Side.png\" alt=\"\"></p>\n<h4 id=\"2-2-2-Receive-Side\"><a href=\"#2-2-2-Receive-Side\" class=\"headerlink\" title=\"2.2.2. Receive Side\"></a>2.2.2. Receive Side</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Receive_Side.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-Congestion-Class-Relationship\"><a href=\"#1-Congestion-Class-Relationship\" class=\"headerlink\" title=\"1. Congestion Class Relationship\"></a>1. Congestion Class Relationship</h2><h3 id=\"1-1-Congestion-Class\"><a href=\"#1-1-Congestion-Class\" class=\"headerlink\" title=\"1.1. Congestion Class\"></a>1.1. Congestion Class</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Class.png\" alt=\"\"></p>","more":"<h3 id=\"1-2-Biterate-Controller\"><a href=\"#1-2-Biterate-Controller\" class=\"headerlink\" title=\"1.2. Biterate Controller\"></a>1.2. Biterate Controller</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Bitrate_Controller_Class.png\" alt=\"\"></p>\n<h2 id=\"2-Congestion-Control-Flow\"><a href=\"#2-Congestion-Control-Flow\" class=\"headerlink\" title=\"2. Congestion Control Flow\"></a>2. Congestion Control Flow</h2><h3 id=\"2-1-Biterate-Controller\"><a href=\"#2-1-Biterate-Controller\" class=\"headerlink\" title=\"2.1. Biterate Controller\"></a>2.1. Biterate Controller</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Bitrate_Controller_Flow.png\" alt=\"\"></p>\n<h3 id=\"2-2-Congestion-Control\"><a href=\"#2-2-Congestion-Control\" class=\"headerlink\" title=\"2.2. Congestion Control\"></a>2.2. Congestion Control</h3><h4 id=\"2-2-1-Send-Side\"><a href=\"#2-2-1-Send-Side\" class=\"headerlink\" title=\"2.2.1. Send Side\"></a>2.2.1. Send Side</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Send_Side.png\" alt=\"\"></p>\n<h4 id=\"2-2-2-Receive-Side\"><a href=\"#2-2-2-Receive-Side\" class=\"headerlink\" title=\"2.2.2. Receive Side\"></a>2.2.2. Receive Side</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/CongestionControl/WebRTC_Congestion_Controll_Receive_Side.png\" alt=\"\"></p>"},{"title":"arm_generic_timer","date":"2019-11-27T05:59:41.000Z","_content":"\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f3e81b7a10d5ad6ebef46cb8e0a252be/9922720e0cf3d7ca5a381fc8f91fbe096a63a945.jpg)\n\n通用定时器是基于累加计数硬件，可以用作schedule events或trigger interrupts. It provides:\n- Generation of timer events as interrupt outputs.  \n- Generation of event streams.  \n- Support for Virtualization Extensions  \n\n<!--more-->\n## 1. Base  \n![generic timer example](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/generic_timer.png)\n\nThe Generic Timer 提供如下几种counter与Timer：\n- __system counter__, measures the passing of time in real-time. \n- __virtual counter__(cpu support for virtualization), measure the passing of time on a particular virtual machine\n- __timer__, that can assert a timer output signal after a period of time has passed.\n\n## 2. system counter\nsystem counter规格如下\n\n|       子项       | 需求                                                       |\n| :--------------: | :--------------------------------------------------------- |\n|      Width       | 至少56bits 宽度，返回64-bit 是以0 进行扩展得到             |\n|    Frequency     | 典型范围 1-50MHz. 在power-saving 时可以更低，例如500-20KHz |\n|    Roll-over     | 不少于40年                                                 |\n| Accuracy（精度） | 24Hours 误差不超过1s                                       |\n|     Start-up     | 从0 开始累计                                               |\n\n可以通过CNTFRQ 设置/读取 frequency. \n\n## 3. physical counter\nCNTPCT（64-bit） 寄存器存储了physical counter\n\n访问权限：\n- secure PL1 mode, Non-secure Hyp mode\n- Non-secure PL1 mode only when CNTHCTL.PL1PCTEN=1\n\n## 4. virtual counter\n在分两种情况：\n- 没有virtualization Extension时，virtual time 与physical time相同\n- 具备virtualization Extension，virtual counter里面的值等于physical counter减去 64-bit virtual offset.(<font color=green>virtual_counter = physical_counter - virtual_offset</font>)\n\nCNTVCT 寄存器包含了virtual counter。 在Secure PL1 mode, Non-secure PL1, PL2 mode 下能访问。\n\nCNTVOFF 寄存器包含了virtual offset, 只有Hyp mode或在SCR.NS=1时，Monitor mode下访问。\n\n## 5. Event streams\nGeneric Timer 可以使用system counter 产生一个或多个event streams.\n\nEvent stream 用处：\n- 产生超时on a Wait For Event polling loop\n- 确保expected event在一定时间内是否generated\n  \n## 6. Timer\n__Security Extensions not implemented__\nThe implementation provides a physical timer and a virtual timer.\n\n__Security Extensions implemented, Virtualization Extensions not implemented__\n- A Non-secure physical timer.  \n- A Secure physical timer.  \n- A virtual timer.\n\n__Virtualization Extensions implemented__\n<font color=red>\n- A Non-secure PL1 physical timer. \n- A Secure PL1 physical timer.  \n- A Non-secure PL2 physical timer.  \n- A virtual timer.\n\n</font>\n\nEach timer is implemented as three registers:\n- A 64-bit __CompareValue register__, that provides a 64-bit unsigned upcounter.  \n- A 32-bit __TimerValue register__, that provides a 32-bit signed down counter.  \n- A 32-bit __Control register__.\n\n![timer registers summary](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/timer_registers_summary.png)\n\nAccessing timer registers\n\n|       timer        | remarks                                                                                                              |\n| :----------------: | :------------------------------------------------------------------------------------------------------------------- |\n| PL1 physical timer | - secure mode<br>- Non-secure Hyp mode<br>- CNTHCTL.PL1PCEN=1, Non-secure PL1 mode<br> - CNTKCTL.PL0PTEN=1, PL0 mode |\n|   virtual timer    | secure, Non-secure PL1 mode, Hyp mode                                                                                |\n| PL2 physical timer | Non-secure Hyp mode, 或SCR.NS=1时 Secure Monitor                                                                     |\n\n在中断号上分配如下：\n\n| IRQ NUM | Remarks                               |\n| :-----: | :------------------------------------ |\n|   29    | physical timer in secure PL1 mode     |\n|   30    | physical timer in Non-secure PL1 mode |\n|   27    | virtual timer in Non-secure PL1 mode  |\n|   26    | physical timer in hyp mode            |\n\n### 6.1. CompareValue\nCompareValue 的操作可以看作是unsigned 64-bit up counter.\n\n<font color=red>Eventtriggered = (Counter[63:0] - Offset[63:0]) - CompareValue[63:0] >= 0 </font>\n\n|     术语     | 说明                                                                 |\n| :----------: | :------------------------------------------------------------------- |\n|   Counter    | physical counter, 读取CNTPCT，CNTVCT 寄存器                          |\n|    Offset    | 如果没有Virtualization Extension, offset=0, 反之，offset = <CNTVOFF> |\n| CompareValue | 比较值寄存器，CNTP_CVAL, CNTHP_CVAL, or CNTV_CVAL.                   |\n\n### 6.2. TimerValue\nTimerValue 的操作可以看作是signed 32-bit down counter.\n\n<font color=red>Eventtriggered = (TimerValue <= 0) </font>\n\nTimerValue 值来源于CNTP_TVAL, CNTHP_TVAL, or CNTV_TVAL.\n\n## 7. Generic Timer registers\n![generic timer registers](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/generic_timer_registers.png)\n\n\n## Reference\ncortex_a7_mpcore_r0p5_trm(arm_trm).pdf\narm_architecture_reference_manual(arm_arm).pdf\n\n[Linux时间子系统之（十七）：ARM generic timer 驱动分析](http://www.wowotech.net/timer_subsystem/armgeneraltimer.html)","source":"_posts/arm-generic-timer.md","raw":"---\ntitle: arm_generic_timer\ndate: 2019-11-27 13:59:41\ntags:\n    - arm\ncategories:\n    - arm\n---\n\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f3e81b7a10d5ad6ebef46cb8e0a252be/9922720e0cf3d7ca5a381fc8f91fbe096a63a945.jpg)\n\n通用定时器是基于累加计数硬件，可以用作schedule events或trigger interrupts. It provides:\n- Generation of timer events as interrupt outputs.  \n- Generation of event streams.  \n- Support for Virtualization Extensions  \n\n<!--more-->\n## 1. Base  \n![generic timer example](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/generic_timer.png)\n\nThe Generic Timer 提供如下几种counter与Timer：\n- __system counter__, measures the passing of time in real-time. \n- __virtual counter__(cpu support for virtualization), measure the passing of time on a particular virtual machine\n- __timer__, that can assert a timer output signal after a period of time has passed.\n\n## 2. system counter\nsystem counter规格如下\n\n|       子项       | 需求                                                       |\n| :--------------: | :--------------------------------------------------------- |\n|      Width       | 至少56bits 宽度，返回64-bit 是以0 进行扩展得到             |\n|    Frequency     | 典型范围 1-50MHz. 在power-saving 时可以更低，例如500-20KHz |\n|    Roll-over     | 不少于40年                                                 |\n| Accuracy（精度） | 24Hours 误差不超过1s                                       |\n|     Start-up     | 从0 开始累计                                               |\n\n可以通过CNTFRQ 设置/读取 frequency. \n\n## 3. physical counter\nCNTPCT（64-bit） 寄存器存储了physical counter\n\n访问权限：\n- secure PL1 mode, Non-secure Hyp mode\n- Non-secure PL1 mode only when CNTHCTL.PL1PCTEN=1\n\n## 4. virtual counter\n在分两种情况：\n- 没有virtualization Extension时，virtual time 与physical time相同\n- 具备virtualization Extension，virtual counter里面的值等于physical counter减去 64-bit virtual offset.(<font color=green>virtual_counter = physical_counter - virtual_offset</font>)\n\nCNTVCT 寄存器包含了virtual counter。 在Secure PL1 mode, Non-secure PL1, PL2 mode 下能访问。\n\nCNTVOFF 寄存器包含了virtual offset, 只有Hyp mode或在SCR.NS=1时，Monitor mode下访问。\n\n## 5. Event streams\nGeneric Timer 可以使用system counter 产生一个或多个event streams.\n\nEvent stream 用处：\n- 产生超时on a Wait For Event polling loop\n- 确保expected event在一定时间内是否generated\n  \n## 6. Timer\n__Security Extensions not implemented__\nThe implementation provides a physical timer and a virtual timer.\n\n__Security Extensions implemented, Virtualization Extensions not implemented__\n- A Non-secure physical timer.  \n- A Secure physical timer.  \n- A virtual timer.\n\n__Virtualization Extensions implemented__\n<font color=red>\n- A Non-secure PL1 physical timer. \n- A Secure PL1 physical timer.  \n- A Non-secure PL2 physical timer.  \n- A virtual timer.\n\n</font>\n\nEach timer is implemented as three registers:\n- A 64-bit __CompareValue register__, that provides a 64-bit unsigned upcounter.  \n- A 32-bit __TimerValue register__, that provides a 32-bit signed down counter.  \n- A 32-bit __Control register__.\n\n![timer registers summary](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/timer_registers_summary.png)\n\nAccessing timer registers\n\n|       timer        | remarks                                                                                                              |\n| :----------------: | :------------------------------------------------------------------------------------------------------------------- |\n| PL1 physical timer | - secure mode<br>- Non-secure Hyp mode<br>- CNTHCTL.PL1PCEN=1, Non-secure PL1 mode<br> - CNTKCTL.PL0PTEN=1, PL0 mode |\n|   virtual timer    | secure, Non-secure PL1 mode, Hyp mode                                                                                |\n| PL2 physical timer | Non-secure Hyp mode, 或SCR.NS=1时 Secure Monitor                                                                     |\n\n在中断号上分配如下：\n\n| IRQ NUM | Remarks                               |\n| :-----: | :------------------------------------ |\n|   29    | physical timer in secure PL1 mode     |\n|   30    | physical timer in Non-secure PL1 mode |\n|   27    | virtual timer in Non-secure PL1 mode  |\n|   26    | physical timer in hyp mode            |\n\n### 6.1. CompareValue\nCompareValue 的操作可以看作是unsigned 64-bit up counter.\n\n<font color=red>Eventtriggered = (Counter[63:0] - Offset[63:0]) - CompareValue[63:0] >= 0 </font>\n\n|     术语     | 说明                                                                 |\n| :----------: | :------------------------------------------------------------------- |\n|   Counter    | physical counter, 读取CNTPCT，CNTVCT 寄存器                          |\n|    Offset    | 如果没有Virtualization Extension, offset=0, 反之，offset = <CNTVOFF> |\n| CompareValue | 比较值寄存器，CNTP_CVAL, CNTHP_CVAL, or CNTV_CVAL.                   |\n\n### 6.2. TimerValue\nTimerValue 的操作可以看作是signed 32-bit down counter.\n\n<font color=red>Eventtriggered = (TimerValue <= 0) </font>\n\nTimerValue 值来源于CNTP_TVAL, CNTHP_TVAL, or CNTV_TVAL.\n\n## 7. Generic Timer registers\n![generic timer registers](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/generic_timer_registers.png)\n\n\n## Reference\ncortex_a7_mpcore_r0p5_trm(arm_trm).pdf\narm_architecture_reference_manual(arm_arm).pdf\n\n[Linux时间子系统之（十七）：ARM generic timer 驱动分析](http://www.wowotech.net/timer_subsystem/armgeneraltimer.html)","slug":"arm-generic-timer","published":1,"updated":"2019-11-29T02:33:32.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pj0011zkgrnxajybqh","content":"<p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f3e81b7a10d5ad6ebef46cb8e0a252be/9922720e0cf3d7ca5a381fc8f91fbe096a63a945.jpg\" alt=\"\"></p>\n<p>通用定时器是基于累加计数硬件，可以用作schedule events或trigger interrupts. It provides:</p>\n<ul>\n<li>Generation of timer events as interrupt outputs.  </li>\n<li>Generation of event streams.  </li>\n<li>Support for Virtualization Extensions  </li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"1-Base\"><a href=\"#1-Base\" class=\"headerlink\" title=\"1. Base\"></a>1. Base</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/generic_timer.png\" alt=\"generic timer example\"></p>\n<p>The Generic Timer 提供如下几种counter与Timer：</p>\n<ul>\n<li><strong>system counter</strong>, measures the passing of time in real-time. </li>\n<li><strong>virtual counter</strong>(cpu support for virtualization), measure the passing of time on a particular virtual machine</li>\n<li><strong>timer</strong>, that can assert a timer output signal after a period of time has passed.</li>\n</ul>\n<h2 id=\"2-system-counter\"><a href=\"#2-system-counter\" class=\"headerlink\" title=\"2. system counter\"></a>2. system counter</h2><p>system counter规格如下</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">子项</th>\n<th style=\"text-align:left\">需求</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Width</td>\n<td style=\"text-align:left\">至少56bits 宽度，返回64-bit 是以0 进行扩展得到</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Frequency</td>\n<td style=\"text-align:left\">典型范围 1-50MHz. 在power-saving 时可以更低，例如500-20KHz</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Roll-over</td>\n<td style=\"text-align:left\">不少于40年</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Accuracy（精度）</td>\n<td style=\"text-align:left\">24Hours 误差不超过1s</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Start-up</td>\n<td style=\"text-align:left\">从0 开始累计</td>\n</tr>\n</tbody>\n</table>\n<p>可以通过CNTFRQ 设置/读取 frequency. </p>\n<h2 id=\"3-physical-counter\"><a href=\"#3-physical-counter\" class=\"headerlink\" title=\"3. physical counter\"></a>3. physical counter</h2><p>CNTPCT（64-bit） 寄存器存储了physical counter</p>\n<p>访问权限：</p>\n<ul>\n<li>secure PL1 mode, Non-secure Hyp mode</li>\n<li>Non-secure PL1 mode only when CNTHCTL.PL1PCTEN=1</li>\n</ul>\n<h2 id=\"4-virtual-counter\"><a href=\"#4-virtual-counter\" class=\"headerlink\" title=\"4. virtual counter\"></a>4. virtual counter</h2><p>在分两种情况：</p>\n<ul>\n<li>没有virtualization Extension时，virtual time 与physical time相同</li>\n<li>具备virtualization Extension，virtual counter里面的值等于physical counter减去 64-bit virtual offset.(<font color=\"green\">virtual_counter = physical_counter - virtual_offset</font>)</li>\n</ul>\n<p>CNTVCT 寄存器包含了virtual counter。 在Secure PL1 mode, Non-secure PL1, PL2 mode 下能访问。</p>\n<p>CNTVOFF 寄存器包含了virtual offset, 只有Hyp mode或在SCR.NS=1时，Monitor mode下访问。</p>\n<h2 id=\"5-Event-streams\"><a href=\"#5-Event-streams\" class=\"headerlink\" title=\"5. Event streams\"></a>5. Event streams</h2><p>Generic Timer 可以使用system counter 产生一个或多个event streams.</p>\n<p>Event stream 用处：</p>\n<ul>\n<li>产生超时on a Wait For Event polling loop</li>\n<li>确保expected event在一定时间内是否generated</li>\n</ul>\n<h2 id=\"6-Timer\"><a href=\"#6-Timer\" class=\"headerlink\" title=\"6. Timer\"></a>6. Timer</h2><p><strong>Security Extensions not implemented</strong><br>The implementation provides a physical timer and a virtual timer.</p>\n<p><strong>Security Extensions implemented, Virtualization Extensions not implemented</strong></p>\n<ul>\n<li>A Non-secure physical timer.  </li>\n<li>A Secure physical timer.  </li>\n<li>A virtual timer.</li>\n</ul>\n<p><strong>Virtualization Extensions implemented</strong></p>\n<font color=\"red\"><br>- A Non-secure PL1 physical timer.<br>- A Secure PL1 physical timer.<br>- A Non-secure PL2 physical timer.<br>- A virtual timer.<br><br></font>\n\n<p>Each timer is implemented as three registers:</p>\n<ul>\n<li>A 64-bit <strong>CompareValue register</strong>, that provides a 64-bit unsigned upcounter.  </li>\n<li>A 32-bit <strong>TimerValue register</strong>, that provides a 32-bit signed down counter.  </li>\n<li>A 32-bit <strong>Control register</strong>.</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/timer_registers_summary.png\" alt=\"timer registers summary\"></p>\n<p>Accessing timer registers</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">timer</th>\n<th style=\"text-align:left\">remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">PL1 physical timer</td>\n<td style=\"text-align:left\">- secure mode<br>- Non-secure Hyp mode<br>- CNTHCTL.PL1PCEN=1, Non-secure PL1 mode<br> - CNTKCTL.PL0PTEN=1, PL0 mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">virtual timer</td>\n<td style=\"text-align:left\">secure, Non-secure PL1 mode, Hyp mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PL2 physical timer</td>\n<td style=\"text-align:left\">Non-secure Hyp mode, 或SCR.NS=1时 Secure Monitor</td>\n</tr>\n</tbody>\n</table>\n<p>在中断号上分配如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">IRQ NUM</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">29</td>\n<td style=\"text-align:left\">physical timer in secure PL1 mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:left\">physical timer in Non-secure PL1 mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:left\">virtual timer in Non-secure PL1 mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">26</td>\n<td style=\"text-align:left\">physical timer in hyp mode</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"6-1-CompareValue\"><a href=\"#6-1-CompareValue\" class=\"headerlink\" title=\"6.1. CompareValue\"></a>6.1. CompareValue</h3><p>CompareValue 的操作可以看作是unsigned 64-bit up counter.</p>\n<font color=\"red\">Eventtriggered = (Counter[63:0] - Offset[63:0]) - CompareValue[63:0] &gt;= 0 </font>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">术语</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Counter</td>\n<td style=\"text-align:left\">physical counter, 读取CNTPCT，CNTVCT 寄存器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Offset</td>\n<td style=\"text-align:left\">如果没有Virtualization Extension, offset=0, 反之，offset = <cntvoff></cntvoff></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CompareValue</td>\n<td style=\"text-align:left\">比较值寄存器，CNTP_CVAL, CNTHP_CVAL, or CNTV_CVAL.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"6-2-TimerValue\"><a href=\"#6-2-TimerValue\" class=\"headerlink\" title=\"6.2. TimerValue\"></a>6.2. TimerValue</h3><p>TimerValue 的操作可以看作是signed 32-bit down counter.</p>\n<font color=\"red\">Eventtriggered = (TimerValue &lt;= 0) </font>\n\n<p>TimerValue 值来源于CNTP_TVAL, CNTHP_TVAL, or CNTV_TVAL.</p>\n<h2 id=\"7-Generic-Timer-registers\"><a href=\"#7-Generic-Timer-registers\" class=\"headerlink\" title=\"7. Generic Timer registers\"></a>7. Generic Timer registers</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/generic_timer_registers.png\" alt=\"generic timer registers\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>cortex_a7_mpcore_r0p5_trm(arm_trm).pdf<br>arm_architecture_reference_manual(arm_arm).pdf</p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/armgeneraltimer.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十七）：ARM generic timer 驱动分析</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f3e81b7a10d5ad6ebef46cb8e0a252be/9922720e0cf3d7ca5a381fc8f91fbe096a63a945.jpg\" alt=\"\"></p>\n<p>通用定时器是基于累加计数硬件，可以用作schedule events或trigger interrupts. It provides:</p>\n<ul>\n<li>Generation of timer events as interrupt outputs.  </li>\n<li>Generation of event streams.  </li>\n<li>Support for Virtualization Extensions  </li>\n</ul>","more":"<h2 id=\"1-Base\"><a href=\"#1-Base\" class=\"headerlink\" title=\"1. Base\"></a>1. Base</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/generic_timer.png\" alt=\"generic timer example\"></p>\n<p>The Generic Timer 提供如下几种counter与Timer：</p>\n<ul>\n<li><strong>system counter</strong>, measures the passing of time in real-time. </li>\n<li><strong>virtual counter</strong>(cpu support for virtualization), measure the passing of time on a particular virtual machine</li>\n<li><strong>timer</strong>, that can assert a timer output signal after a period of time has passed.</li>\n</ul>\n<h2 id=\"2-system-counter\"><a href=\"#2-system-counter\" class=\"headerlink\" title=\"2. system counter\"></a>2. system counter</h2><p>system counter规格如下</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">子项</th>\n<th style=\"text-align:left\">需求</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Width</td>\n<td style=\"text-align:left\">至少56bits 宽度，返回64-bit 是以0 进行扩展得到</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Frequency</td>\n<td style=\"text-align:left\">典型范围 1-50MHz. 在power-saving 时可以更低，例如500-20KHz</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Roll-over</td>\n<td style=\"text-align:left\">不少于40年</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Accuracy（精度）</td>\n<td style=\"text-align:left\">24Hours 误差不超过1s</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Start-up</td>\n<td style=\"text-align:left\">从0 开始累计</td>\n</tr>\n</tbody>\n</table>\n<p>可以通过CNTFRQ 设置/读取 frequency. </p>\n<h2 id=\"3-physical-counter\"><a href=\"#3-physical-counter\" class=\"headerlink\" title=\"3. physical counter\"></a>3. physical counter</h2><p>CNTPCT（64-bit） 寄存器存储了physical counter</p>\n<p>访问权限：</p>\n<ul>\n<li>secure PL1 mode, Non-secure Hyp mode</li>\n<li>Non-secure PL1 mode only when CNTHCTL.PL1PCTEN=1</li>\n</ul>\n<h2 id=\"4-virtual-counter\"><a href=\"#4-virtual-counter\" class=\"headerlink\" title=\"4. virtual counter\"></a>4. virtual counter</h2><p>在分两种情况：</p>\n<ul>\n<li>没有virtualization Extension时，virtual time 与physical time相同</li>\n<li>具备virtualization Extension，virtual counter里面的值等于physical counter减去 64-bit virtual offset.(<font color=\"green\">virtual_counter = physical_counter - virtual_offset</font>)</li>\n</ul>\n<p>CNTVCT 寄存器包含了virtual counter。 在Secure PL1 mode, Non-secure PL1, PL2 mode 下能访问。</p>\n<p>CNTVOFF 寄存器包含了virtual offset, 只有Hyp mode或在SCR.NS=1时，Monitor mode下访问。</p>\n<h2 id=\"5-Event-streams\"><a href=\"#5-Event-streams\" class=\"headerlink\" title=\"5. Event streams\"></a>5. Event streams</h2><p>Generic Timer 可以使用system counter 产生一个或多个event streams.</p>\n<p>Event stream 用处：</p>\n<ul>\n<li>产生超时on a Wait For Event polling loop</li>\n<li>确保expected event在一定时间内是否generated</li>\n</ul>\n<h2 id=\"6-Timer\"><a href=\"#6-Timer\" class=\"headerlink\" title=\"6. Timer\"></a>6. Timer</h2><p><strong>Security Extensions not implemented</strong><br>The implementation provides a physical timer and a virtual timer.</p>\n<p><strong>Security Extensions implemented, Virtualization Extensions not implemented</strong></p>\n<ul>\n<li>A Non-secure physical timer.  </li>\n<li>A Secure physical timer.  </li>\n<li>A virtual timer.</li>\n</ul>\n<p><strong>Virtualization Extensions implemented</strong></p>\n<font color=\"red\"><br>- A Non-secure PL1 physical timer.<br>- A Secure PL1 physical timer.<br>- A Non-secure PL2 physical timer.<br>- A virtual timer.<br><br></font>\n\n<p>Each timer is implemented as three registers:</p>\n<ul>\n<li>A 64-bit <strong>CompareValue register</strong>, that provides a 64-bit unsigned upcounter.  </li>\n<li>A 32-bit <strong>TimerValue register</strong>, that provides a 32-bit signed down counter.  </li>\n<li>A 32-bit <strong>Control register</strong>.</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/timer_registers_summary.png\" alt=\"timer registers summary\"></p>\n<p>Accessing timer registers</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">timer</th>\n<th style=\"text-align:left\">remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">PL1 physical timer</td>\n<td style=\"text-align:left\">- secure mode<br>- Non-secure Hyp mode<br>- CNTHCTL.PL1PCEN=1, Non-secure PL1 mode<br> - CNTKCTL.PL0PTEN=1, PL0 mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">virtual timer</td>\n<td style=\"text-align:left\">secure, Non-secure PL1 mode, Hyp mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PL2 physical timer</td>\n<td style=\"text-align:left\">Non-secure Hyp mode, 或SCR.NS=1时 Secure Monitor</td>\n</tr>\n</tbody>\n</table>\n<p>在中断号上分配如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">IRQ NUM</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">29</td>\n<td style=\"text-align:left\">physical timer in secure PL1 mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:left\">physical timer in Non-secure PL1 mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:left\">virtual timer in Non-secure PL1 mode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">26</td>\n<td style=\"text-align:left\">physical timer in hyp mode</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"6-1-CompareValue\"><a href=\"#6-1-CompareValue\" class=\"headerlink\" title=\"6.1. CompareValue\"></a>6.1. CompareValue</h3><p>CompareValue 的操作可以看作是unsigned 64-bit up counter.</p>\n<font color=\"red\">Eventtriggered = (Counter[63:0] - Offset[63:0]) - CompareValue[63:0] &gt;= 0 </font>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">术语</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Counter</td>\n<td style=\"text-align:left\">physical counter, 读取CNTPCT，CNTVCT 寄存器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Offset</td>\n<td style=\"text-align:left\">如果没有Virtualization Extension, offset=0, 反之，offset = <cntvoff></cntvoff></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CompareValue</td>\n<td style=\"text-align:left\">比较值寄存器，CNTP_CVAL, CNTHP_CVAL, or CNTV_CVAL.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"6-2-TimerValue\"><a href=\"#6-2-TimerValue\" class=\"headerlink\" title=\"6.2. TimerValue\"></a>6.2. TimerValue</h3><p>TimerValue 的操作可以看作是signed 32-bit down counter.</p>\n<font color=\"red\">Eventtriggered = (TimerValue &lt;= 0) </font>\n\n<p>TimerValue 值来源于CNTP_TVAL, CNTHP_TVAL, or CNTV_TVAL.</p>\n<h2 id=\"7-Generic-Timer-registers\"><a href=\"#7-Generic-Timer-registers\" class=\"headerlink\" title=\"7. Generic Timer registers\"></a>7. Generic Timer registers</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/arm-generic-timer/generic_timer_registers.png\" alt=\"generic timer registers\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>cortex_a7_mpcore_r0p5_trm(arm_trm).pdf<br>arm_architecture_reference_manual(arm_arm).pdf</p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/armgeneraltimer.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十七）：ARM generic timer 驱动分析</a></p>"},{"title":"boot_time_optimization","date":"2020-04-09T09:26:48.000Z","_content":"\n从uboot 的引导到kenrel，以及之后的init 进程的运行，中间耗费的时间，当然越短越是理想。\n\n<!--more-->\n\n## 1. Method\n常见的方法有：\n- grabserial: add timestamps to all serial console output\n- bootgraph: measuring time of kernel functions\n- bootchart: measuring time of user-space processes\n\n## 2. Kernel optimization\nkernel 启动优化的建议, 主要是：越少的模块，打印更少。\n- `quiet` boot argument\n- slim down useless driers file system\n- slim down device tree by removing hardware interfaces that not used\n\n[bootgraph](https://jshell07.github.io/2020/04/09/bootgraph/)\n\n## 3. user-space processes optimization\n用户空间优化建议：\n- apps startup or running order(应用执行顺序，进程之间可能有等待资源情况)\n- build optimization e.g. compile flags\n- library optimizations to reduce load time\n\n[bootchart](https://jshell07.github.io/2020/04/09/bootchart/)\n\n## Reference\n[A Pragmatic Guide to Boot-Time Optimization - Chris Simmonds, Consultant](https://www.bilibili.com/video/BV1y4411X7e2)\n\n[LPC_2019_kernel_fastboot_on_the_way.pdf](https://linuxplumbersconf.org/event/4/contributions/281/attachments/216/617/LPC_2019_kernel_fastboot_on_the_way.pdf)\n\n[Linux kernel fastboot on the way](https://linuxplumbersconf.org/event/4/contributions/281/)","source":"_posts/boot-time-optimization.md","raw":"---\ntitle: boot_time_optimization\ndate: 2020-04-09 17:26:48\ntags: boot_time\ncategories: tools\n---\n\n从uboot 的引导到kenrel，以及之后的init 进程的运行，中间耗费的时间，当然越短越是理想。\n\n<!--more-->\n\n## 1. Method\n常见的方法有：\n- grabserial: add timestamps to all serial console output\n- bootgraph: measuring time of kernel functions\n- bootchart: measuring time of user-space processes\n\n## 2. Kernel optimization\nkernel 启动优化的建议, 主要是：越少的模块，打印更少。\n- `quiet` boot argument\n- slim down useless driers file system\n- slim down device tree by removing hardware interfaces that not used\n\n[bootgraph](https://jshell07.github.io/2020/04/09/bootgraph/)\n\n## 3. user-space processes optimization\n用户空间优化建议：\n- apps startup or running order(应用执行顺序，进程之间可能有等待资源情况)\n- build optimization e.g. compile flags\n- library optimizations to reduce load time\n\n[bootchart](https://jshell07.github.io/2020/04/09/bootchart/)\n\n## Reference\n[A Pragmatic Guide to Boot-Time Optimization - Chris Simmonds, Consultant](https://www.bilibili.com/video/BV1y4411X7e2)\n\n[LPC_2019_kernel_fastboot_on_the_way.pdf](https://linuxplumbersconf.org/event/4/contributions/281/attachments/216/617/LPC_2019_kernel_fastboot_on_the_way.pdf)\n\n[Linux kernel fastboot on the way](https://linuxplumbersconf.org/event/4/contributions/281/)","slug":"boot-time-optimization","published":1,"updated":"2020-04-09T10:24:25.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pl0015zkgr4jrjnjvm","content":"<p>从uboot 的引导到kenrel，以及之后的init 进程的运行，中间耗费的时间，当然越短越是理想。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-Method\"><a href=\"#1-Method\" class=\"headerlink\" title=\"1. Method\"></a>1. Method</h2><p>常见的方法有：</p>\n<ul>\n<li>grabserial: add timestamps to all serial console output</li>\n<li>bootgraph: measuring time of kernel functions</li>\n<li>bootchart: measuring time of user-space processes</li>\n</ul>\n<h2 id=\"2-Kernel-optimization\"><a href=\"#2-Kernel-optimization\" class=\"headerlink\" title=\"2. Kernel optimization\"></a>2. Kernel optimization</h2><p>kernel 启动优化的建议, 主要是：越少的模块，打印更少。</p>\n<ul>\n<li><code>quiet</code> boot argument</li>\n<li>slim down useless driers file system</li>\n<li>slim down device tree by removing hardware interfaces that not used</li>\n</ul>\n<p><a href=\"https://jshell07.github.io/2020/04/09/bootgraph/\" target=\"_blank\" rel=\"noopener\">bootgraph</a></p>\n<h2 id=\"3-user-space-processes-optimization\"><a href=\"#3-user-space-processes-optimization\" class=\"headerlink\" title=\"3. user-space processes optimization\"></a>3. user-space processes optimization</h2><p>用户空间优化建议：</p>\n<ul>\n<li>apps startup or running order(应用执行顺序，进程之间可能有等待资源情况)</li>\n<li>build optimization e.g. compile flags</li>\n<li>library optimizations to reduce load time</li>\n</ul>\n<p><a href=\"https://jshell07.github.io/2020/04/09/bootchart/\" target=\"_blank\" rel=\"noopener\">bootchart</a></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.bilibili.com/video/BV1y4411X7e2\" target=\"_blank\" rel=\"noopener\">A Pragmatic Guide to Boot-Time Optimization - Chris Simmonds, Consultant</a></p>\n<p><a href=\"https://linuxplumbersconf.org/event/4/contributions/281/attachments/216/617/LPC_2019_kernel_fastboot_on_the_way.pdf\" target=\"_blank\" rel=\"noopener\">LPC_2019_kernel_fastboot_on_the_way.pdf</a></p>\n<p><a href=\"https://linuxplumbersconf.org/event/4/contributions/281/\" target=\"_blank\" rel=\"noopener\">Linux kernel fastboot on the way</a></p>\n","site":{"data":{}},"excerpt":"<p>从uboot 的引导到kenrel，以及之后的init 进程的运行，中间耗费的时间，当然越短越是理想。</p>","more":"<h2 id=\"1-Method\"><a href=\"#1-Method\" class=\"headerlink\" title=\"1. Method\"></a>1. Method</h2><p>常见的方法有：</p>\n<ul>\n<li>grabserial: add timestamps to all serial console output</li>\n<li>bootgraph: measuring time of kernel functions</li>\n<li>bootchart: measuring time of user-space processes</li>\n</ul>\n<h2 id=\"2-Kernel-optimization\"><a href=\"#2-Kernel-optimization\" class=\"headerlink\" title=\"2. Kernel optimization\"></a>2. Kernel optimization</h2><p>kernel 启动优化的建议, 主要是：越少的模块，打印更少。</p>\n<ul>\n<li><code>quiet</code> boot argument</li>\n<li>slim down useless driers file system</li>\n<li>slim down device tree by removing hardware interfaces that not used</li>\n</ul>\n<p><a href=\"https://jshell07.github.io/2020/04/09/bootgraph/\" target=\"_blank\" rel=\"noopener\">bootgraph</a></p>\n<h2 id=\"3-user-space-processes-optimization\"><a href=\"#3-user-space-processes-optimization\" class=\"headerlink\" title=\"3. user-space processes optimization\"></a>3. user-space processes optimization</h2><p>用户空间优化建议：</p>\n<ul>\n<li>apps startup or running order(应用执行顺序，进程之间可能有等待资源情况)</li>\n<li>build optimization e.g. compile flags</li>\n<li>library optimizations to reduce load time</li>\n</ul>\n<p><a href=\"https://jshell07.github.io/2020/04/09/bootchart/\" target=\"_blank\" rel=\"noopener\">bootchart</a></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.bilibili.com/video/BV1y4411X7e2\" target=\"_blank\" rel=\"noopener\">A Pragmatic Guide to Boot-Time Optimization - Chris Simmonds, Consultant</a></p>\n<p><a href=\"https://linuxplumbersconf.org/event/4/contributions/281/attachments/216/617/LPC_2019_kernel_fastboot_on_the_way.pdf\" target=\"_blank\" rel=\"noopener\">LPC_2019_kernel_fastboot_on_the_way.pdf</a></p>\n<p><a href=\"https://linuxplumbersconf.org/event/4/contributions/281/\" target=\"_blank\" rel=\"noopener\">Linux kernel fastboot on the way</a></p>"},{"title":"bootchart","date":"2020-04-09T09:35:24.000Z","_content":"\nbootchart 主要用于量度user-space processess 启动顺序及时间， 但是它的时间单位粒度其实有点大。\n\n<!--more-->\n\n## 1. Prepare\n### 1.1. 平台支持bootchartd 命令\n配置busybox，使其支持bootchartd 命令，用于抓取log。\n\n![busybox_config_bootchartd](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/busybox_config_bootchartd.png)\n\n### 1.2. 启动参数设定\n\n```bash\nbootargs = \"init=/sbin/bootchartd\"\n```\n\n### 1.3. Host tools\n用于解析抓取到日志文件： [bootchart2-0.14.8.tar.bz2](https://github.com/xrmx/bootchart/releases/download/0.14.8/bootchart2-0.14.8.tar.bz2)\n\n在PC 上编译并安装：\n```bash\nmake install\n```\n\n## 2. Usage\n在platform 正常启动后，我们可以在<font color=red>/var/log/bootlog.tgz</font> 找到bootchartd抓取到的LOG。\n\n![bootchartd_log](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/bootchartd_log.png)\n\n将抓取到LOG 用host 上tools 运行， 并在当前路径下生成图片：\n\n```bash\n/bootchart2-0.14.8/pybootchartgui.py bootlog.tgz\n```\n\n## 3. Example\n[bootlog.tgz](https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/bootlog.tgz)\n\n![boot_chart_example](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/boot_chart_example.png)\n\n## Reference\n[bootchart](https://elinux.org/Bootchart)\n[bootchart2-tools](https://github.com/xrmx/bootchart/releases)","source":"_posts/bootchart.md","raw":"---\ntitle: bootchart\ndate: 2020-04-09 17:35:24\ntags: optimization\ncategories: tools\n---\n\nbootchart 主要用于量度user-space processess 启动顺序及时间， 但是它的时间单位粒度其实有点大。\n\n<!--more-->\n\n## 1. Prepare\n### 1.1. 平台支持bootchartd 命令\n配置busybox，使其支持bootchartd 命令，用于抓取log。\n\n![busybox_config_bootchartd](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/busybox_config_bootchartd.png)\n\n### 1.2. 启动参数设定\n\n```bash\nbootargs = \"init=/sbin/bootchartd\"\n```\n\n### 1.3. Host tools\n用于解析抓取到日志文件： [bootchart2-0.14.8.tar.bz2](https://github.com/xrmx/bootchart/releases/download/0.14.8/bootchart2-0.14.8.tar.bz2)\n\n在PC 上编译并安装：\n```bash\nmake install\n```\n\n## 2. Usage\n在platform 正常启动后，我们可以在<font color=red>/var/log/bootlog.tgz</font> 找到bootchartd抓取到的LOG。\n\n![bootchartd_log](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/bootchartd_log.png)\n\n将抓取到LOG 用host 上tools 运行， 并在当前路径下生成图片：\n\n```bash\n/bootchart2-0.14.8/pybootchartgui.py bootlog.tgz\n```\n\n## 3. Example\n[bootlog.tgz](https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/bootlog.tgz)\n\n![boot_chart_example](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/boot_chart_example.png)\n\n## Reference\n[bootchart](https://elinux.org/Bootchart)\n[bootchart2-tools](https://github.com/xrmx/bootchart/releases)","slug":"bootchart","published":1,"updated":"2020-04-09T10:20:52.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pn0017zkgr7mk9ri09","content":"<p>bootchart 主要用于量度user-space processess 启动顺序及时间， 但是它的时间单位粒度其实有点大。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-Prepare\"><a href=\"#1-Prepare\" class=\"headerlink\" title=\"1. Prepare\"></a>1. Prepare</h2><h3 id=\"1-1-平台支持bootchartd-命令\"><a href=\"#1-1-平台支持bootchartd-命令\" class=\"headerlink\" title=\"1.1. 平台支持bootchartd 命令\"></a>1.1. 平台支持bootchartd 命令</h3><p>配置busybox，使其支持bootchartd 命令，用于抓取log。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/busybox_config_bootchartd.png\" alt=\"busybox_config_bootchartd\"></p>\n<h3 id=\"1-2-启动参数设定\"><a href=\"#1-2-启动参数设定\" class=\"headerlink\" title=\"1.2. 启动参数设定\"></a>1.2. 启动参数设定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bootargs = <span class=\"string\">\"init=/sbin/bootchartd\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-Host-tools\"><a href=\"#1-3-Host-tools\" class=\"headerlink\" title=\"1.3. Host tools\"></a>1.3. Host tools</h3><p>用于解析抓取到日志文件： <a href=\"https://github.com/xrmx/bootchart/releases/download/0.14.8/bootchart2-0.14.8.tar.bz2\" target=\"_blank\" rel=\"noopener\">bootchart2-0.14.8.tar.bz2</a></p>\n<p>在PC 上编译并安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make install</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-Usage\"><a href=\"#2-Usage\" class=\"headerlink\" title=\"2. Usage\"></a>2. Usage</h2><p>在platform 正常启动后，我们可以在<font color=\"red\">/var/log/bootlog.tgz</font> 找到bootchartd抓取到的LOG。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/bootchartd_log.png\" alt=\"bootchartd_log\"></p>\n<p>将抓取到LOG 用host 上tools 运行， 并在当前路径下生成图片：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bootchart2-0.14.8/pybootchartgui.py bootlog.tgz</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-Example\"><a href=\"#3-Example\" class=\"headerlink\" title=\"3. Example\"></a>3. Example</h2><p><a href=\"https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/bootlog.tgz\" target=\"_blank\" rel=\"noopener\">bootlog.tgz</a></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/boot_chart_example.png\" alt=\"boot_chart_example\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://elinux.org/Bootchart\" target=\"_blank\" rel=\"noopener\">bootchart</a><br><a href=\"https://github.com/xrmx/bootchart/releases\" target=\"_blank\" rel=\"noopener\">bootchart2-tools</a></p>\n","site":{"data":{}},"excerpt":"<p>bootchart 主要用于量度user-space processess 启动顺序及时间， 但是它的时间单位粒度其实有点大。</p>","more":"<h2 id=\"1-Prepare\"><a href=\"#1-Prepare\" class=\"headerlink\" title=\"1. Prepare\"></a>1. Prepare</h2><h3 id=\"1-1-平台支持bootchartd-命令\"><a href=\"#1-1-平台支持bootchartd-命令\" class=\"headerlink\" title=\"1.1. 平台支持bootchartd 命令\"></a>1.1. 平台支持bootchartd 命令</h3><p>配置busybox，使其支持bootchartd 命令，用于抓取log。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/busybox_config_bootchartd.png\" alt=\"busybox_config_bootchartd\"></p>\n<h3 id=\"1-2-启动参数设定\"><a href=\"#1-2-启动参数设定\" class=\"headerlink\" title=\"1.2. 启动参数设定\"></a>1.2. 启动参数设定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bootargs = <span class=\"string\">\"init=/sbin/bootchartd\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-Host-tools\"><a href=\"#1-3-Host-tools\" class=\"headerlink\" title=\"1.3. Host tools\"></a>1.3. Host tools</h3><p>用于解析抓取到日志文件： <a href=\"https://github.com/xrmx/bootchart/releases/download/0.14.8/bootchart2-0.14.8.tar.bz2\" target=\"_blank\" rel=\"noopener\">bootchart2-0.14.8.tar.bz2</a></p>\n<p>在PC 上编译并安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make install</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-Usage\"><a href=\"#2-Usage\" class=\"headerlink\" title=\"2. Usage\"></a>2. Usage</h2><p>在platform 正常启动后，我们可以在<font color=\"red\">/var/log/bootlog.tgz</font> 找到bootchartd抓取到的LOG。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/bootchartd_log.png\" alt=\"bootchartd_log\"></p>\n<p>将抓取到LOG 用host 上tools 运行， 并在当前路径下生成图片：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bootchart2-0.14.8/pybootchartgui.py bootlog.tgz</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-Example\"><a href=\"#3-Example\" class=\"headerlink\" title=\"3. Example\"></a>3. Example</h2><p><a href=\"https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/bootlog.tgz\" target=\"_blank\" rel=\"noopener\">bootlog.tgz</a></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/boot_chart_example.png\" alt=\"boot_chart_example\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://elinux.org/Bootchart\" target=\"_blank\" rel=\"noopener\">bootchart</a><br><a href=\"https://github.com/xrmx/bootchart/releases\" target=\"_blank\" rel=\"noopener\">bootchart2-tools</a></p>"},{"title":"arm arm","date":"2019-05-28T05:55:44.000Z","_content":"\n## Part A. Application Level Architecture\n---\n### A1. Introduction to the ARM Architecture\n---\n<!--more-->\n\n#### A1.4 Architecture extensions\n__Jazelle__\nIs the Java bytecode execution extension that extended ARMv5TE to ARMv5TEJ. From\nARMv6, the architecture requires at least the trivial Jazelle implementation, but a Jazelle\nimplementation is still often described as a Jazelle extension.\nThe Virtualization Extensions require that the Jazelle implementation is the trivial Jazelle\nimplementation.\n\n__ThumbEE__\nIs an extension that provides the ThumbEE instruction set, a variant of the Thumb\ninstruction set that is designed as a target for dynamically generated code. In the original\nrelease of the ARMv7 architecture, the ThumbEE extension was:\n• A required extension to the ARMv7-A profile.\n• An optional extension to the ARMv7-R profile.\n\nFrom publication of issue C.a of this manual, ARM deprecates any use of ThumbEE\ninstructions. However, ARMv7-A implementations must continue to include ThumbEE\nsupport, for backwards compatibility.\n\n__Floating-point__\nIs a floating-point coprocessor extension to the instruction set architectures. For historic\nreasons, the Floating-point Extension is also called the VFP Extension. \n\n__Advanced SIMD__\nIs an instruction set extension that provides Single Instruction Multiple Data (SIMD)\ninteger and single-precision floating-point vector operations on doubleword and quadword\nregisters.\t\n\n### A1.4.2 Architecture extensions\nThis manual also describes the following extensions to the ARMv7 architecture:\n__Security Extensions__\n\n__Multiprocessing Extensions__\nAre an OPTIONAL set of extensions to the ARMv7-A and ARMv7-R profiles, that provides a set of\nfeatures that enhance multiprocessing functionality.\n\n__Large Physical Address Extension__\nIs an OPTIONAL extension to VMSAv7 that provides an address translation system supporting\nphysical addresses of up to 40 bits at a fine grain of translation.\nThe Large Physical Address Extension requires implementation of the Multiprocessing Extensions.\n\n__Virtualization Extensions__\nAre an OPTIONAL set of extensions to VMSAv7 that provides hardware support for virtualizing the\nNon-secure state of a VMSAv7 implementation. This supports system use of a virtual machine\nmonitor, also called a hypervisor.\n\n__Generic Timer Extension__\nIs an OPTIONAL extension to any ARMv7-A or ARMv7-R, that provides a system timer, and a\nlow-latency register interface to it.\n\n__Performance Monitors Extension__\nThe ARMv7 architecture:\n• reserves CP15 register space for IMPLEMENTATION DEFINED performance monitors\n• defines a recommended performance monitors implementation.\n\n---\n### A2. Application Level Programmers’ Model\n#### A2.1 About the Application level programmers’ model\nDepending on the implemented architecture extensions, the architecture supports multiple levels of execution\nprivilege, that number upwards from PL0, where PL0 is the lowest privilege level and is often described as\nunprivileged.\n\nWhen an operating system supports execution at both PL1 and PL0, an application usually runs unprivileged. This:\n• permits the operating system to __allocate system resources__ to an application in a unique or shared manner\n• provides __a degree of protection from other processes and tasks__, and so helps protect the operating system\nfrom malfunctioning applications.\n\n#### A2.2 ARM core data types and arithmetic\nAll ARMv7-A and ARMv7-R processors support the following data types in memory:\nByte           8 bits\nHalfword       16 bits\nWord           32 bits\nDoubleword     64 bits.\n\nProcessor registers are 32 bits in size. The instruction set contains instructions supporting the following data types\nheld in registers:\n• 32-bit pointers\n• unsigned or signed 32-bit integers\n• unsigned 16-bit or 8-bit integers, held in zero-extended form\n• signed 16-bit or 8-bit integers, held in sign-extended form\n• two 16-bit integers packed into a register\n• four 8-bit integers packed into a register\n• unsigned or signed 64-bit integers held in two registers.\n\n#### A2.3 ARM core registers\nIn the application level view, an ARM processor has:\n• thirteen general-purpose 32-bit registers, R0 to R12\n• three 32-bit registers with special uses, SP, LR, and PC, that can be described as R13 to R15.\nThe special registers are:\n__SP, the stack pointer__\nThe processor uses SP as a pointer to the active stack.\nIn the Thumb instruction set, most instructions cannot access SP. The only instructions that can\naccess SP are those designed to use SP as a stack pointer.\nThe ARM instruction set provides more general access to the SP, and it can be used as a\ngeneral-purpose register. However, ARM deprecates the use of SP for any purpose other than as a\nstack pointer.Software can refer to SP as R13.\n\n__LR, the link register__\nThe link register is a special register that can hold return link information. Some cases described in\nthis manual require this use of the LR. When software does not require the LR for linking, it can use\nit for other purposes. It can refer to LR as R14.\n\n__PC, the program counter__\n• When executing an ARM instruction, PC reads as the address of the current instruction plus 8.（PC始终指向你要取的指令的地址。ARM三级流水线，下一条指令是包含了预取指令，执行指令）\n• When executing a Thumb instruction, PC reads as the address of the current instruction plus 4.\n• Writing an address to PC causes a branch to that address.\nMost Thumb instructions cannot access PC.\nThe ARM instruction set provides more general access to the PC, and many ARM instructions can\nuse the PC as a general-purpose register. However, ARM deprecates the use of PC for any purpose\nother than as the program counter. Software can refer to PC as R15.\n\n##### A2.3.1 Writing to the PC\nIn ARMv7, many data-processing instructions can write to the PC. Writes to the PC are handled as follows:\n• The B, BL, CBNZ, CBZ, CHKA, HB, HBL, HBLP, HBP, TBB, and TBH instructions remain in the same instruction set state\nand branch to the value written to the PC.\nThe definition of each of these instructions ensures that the value written to the PC is correctly aligned for\nthe current instruction set state.\n\n• The BLX (immediate) instruction switches between ARM and Thumb states and branches to the value written\nto the PC. Its definition ensures that the value written to the PC is correctly aligned for the new instruction\nset state.\n\n• The following instructions write a value to the PC, treating that value as an interworking address to branch\nto, with low-order bits that determine the new instruction set state:\n\t— BLX (register), BX, and BXJ\n\t— LDR instructions with <Rt> equal to the PC\n\t— POP and all forms of LDM except LDM (exception return), when the register list includes the PC\n\t— in ARM state only, ADC, ADD, ADR, AND, ASR (immediate), BIC, EOR, LSL (immediate), LSR (immediate), MOV,\n\t\tMVN, ORR, ROR (immediate), RRX, RSB, RSC, SBC, and SUB instructions with <Rd> equal to the PC and without\n\t\tflag-setting specified.\n\n#### A2.4 The Application Program Status Register (APSR)\nFixme [APSR] Page49\n\n• Bits that can be set by many instructions:\n— The Condition flags:\n\tN, bit[31] Negative condition flag. Set to bit[31] of the result of the instruction. If the result is\n\tregarded as a two's complement signed integer, then the processor sets N to 1 if the result\n\tis negative, and sets N to 0 if it is positive or zero.\n\tZ, bit[30] Zero condition flag. Set to 1 if the result of the instruction is zero, and to 0 otherwise. A\n\tresult of zero often indicates an equal result from a comparison.\n\tC, bit[29] Carry condition flag. Set to 1 if the instruction results in a carry condition, for example an\n\tunsigned overflow on an addition.\n\tV, bit[28] Overflow condition flag. Set to 1 if the instruction results in an overflow condition, for\n\texample a signed overflow on an addition.\n\n— The Overflow or saturation flag:\n\tQ, bit[27] Set to 1 to indicate overflow or saturation occurred in some instructions, normally related\n\tto digital signal processing (DSP). For more information, see Pseudocode details of\n\tsaturation on page A2-44.\n\n— The Greater than or Equal flags:\n\tGE[3:0], bits[19:16]\n\tThe instructions described in Parallel addition and subtraction instructions on\n\tpage A4-171 update these flags to indicate the results from individual bytes or halfwords\n\tof the operation. These flags can control a later SEL instruction. For more information, see\n\tSEL on page A8-602.\n\nIn ARMv7-A and ARMv7-R, the APSR is the same register as the CPSR, but the APSR must be used only to access\nthe N, Z, C, V, Q, and GE[3:0] bits.\n\n#### A2.5 Execution state registers\nThe execution state registers modify the execution of instructions. They control:\n• Whether instructions are interpreted as Thumb instructions, ARM instructions, ThumbEE instructions, or\nJava bytecodes. For more information, see Instruction set state register, ISETSTATE.\n\n• In Thumb state and ThumbEE state only, the condition codes that apply to the next one to four instructions.\nFor more information, see IT block state register, ITSTATE on page A2-51.\n\n• Whether data is interpreted as big-endian or little-endian. For more information, see Endianness mapping\nregister, ENDIANSTATE on page A2-53.\n\nIn ARMv7-A and ARMv7-R, the execution state registers are part of the Current Program Status Register. For more\ninformation, see Program Status Registers (PSRs) on page B1-1147.\n\n##### A2.5.1 Instruction set state register, ISETSTATE\nThe instruction set state register, ISETSTATE, format is:\nThe J bit and the T bit determine the current instruction set state for the processor. Table A2-1 shows the encoding\nof these bits.\n\nFixme [Table A2-1 J and T bit encoding in ISETSTATE]Page50\n\n##### A2.5.2 IT block state register, ITSTATE\nFixme [Table A2-2 Effect of IT execution state bits]Page52\n\n##### A2.5.3 Endianness mapping register, ENDIANSTATE\nFixme [Table A2-3 ENDIANSTATE encoding of endianness]Page53\n\n\n#### A2.6 Advanced SIMD and Floating-point Extensions\nAdvanced SIMD and Floating-point (VFP) are two OPTIONAL extensions to ARMv7.\n\nThe Advanced SIMD Extension performs packed Single Instruction Multiple Data (SIMD) operations, either\ninteger or single-precision floating-point.\n\n....\n\n\n#### A2.11 Jazelle direct bytecode execution support\nThe Jazelle extension provides architectural support for hardware acceleration of bytecode execution by a Java Virtual\nMachine (JVM).\n\nThese requirements for the Jazelle extension mean a JVM can be written to both:\n• function correctly on all processors that include a Jazelle extension implementation\n• automatically take advantage of the accelerated bytecode execution provided by a processor that includes a\nnon-trivial implementation.\n\nThe required features of a non-trivial implementation are:\n• provision of the Jazelle state\n• a new instruction, BXJ, to enter Jazelle state\n• system support that enables an operating system to regulate the use of the Jazelle extension hardware\n• system support that enables a JVM to configure the Jazelle extension hardware to its specific needs.\n\n...\n\n### A3 Application Level Memory Model\n\n...\n\n#### A3.2 Alignment support\nInstructions in the ARM architecture are aligned as follows:\n• ARM instructions are word-aligned\n• Thumb and ThumbEE instructions are halfword-aligned\n• Java bytecodes are byte-aligned.\nIn the ARMv7 architecture, some load and store instructions support unaligned data accesses, as described in\nUnaligned data access.\n\n##### A3.2.1 Unaligned data access\nAn ARMv7 implementation must support unaligned data accesses to Normal memory by some load and store\ninstructions. __Software can set the SCTLR.A bit to control whether a misaligned access to Normal memory by one of these instructions causes an Alignment fault Data Abort exception.__\n\n__Unaligned access operations must not be used for accessing memory-mapped registers in a Device or Strongly-ordered memory region.__\n\nFixme [Table A3-1 Alignment requirements of load/store instructions]  page108\n\n#### A3.3 Endian support\nData support big-endian or little-endian.\n\n##### A3.3.1 Instruction endianness\n__In ARMv7-A, the mapping of instruction memory is always little-endian__. In ARMv7-R, instruction endianness can\nbe controlled at the system level, In ARMv7-A, the mapping of instruction memory is always little-endian. In ARMv7-R, instruction endianness can be controlled at the system level, see Instruction endianness static configuration, ARMv7-R only on page A3-112.\n\n##### A3.3.2 Element size and endianness\n\nFixme [Table A3-2 Element size of load/store instructions] page112\n\n##### A3.3.4 Endianness in Advanced SIMD\nAdvanced SIMD element load/store instructions transfer vectors of elements between memory and the Advanced\nSIMD register bank.An instruction specifies both the length of the transfer and the size of the data elements being\ntransferred. This information is used by the processor to load and store data correctly in both big-endian and\nlittle-endian systems.\n\n处理器根据提供的信息，能保证在Advanced SIMD register bank 中的数据是一样的，不论它是否是大端，小端\nFixme [Figure A3-2 Advanced SIMD byte order example] page113\n\n#### A3.4 Synchronization and semaphores\nIn architecture versions before ARMv6, support for the synchronization of shared memory depends on the SWP and\nSWPB instructions.These are read-locked-write operations that swap register contents with memory, and are\ndescribed in SWP, SWPB on page A8-722. These instructions support basic busy/free semaphore mechanisms, but\ndo not support mechanisms that require calculation to be performed on the semaphore between the read and write\nphases.\n\nARMv7 extends support for\nthis mechanism, and provides the following synchronization primitives in the ARM and Thumb instruction sets:\n• Load-Exclusives:\n\t— LDREX, see LDREX on page A8-432\n\t— LDREXB, see LDREXB on page A8-434\n\t— LDREXD, see LDREXD on page A8-436\n\t— LDREXH, see LDREXH on page A8-438\n• Store-Exclusives:\n\t— STREX, see STREX on page A8-690\n\t— STREXB, see STREXB on page A8-692\n\t— STREXD, see STREXD on page A8-694\n\t— STREXH, see STREXH on page A8-696\n• Clear-Exclusive, CLREX, see CLREX on page A8-360.\n\nNote\n• ARM strongly recommends that all software uses the synchronization primitives described in this section,\nrather than SWP or SWPB.\n\n##### A3.4.1 Exclusive access instructions and Non-shareable memory regions\nFor memory regions that do not have the Shareable attribute, the exclusive access instructions __rely on a local monitor that tags any address__ from which the processor executes a Load-Exclusive. Any non-aborted attempt by the\nsame processor to use a Store-Exclusive to modify any address is guaranteed to clear the tag.\n\nA Load-Exclusive performs a load from memory, and:\n• the executing processor tags the physical memory address for exclusive access\n• the local monitor of the executing processor transitions to the Exclusive Access state.\n\nA Store-Exclusive performs a conditional store to memory, that depends on the state of the local monitor:\n__If the local monitor is in the Exclusive Access state__\n\t• If the address of the Store-Exclusive is the same as the address that has been tagged in the\n\tmonitor by an earlier Load-Exclusive, then the store occurs, otherwise it is IMPLEMENTATION\n\tDEFINED whether the store occurs.\n\t• A status value is returned to a register:\n\t\t— if the store took place the status value is 0\n\t\t— otherwise, the status value is 1.\n\t• The local monitor of the executing processor transitions to the Open Access state.\n__If the local monitor is in the Open Access state__\n\t• no store takes place\n\t• a status value of 1 is returned to a register.\n\t• the local monitor remains in the Open Access state.\n\nFixme [Figure A3-3 Local monitor state machine diagram]Page 116\t\n\nFixme [Table A3-3 Effect of Exclusive instructions and write operations on the local monitor]Page 116\n\n\n##### A3.4.2 Exclusive access instructions and Shareable memory regions\nFor memory regions that have the Shareable attribute, exclusive access instructions rely on:\n• __A local monitor for each processor in the system__, that tags any address from which the processor executes a\nLoad-Exclusive. The local monitor can ignore accesses from other processors in the system.\n\n• __A global monitor that tags a physical address as exclusive access for a particular processor__. This tag is used\nlater to determine whether a Store-Exclusive to that address that has not been failed by the local monitor can\noccur. Any successful write to the tagged address by any other observer in the shareability domain of the\nmemory location is guaranteed to clear the tag. For each processor in the system, the global monitor:\n\t— can hold at least one tagged address\n\t— maintains a state machine for each tagged address it can hold.\n\n__Operation of the global monitor__\nA Load-Exclusive from Shareable memory performs a load from memory, and causes the __physical address of the access to be tagged as exclusive access for the requesting processor.__ This access also causes the exclusive access tag to be removed from any other physical address that has been tagged by the requesting processor.\n\nThe global monitor only supports a single outstanding exclusive access to Shareable memory per processor. A\nLoad-Exclusive by one processor has no effect on the global monitor state for any other processor.\n\nFixme [Table A3-4 Effect of load/store operations on global monitor for processor(n)] Page120\n\n\n##### A3.4.3 Tagging and the size of the tagged memory block\nTagged_address = Memory_address[31:a]\nThe value of a in this assignment is IMPLEMENTATION DEFINED, between a minimum value of 3 and a maximum\nvalue of 11. For example, in an implementation where a is 4, a successful LDREX of address 0x000341B4 gives a tag\nvalue of bits[31:4] of the address, giving 0x000341B. This means that the four words of memory from 0x000341B0 to\n0x000341BF are tagged for exclusive access.\n\nThe size of the tagged memory block is called the Exclusives Reservation Granule. The Exclusives Reservation\nGranule is IMPLEMENTATION DEFINED in the range 2-512 words:\n• 2 words in an implementation where a is 3\n• 512 words in an implementation where a is 11.\n\n##### A3.4.4 Context switch support\nAfter a context switch, software must ensure that the local monitor is in the Open Access state. This requires it to\neither:\n• execute a CLREX instruction\n• execute a dummy STREX to a memory address allocated for this purpose.\n\nNote:\nUsing a dummy STREX for this purpose is backwards-compatible with the ARMv6 implementation of the\nexclusive operations. The CLREX instruction is introduced in ARMv6K.\n\n##### A3.4.5 Load-Exclusive and Store-Exclusive usage restrictions\nThe Load-Exclusive and Store-Exclusive instructions are intended to work together, as a pair, for example a\nLDREX/STREX pair or a LDREXB/STREXB pair.\n\n• An implementation of the Load-Exclusive and Store-Exclusive instructions can require that, in any thread of\nexecution, the transaction size of a Store-Exclusive is the same as the transaction size of the preceding\nLoad-Exclusive executed in that thread.\n\n• An implementation might clear an exclusive monitor between the LDREX and the STREX, without any\napplication-related cause. Software written for such an implementation must, in any single thread of execution, __avoid having any explicit memory accesses, System control register updates, or cache maintenance operations between the LDREX instruction and the associated STREX instruction.__\n\n• In some implementations, an access to Strongly-ordered or Device memory might clear the exclusive\nmonitor. Therefore, __software must not place a load or a store to Strongly-ordered or Device memory between an LDREX and an STREX in a single thread of execution.__\n\n• Implementations can benefit from keeping the LDREX and STREX operations close together in a single thread of\nexecution. This minimizes the likelihood of the exclusive monitor state being cleared between the LDREX\ninstruction and the STREX instruction. Therefore, __for best performance, ARM strongly recommends a limit of 128 bytes between LDREX and STREX instructions in a single thread of execution.__\n\n• After taking a Data Abort exception, the state of the exclusive monitors is UNKNOWN. Therefore ARM\nstrongly recommends that the abort handling software performs a CLREX instruction, or a dummy STREX\ninstruction, to clear the monitor state.\n\n• The effect of a data or unified cache invalidate, cache clean, or cache clean and invalidate instruction on a\nlocal or global exclusive monitor that is in the Exclusive Access state is UNPREDICTABLE. Execution of the\ninstruction might clear the monitor, or it might leave it in the Exclusive Access state.\n\n• For the memory location being accessed by a LoadExcl/StoreExcl pair, if the memory attributes for the\nLoadExcl instruction differ from the memory attributes for the StoreExcl instruction, behavior is\nUNPREDICTABLE.\n\n##### A3.4.6 Semaphores\nThe Swap (SWP) and Swap Byte (SWPB) instructions must be used with care to ensure that expected behavior is\nobserved.\n\nNote\nFrom ARMv6, ARM deprecates use of the Swap and Swap Byte instructions, and strongly recommends that all new\nsoftware uses the Load-Exclusive and Store-Exclusive synchronization primitives\n\n##### A3.4.7 Synchronization primitives and the memory order model\nThe synchronization primitives follow the memory order model of the memory type accessed by the instructions.\nFor this reason:\n• Portable software for claiming a spin-lock must include a Data Memory Barrier (DMB) operation, performed\nby a DMB instruction, between claiming the spin-lock and making any access that makes use of the spin-lock.\n• Portable software for releasing a spin-lock must include a DMB instruction before writing to clear the spin-lock.\nThis requirement applies to software using:\n• the Load-Exclusive/Store-Exclusive instruction pairs, for example LDREX/STREX\n• the deprecated synchronization primitives, SWP/SWPB.\n\n[ISB > DSB > DMB](https://blog.csdn.net/wangbinyantai/article/details/78986974)\n\n##### A3.4.8 Use of WFE and SEV instructions by spin-locks\nARMv7 and ARMv6K provide Wait For Event and Send Event instructions, WFE and SEV, that can assist with\nreducing power consumption and bus contention caused by processors repeatedly attempting to obtain a spin-lock.\nThese instructions can be used at the application level, but a complete understanding of what they do depends on\nsystem level understanding of exceptions.\n\n#### A3.5 Memory types and attributes and the memory order model\n##### A3.5.1 Memory types\nexclusive memory types:\n• Normal\n• Device\n• Strongly-ordered.\n\n##### A3.5.2 Summary of ARMv7 memory attributes\n\n__Shareability__\nApplies only to Normal memory, and __to Device memory in an implementation that does not include the Large Physical Address Extension.__ In an implementation that includes the Large Physical\nAddress Extension, Device memory is always Outer Shareable,\nWhen it is possible to assign a shareability attribute to Device memory, ARM deprecates assigning\nany attribute other than Shareable or Outer Shareable, see Shareable attribute for Device memory\nregions on page A3-137\nWhether an ARMv7 implementation distinguishes between Inner Shareable and Outer Shareable\nmemory is IMPLEMENTATION DEFINED.\n\n__Cacheability__\nApplies only to Normal memory, and can be defined independently for Inner and Outer cache\nregions. Some cacheability attributes can be complemented by a cache allocation hint. This is an\nindication to the memory system of whether allocating a value to a cache is likely to improve\nperformance. \n\nFixme [Table A3-5 Memory attribute summary] page127\n\n##### A3.5.3 Atomicity in the ARM architecture\nAtomicity is a feature of memory accesses, described as atomic accesses. The ARM architecture description refers\nto two types of atomicity, defined in:\n• Single-copy atomicity\n• Multi-copy atomicity on page A3-130.\n\n__Single-copy atomicity__\nIn ARMv7, the single-copy atomic processor accesses are:\n• All byte accesses.\n• All halfword accesses to halfword-aligned locations.\n• All word accesses to word-aligned locations.\n• Memory accesses caused by a LDREXD/STREXD to a doubleword-aligned location for which the STREXD succeeds\ncause single-copy atomic updates of the doubleword being accessed.\nNote\nThe way to atomically load two 32-bit quantities is to perform a LDREXD/STREXD sequence, reading and writing\nthe same value, for which the STREXD succeeds, and use the read values\n\n__Multi-copy atomicity__\nIn a multiprocessing system, writes to a memory location are multi-copy atomic\n\nWrites to Normal memory are not multi-copy atomic. (有缓存机制以及SNOOP等)\nAll writes to Device and Strongly-ordered memory that are single-copy atomic are also multi-copy atomic.\n\n##### A3.5.4 Concurrent modification and execution of instructions\nThe ARMv7 architecture limits the set of instructions that can be executed by one thread of execution as they are\nbeing modified by another thread of execution without requiring explicit synchronization.\n\nExcept for the instructions identified in this section, the effect of the concurrent modification and execution of an\ninstruction is UNPREDICTABLE. （无条件跳转等命令，不受这个限制）\n\n\n__In the Thumb instruction set__\nThe 16-bit encodings of the B, NOP, BKPT, and SVC instructions\n\n__In the ARM instruction set__\nThe B, BL, NOP, BKPT, SVC, HVC, and SMC instructions.\n\n##### A3.5.5 Normal memory\nAccesses to normal memory region are idempotent, meaning that they exhibit the following properties:\n• read accesses can be repeated with no side-effects\n• repeated read accesses return the last value written to the resource being read\n• read accesses can fetch additional memory locations with no side-effects\n• write accesses can be repeated with no side-effects in the following cases:\n\t— if the contents of the location accessed are unchanged between the repeated writes\n\t— as the result of an exception, as described in this section\n• unaligned accesses can be supported\n• accesses can be merged before accessing the target memory system.\n\nNormal memory can be read/write or read-only, and a Normal memory region is defined as being either Shareable\nor Non-shareable.\n\n__Non-shareable Normal memory__\nFor a Normal memory region, the Non-shareable attribute identifies Normal memory that is likely to be accessed\nonly by a single processor.\n\n__Shareable, Inner Shareable, and Outer Shareable Normal memory__\nFor Normal memory, the Shareable and Outer Shareable memory attributes describe Normal memory that is\nexpected to __be accessed by multiple processors or other system masters:__\n• In a VMSA implementation, Normal memory that has the Shareable attribute but not the Outer Shareable\nattribute assigned is described as having the Inner Shareable attribute.\n• In a PMSA implementation, no distinction is made between Inner Shareable and Outer Shareable Normal\nmemory.\n\nVMSA: Virtual Memory System Architecture\nPMSA: Protected Memory System Architecture\n\n__Write-Through Cacheable, Write-Back Cacheable and Non-cacheable Normal memory__\nThe cacheability attributes provide a mechanism of coherency control with observers that lie outside the shareability\ndomain of a region of memory.\n• Write-Through Cacheable\n• Write-Back Cacheable\n• Non-cacheable.\n\nThe cacheability attributes provide a mechanism of coherency control with observers that lie outside the shareability\ndomain of a region of memory. In some cases, the use of Write-Through Cacheable or Non-cacheable regions of\nmemory might provide a better mechanism for controlling coherency than the use of hardware coherency\nmechanisms or the use of cache maintenance routines.\n\n##### A3.5.6 Device and Strongly-ordered memory\nExamples of memory regions normally marked as being Device or Strongly-ordered memory are Memory-mapped\nperipherals and I/O locations. __Address locations marked as Device or Strongly-ordered are never held in a cache.__\n\nThe architecture permits an Advanced SIMD element or structure load instruction to access bytes in Device or\nStrongly-ordered memory.\n\n__The architecture does not permit unaligned accesses to Strongly-ordered or Device memory.__\n\n###### Shareable attribute for Device memory regions\nIn an implementation that does not include the Large Physical Address Extension, Device memory regions can be\ngiven the Shareable attribute. When a Device memory region is give the Shareable attribute it can also be given the\nOuter Shareable attribute. This means that a region of Device memory can be described as one of:\n• Outer Shareable Device memory\n• Inner Shareable Device memory\n• Non-shareable Device memory.\n\n\nARM deprecates the marking of Device memory with a shareability attribute other than Outer Shareable or\nShareable. This means __ARM strongly recommends that Device memory is never assigned a shareability attribute of Non-shareable or Inner Shareable.__\n\n###### Device and Strongly-ordered memory shareability, Large Physical Address Extension\nIn an implementation that includes the Large Physical Address Extension, the Long-descriptor translation table\nformat does not distinguish between Shareable and Non-shareable Device memory.\n\nIn an implementation that includes the Large Physical Address Extension and is using the Short-descriptor\ntranslation table format:\n• An address-based cache maintenance operation for an addresses in a region with the Strongly-ordered or\nDevice memory type applies to all processors in the same Outer Shareable domain, regardless of any\nshareability attributes applied to the region.\n• Device memory transactions to a single peripheral must not be reordered, regardless of any shareability\nattributes that are applied to the corresponding Device memory region.\nAny single peripheral has an IMPLEMENTATION DEFINED size of not less than 1KB.\n\n##### A3.5.7 Memory access restrictions\nThe following restrictions apply to memory accesses:\n• For accesses to any two bytes, p and q, that are generated by the same instruction:\n\t— The bytes p and q must have the same memory type and shareability attributes\n\t— Except for possible differences in the cache allocation hints, ARM deprecates having different\n\tcacheability attributes for the bytes p and q.\n\n• Unaligned data access on page A3-108 identifies the instructions that can make an unaligned memory\naccess,If such an access is to Device or Strongly-ordered memory then:\n\t— if the implementation does not include the Virtualization Extensions, the effect is UNPREDICTABLE\n\t— if the implementation includes the Virtualization Extensions, the access generates an Alignment fault\n\n• __The accesses of an instruction that causes multiple accesses to Device or Strongly-ordered memory must not cross a 4KB address boundary__\n\n• __Any instruction fetch must access only Normal memory.__ If it accesses Device or Strongly-ordered memory,\nthe result is UNPREDICTABLE.\n\n\n##### A3.5.8 The effect of the Security Extensions\nThe Security Extensions can be included as part of an ARMv7-A implementation, with a VMSA. They provide two\ndistinct 4GByte virtual memory spaces:\n• a Secure virtual memory space\n• a Non-secure virtual memory space.\nThe Secure virtual memory space is accessed by memory accesses in the Secure state, and the Non-secure virtual\nmemory space is accessed by memory accesses in the Non-secure state.\nBy providing different virtual memory spaces, the Security Extensions permit memory accesses made from the\nNon-secure state to be distinguished from those made from the Secure state.\n\n#### A3.6 Access rights\n##### A3.6.1 Processor privilege levels, execution privilege, and access privilege\nARMv7 architecture defines different levels of execution privilege:\n• in Secure state, the privilege levels are PL1 and PL0\n• in Non-secure state, the privilege levels are PL2, PL1, and PL0.\n\n__PL0__\nThe privilege level of application software, that executes in User mode. Therefore, software\nexecuted in User mode is described as unprivileged software. This software cannot access some\nfeatures of the architecture. In particular, it cannot change many of the configuration settings.\nSoftware executing at PL0 makes only unprivileged memory accesses.\n\n__PL1__\nSoftware execution in all modes other than User mode and Hyp mode is at PL1. Normally, operating\nsystem software executes at PL1. Software executing at PL1 can access all features of the\narchitecture, and can change the configuration settings for those features, except for some features\nadded by the Virtualization Extensions that are only accessible at PL2.\nNote\nIn many implementation models, system software is unaware of the PL2 level of privilege, and of\nwhether the implementation includes the Virtualization Extensions.\nThe PL1 modes refers to all the modes other than User mode and Hyp mode.\nSoftware executing at PL1 makes privileged memory accesses by default, but can also make\nunprivileged accesses.\n\n__PL2__\nSoftware executing in Hyp mode executes at PL2.\nSoftware executing at PL2 can perform all of the operations accessible at PL1, and can access some\nadditional functionality.\nHyp mode is normally used by a hypervisor, that controls, and can switch between, Guest OSs, that\nexecute at PL1.\n\nHyp mode is implemented only as part of the Virtualization Extensions, and only in Non-secure\nstate. This means that:\n• implementations that do not include the Virtualization Extensions have only two privilege\nlevels, PL0 and PL1\n• execution in Secure state has only two privilege levels, PL0 and PL1\n\n#### A3.8 Memory access order\n\n##### A3.8.1 Reads and writes\nThe following can cause memory accesses that are not explicit:\n• instruction fetches\n• cache loads and write-backs\n• translation table walks.\n\n###### Reads\nReads are defined as memory operations that have the semantics of a load.\nThe memory accesses of the following instructions are reads:\n• LDR, LDRB, LDRH, LDRSB, and LDRSH.\n• LDRT, LDRBT, LDRHT, LDRSBT, and LDRSHT.\n• LDREX, LDREXB, LDREXD, and LDREXH.\n• LDM, LDRD, POP, and RFE.\n• LDC, LDC2, VLDM, VLDR, VLD1, VLD2, VLD3, VLD4, and VPOP.\n• The return of status values by STREX, STREXB, STREXD, and STREXH.\n• SWP and SWPB. These instructions are available only in the ARM instruction set.\n• TBB and TBH. These instructions are available only in the Thumb instruction set.\nHardware-accelerated opcode execution by the Jazelle extension can cause a number of reads to occur, according\nto the state of the operand stack and the implementation of the Jazelle hardware acceleration.\n\n###### Writes\nWrites are defined as memory operations that have the semantics of a store.\nThe memory accesses of the following instructions are Writes:\n• STR, STRB, and STRH.\n• STRT, STRBT, and STRHT.\n• STREX, STREXB, STREXD, and STREXH.\n• STM, STRD, PUSH, and SRS.\n• STC, STC2, VPUSH, VSTM, VSTR, VST1, VST2, VST3, and VST4.\n• SWP and SWPB. These instructions are available only in the ARM instruction set.\nHardware-accelerated opcode execution by the Jazelle extension can cause a number of writes to occur, according\nto the state of the operand stack and the implementation of the Jazelle hardware acceleration.\n\n###### Synchronization primitives\nSynchronization primitives must ensure correct operation of system semaphores in the memory order model. They are the following instructions:\n• LDREX, STREX, LDREXB, STREXB, LDREXD, STREXD, LDREXH, STREXH.\n• SWP, SWPB. From ARMv6, ARM deprecates the use of these instructions.\n\n##### A3.8.3 Memory barriers\nMemory barrier is the general term applied to an instruction, or sequence of instructions, that forces synchronization\nevents by a processor with respect to retiring load/store instructions.\n\nThe ARM architecture defines a number of memory barriers that provide a range of functionality, including:\n• ordering of load/store instructions\n• completion of load/store instructions\n• context synchronization.\n\nIn ARMv7 the memory barriers are provided as instructions that are available in the ARM and Thumb\ninstruction sets, and in ARMv6 the memory barriers are performed by CP15 register writes. The three memory\nbarriers are:\n• Data Memory Barrier, see Data Memory Barrier (DMB) on page A3-152\n• Data Synchronization Barrier, see Data Synchronization Barrier (DSB) on page A3-153\n• Instruction Synchronization Barrier, see Instruction Synchronization Barrier (ISB) on page A3-153.\n\n###### Data Memory Barrier (DMB)\nThe DMB instruction is a data memory barrier. __DMB only affects memory accesses and data and unified cache maintenance operations,  It has no effect on the ordering of any other instructions executing on the processor.__\n\n###### Data Synchronization Barrier (DSB)\nThe DSB instruction is a special memory barrier, that synchronizes the execution stream with memory accesses. __In addition, no instruction that appears in program order after the DSB instruction can execute until the DSB completes.__\n\n###### Instruction Synchronization Barrier (ISB)\n__An ISB instruction flushes the pipeline in the processor, so that all instructions that come after the ISB instruction in program order are fetched from cache or memory only after the ISB instruction has completed.__\n\nUsing an ISB ensures that the effects of context-changing operations executed before the ISB are visible to the instructions fetched after the ISB instruction. \n\nExamples of context-changing operations that require the insertion of an ISB instruction to ensure\nthe effects of the operation are visible to instructions fetched after the ISB instruction are:\n• completed cache, TLB, and branch predictor maintenance operations\n• changes to system control registers. \n\n#### A3.9 Caches and memory hierarchy\n\n##### A3.9.1 Introduction to caches\nA cache is a block of high-speed memory that contains a number of entries, each consisting of:\n• main memory address information, commonly called a tag\n• the associated data\n\n##### A3.9.2 Memory hierarchy\nMemory close to a processor has very low latency, but is limited in size and expensive to implement.To optimize overall\nperformance, an ARMv7 memory system can include multiple levels of cache in a hierarchical memory system. \n\nFixme[Figure A3-6 Multiple levels of cache in a memory hierarchy] page 157\n\n##### A3.9.4 Preloading caches\nThe ARM architecture provides memory system hints PLD (Preload Data), PLDW (Preload Data with intent to write),\nand PLI (Preload Instruction) to permit software to communicate the expected use of memory locations to the\nhardware. \n\n### A4. The Instruction Sets\n#### A4.1 About the instruction sets\nARMv7 contains two main instruction sets, the ARM and Thumb instruction sets. \n\nThe ARM and Thumb instruction sets can interwork freely, that is, different procedures can be compiled or assembled to different instruction sets, and still be able to call each other efficiently.\n\n__ThumbEE__ is a variant of the Thumb instruction set that is designed as a target for __dynamically generated code.__\nHowever, it cannot interwork freely with the ARM and Thumb instruction sets.\n\nThe two instruction sets differ in how instructions are encoded:\n• Thumb instructions are either 16-bit or 32-bit, and are aligned on __a two-byte boundary__. 16-bit and 32-bit\ninstructions can be intermixed freely. Many common operations are most efficiently executed using 16-bit\ninstructions. However:\n\t— Most 16-bit instructions can only access the first eight of the ARM core registers, R0-R7. These are\n\tcalled the low registers. A small number of 16-bit instructions can also access the high registers,\n\tR8-R15.\n\t— Many operations that would require two or more 16-bit instructions can be more efficiently executed\n\twith a single 32-bit instruction.\n\t— All 32-bit instructions can access all of the ARM core registers, R0-R15.\n\n• ARM instructions are always 32-bit, and are aligned on a four-byte boundary\n\n##### A4.1.1 Changing between Thumb state and ARM state\n\n###### Thumb to ARM state\nA processor in Thumb state can enter ARM state by executing any of the following instructions: __BX, BLX, or an LDR or LDM that loads the PC.__\n\n###### ARM to Thumb state\nA processor in ARM state can enter Thumb state by executing any of the same instructions.\n\nIn ARMv7, a processor in ARM state can also enter Thumb state by executing an ADC, ADD, AND, ASR, BIC, EOR, LSL,\nLSR, MOV, MVN, ORR, ROR, RRX, RSB, RSC, SBC, or SUB instruction that __has the PC as destination register and does not set the condition flags.__\n\n###### others\nThe target instruction set is either encoded directly in the instruction (for the immediate offset version of BLX), or is\nheld as bit[0] of an interworking address. For details, see the description of the BXWritePC() function in Pseudocode\ndetails of operations on ARM core registers on page A2-47.\nbit[0]    1 thumb      thumb is 2 bytes boundary but ARM some support Jazella extension\nbit[1:0] 00 arm        arm is 4 bytes boundary\nbit[1:0] 10 unknown\n\nException entries and returns can also change between ARM and Thumb states. For details see Exception handling\non page B1-1165.\n\n##### A4.1.2 Conditional execution\nIn the ARM and Thumb instruction sets, most instructions can be conditionally executed\n\nIn the ARM instruction set,  has its normal effect on the programmers’ model operation, memory and coprocessors if the N, Z, C and V condition flags in the APSR satisfy.\n\nIf the flags do not satisfy this condition, the instruction acts as a NOP.\n\nIn the Thumb instruction set, different mechanisms control conditional execution:\n• For the following Thumb encodings, conditional execution is controlled in a similar way to the ARM\ninstructions:\n\t— A 16-bit conditional branch instruction encoding, with a branch range of –256 to +254 bytes. Before\n\tARMv6T2, this was the only mechanism for conditional execution in Thumb code.\n\t— A 32-bit conditional branch instruction encoding, with a branch range of approximately ±1MB.\n\n• The CBZ and CBNZ instructions, Compare and Branch on Zero and Compare and Branch on Nonzero, are 16-bit\nconditional instructions with a branch range of +4 to +130 bytes.\t\n\n• The 16-bit If-Then instruction makes up to four following instructions conditional, and can make most other\nThumb instructions conditional. For details see IT on page A8-390. \n\n#### A4.3 Branch instructions\nFixme [Table A4-1 Branch instructions] Page164\n\n#### A4.4 Data-processing instructions\n##### A4.4.1 Standard data-processing instructions\nFixme [Table A4-2 Standard data-processing instructions] Page166\n\n##### A4.4.2 Shift instructions\nFixme [Table A4-3 Shift instructions] Page167\n\n##### A4.4.3 Multiply instructions\nThese instructions can operate on signed or unsigned quantities. In some types of operation, the results are same\nwhether the operands are signed or unsigned.\n\nFixme [Table A4-4 General multiply instructions] Page167\n\nFixme [Table A4-5 Signed multiply instructions] Page168\n\nFixme [Table A4-6 Unsigned multiply instructions] Page168\n\n##### A4.4.4 Saturating instructions\n饱和指令： 将超出unsigned, signed 的值限制到本身支持的最大值或最小值\n\n##### A4.4.5 Saturating addition and subtraction instructions\n\n##### A4.4.6 Packing and unpacking instructions\n扩展指令： 将[半]字节扩展到[有/无]32位\n\n##### A4.4.7 Parallel addition and subtraction instructions\nThese instructions perform additions and subtractions on the values of two registers and write the result to a\ndestination register, treating the register values as sets of two halfwords or four bytes. That is, they perform SIMD\nadditions or subtractions on the registers. \n\n##### A4.4.8 Divide instructions\n\nFor descriptions of the instructions see:\n• SDIV on page A8-600\n• UDIV on page A8-760\n\nIn the ARMv7-R profile, the SCTLR.DZ bit enables divide by zero fault detection:\nSCTLR.DZ == 0 Divide-by-zero returns a zero result.\nSCTLR.DZ == 1 SDIV and UDIV generate an Undefined Instruction exception on a divide-by-zero.\nThe SCTLR.DZ bit is cleared to zero on reset\n\n##### A4.4.9 Miscellaneous data-processing instructions\nFixme [Table A4-11 Miscellaneous data-processing instructions] page173\n\n#### A4.5 Status register access instructions\n\nThe MRS and MSR instructions move the contents of the Application Program Status Register (APSR) to or from an\nARM core register, see:\n• MRS on page A8-496\n• MSR (immediate) on page A8-498\n• MSR (register) on page A8-500.\n\nAt system level, software can also:\n• use these instructions to access the SPSR of the current mode\n• use the CPS instruction to change the CPSR.M field and the CPSR.{A, I, F} interrupt mask bits.\n\n#### A4.6 Load/store instructions\nFixme [Table A4-12 Load/store instructions] Page175\n\n#### A4.7 Load/store multiple instructions\nLoad Multiple instructions load a subset, or possibly all, of the ARM core registers from memory.\nStore Multiple instructions store a subset, or possibly all, of the ARM core registers to memory.\n\nFixme [Table A4-13 Load/store multiple instructions] Page177\n\n#### A4.8 Miscellaneous instructions\nFixme [Table A4-14 Miscellaneous instructions] Page178\n\n#### A4.9 Exception-generating and exception-handling instructions\nThe following instructions are intended specifically to cause a synchronous processor exception to occur:\n• The SVC instruction generates a Supervisor Call exception. For more information, see Supervisor Call (SVC)\nexception on page B1-1210.\n• The Breakpoint instruction BKPT provides software breakpoints. For more information, see About debug\nevents on page C3-2038.\n• In a processor that implements the Security Extensions, when executing at PL1 or higher, the SMC instruction\ngenerates a Secure Monitor Call exception. For more information, see Secure Monitor Call (SMC) exception\non page B1-1211.\n• In a processor that implements the Virtualization Extensions, in software executing in a Non-secure PL1\nmode, the HVC instruction generates a Hypervisor Call exception. For more information, see Hypervisor Call\n(HVC) exception on page B1-1212.\n\nFixme [Table A4-15 Exception-generating and exception-handling instructions] Page179\n\n#### A4.10 Coprocessor instructions\nThere are three types of instruction for communicating with coprocessors. These permit the processor to:\n• Initiate a coprocessor data-processing operation. For details see CDP, CDP2 on page A8-358.\n• Transfer ARM core registers to and from coprocessor registers. For details, see:\n\t— MCR, MCR2 on page A8-476\n\t— MCRR, MCRR2 on page A8-478\n\t— MRC, MRC2 on page A8-492\n\t— MRRC, MRRC2 on page A8-494.\n• Load or store the values of coprocessor registers. For details, see:\n\t— LDC, LDC2 (immediate) on page A8-392\n\t— LDC, LDC2 (literal) on page A8-394\n\t— STC, STC2 on page A8-662.\n\n#### A4.11 Advanced SIMD and Floating-point load/store instructions\nFixme [Table A4-16 Extension register load/store instructions] Page181\nFixme [Table A4-17 Element and structure load/store instructions] Page181\n\n#### A4.12 Advanced SIMD and Floating-point register transfer instructions\nFixme [Table A4-18 Extension register transfer instructions] Page183\n\n#### A4.13 Advanced SIMD data-processing instructions\nAdvanced SIMD data-processing instructions process registers containing vectors of elements of the same type\npacked together, enabling the same operation to be performed on multiple items in parallel.\n\nFixme [Figure A4-2 Advanced SIMD instruction operating on 64-bit registers] Page184\n\n##### A4.13.1 Advanced SIMD parallel addition and subtraction\n\nFixme [Table A4-19 Advanced SIMD parallel add and subtract instructions] Page185\n\n##### A4.13.2 Bitwise Advanced SIMD data-processing instructions\nFixme [Table A4-20 Bitwise Advanced SIMD data-processing instructions] Page186\n\n##### A4.13.3 Advanced SIMD comparison instructions\nFixme [Table A4-21 Advanced SIMD comparison instructions] Page186\n\n##### A4.13.4 Advanced SIMD shift instructions\nFixme [Table A4-22 Advanced SIMD shift instructions] Page187\n\n##### A4.13.5 Advanced SIMD multiply instructions\nFixme [Table A4-23 Advanced SIMD multiply instructions] Page188\n\n##### A4.13.6 Miscellaneous Advanced SIMD data-processing instructions\nFixme [Table A4-24 Miscellaneous Advanced SIMD data-processing instructions] Page189\n\n#### A4.14 Floating-point data-processing instruction\nFixme [Table A4-25 Floating-point data-processing instructions] Page191\n\n\n### A5. ARM Instruction Set Encoding\n#### A5.1 ARM instruction set encoding\n__The ARM instruction stream is a sequence of word-aligned words. Each ARM instruction is a single 32-bit word__ in\nthat stream. The encoding of an ARM instruction is:\n\nFixme [32 bits instruction structure] page194\n\nFixme [Table A5-1 ARM instruction encoding] page194\n\n##### A5.1.1 The condition code field\nThis field contains one of the values 0b0000-0b1110, as shown in Table A8-1 on page A8-288.\nFixme [Table A8-1 Condition codes]page288\n\n#### A5.2 Data-processing and miscellaneous instructions\nFixme [data process instructions structure]page196\n\nFixme [Table A5-2 Data-processing and miscellaneous instructions]page196\n\n其余指令可参照此命令，只是op 的不同。\n\n### A6. Thumb Instruction Set Encoding\n#### A6.1 Thumb instruction set encoding\nThe Thumb instruction stream is a sequence of halfword-aligned halfwords. Each Thumb instruction is either a\nsingle 16-bit halfword in that stream, or a 32-bit instruction consisting of two consecutive halfwords in that stream.\nIf the value of bits[15:11] of the halfword being decoded is one of the following, the halfword is the first halfword\nof a 32-bit instruction:\n• 0b11101\n• 0b11110\n• 0b11111.\nOtherwise, the halfword is a 16-bit instruction\n\n疑问点：thumb 是16bit 或32bit对齐，那怎么与32 bit的ARM 指令集怎么区分？\n当ARM 处于ARM state，CPU 将会按照32 bit ARM指令集去取指并执行，反之使用16、32bit 的thumb 指令集解析。\n\n#### A6.2 16-bit Thumb instruction encoding\nFixme [16-bit thumb instruction encoding]page223\n\nFixme [Table A6-1 16-bit Thumb instruction encoding]page223\n\n#### A6.3 32-bit Thumb instruction encoding\nFixme [ 32-bit Thumb instruction encoding]page230\n\nFixme [Table A6-9 32-bit Thumb instruction encoding]page230\n\n### A7 Advanced SIMD and Floating-point Instruction Encoding\nskip\n\n### A9 The ThumbEE Instruction Set\n#### A9.1 About the ThumbEE instruction set\nIn general, __instructions in ThumbEE are identical to Thumb instructions__, with the following exceptions:\n• A small number of instructions are affected by modifications to transitions from ThumbEE state. For more\ninformation, see ThumbEE state transitions.\n\n• __A substantial number of instructions have a null check on the base register before any other operation takes__\nplace, but are identical (or almost identical) in all other respects. For more information, see Null checking on\npage A9-1113.\n\n• A small number of instructions are modified in additional ways. See Instructions with modifications on\npage A9-1113.\n\n• Three Thumb instructions, BLX (immediate), 16-bit LDM, and 16-bit STM, are removed in ThumbEE state.\nThe encoding corresponding to BLX (immediate) in Thumb is UNDEFINED in ThumbEE state.\n16-bit LDM and STM are replaced by new instructions, for details see Additional ThumbEE instructions on\npage A9-1123.\n\n• Two new 32-bit instructions, ENTERX and LEAVEX, are introduced in both the Thumb instruction set and the\nThumbEE instruction set. See Additional instructions in Thumb and ThumbEE instruction sets on\npage A9-1116. These instructions use previously UNDEFINED encodings.\n\n__Attempting to execute ThumbEE instructions at PL2 is UNPREDICTABLE.__\n\n##### A9.1.1 ThumbEE state transitions\nInstruction set state transitions to ThumbEE state can occur implicitly as part of a return from exception, or\nexplicitly on execution of an __ENTERX instruction.__\n\nInstruction set state transitions from ThumbEE state can only occur due to an exception, or due to a transition to\nThumb state using the __LEAVEX instruction.__ Return from exception instructions (RFE and SUBS PC, LR, #imm) are\nUNPREDICTABLE in ThumbEE state.\n\n##### A9.1.2 Null checking\nA null check is performed for all load/store instructions when they are executed in ThumbEE state. If the value in\nthe base register is zero, execution branches to the NullCheck handler at HandlerBase – 4.\n\n#### A9.2 ThumbEE instruction set encoding\nIn general, instructions in the ThumbEE instruction set are encoded in exactly the same way as Thumb instructions\ndescribed in Chapter A6 Thumb Instruction Set Encoding. The differences are as follows:\n• There are no 16-bit LDM or STM instructions in the ThumbEE instruction set.\n• The 16-bit encodings used for LDM and STM in the Thumb instruction set are used for different 16-bit\ninstructions in the ThumbEE instruction set. For details, see 16-bit ThumbEE instructions.\n• There are two new 32-bit instructions in both Thumb state and ThumbEE state. For details, see Additional\ninstructions in Thumb and ThumbEE instruction sets on page A9-1116.\n\n##### A9.2.1 16-bit ThumbEE instructions\nFixme [Table A9-2 16-bit ThumbEE instructions]page1115\n\n#### A9.3 Additional instructions in Thumb and ThumbEE instruction sets\nOn a processor with the ThumbEE Extension, there are two additional 32-bit instructions, ENTERX and LEAVEX. These\nare available in both Thumb state and ThumbEE state.\n##### A9.3.1 ENTERX, LEAVEX\nENTERX causes a change from Thumb state to ThumbEE state, or has no effect in ThumbEE state.\nENTERX is UNDEFINED in Hyp mode.\nLEAVEX causes a change from ThumbEE state to Thumb state, or has no effect in Thumb state.\n\n### A8 Instruction Descriptions\n\n#### A8.2 Standard assembler syntax fields\nThe following assembler syntax fields are standard across all or most instructions:\n<c> Is an optional field. It specifies the condition under which the instruction is executed. See\n\tConditional execution on page A8-288 for the range of available conditions and their encoding. If\n\t<c> is omitted, it defaults to always (AL).\n\n<q> Specifies optional assembler qualifiers on the instruction. The following qualifiers are defined:\n\t.N Meaning narrow, specifies that the assembler must select a 16-bit encoding for the\n\tinstruction. If this is not possible, an assembler error is produced.\n\t.W Meaning wide, specifies that the assembler must select a 32-bit encoding for the\n\tinstruction. If this is not possible, an assembler error is produced.\n\n#### A8.3 Conditional execution\t\nMost ARM instructions, and most Thumb instructions from ARMv6T2 onwards, can be executed conditionally,\nbased on the values of the APSR condition flags.\n\nFixme [Table A8-1 Condition codes]page288\n","source":"_posts/arm_arm.md","raw":"---\ntitle: arm arm\ndate: 2019-05-28 13:55:44\ntags:\n    - arm\n    - spec\ncategories:\n    - arm\n---\n\n## Part A. Application Level Architecture\n---\n### A1. Introduction to the ARM Architecture\n---\n<!--more-->\n\n#### A1.4 Architecture extensions\n__Jazelle__\nIs the Java bytecode execution extension that extended ARMv5TE to ARMv5TEJ. From\nARMv6, the architecture requires at least the trivial Jazelle implementation, but a Jazelle\nimplementation is still often described as a Jazelle extension.\nThe Virtualization Extensions require that the Jazelle implementation is the trivial Jazelle\nimplementation.\n\n__ThumbEE__\nIs an extension that provides the ThumbEE instruction set, a variant of the Thumb\ninstruction set that is designed as a target for dynamically generated code. In the original\nrelease of the ARMv7 architecture, the ThumbEE extension was:\n• A required extension to the ARMv7-A profile.\n• An optional extension to the ARMv7-R profile.\n\nFrom publication of issue C.a of this manual, ARM deprecates any use of ThumbEE\ninstructions. However, ARMv7-A implementations must continue to include ThumbEE\nsupport, for backwards compatibility.\n\n__Floating-point__\nIs a floating-point coprocessor extension to the instruction set architectures. For historic\nreasons, the Floating-point Extension is also called the VFP Extension. \n\n__Advanced SIMD__\nIs an instruction set extension that provides Single Instruction Multiple Data (SIMD)\ninteger and single-precision floating-point vector operations on doubleword and quadword\nregisters.\t\n\n### A1.4.2 Architecture extensions\nThis manual also describes the following extensions to the ARMv7 architecture:\n__Security Extensions__\n\n__Multiprocessing Extensions__\nAre an OPTIONAL set of extensions to the ARMv7-A and ARMv7-R profiles, that provides a set of\nfeatures that enhance multiprocessing functionality.\n\n__Large Physical Address Extension__\nIs an OPTIONAL extension to VMSAv7 that provides an address translation system supporting\nphysical addresses of up to 40 bits at a fine grain of translation.\nThe Large Physical Address Extension requires implementation of the Multiprocessing Extensions.\n\n__Virtualization Extensions__\nAre an OPTIONAL set of extensions to VMSAv7 that provides hardware support for virtualizing the\nNon-secure state of a VMSAv7 implementation. This supports system use of a virtual machine\nmonitor, also called a hypervisor.\n\n__Generic Timer Extension__\nIs an OPTIONAL extension to any ARMv7-A or ARMv7-R, that provides a system timer, and a\nlow-latency register interface to it.\n\n__Performance Monitors Extension__\nThe ARMv7 architecture:\n• reserves CP15 register space for IMPLEMENTATION DEFINED performance monitors\n• defines a recommended performance monitors implementation.\n\n---\n### A2. Application Level Programmers’ Model\n#### A2.1 About the Application level programmers’ model\nDepending on the implemented architecture extensions, the architecture supports multiple levels of execution\nprivilege, that number upwards from PL0, where PL0 is the lowest privilege level and is often described as\nunprivileged.\n\nWhen an operating system supports execution at both PL1 and PL0, an application usually runs unprivileged. This:\n• permits the operating system to __allocate system resources__ to an application in a unique or shared manner\n• provides __a degree of protection from other processes and tasks__, and so helps protect the operating system\nfrom malfunctioning applications.\n\n#### A2.2 ARM core data types and arithmetic\nAll ARMv7-A and ARMv7-R processors support the following data types in memory:\nByte           8 bits\nHalfword       16 bits\nWord           32 bits\nDoubleword     64 bits.\n\nProcessor registers are 32 bits in size. The instruction set contains instructions supporting the following data types\nheld in registers:\n• 32-bit pointers\n• unsigned or signed 32-bit integers\n• unsigned 16-bit or 8-bit integers, held in zero-extended form\n• signed 16-bit or 8-bit integers, held in sign-extended form\n• two 16-bit integers packed into a register\n• four 8-bit integers packed into a register\n• unsigned or signed 64-bit integers held in two registers.\n\n#### A2.3 ARM core registers\nIn the application level view, an ARM processor has:\n• thirteen general-purpose 32-bit registers, R0 to R12\n• three 32-bit registers with special uses, SP, LR, and PC, that can be described as R13 to R15.\nThe special registers are:\n__SP, the stack pointer__\nThe processor uses SP as a pointer to the active stack.\nIn the Thumb instruction set, most instructions cannot access SP. The only instructions that can\naccess SP are those designed to use SP as a stack pointer.\nThe ARM instruction set provides more general access to the SP, and it can be used as a\ngeneral-purpose register. However, ARM deprecates the use of SP for any purpose other than as a\nstack pointer.Software can refer to SP as R13.\n\n__LR, the link register__\nThe link register is a special register that can hold return link information. Some cases described in\nthis manual require this use of the LR. When software does not require the LR for linking, it can use\nit for other purposes. It can refer to LR as R14.\n\n__PC, the program counter__\n• When executing an ARM instruction, PC reads as the address of the current instruction plus 8.（PC始终指向你要取的指令的地址。ARM三级流水线，下一条指令是包含了预取指令，执行指令）\n• When executing a Thumb instruction, PC reads as the address of the current instruction plus 4.\n• Writing an address to PC causes a branch to that address.\nMost Thumb instructions cannot access PC.\nThe ARM instruction set provides more general access to the PC, and many ARM instructions can\nuse the PC as a general-purpose register. However, ARM deprecates the use of PC for any purpose\nother than as the program counter. Software can refer to PC as R15.\n\n##### A2.3.1 Writing to the PC\nIn ARMv7, many data-processing instructions can write to the PC. Writes to the PC are handled as follows:\n• The B, BL, CBNZ, CBZ, CHKA, HB, HBL, HBLP, HBP, TBB, and TBH instructions remain in the same instruction set state\nand branch to the value written to the PC.\nThe definition of each of these instructions ensures that the value written to the PC is correctly aligned for\nthe current instruction set state.\n\n• The BLX (immediate) instruction switches between ARM and Thumb states and branches to the value written\nto the PC. Its definition ensures that the value written to the PC is correctly aligned for the new instruction\nset state.\n\n• The following instructions write a value to the PC, treating that value as an interworking address to branch\nto, with low-order bits that determine the new instruction set state:\n\t— BLX (register), BX, and BXJ\n\t— LDR instructions with <Rt> equal to the PC\n\t— POP and all forms of LDM except LDM (exception return), when the register list includes the PC\n\t— in ARM state only, ADC, ADD, ADR, AND, ASR (immediate), BIC, EOR, LSL (immediate), LSR (immediate), MOV,\n\t\tMVN, ORR, ROR (immediate), RRX, RSB, RSC, SBC, and SUB instructions with <Rd> equal to the PC and without\n\t\tflag-setting specified.\n\n#### A2.4 The Application Program Status Register (APSR)\nFixme [APSR] Page49\n\n• Bits that can be set by many instructions:\n— The Condition flags:\n\tN, bit[31] Negative condition flag. Set to bit[31] of the result of the instruction. If the result is\n\tregarded as a two's complement signed integer, then the processor sets N to 1 if the result\n\tis negative, and sets N to 0 if it is positive or zero.\n\tZ, bit[30] Zero condition flag. Set to 1 if the result of the instruction is zero, and to 0 otherwise. A\n\tresult of zero often indicates an equal result from a comparison.\n\tC, bit[29] Carry condition flag. Set to 1 if the instruction results in a carry condition, for example an\n\tunsigned overflow on an addition.\n\tV, bit[28] Overflow condition flag. Set to 1 if the instruction results in an overflow condition, for\n\texample a signed overflow on an addition.\n\n— The Overflow or saturation flag:\n\tQ, bit[27] Set to 1 to indicate overflow or saturation occurred in some instructions, normally related\n\tto digital signal processing (DSP). For more information, see Pseudocode details of\n\tsaturation on page A2-44.\n\n— The Greater than or Equal flags:\n\tGE[3:0], bits[19:16]\n\tThe instructions described in Parallel addition and subtraction instructions on\n\tpage A4-171 update these flags to indicate the results from individual bytes or halfwords\n\tof the operation. These flags can control a later SEL instruction. For more information, see\n\tSEL on page A8-602.\n\nIn ARMv7-A and ARMv7-R, the APSR is the same register as the CPSR, but the APSR must be used only to access\nthe N, Z, C, V, Q, and GE[3:0] bits.\n\n#### A2.5 Execution state registers\nThe execution state registers modify the execution of instructions. They control:\n• Whether instructions are interpreted as Thumb instructions, ARM instructions, ThumbEE instructions, or\nJava bytecodes. For more information, see Instruction set state register, ISETSTATE.\n\n• In Thumb state and ThumbEE state only, the condition codes that apply to the next one to four instructions.\nFor more information, see IT block state register, ITSTATE on page A2-51.\n\n• Whether data is interpreted as big-endian or little-endian. For more information, see Endianness mapping\nregister, ENDIANSTATE on page A2-53.\n\nIn ARMv7-A and ARMv7-R, the execution state registers are part of the Current Program Status Register. For more\ninformation, see Program Status Registers (PSRs) on page B1-1147.\n\n##### A2.5.1 Instruction set state register, ISETSTATE\nThe instruction set state register, ISETSTATE, format is:\nThe J bit and the T bit determine the current instruction set state for the processor. Table A2-1 shows the encoding\nof these bits.\n\nFixme [Table A2-1 J and T bit encoding in ISETSTATE]Page50\n\n##### A2.5.2 IT block state register, ITSTATE\nFixme [Table A2-2 Effect of IT execution state bits]Page52\n\n##### A2.5.3 Endianness mapping register, ENDIANSTATE\nFixme [Table A2-3 ENDIANSTATE encoding of endianness]Page53\n\n\n#### A2.6 Advanced SIMD and Floating-point Extensions\nAdvanced SIMD and Floating-point (VFP) are two OPTIONAL extensions to ARMv7.\n\nThe Advanced SIMD Extension performs packed Single Instruction Multiple Data (SIMD) operations, either\ninteger or single-precision floating-point.\n\n....\n\n\n#### A2.11 Jazelle direct bytecode execution support\nThe Jazelle extension provides architectural support for hardware acceleration of bytecode execution by a Java Virtual\nMachine (JVM).\n\nThese requirements for the Jazelle extension mean a JVM can be written to both:\n• function correctly on all processors that include a Jazelle extension implementation\n• automatically take advantage of the accelerated bytecode execution provided by a processor that includes a\nnon-trivial implementation.\n\nThe required features of a non-trivial implementation are:\n• provision of the Jazelle state\n• a new instruction, BXJ, to enter Jazelle state\n• system support that enables an operating system to regulate the use of the Jazelle extension hardware\n• system support that enables a JVM to configure the Jazelle extension hardware to its specific needs.\n\n...\n\n### A3 Application Level Memory Model\n\n...\n\n#### A3.2 Alignment support\nInstructions in the ARM architecture are aligned as follows:\n• ARM instructions are word-aligned\n• Thumb and ThumbEE instructions are halfword-aligned\n• Java bytecodes are byte-aligned.\nIn the ARMv7 architecture, some load and store instructions support unaligned data accesses, as described in\nUnaligned data access.\n\n##### A3.2.1 Unaligned data access\nAn ARMv7 implementation must support unaligned data accesses to Normal memory by some load and store\ninstructions. __Software can set the SCTLR.A bit to control whether a misaligned access to Normal memory by one of these instructions causes an Alignment fault Data Abort exception.__\n\n__Unaligned access operations must not be used for accessing memory-mapped registers in a Device or Strongly-ordered memory region.__\n\nFixme [Table A3-1 Alignment requirements of load/store instructions]  page108\n\n#### A3.3 Endian support\nData support big-endian or little-endian.\n\n##### A3.3.1 Instruction endianness\n__In ARMv7-A, the mapping of instruction memory is always little-endian__. In ARMv7-R, instruction endianness can\nbe controlled at the system level, In ARMv7-A, the mapping of instruction memory is always little-endian. In ARMv7-R, instruction endianness can be controlled at the system level, see Instruction endianness static configuration, ARMv7-R only on page A3-112.\n\n##### A3.3.2 Element size and endianness\n\nFixme [Table A3-2 Element size of load/store instructions] page112\n\n##### A3.3.4 Endianness in Advanced SIMD\nAdvanced SIMD element load/store instructions transfer vectors of elements between memory and the Advanced\nSIMD register bank.An instruction specifies both the length of the transfer and the size of the data elements being\ntransferred. This information is used by the processor to load and store data correctly in both big-endian and\nlittle-endian systems.\n\n处理器根据提供的信息，能保证在Advanced SIMD register bank 中的数据是一样的，不论它是否是大端，小端\nFixme [Figure A3-2 Advanced SIMD byte order example] page113\n\n#### A3.4 Synchronization and semaphores\nIn architecture versions before ARMv6, support for the synchronization of shared memory depends on the SWP and\nSWPB instructions.These are read-locked-write operations that swap register contents with memory, and are\ndescribed in SWP, SWPB on page A8-722. These instructions support basic busy/free semaphore mechanisms, but\ndo not support mechanisms that require calculation to be performed on the semaphore between the read and write\nphases.\n\nARMv7 extends support for\nthis mechanism, and provides the following synchronization primitives in the ARM and Thumb instruction sets:\n• Load-Exclusives:\n\t— LDREX, see LDREX on page A8-432\n\t— LDREXB, see LDREXB on page A8-434\n\t— LDREXD, see LDREXD on page A8-436\n\t— LDREXH, see LDREXH on page A8-438\n• Store-Exclusives:\n\t— STREX, see STREX on page A8-690\n\t— STREXB, see STREXB on page A8-692\n\t— STREXD, see STREXD on page A8-694\n\t— STREXH, see STREXH on page A8-696\n• Clear-Exclusive, CLREX, see CLREX on page A8-360.\n\nNote\n• ARM strongly recommends that all software uses the synchronization primitives described in this section,\nrather than SWP or SWPB.\n\n##### A3.4.1 Exclusive access instructions and Non-shareable memory regions\nFor memory regions that do not have the Shareable attribute, the exclusive access instructions __rely on a local monitor that tags any address__ from which the processor executes a Load-Exclusive. Any non-aborted attempt by the\nsame processor to use a Store-Exclusive to modify any address is guaranteed to clear the tag.\n\nA Load-Exclusive performs a load from memory, and:\n• the executing processor tags the physical memory address for exclusive access\n• the local monitor of the executing processor transitions to the Exclusive Access state.\n\nA Store-Exclusive performs a conditional store to memory, that depends on the state of the local monitor:\n__If the local monitor is in the Exclusive Access state__\n\t• If the address of the Store-Exclusive is the same as the address that has been tagged in the\n\tmonitor by an earlier Load-Exclusive, then the store occurs, otherwise it is IMPLEMENTATION\n\tDEFINED whether the store occurs.\n\t• A status value is returned to a register:\n\t\t— if the store took place the status value is 0\n\t\t— otherwise, the status value is 1.\n\t• The local monitor of the executing processor transitions to the Open Access state.\n__If the local monitor is in the Open Access state__\n\t• no store takes place\n\t• a status value of 1 is returned to a register.\n\t• the local monitor remains in the Open Access state.\n\nFixme [Figure A3-3 Local monitor state machine diagram]Page 116\t\n\nFixme [Table A3-3 Effect of Exclusive instructions and write operations on the local monitor]Page 116\n\n\n##### A3.4.2 Exclusive access instructions and Shareable memory regions\nFor memory regions that have the Shareable attribute, exclusive access instructions rely on:\n• __A local monitor for each processor in the system__, that tags any address from which the processor executes a\nLoad-Exclusive. The local monitor can ignore accesses from other processors in the system.\n\n• __A global monitor that tags a physical address as exclusive access for a particular processor__. This tag is used\nlater to determine whether a Store-Exclusive to that address that has not been failed by the local monitor can\noccur. Any successful write to the tagged address by any other observer in the shareability domain of the\nmemory location is guaranteed to clear the tag. For each processor in the system, the global monitor:\n\t— can hold at least one tagged address\n\t— maintains a state machine for each tagged address it can hold.\n\n__Operation of the global monitor__\nA Load-Exclusive from Shareable memory performs a load from memory, and causes the __physical address of the access to be tagged as exclusive access for the requesting processor.__ This access also causes the exclusive access tag to be removed from any other physical address that has been tagged by the requesting processor.\n\nThe global monitor only supports a single outstanding exclusive access to Shareable memory per processor. A\nLoad-Exclusive by one processor has no effect on the global monitor state for any other processor.\n\nFixme [Table A3-4 Effect of load/store operations on global monitor for processor(n)] Page120\n\n\n##### A3.4.3 Tagging and the size of the tagged memory block\nTagged_address = Memory_address[31:a]\nThe value of a in this assignment is IMPLEMENTATION DEFINED, between a minimum value of 3 and a maximum\nvalue of 11. For example, in an implementation where a is 4, a successful LDREX of address 0x000341B4 gives a tag\nvalue of bits[31:4] of the address, giving 0x000341B. This means that the four words of memory from 0x000341B0 to\n0x000341BF are tagged for exclusive access.\n\nThe size of the tagged memory block is called the Exclusives Reservation Granule. The Exclusives Reservation\nGranule is IMPLEMENTATION DEFINED in the range 2-512 words:\n• 2 words in an implementation where a is 3\n• 512 words in an implementation where a is 11.\n\n##### A3.4.4 Context switch support\nAfter a context switch, software must ensure that the local monitor is in the Open Access state. This requires it to\neither:\n• execute a CLREX instruction\n• execute a dummy STREX to a memory address allocated for this purpose.\n\nNote:\nUsing a dummy STREX for this purpose is backwards-compatible with the ARMv6 implementation of the\nexclusive operations. The CLREX instruction is introduced in ARMv6K.\n\n##### A3.4.5 Load-Exclusive and Store-Exclusive usage restrictions\nThe Load-Exclusive and Store-Exclusive instructions are intended to work together, as a pair, for example a\nLDREX/STREX pair or a LDREXB/STREXB pair.\n\n• An implementation of the Load-Exclusive and Store-Exclusive instructions can require that, in any thread of\nexecution, the transaction size of a Store-Exclusive is the same as the transaction size of the preceding\nLoad-Exclusive executed in that thread.\n\n• An implementation might clear an exclusive monitor between the LDREX and the STREX, without any\napplication-related cause. Software written for such an implementation must, in any single thread of execution, __avoid having any explicit memory accesses, System control register updates, or cache maintenance operations between the LDREX instruction and the associated STREX instruction.__\n\n• In some implementations, an access to Strongly-ordered or Device memory might clear the exclusive\nmonitor. Therefore, __software must not place a load or a store to Strongly-ordered or Device memory between an LDREX and an STREX in a single thread of execution.__\n\n• Implementations can benefit from keeping the LDREX and STREX operations close together in a single thread of\nexecution. This minimizes the likelihood of the exclusive monitor state being cleared between the LDREX\ninstruction and the STREX instruction. Therefore, __for best performance, ARM strongly recommends a limit of 128 bytes between LDREX and STREX instructions in a single thread of execution.__\n\n• After taking a Data Abort exception, the state of the exclusive monitors is UNKNOWN. Therefore ARM\nstrongly recommends that the abort handling software performs a CLREX instruction, or a dummy STREX\ninstruction, to clear the monitor state.\n\n• The effect of a data or unified cache invalidate, cache clean, or cache clean and invalidate instruction on a\nlocal or global exclusive monitor that is in the Exclusive Access state is UNPREDICTABLE. Execution of the\ninstruction might clear the monitor, or it might leave it in the Exclusive Access state.\n\n• For the memory location being accessed by a LoadExcl/StoreExcl pair, if the memory attributes for the\nLoadExcl instruction differ from the memory attributes for the StoreExcl instruction, behavior is\nUNPREDICTABLE.\n\n##### A3.4.6 Semaphores\nThe Swap (SWP) and Swap Byte (SWPB) instructions must be used with care to ensure that expected behavior is\nobserved.\n\nNote\nFrom ARMv6, ARM deprecates use of the Swap and Swap Byte instructions, and strongly recommends that all new\nsoftware uses the Load-Exclusive and Store-Exclusive synchronization primitives\n\n##### A3.4.7 Synchronization primitives and the memory order model\nThe synchronization primitives follow the memory order model of the memory type accessed by the instructions.\nFor this reason:\n• Portable software for claiming a spin-lock must include a Data Memory Barrier (DMB) operation, performed\nby a DMB instruction, between claiming the spin-lock and making any access that makes use of the spin-lock.\n• Portable software for releasing a spin-lock must include a DMB instruction before writing to clear the spin-lock.\nThis requirement applies to software using:\n• the Load-Exclusive/Store-Exclusive instruction pairs, for example LDREX/STREX\n• the deprecated synchronization primitives, SWP/SWPB.\n\n[ISB > DSB > DMB](https://blog.csdn.net/wangbinyantai/article/details/78986974)\n\n##### A3.4.8 Use of WFE and SEV instructions by spin-locks\nARMv7 and ARMv6K provide Wait For Event and Send Event instructions, WFE and SEV, that can assist with\nreducing power consumption and bus contention caused by processors repeatedly attempting to obtain a spin-lock.\nThese instructions can be used at the application level, but a complete understanding of what they do depends on\nsystem level understanding of exceptions.\n\n#### A3.5 Memory types and attributes and the memory order model\n##### A3.5.1 Memory types\nexclusive memory types:\n• Normal\n• Device\n• Strongly-ordered.\n\n##### A3.5.2 Summary of ARMv7 memory attributes\n\n__Shareability__\nApplies only to Normal memory, and __to Device memory in an implementation that does not include the Large Physical Address Extension.__ In an implementation that includes the Large Physical\nAddress Extension, Device memory is always Outer Shareable,\nWhen it is possible to assign a shareability attribute to Device memory, ARM deprecates assigning\nany attribute other than Shareable or Outer Shareable, see Shareable attribute for Device memory\nregions on page A3-137\nWhether an ARMv7 implementation distinguishes between Inner Shareable and Outer Shareable\nmemory is IMPLEMENTATION DEFINED.\n\n__Cacheability__\nApplies only to Normal memory, and can be defined independently for Inner and Outer cache\nregions. Some cacheability attributes can be complemented by a cache allocation hint. This is an\nindication to the memory system of whether allocating a value to a cache is likely to improve\nperformance. \n\nFixme [Table A3-5 Memory attribute summary] page127\n\n##### A3.5.3 Atomicity in the ARM architecture\nAtomicity is a feature of memory accesses, described as atomic accesses. The ARM architecture description refers\nto two types of atomicity, defined in:\n• Single-copy atomicity\n• Multi-copy atomicity on page A3-130.\n\n__Single-copy atomicity__\nIn ARMv7, the single-copy atomic processor accesses are:\n• All byte accesses.\n• All halfword accesses to halfword-aligned locations.\n• All word accesses to word-aligned locations.\n• Memory accesses caused by a LDREXD/STREXD to a doubleword-aligned location for which the STREXD succeeds\ncause single-copy atomic updates of the doubleword being accessed.\nNote\nThe way to atomically load two 32-bit quantities is to perform a LDREXD/STREXD sequence, reading and writing\nthe same value, for which the STREXD succeeds, and use the read values\n\n__Multi-copy atomicity__\nIn a multiprocessing system, writes to a memory location are multi-copy atomic\n\nWrites to Normal memory are not multi-copy atomic. (有缓存机制以及SNOOP等)\nAll writes to Device and Strongly-ordered memory that are single-copy atomic are also multi-copy atomic.\n\n##### A3.5.4 Concurrent modification and execution of instructions\nThe ARMv7 architecture limits the set of instructions that can be executed by one thread of execution as they are\nbeing modified by another thread of execution without requiring explicit synchronization.\n\nExcept for the instructions identified in this section, the effect of the concurrent modification and execution of an\ninstruction is UNPREDICTABLE. （无条件跳转等命令，不受这个限制）\n\n\n__In the Thumb instruction set__\nThe 16-bit encodings of the B, NOP, BKPT, and SVC instructions\n\n__In the ARM instruction set__\nThe B, BL, NOP, BKPT, SVC, HVC, and SMC instructions.\n\n##### A3.5.5 Normal memory\nAccesses to normal memory region are idempotent, meaning that they exhibit the following properties:\n• read accesses can be repeated with no side-effects\n• repeated read accesses return the last value written to the resource being read\n• read accesses can fetch additional memory locations with no side-effects\n• write accesses can be repeated with no side-effects in the following cases:\n\t— if the contents of the location accessed are unchanged between the repeated writes\n\t— as the result of an exception, as described in this section\n• unaligned accesses can be supported\n• accesses can be merged before accessing the target memory system.\n\nNormal memory can be read/write or read-only, and a Normal memory region is defined as being either Shareable\nor Non-shareable.\n\n__Non-shareable Normal memory__\nFor a Normal memory region, the Non-shareable attribute identifies Normal memory that is likely to be accessed\nonly by a single processor.\n\n__Shareable, Inner Shareable, and Outer Shareable Normal memory__\nFor Normal memory, the Shareable and Outer Shareable memory attributes describe Normal memory that is\nexpected to __be accessed by multiple processors or other system masters:__\n• In a VMSA implementation, Normal memory that has the Shareable attribute but not the Outer Shareable\nattribute assigned is described as having the Inner Shareable attribute.\n• In a PMSA implementation, no distinction is made between Inner Shareable and Outer Shareable Normal\nmemory.\n\nVMSA: Virtual Memory System Architecture\nPMSA: Protected Memory System Architecture\n\n__Write-Through Cacheable, Write-Back Cacheable and Non-cacheable Normal memory__\nThe cacheability attributes provide a mechanism of coherency control with observers that lie outside the shareability\ndomain of a region of memory.\n• Write-Through Cacheable\n• Write-Back Cacheable\n• Non-cacheable.\n\nThe cacheability attributes provide a mechanism of coherency control with observers that lie outside the shareability\ndomain of a region of memory. In some cases, the use of Write-Through Cacheable or Non-cacheable regions of\nmemory might provide a better mechanism for controlling coherency than the use of hardware coherency\nmechanisms or the use of cache maintenance routines.\n\n##### A3.5.6 Device and Strongly-ordered memory\nExamples of memory regions normally marked as being Device or Strongly-ordered memory are Memory-mapped\nperipherals and I/O locations. __Address locations marked as Device or Strongly-ordered are never held in a cache.__\n\nThe architecture permits an Advanced SIMD element or structure load instruction to access bytes in Device or\nStrongly-ordered memory.\n\n__The architecture does not permit unaligned accesses to Strongly-ordered or Device memory.__\n\n###### Shareable attribute for Device memory regions\nIn an implementation that does not include the Large Physical Address Extension, Device memory regions can be\ngiven the Shareable attribute. When a Device memory region is give the Shareable attribute it can also be given the\nOuter Shareable attribute. This means that a region of Device memory can be described as one of:\n• Outer Shareable Device memory\n• Inner Shareable Device memory\n• Non-shareable Device memory.\n\n\nARM deprecates the marking of Device memory with a shareability attribute other than Outer Shareable or\nShareable. This means __ARM strongly recommends that Device memory is never assigned a shareability attribute of Non-shareable or Inner Shareable.__\n\n###### Device and Strongly-ordered memory shareability, Large Physical Address Extension\nIn an implementation that includes the Large Physical Address Extension, the Long-descriptor translation table\nformat does not distinguish between Shareable and Non-shareable Device memory.\n\nIn an implementation that includes the Large Physical Address Extension and is using the Short-descriptor\ntranslation table format:\n• An address-based cache maintenance operation for an addresses in a region with the Strongly-ordered or\nDevice memory type applies to all processors in the same Outer Shareable domain, regardless of any\nshareability attributes applied to the region.\n• Device memory transactions to a single peripheral must not be reordered, regardless of any shareability\nattributes that are applied to the corresponding Device memory region.\nAny single peripheral has an IMPLEMENTATION DEFINED size of not less than 1KB.\n\n##### A3.5.7 Memory access restrictions\nThe following restrictions apply to memory accesses:\n• For accesses to any two bytes, p and q, that are generated by the same instruction:\n\t— The bytes p and q must have the same memory type and shareability attributes\n\t— Except for possible differences in the cache allocation hints, ARM deprecates having different\n\tcacheability attributes for the bytes p and q.\n\n• Unaligned data access on page A3-108 identifies the instructions that can make an unaligned memory\naccess,If such an access is to Device or Strongly-ordered memory then:\n\t— if the implementation does not include the Virtualization Extensions, the effect is UNPREDICTABLE\n\t— if the implementation includes the Virtualization Extensions, the access generates an Alignment fault\n\n• __The accesses of an instruction that causes multiple accesses to Device or Strongly-ordered memory must not cross a 4KB address boundary__\n\n• __Any instruction fetch must access only Normal memory.__ If it accesses Device or Strongly-ordered memory,\nthe result is UNPREDICTABLE.\n\n\n##### A3.5.8 The effect of the Security Extensions\nThe Security Extensions can be included as part of an ARMv7-A implementation, with a VMSA. They provide two\ndistinct 4GByte virtual memory spaces:\n• a Secure virtual memory space\n• a Non-secure virtual memory space.\nThe Secure virtual memory space is accessed by memory accesses in the Secure state, and the Non-secure virtual\nmemory space is accessed by memory accesses in the Non-secure state.\nBy providing different virtual memory spaces, the Security Extensions permit memory accesses made from the\nNon-secure state to be distinguished from those made from the Secure state.\n\n#### A3.6 Access rights\n##### A3.6.1 Processor privilege levels, execution privilege, and access privilege\nARMv7 architecture defines different levels of execution privilege:\n• in Secure state, the privilege levels are PL1 and PL0\n• in Non-secure state, the privilege levels are PL2, PL1, and PL0.\n\n__PL0__\nThe privilege level of application software, that executes in User mode. Therefore, software\nexecuted in User mode is described as unprivileged software. This software cannot access some\nfeatures of the architecture. In particular, it cannot change many of the configuration settings.\nSoftware executing at PL0 makes only unprivileged memory accesses.\n\n__PL1__\nSoftware execution in all modes other than User mode and Hyp mode is at PL1. Normally, operating\nsystem software executes at PL1. Software executing at PL1 can access all features of the\narchitecture, and can change the configuration settings for those features, except for some features\nadded by the Virtualization Extensions that are only accessible at PL2.\nNote\nIn many implementation models, system software is unaware of the PL2 level of privilege, and of\nwhether the implementation includes the Virtualization Extensions.\nThe PL1 modes refers to all the modes other than User mode and Hyp mode.\nSoftware executing at PL1 makes privileged memory accesses by default, but can also make\nunprivileged accesses.\n\n__PL2__\nSoftware executing in Hyp mode executes at PL2.\nSoftware executing at PL2 can perform all of the operations accessible at PL1, and can access some\nadditional functionality.\nHyp mode is normally used by a hypervisor, that controls, and can switch between, Guest OSs, that\nexecute at PL1.\n\nHyp mode is implemented only as part of the Virtualization Extensions, and only in Non-secure\nstate. This means that:\n• implementations that do not include the Virtualization Extensions have only two privilege\nlevels, PL0 and PL1\n• execution in Secure state has only two privilege levels, PL0 and PL1\n\n#### A3.8 Memory access order\n\n##### A3.8.1 Reads and writes\nThe following can cause memory accesses that are not explicit:\n• instruction fetches\n• cache loads and write-backs\n• translation table walks.\n\n###### Reads\nReads are defined as memory operations that have the semantics of a load.\nThe memory accesses of the following instructions are reads:\n• LDR, LDRB, LDRH, LDRSB, and LDRSH.\n• LDRT, LDRBT, LDRHT, LDRSBT, and LDRSHT.\n• LDREX, LDREXB, LDREXD, and LDREXH.\n• LDM, LDRD, POP, and RFE.\n• LDC, LDC2, VLDM, VLDR, VLD1, VLD2, VLD3, VLD4, and VPOP.\n• The return of status values by STREX, STREXB, STREXD, and STREXH.\n• SWP and SWPB. These instructions are available only in the ARM instruction set.\n• TBB and TBH. These instructions are available only in the Thumb instruction set.\nHardware-accelerated opcode execution by the Jazelle extension can cause a number of reads to occur, according\nto the state of the operand stack and the implementation of the Jazelle hardware acceleration.\n\n###### Writes\nWrites are defined as memory operations that have the semantics of a store.\nThe memory accesses of the following instructions are Writes:\n• STR, STRB, and STRH.\n• STRT, STRBT, and STRHT.\n• STREX, STREXB, STREXD, and STREXH.\n• STM, STRD, PUSH, and SRS.\n• STC, STC2, VPUSH, VSTM, VSTR, VST1, VST2, VST3, and VST4.\n• SWP and SWPB. These instructions are available only in the ARM instruction set.\nHardware-accelerated opcode execution by the Jazelle extension can cause a number of writes to occur, according\nto the state of the operand stack and the implementation of the Jazelle hardware acceleration.\n\n###### Synchronization primitives\nSynchronization primitives must ensure correct operation of system semaphores in the memory order model. They are the following instructions:\n• LDREX, STREX, LDREXB, STREXB, LDREXD, STREXD, LDREXH, STREXH.\n• SWP, SWPB. From ARMv6, ARM deprecates the use of these instructions.\n\n##### A3.8.3 Memory barriers\nMemory barrier is the general term applied to an instruction, or sequence of instructions, that forces synchronization\nevents by a processor with respect to retiring load/store instructions.\n\nThe ARM architecture defines a number of memory barriers that provide a range of functionality, including:\n• ordering of load/store instructions\n• completion of load/store instructions\n• context synchronization.\n\nIn ARMv7 the memory barriers are provided as instructions that are available in the ARM and Thumb\ninstruction sets, and in ARMv6 the memory barriers are performed by CP15 register writes. The three memory\nbarriers are:\n• Data Memory Barrier, see Data Memory Barrier (DMB) on page A3-152\n• Data Synchronization Barrier, see Data Synchronization Barrier (DSB) on page A3-153\n• Instruction Synchronization Barrier, see Instruction Synchronization Barrier (ISB) on page A3-153.\n\n###### Data Memory Barrier (DMB)\nThe DMB instruction is a data memory barrier. __DMB only affects memory accesses and data and unified cache maintenance operations,  It has no effect on the ordering of any other instructions executing on the processor.__\n\n###### Data Synchronization Barrier (DSB)\nThe DSB instruction is a special memory barrier, that synchronizes the execution stream with memory accesses. __In addition, no instruction that appears in program order after the DSB instruction can execute until the DSB completes.__\n\n###### Instruction Synchronization Barrier (ISB)\n__An ISB instruction flushes the pipeline in the processor, so that all instructions that come after the ISB instruction in program order are fetched from cache or memory only after the ISB instruction has completed.__\n\nUsing an ISB ensures that the effects of context-changing operations executed before the ISB are visible to the instructions fetched after the ISB instruction. \n\nExamples of context-changing operations that require the insertion of an ISB instruction to ensure\nthe effects of the operation are visible to instructions fetched after the ISB instruction are:\n• completed cache, TLB, and branch predictor maintenance operations\n• changes to system control registers. \n\n#### A3.9 Caches and memory hierarchy\n\n##### A3.9.1 Introduction to caches\nA cache is a block of high-speed memory that contains a number of entries, each consisting of:\n• main memory address information, commonly called a tag\n• the associated data\n\n##### A3.9.2 Memory hierarchy\nMemory close to a processor has very low latency, but is limited in size and expensive to implement.To optimize overall\nperformance, an ARMv7 memory system can include multiple levels of cache in a hierarchical memory system. \n\nFixme[Figure A3-6 Multiple levels of cache in a memory hierarchy] page 157\n\n##### A3.9.4 Preloading caches\nThe ARM architecture provides memory system hints PLD (Preload Data), PLDW (Preload Data with intent to write),\nand PLI (Preload Instruction) to permit software to communicate the expected use of memory locations to the\nhardware. \n\n### A4. The Instruction Sets\n#### A4.1 About the instruction sets\nARMv7 contains two main instruction sets, the ARM and Thumb instruction sets. \n\nThe ARM and Thumb instruction sets can interwork freely, that is, different procedures can be compiled or assembled to different instruction sets, and still be able to call each other efficiently.\n\n__ThumbEE__ is a variant of the Thumb instruction set that is designed as a target for __dynamically generated code.__\nHowever, it cannot interwork freely with the ARM and Thumb instruction sets.\n\nThe two instruction sets differ in how instructions are encoded:\n• Thumb instructions are either 16-bit or 32-bit, and are aligned on __a two-byte boundary__. 16-bit and 32-bit\ninstructions can be intermixed freely. Many common operations are most efficiently executed using 16-bit\ninstructions. However:\n\t— Most 16-bit instructions can only access the first eight of the ARM core registers, R0-R7. These are\n\tcalled the low registers. A small number of 16-bit instructions can also access the high registers,\n\tR8-R15.\n\t— Many operations that would require two or more 16-bit instructions can be more efficiently executed\n\twith a single 32-bit instruction.\n\t— All 32-bit instructions can access all of the ARM core registers, R0-R15.\n\n• ARM instructions are always 32-bit, and are aligned on a four-byte boundary\n\n##### A4.1.1 Changing between Thumb state and ARM state\n\n###### Thumb to ARM state\nA processor in Thumb state can enter ARM state by executing any of the following instructions: __BX, BLX, or an LDR or LDM that loads the PC.__\n\n###### ARM to Thumb state\nA processor in ARM state can enter Thumb state by executing any of the same instructions.\n\nIn ARMv7, a processor in ARM state can also enter Thumb state by executing an ADC, ADD, AND, ASR, BIC, EOR, LSL,\nLSR, MOV, MVN, ORR, ROR, RRX, RSB, RSC, SBC, or SUB instruction that __has the PC as destination register and does not set the condition flags.__\n\n###### others\nThe target instruction set is either encoded directly in the instruction (for the immediate offset version of BLX), or is\nheld as bit[0] of an interworking address. For details, see the description of the BXWritePC() function in Pseudocode\ndetails of operations on ARM core registers on page A2-47.\nbit[0]    1 thumb      thumb is 2 bytes boundary but ARM some support Jazella extension\nbit[1:0] 00 arm        arm is 4 bytes boundary\nbit[1:0] 10 unknown\n\nException entries and returns can also change between ARM and Thumb states. For details see Exception handling\non page B1-1165.\n\n##### A4.1.2 Conditional execution\nIn the ARM and Thumb instruction sets, most instructions can be conditionally executed\n\nIn the ARM instruction set,  has its normal effect on the programmers’ model operation, memory and coprocessors if the N, Z, C and V condition flags in the APSR satisfy.\n\nIf the flags do not satisfy this condition, the instruction acts as a NOP.\n\nIn the Thumb instruction set, different mechanisms control conditional execution:\n• For the following Thumb encodings, conditional execution is controlled in a similar way to the ARM\ninstructions:\n\t— A 16-bit conditional branch instruction encoding, with a branch range of –256 to +254 bytes. Before\n\tARMv6T2, this was the only mechanism for conditional execution in Thumb code.\n\t— A 32-bit conditional branch instruction encoding, with a branch range of approximately ±1MB.\n\n• The CBZ and CBNZ instructions, Compare and Branch on Zero and Compare and Branch on Nonzero, are 16-bit\nconditional instructions with a branch range of +4 to +130 bytes.\t\n\n• The 16-bit If-Then instruction makes up to four following instructions conditional, and can make most other\nThumb instructions conditional. For details see IT on page A8-390. \n\n#### A4.3 Branch instructions\nFixme [Table A4-1 Branch instructions] Page164\n\n#### A4.4 Data-processing instructions\n##### A4.4.1 Standard data-processing instructions\nFixme [Table A4-2 Standard data-processing instructions] Page166\n\n##### A4.4.2 Shift instructions\nFixme [Table A4-3 Shift instructions] Page167\n\n##### A4.4.3 Multiply instructions\nThese instructions can operate on signed or unsigned quantities. In some types of operation, the results are same\nwhether the operands are signed or unsigned.\n\nFixme [Table A4-4 General multiply instructions] Page167\n\nFixme [Table A4-5 Signed multiply instructions] Page168\n\nFixme [Table A4-6 Unsigned multiply instructions] Page168\n\n##### A4.4.4 Saturating instructions\n饱和指令： 将超出unsigned, signed 的值限制到本身支持的最大值或最小值\n\n##### A4.4.5 Saturating addition and subtraction instructions\n\n##### A4.4.6 Packing and unpacking instructions\n扩展指令： 将[半]字节扩展到[有/无]32位\n\n##### A4.4.7 Parallel addition and subtraction instructions\nThese instructions perform additions and subtractions on the values of two registers and write the result to a\ndestination register, treating the register values as sets of two halfwords or four bytes. That is, they perform SIMD\nadditions or subtractions on the registers. \n\n##### A4.4.8 Divide instructions\n\nFor descriptions of the instructions see:\n• SDIV on page A8-600\n• UDIV on page A8-760\n\nIn the ARMv7-R profile, the SCTLR.DZ bit enables divide by zero fault detection:\nSCTLR.DZ == 0 Divide-by-zero returns a zero result.\nSCTLR.DZ == 1 SDIV and UDIV generate an Undefined Instruction exception on a divide-by-zero.\nThe SCTLR.DZ bit is cleared to zero on reset\n\n##### A4.4.9 Miscellaneous data-processing instructions\nFixme [Table A4-11 Miscellaneous data-processing instructions] page173\n\n#### A4.5 Status register access instructions\n\nThe MRS and MSR instructions move the contents of the Application Program Status Register (APSR) to or from an\nARM core register, see:\n• MRS on page A8-496\n• MSR (immediate) on page A8-498\n• MSR (register) on page A8-500.\n\nAt system level, software can also:\n• use these instructions to access the SPSR of the current mode\n• use the CPS instruction to change the CPSR.M field and the CPSR.{A, I, F} interrupt mask bits.\n\n#### A4.6 Load/store instructions\nFixme [Table A4-12 Load/store instructions] Page175\n\n#### A4.7 Load/store multiple instructions\nLoad Multiple instructions load a subset, or possibly all, of the ARM core registers from memory.\nStore Multiple instructions store a subset, or possibly all, of the ARM core registers to memory.\n\nFixme [Table A4-13 Load/store multiple instructions] Page177\n\n#### A4.8 Miscellaneous instructions\nFixme [Table A4-14 Miscellaneous instructions] Page178\n\n#### A4.9 Exception-generating and exception-handling instructions\nThe following instructions are intended specifically to cause a synchronous processor exception to occur:\n• The SVC instruction generates a Supervisor Call exception. For more information, see Supervisor Call (SVC)\nexception on page B1-1210.\n• The Breakpoint instruction BKPT provides software breakpoints. For more information, see About debug\nevents on page C3-2038.\n• In a processor that implements the Security Extensions, when executing at PL1 or higher, the SMC instruction\ngenerates a Secure Monitor Call exception. For more information, see Secure Monitor Call (SMC) exception\non page B1-1211.\n• In a processor that implements the Virtualization Extensions, in software executing in a Non-secure PL1\nmode, the HVC instruction generates a Hypervisor Call exception. For more information, see Hypervisor Call\n(HVC) exception on page B1-1212.\n\nFixme [Table A4-15 Exception-generating and exception-handling instructions] Page179\n\n#### A4.10 Coprocessor instructions\nThere are three types of instruction for communicating with coprocessors. These permit the processor to:\n• Initiate a coprocessor data-processing operation. For details see CDP, CDP2 on page A8-358.\n• Transfer ARM core registers to and from coprocessor registers. For details, see:\n\t— MCR, MCR2 on page A8-476\n\t— MCRR, MCRR2 on page A8-478\n\t— MRC, MRC2 on page A8-492\n\t— MRRC, MRRC2 on page A8-494.\n• Load or store the values of coprocessor registers. For details, see:\n\t— LDC, LDC2 (immediate) on page A8-392\n\t— LDC, LDC2 (literal) on page A8-394\n\t— STC, STC2 on page A8-662.\n\n#### A4.11 Advanced SIMD and Floating-point load/store instructions\nFixme [Table A4-16 Extension register load/store instructions] Page181\nFixme [Table A4-17 Element and structure load/store instructions] Page181\n\n#### A4.12 Advanced SIMD and Floating-point register transfer instructions\nFixme [Table A4-18 Extension register transfer instructions] Page183\n\n#### A4.13 Advanced SIMD data-processing instructions\nAdvanced SIMD data-processing instructions process registers containing vectors of elements of the same type\npacked together, enabling the same operation to be performed on multiple items in parallel.\n\nFixme [Figure A4-2 Advanced SIMD instruction operating on 64-bit registers] Page184\n\n##### A4.13.1 Advanced SIMD parallel addition and subtraction\n\nFixme [Table A4-19 Advanced SIMD parallel add and subtract instructions] Page185\n\n##### A4.13.2 Bitwise Advanced SIMD data-processing instructions\nFixme [Table A4-20 Bitwise Advanced SIMD data-processing instructions] Page186\n\n##### A4.13.3 Advanced SIMD comparison instructions\nFixme [Table A4-21 Advanced SIMD comparison instructions] Page186\n\n##### A4.13.4 Advanced SIMD shift instructions\nFixme [Table A4-22 Advanced SIMD shift instructions] Page187\n\n##### A4.13.5 Advanced SIMD multiply instructions\nFixme [Table A4-23 Advanced SIMD multiply instructions] Page188\n\n##### A4.13.6 Miscellaneous Advanced SIMD data-processing instructions\nFixme [Table A4-24 Miscellaneous Advanced SIMD data-processing instructions] Page189\n\n#### A4.14 Floating-point data-processing instruction\nFixme [Table A4-25 Floating-point data-processing instructions] Page191\n\n\n### A5. ARM Instruction Set Encoding\n#### A5.1 ARM instruction set encoding\n__The ARM instruction stream is a sequence of word-aligned words. Each ARM instruction is a single 32-bit word__ in\nthat stream. The encoding of an ARM instruction is:\n\nFixme [32 bits instruction structure] page194\n\nFixme [Table A5-1 ARM instruction encoding] page194\n\n##### A5.1.1 The condition code field\nThis field contains one of the values 0b0000-0b1110, as shown in Table A8-1 on page A8-288.\nFixme [Table A8-1 Condition codes]page288\n\n#### A5.2 Data-processing and miscellaneous instructions\nFixme [data process instructions structure]page196\n\nFixme [Table A5-2 Data-processing and miscellaneous instructions]page196\n\n其余指令可参照此命令，只是op 的不同。\n\n### A6. Thumb Instruction Set Encoding\n#### A6.1 Thumb instruction set encoding\nThe Thumb instruction stream is a sequence of halfword-aligned halfwords. Each Thumb instruction is either a\nsingle 16-bit halfword in that stream, or a 32-bit instruction consisting of two consecutive halfwords in that stream.\nIf the value of bits[15:11] of the halfword being decoded is one of the following, the halfword is the first halfword\nof a 32-bit instruction:\n• 0b11101\n• 0b11110\n• 0b11111.\nOtherwise, the halfword is a 16-bit instruction\n\n疑问点：thumb 是16bit 或32bit对齐，那怎么与32 bit的ARM 指令集怎么区分？\n当ARM 处于ARM state，CPU 将会按照32 bit ARM指令集去取指并执行，反之使用16、32bit 的thumb 指令集解析。\n\n#### A6.2 16-bit Thumb instruction encoding\nFixme [16-bit thumb instruction encoding]page223\n\nFixme [Table A6-1 16-bit Thumb instruction encoding]page223\n\n#### A6.3 32-bit Thumb instruction encoding\nFixme [ 32-bit Thumb instruction encoding]page230\n\nFixme [Table A6-9 32-bit Thumb instruction encoding]page230\n\n### A7 Advanced SIMD and Floating-point Instruction Encoding\nskip\n\n### A9 The ThumbEE Instruction Set\n#### A9.1 About the ThumbEE instruction set\nIn general, __instructions in ThumbEE are identical to Thumb instructions__, with the following exceptions:\n• A small number of instructions are affected by modifications to transitions from ThumbEE state. For more\ninformation, see ThumbEE state transitions.\n\n• __A substantial number of instructions have a null check on the base register before any other operation takes__\nplace, but are identical (or almost identical) in all other respects. For more information, see Null checking on\npage A9-1113.\n\n• A small number of instructions are modified in additional ways. See Instructions with modifications on\npage A9-1113.\n\n• Three Thumb instructions, BLX (immediate), 16-bit LDM, and 16-bit STM, are removed in ThumbEE state.\nThe encoding corresponding to BLX (immediate) in Thumb is UNDEFINED in ThumbEE state.\n16-bit LDM and STM are replaced by new instructions, for details see Additional ThumbEE instructions on\npage A9-1123.\n\n• Two new 32-bit instructions, ENTERX and LEAVEX, are introduced in both the Thumb instruction set and the\nThumbEE instruction set. See Additional instructions in Thumb and ThumbEE instruction sets on\npage A9-1116. These instructions use previously UNDEFINED encodings.\n\n__Attempting to execute ThumbEE instructions at PL2 is UNPREDICTABLE.__\n\n##### A9.1.1 ThumbEE state transitions\nInstruction set state transitions to ThumbEE state can occur implicitly as part of a return from exception, or\nexplicitly on execution of an __ENTERX instruction.__\n\nInstruction set state transitions from ThumbEE state can only occur due to an exception, or due to a transition to\nThumb state using the __LEAVEX instruction.__ Return from exception instructions (RFE and SUBS PC, LR, #imm) are\nUNPREDICTABLE in ThumbEE state.\n\n##### A9.1.2 Null checking\nA null check is performed for all load/store instructions when they are executed in ThumbEE state. If the value in\nthe base register is zero, execution branches to the NullCheck handler at HandlerBase – 4.\n\n#### A9.2 ThumbEE instruction set encoding\nIn general, instructions in the ThumbEE instruction set are encoded in exactly the same way as Thumb instructions\ndescribed in Chapter A6 Thumb Instruction Set Encoding. The differences are as follows:\n• There are no 16-bit LDM or STM instructions in the ThumbEE instruction set.\n• The 16-bit encodings used for LDM and STM in the Thumb instruction set are used for different 16-bit\ninstructions in the ThumbEE instruction set. For details, see 16-bit ThumbEE instructions.\n• There are two new 32-bit instructions in both Thumb state and ThumbEE state. For details, see Additional\ninstructions in Thumb and ThumbEE instruction sets on page A9-1116.\n\n##### A9.2.1 16-bit ThumbEE instructions\nFixme [Table A9-2 16-bit ThumbEE instructions]page1115\n\n#### A9.3 Additional instructions in Thumb and ThumbEE instruction sets\nOn a processor with the ThumbEE Extension, there are two additional 32-bit instructions, ENTERX and LEAVEX. These\nare available in both Thumb state and ThumbEE state.\n##### A9.3.1 ENTERX, LEAVEX\nENTERX causes a change from Thumb state to ThumbEE state, or has no effect in ThumbEE state.\nENTERX is UNDEFINED in Hyp mode.\nLEAVEX causes a change from ThumbEE state to Thumb state, or has no effect in Thumb state.\n\n### A8 Instruction Descriptions\n\n#### A8.2 Standard assembler syntax fields\nThe following assembler syntax fields are standard across all or most instructions:\n<c> Is an optional field. It specifies the condition under which the instruction is executed. See\n\tConditional execution on page A8-288 for the range of available conditions and their encoding. If\n\t<c> is omitted, it defaults to always (AL).\n\n<q> Specifies optional assembler qualifiers on the instruction. The following qualifiers are defined:\n\t.N Meaning narrow, specifies that the assembler must select a 16-bit encoding for the\n\tinstruction. If this is not possible, an assembler error is produced.\n\t.W Meaning wide, specifies that the assembler must select a 32-bit encoding for the\n\tinstruction. If this is not possible, an assembler error is produced.\n\n#### A8.3 Conditional execution\t\nMost ARM instructions, and most Thumb instructions from ARMv6T2 onwards, can be executed conditionally,\nbased on the values of the APSR condition flags.\n\nFixme [Table A8-1 Condition codes]page288\n","slug":"arm_arm","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0po001azkgrv10ioxqr","content":"<h2 id=\"Part-A-Application-Level-Architecture\"><a href=\"#Part-A-Application-Level-Architecture\" class=\"headerlink\" title=\"Part A. Application Level Architecture\"></a>Part A. Application Level Architecture</h2><hr>\n<h3 id=\"A1-Introduction-to-the-ARM-Architecture\"><a href=\"#A1-Introduction-to-the-ARM-Architecture\" class=\"headerlink\" title=\"A1. Introduction to the ARM Architecture\"></a>A1. Introduction to the ARM Architecture</h3><hr>\n<a id=\"more\"></a>\n<h4 id=\"A1-4-Architecture-extensions\"><a href=\"#A1-4-Architecture-extensions\" class=\"headerlink\" title=\"A1.4 Architecture extensions\"></a>A1.4 Architecture extensions</h4><p><strong>Jazelle</strong><br>Is the Java bytecode execution extension that extended ARMv5TE to ARMv5TEJ. From<br>ARMv6, the architecture requires at least the trivial Jazelle implementation, but a Jazelle<br>implementation is still often described as a Jazelle extension.<br>The Virtualization Extensions require that the Jazelle implementation is the trivial Jazelle<br>implementation.</p>\n<p><strong>ThumbEE</strong><br>Is an extension that provides the ThumbEE instruction set, a variant of the Thumb<br>instruction set that is designed as a target for dynamically generated code. In the original<br>release of the ARMv7 architecture, the ThumbEE extension was:<br>• A required extension to the ARMv7-A profile.<br>• An optional extension to the ARMv7-R profile.</p>\n<p>From publication of issue C.a of this manual, ARM deprecates any use of ThumbEE<br>instructions. However, ARMv7-A implementations must continue to include ThumbEE<br>support, for backwards compatibility.</p>\n<p><strong>Floating-point</strong><br>Is a floating-point coprocessor extension to the instruction set architectures. For historic<br>reasons, the Floating-point Extension is also called the VFP Extension. </p>\n<p><strong>Advanced SIMD</strong><br>Is an instruction set extension that provides Single Instruction Multiple Data (SIMD)<br>integer and single-precision floating-point vector operations on doubleword and quadword<br>registers.    </p>\n<h3 id=\"A1-4-2-Architecture-extensions\"><a href=\"#A1-4-2-Architecture-extensions\" class=\"headerlink\" title=\"A1.4.2 Architecture extensions\"></a>A1.4.2 Architecture extensions</h3><p>This manual also describes the following extensions to the ARMv7 architecture:<br><strong>Security Extensions</strong></p>\n<p><strong>Multiprocessing Extensions</strong><br>Are an OPTIONAL set of extensions to the ARMv7-A and ARMv7-R profiles, that provides a set of<br>features that enhance multiprocessing functionality.</p>\n<p><strong>Large Physical Address Extension</strong><br>Is an OPTIONAL extension to VMSAv7 that provides an address translation system supporting<br>physical addresses of up to 40 bits at a fine grain of translation.<br>The Large Physical Address Extension requires implementation of the Multiprocessing Extensions.</p>\n<p><strong>Virtualization Extensions</strong><br>Are an OPTIONAL set of extensions to VMSAv7 that provides hardware support for virtualizing the<br>Non-secure state of a VMSAv7 implementation. This supports system use of a virtual machine<br>monitor, also called a hypervisor.</p>\n<p><strong>Generic Timer Extension</strong><br>Is an OPTIONAL extension to any ARMv7-A or ARMv7-R, that provides a system timer, and a<br>low-latency register interface to it.</p>\n<p><strong>Performance Monitors Extension</strong><br>The ARMv7 architecture:<br>• reserves CP15 register space for IMPLEMENTATION DEFINED performance monitors<br>• defines a recommended performance monitors implementation.</p>\n<hr>\n<h3 id=\"A2-Application-Level-Programmers’-Model\"><a href=\"#A2-Application-Level-Programmers’-Model\" class=\"headerlink\" title=\"A2. Application Level Programmers’ Model\"></a>A2. Application Level Programmers’ Model</h3><h4 id=\"A2-1-About-the-Application-level-programmers’-model\"><a href=\"#A2-1-About-the-Application-level-programmers’-model\" class=\"headerlink\" title=\"A2.1 About the Application level programmers’ model\"></a>A2.1 About the Application level programmers’ model</h4><p>Depending on the implemented architecture extensions, the architecture supports multiple levels of execution<br>privilege, that number upwards from PL0, where PL0 is the lowest privilege level and is often described as<br>unprivileged.</p>\n<p>When an operating system supports execution at both PL1 and PL0, an application usually runs unprivileged. This:<br>• permits the operating system to <strong>allocate system resources</strong> to an application in a unique or shared manner<br>• provides <strong>a degree of protection from other processes and tasks</strong>, and so helps protect the operating system<br>from malfunctioning applications.</p>\n<h4 id=\"A2-2-ARM-core-data-types-and-arithmetic\"><a href=\"#A2-2-ARM-core-data-types-and-arithmetic\" class=\"headerlink\" title=\"A2.2 ARM core data types and arithmetic\"></a>A2.2 ARM core data types and arithmetic</h4><p>All ARMv7-A and ARMv7-R processors support the following data types in memory:<br>Byte           8 bits<br>Halfword       16 bits<br>Word           32 bits<br>Doubleword     64 bits.</p>\n<p>Processor registers are 32 bits in size. The instruction set contains instructions supporting the following data types<br>held in registers:<br>• 32-bit pointers<br>• unsigned or signed 32-bit integers<br>• unsigned 16-bit or 8-bit integers, held in zero-extended form<br>• signed 16-bit or 8-bit integers, held in sign-extended form<br>• two 16-bit integers packed into a register<br>• four 8-bit integers packed into a register<br>• unsigned or signed 64-bit integers held in two registers.</p>\n<h4 id=\"A2-3-ARM-core-registers\"><a href=\"#A2-3-ARM-core-registers\" class=\"headerlink\" title=\"A2.3 ARM core registers\"></a>A2.3 ARM core registers</h4><p>In the application level view, an ARM processor has:<br>• thirteen general-purpose 32-bit registers, R0 to R12<br>• three 32-bit registers with special uses, SP, LR, and PC, that can be described as R13 to R15.<br>The special registers are:<br><strong>SP, the stack pointer</strong><br>The processor uses SP as a pointer to the active stack.<br>In the Thumb instruction set, most instructions cannot access SP. The only instructions that can<br>access SP are those designed to use SP as a stack pointer.<br>The ARM instruction set provides more general access to the SP, and it can be used as a<br>general-purpose register. However, ARM deprecates the use of SP for any purpose other than as a<br>stack pointer.Software can refer to SP as R13.</p>\n<p><strong>LR, the link register</strong><br>The link register is a special register that can hold return link information. Some cases described in<br>this manual require this use of the LR. When software does not require the LR for linking, it can use<br>it for other purposes. It can refer to LR as R14.</p>\n<p><strong>PC, the program counter</strong><br>• When executing an ARM instruction, PC reads as the address of the current instruction plus 8.（PC始终指向你要取的指令的地址。ARM三级流水线，下一条指令是包含了预取指令，执行指令）<br>• When executing a Thumb instruction, PC reads as the address of the current instruction plus 4.<br>• Writing an address to PC causes a branch to that address.<br>Most Thumb instructions cannot access PC.<br>The ARM instruction set provides more general access to the PC, and many ARM instructions can<br>use the PC as a general-purpose register. However, ARM deprecates the use of PC for any purpose<br>other than as the program counter. Software can refer to PC as R15.</p>\n<h5 id=\"A2-3-1-Writing-to-the-PC\"><a href=\"#A2-3-1-Writing-to-the-PC\" class=\"headerlink\" title=\"A2.3.1 Writing to the PC\"></a>A2.3.1 Writing to the PC</h5><p>In ARMv7, many data-processing instructions can write to the PC. Writes to the PC are handled as follows:<br>• The B, BL, CBNZ, CBZ, CHKA, HB, HBL, HBLP, HBP, TBB, and TBH instructions remain in the same instruction set state<br>and branch to the value written to the PC.<br>The definition of each of these instructions ensures that the value written to the PC is correctly aligned for<br>the current instruction set state.</p>\n<p>• The BLX (immediate) instruction switches between ARM and Thumb states and branches to the value written<br>to the PC. Its definition ensures that the value written to the PC is correctly aligned for the new instruction<br>set state.</p>\n<p>• The following instructions write a value to the PC, treating that value as an interworking address to branch<br>to, with low-order bits that determine the new instruction set state:<br>    — BLX (register), BX, and BXJ<br>    — LDR instructions with <rt> equal to the PC<br>    — POP and all forms of LDM except LDM (exception return), when the register list includes the PC<br>    — in ARM state only, ADC, ADD, ADR, AND, ASR (immediate), BIC, EOR, LSL (immediate), LSR (immediate), MOV,<br>        MVN, ORR, ROR (immediate), RRX, RSB, RSC, SBC, and SUB instructions with <rd> equal to the PC and without<br>        flag-setting specified.</rd></rt></p>\n<h4 id=\"A2-4-The-Application-Program-Status-Register-APSR\"><a href=\"#A2-4-The-Application-Program-Status-Register-APSR\" class=\"headerlink\" title=\"A2.4 The Application Program Status Register (APSR)\"></a>A2.4 The Application Program Status Register (APSR)</h4><p>Fixme [APSR] Page49</p>\n<p>• Bits that can be set by many instructions:<br>— The Condition flags:<br>    N, bit[31] Negative condition flag. Set to bit[31] of the result of the instruction. If the result is<br>    regarded as a two’s complement signed integer, then the processor sets N to 1 if the result<br>    is negative, and sets N to 0 if it is positive or zero.<br>    Z, bit[30] Zero condition flag. Set to 1 if the result of the instruction is zero, and to 0 otherwise. A<br>    result of zero often indicates an equal result from a comparison.<br>    C, bit[29] Carry condition flag. Set to 1 if the instruction results in a carry condition, for example an<br>    unsigned overflow on an addition.<br>    V, bit[28] Overflow condition flag. Set to 1 if the instruction results in an overflow condition, for<br>    example a signed overflow on an addition.</p>\n<p>— The Overflow or saturation flag:<br>    Q, bit[27] Set to 1 to indicate overflow or saturation occurred in some instructions, normally related<br>    to digital signal processing (DSP). For more information, see Pseudocode details of<br>    saturation on page A2-44.</p>\n<p>— The Greater than or Equal flags:<br>    GE[3:0], bits[19:16]<br>    The instructions described in Parallel addition and subtraction instructions on<br>    page A4-171 update these flags to indicate the results from individual bytes or halfwords<br>    of the operation. These flags can control a later SEL instruction. For more information, see<br>    SEL on page A8-602.</p>\n<p>In ARMv7-A and ARMv7-R, the APSR is the same register as the CPSR, but the APSR must be used only to access<br>the N, Z, C, V, Q, and GE[3:0] bits.</p>\n<h4 id=\"A2-5-Execution-state-registers\"><a href=\"#A2-5-Execution-state-registers\" class=\"headerlink\" title=\"A2.5 Execution state registers\"></a>A2.5 Execution state registers</h4><p>The execution state registers modify the execution of instructions. They control:<br>• Whether instructions are interpreted as Thumb instructions, ARM instructions, ThumbEE instructions, or<br>Java bytecodes. For more information, see Instruction set state register, ISETSTATE.</p>\n<p>• In Thumb state and ThumbEE state only, the condition codes that apply to the next one to four instructions.<br>For more information, see IT block state register, ITSTATE on page A2-51.</p>\n<p>• Whether data is interpreted as big-endian or little-endian. For more information, see Endianness mapping<br>register, ENDIANSTATE on page A2-53.</p>\n<p>In ARMv7-A and ARMv7-R, the execution state registers are part of the Current Program Status Register. For more<br>information, see Program Status Registers (PSRs) on page B1-1147.</p>\n<h5 id=\"A2-5-1-Instruction-set-state-register-ISETSTATE\"><a href=\"#A2-5-1-Instruction-set-state-register-ISETSTATE\" class=\"headerlink\" title=\"A2.5.1 Instruction set state register, ISETSTATE\"></a>A2.5.1 Instruction set state register, ISETSTATE</h5><p>The instruction set state register, ISETSTATE, format is:<br>The J bit and the T bit determine the current instruction set state for the processor. Table A2-1 shows the encoding<br>of these bits.</p>\n<p>Fixme [Table A2-1 J and T bit encoding in ISETSTATE]Page50</p>\n<h5 id=\"A2-5-2-IT-block-state-register-ITSTATE\"><a href=\"#A2-5-2-IT-block-state-register-ITSTATE\" class=\"headerlink\" title=\"A2.5.2 IT block state register, ITSTATE\"></a>A2.5.2 IT block state register, ITSTATE</h5><p>Fixme [Table A2-2 Effect of IT execution state bits]Page52</p>\n<h5 id=\"A2-5-3-Endianness-mapping-register-ENDIANSTATE\"><a href=\"#A2-5-3-Endianness-mapping-register-ENDIANSTATE\" class=\"headerlink\" title=\"A2.5.3 Endianness mapping register, ENDIANSTATE\"></a>A2.5.3 Endianness mapping register, ENDIANSTATE</h5><p>Fixme [Table A2-3 ENDIANSTATE encoding of endianness]Page53</p>\n<h4 id=\"A2-6-Advanced-SIMD-and-Floating-point-Extensions\"><a href=\"#A2-6-Advanced-SIMD-and-Floating-point-Extensions\" class=\"headerlink\" title=\"A2.6 Advanced SIMD and Floating-point Extensions\"></a>A2.6 Advanced SIMD and Floating-point Extensions</h4><p>Advanced SIMD and Floating-point (VFP) are two OPTIONAL extensions to ARMv7.</p>\n<p>The Advanced SIMD Extension performs packed Single Instruction Multiple Data (SIMD) operations, either<br>integer or single-precision floating-point.</p>\n<p>….</p>\n<h4 id=\"A2-11-Jazelle-direct-bytecode-execution-support\"><a href=\"#A2-11-Jazelle-direct-bytecode-execution-support\" class=\"headerlink\" title=\"A2.11 Jazelle direct bytecode execution support\"></a>A2.11 Jazelle direct bytecode execution support</h4><p>The Jazelle extension provides architectural support for hardware acceleration of bytecode execution by a Java Virtual<br>Machine (JVM).</p>\n<p>These requirements for the Jazelle extension mean a JVM can be written to both:<br>• function correctly on all processors that include a Jazelle extension implementation<br>• automatically take advantage of the accelerated bytecode execution provided by a processor that includes a<br>non-trivial implementation.</p>\n<p>The required features of a non-trivial implementation are:<br>• provision of the Jazelle state<br>• a new instruction, BXJ, to enter Jazelle state<br>• system support that enables an operating system to regulate the use of the Jazelle extension hardware<br>• system support that enables a JVM to configure the Jazelle extension hardware to its specific needs.</p>\n<p>…</p>\n<h3 id=\"A3-Application-Level-Memory-Model\"><a href=\"#A3-Application-Level-Memory-Model\" class=\"headerlink\" title=\"A3 Application Level Memory Model\"></a>A3 Application Level Memory Model</h3><p>…</p>\n<h4 id=\"A3-2-Alignment-support\"><a href=\"#A3-2-Alignment-support\" class=\"headerlink\" title=\"A3.2 Alignment support\"></a>A3.2 Alignment support</h4><p>Instructions in the ARM architecture are aligned as follows:<br>• ARM instructions are word-aligned<br>• Thumb and ThumbEE instructions are halfword-aligned<br>• Java bytecodes are byte-aligned.<br>In the ARMv7 architecture, some load and store instructions support unaligned data accesses, as described in<br>Unaligned data access.</p>\n<h5 id=\"A3-2-1-Unaligned-data-access\"><a href=\"#A3-2-1-Unaligned-data-access\" class=\"headerlink\" title=\"A3.2.1 Unaligned data access\"></a>A3.2.1 Unaligned data access</h5><p>An ARMv7 implementation must support unaligned data accesses to Normal memory by some load and store<br>instructions. <strong>Software can set the SCTLR.A bit to control whether a misaligned access to Normal memory by one of these instructions causes an Alignment fault Data Abort exception.</strong></p>\n<p><strong>Unaligned access operations must not be used for accessing memory-mapped registers in a Device or Strongly-ordered memory region.</strong></p>\n<p>Fixme [Table A3-1 Alignment requirements of load/store instructions]  page108</p>\n<h4 id=\"A3-3-Endian-support\"><a href=\"#A3-3-Endian-support\" class=\"headerlink\" title=\"A3.3 Endian support\"></a>A3.3 Endian support</h4><p>Data support big-endian or little-endian.</p>\n<h5 id=\"A3-3-1-Instruction-endianness\"><a href=\"#A3-3-1-Instruction-endianness\" class=\"headerlink\" title=\"A3.3.1 Instruction endianness\"></a>A3.3.1 Instruction endianness</h5><p><strong>In ARMv7-A, the mapping of instruction memory is always little-endian</strong>. In ARMv7-R, instruction endianness can<br>be controlled at the system level, In ARMv7-A, the mapping of instruction memory is always little-endian. In ARMv7-R, instruction endianness can be controlled at the system level, see Instruction endianness static configuration, ARMv7-R only on page A3-112.</p>\n<h5 id=\"A3-3-2-Element-size-and-endianness\"><a href=\"#A3-3-2-Element-size-and-endianness\" class=\"headerlink\" title=\"A3.3.2 Element size and endianness\"></a>A3.3.2 Element size and endianness</h5><p>Fixme [Table A3-2 Element size of load/store instructions] page112</p>\n<h5 id=\"A3-3-4-Endianness-in-Advanced-SIMD\"><a href=\"#A3-3-4-Endianness-in-Advanced-SIMD\" class=\"headerlink\" title=\"A3.3.4 Endianness in Advanced SIMD\"></a>A3.3.4 Endianness in Advanced SIMD</h5><p>Advanced SIMD element load/store instructions transfer vectors of elements between memory and the Advanced<br>SIMD register bank.An instruction specifies both the length of the transfer and the size of the data elements being<br>transferred. This information is used by the processor to load and store data correctly in both big-endian and<br>little-endian systems.</p>\n<p>处理器根据提供的信息，能保证在Advanced SIMD register bank 中的数据是一样的，不论它是否是大端，小端<br>Fixme [Figure A3-2 Advanced SIMD byte order example] page113</p>\n<h4 id=\"A3-4-Synchronization-and-semaphores\"><a href=\"#A3-4-Synchronization-and-semaphores\" class=\"headerlink\" title=\"A3.4 Synchronization and semaphores\"></a>A3.4 Synchronization and semaphores</h4><p>In architecture versions before ARMv6, support for the synchronization of shared memory depends on the SWP and<br>SWPB instructions.These are read-locked-write operations that swap register contents with memory, and are<br>described in SWP, SWPB on page A8-722. These instructions support basic busy/free semaphore mechanisms, but<br>do not support mechanisms that require calculation to be performed on the semaphore between the read and write<br>phases.</p>\n<p>ARMv7 extends support for<br>this mechanism, and provides the following synchronization primitives in the ARM and Thumb instruction sets:<br>• Load-Exclusives:<br>    — LDREX, see LDREX on page A8-432<br>    — LDREXB, see LDREXB on page A8-434<br>    — LDREXD, see LDREXD on page A8-436<br>    — LDREXH, see LDREXH on page A8-438<br>• Store-Exclusives:<br>    — STREX, see STREX on page A8-690<br>    — STREXB, see STREXB on page A8-692<br>    — STREXD, see STREXD on page A8-694<br>    — STREXH, see STREXH on page A8-696<br>• Clear-Exclusive, CLREX, see CLREX on page A8-360.</p>\n<p>Note<br>• ARM strongly recommends that all software uses the synchronization primitives described in this section,<br>rather than SWP or SWPB.</p>\n<h5 id=\"A3-4-1-Exclusive-access-instructions-and-Non-shareable-memory-regions\"><a href=\"#A3-4-1-Exclusive-access-instructions-and-Non-shareable-memory-regions\" class=\"headerlink\" title=\"A3.4.1 Exclusive access instructions and Non-shareable memory regions\"></a>A3.4.1 Exclusive access instructions and Non-shareable memory regions</h5><p>For memory regions that do not have the Shareable attribute, the exclusive access instructions <strong>rely on a local monitor that tags any address</strong> from which the processor executes a Load-Exclusive. Any non-aborted attempt by the<br>same processor to use a Store-Exclusive to modify any address is guaranteed to clear the tag.</p>\n<p>A Load-Exclusive performs a load from memory, and:<br>• the executing processor tags the physical memory address for exclusive access<br>• the local monitor of the executing processor transitions to the Exclusive Access state.</p>\n<p>A Store-Exclusive performs a conditional store to memory, that depends on the state of the local monitor:<br><strong>If the local monitor is in the Exclusive Access state</strong><br>    • If the address of the Store-Exclusive is the same as the address that has been tagged in the<br>    monitor by an earlier Load-Exclusive, then the store occurs, otherwise it is IMPLEMENTATION<br>    DEFINED whether the store occurs.<br>    • A status value is returned to a register:<br>        — if the store took place the status value is 0<br>        — otherwise, the status value is 1.<br>    • The local monitor of the executing processor transitions to the Open Access state.<br><strong>If the local monitor is in the Open Access state</strong><br>    • no store takes place<br>    • a status value of 1 is returned to a register.<br>    • the local monitor remains in the Open Access state.</p>\n<p>Fixme [Figure A3-3 Local monitor state machine diagram]Page 116    </p>\n<p>Fixme [Table A3-3 Effect of Exclusive instructions and write operations on the local monitor]Page 116</p>\n<h5 id=\"A3-4-2-Exclusive-access-instructions-and-Shareable-memory-regions\"><a href=\"#A3-4-2-Exclusive-access-instructions-and-Shareable-memory-regions\" class=\"headerlink\" title=\"A3.4.2 Exclusive access instructions and Shareable memory regions\"></a>A3.4.2 Exclusive access instructions and Shareable memory regions</h5><p>For memory regions that have the Shareable attribute, exclusive access instructions rely on:<br>• <strong>A local monitor for each processor in the system</strong>, that tags any address from which the processor executes a<br>Load-Exclusive. The local monitor can ignore accesses from other processors in the system.</p>\n<p>• <strong>A global monitor that tags a physical address as exclusive access for a particular processor</strong>. This tag is used<br>later to determine whether a Store-Exclusive to that address that has not been failed by the local monitor can<br>occur. Any successful write to the tagged address by any other observer in the shareability domain of the<br>memory location is guaranteed to clear the tag. For each processor in the system, the global monitor:<br>    — can hold at least one tagged address<br>    — maintains a state machine for each tagged address it can hold.</p>\n<p><strong>Operation of the global monitor</strong><br>A Load-Exclusive from Shareable memory performs a load from memory, and causes the <strong>physical address of the access to be tagged as exclusive access for the requesting processor.</strong> This access also causes the exclusive access tag to be removed from any other physical address that has been tagged by the requesting processor.</p>\n<p>The global monitor only supports a single outstanding exclusive access to Shareable memory per processor. A<br>Load-Exclusive by one processor has no effect on the global monitor state for any other processor.</p>\n<p>Fixme [Table A3-4 Effect of load/store operations on global monitor for processor(n)] Page120</p>\n<h5 id=\"A3-4-3-Tagging-and-the-size-of-the-tagged-memory-block\"><a href=\"#A3-4-3-Tagging-and-the-size-of-the-tagged-memory-block\" class=\"headerlink\" title=\"A3.4.3 Tagging and the size of the tagged memory block\"></a>A3.4.3 Tagging and the size of the tagged memory block</h5><p>Tagged_address = Memory_address[31:a]<br>The value of a in this assignment is IMPLEMENTATION DEFINED, between a minimum value of 3 and a maximum<br>value of 11. For example, in an implementation where a is 4, a successful LDREX of address 0x000341B4 gives a tag<br>value of bits[31:4] of the address, giving 0x000341B. This means that the four words of memory from 0x000341B0 to<br>0x000341BF are tagged for exclusive access.</p>\n<p>The size of the tagged memory block is called the Exclusives Reservation Granule. The Exclusives Reservation<br>Granule is IMPLEMENTATION DEFINED in the range 2-512 words:<br>• 2 words in an implementation where a is 3<br>• 512 words in an implementation where a is 11.</p>\n<h5 id=\"A3-4-4-Context-switch-support\"><a href=\"#A3-4-4-Context-switch-support\" class=\"headerlink\" title=\"A3.4.4 Context switch support\"></a>A3.4.4 Context switch support</h5><p>After a context switch, software must ensure that the local monitor is in the Open Access state. This requires it to<br>either:<br>• execute a CLREX instruction<br>• execute a dummy STREX to a memory address allocated for this purpose.</p>\n<p>Note:<br>Using a dummy STREX for this purpose is backwards-compatible with the ARMv6 implementation of the<br>exclusive operations. The CLREX instruction is introduced in ARMv6K.</p>\n<h5 id=\"A3-4-5-Load-Exclusive-and-Store-Exclusive-usage-restrictions\"><a href=\"#A3-4-5-Load-Exclusive-and-Store-Exclusive-usage-restrictions\" class=\"headerlink\" title=\"A3.4.5 Load-Exclusive and Store-Exclusive usage restrictions\"></a>A3.4.5 Load-Exclusive and Store-Exclusive usage restrictions</h5><p>The Load-Exclusive and Store-Exclusive instructions are intended to work together, as a pair, for example a<br>LDREX/STREX pair or a LDREXB/STREXB pair.</p>\n<p>• An implementation of the Load-Exclusive and Store-Exclusive instructions can require that, in any thread of<br>execution, the transaction size of a Store-Exclusive is the same as the transaction size of the preceding<br>Load-Exclusive executed in that thread.</p>\n<p>• An implementation might clear an exclusive monitor between the LDREX and the STREX, without any<br>application-related cause. Software written for such an implementation must, in any single thread of execution, <strong>avoid having any explicit memory accesses, System control register updates, or cache maintenance operations between the LDREX instruction and the associated STREX instruction.</strong></p>\n<p>• In some implementations, an access to Strongly-ordered or Device memory might clear the exclusive<br>monitor. Therefore, <strong>software must not place a load or a store to Strongly-ordered or Device memory between an LDREX and an STREX in a single thread of execution.</strong></p>\n<p>• Implementations can benefit from keeping the LDREX and STREX operations close together in a single thread of<br>execution. This minimizes the likelihood of the exclusive monitor state being cleared between the LDREX<br>instruction and the STREX instruction. Therefore, <strong>for best performance, ARM strongly recommends a limit of 128 bytes between LDREX and STREX instructions in a single thread of execution.</strong></p>\n<p>• After taking a Data Abort exception, the state of the exclusive monitors is UNKNOWN. Therefore ARM<br>strongly recommends that the abort handling software performs a CLREX instruction, or a dummy STREX<br>instruction, to clear the monitor state.</p>\n<p>• The effect of a data or unified cache invalidate, cache clean, or cache clean and invalidate instruction on a<br>local or global exclusive monitor that is in the Exclusive Access state is UNPREDICTABLE. Execution of the<br>instruction might clear the monitor, or it might leave it in the Exclusive Access state.</p>\n<p>• For the memory location being accessed by a LoadExcl/StoreExcl pair, if the memory attributes for the<br>LoadExcl instruction differ from the memory attributes for the StoreExcl instruction, behavior is<br>UNPREDICTABLE.</p>\n<h5 id=\"A3-4-6-Semaphores\"><a href=\"#A3-4-6-Semaphores\" class=\"headerlink\" title=\"A3.4.6 Semaphores\"></a>A3.4.6 Semaphores</h5><p>The Swap (SWP) and Swap Byte (SWPB) instructions must be used with care to ensure that expected behavior is<br>observed.</p>\n<p>Note<br>From ARMv6, ARM deprecates use of the Swap and Swap Byte instructions, and strongly recommends that all new<br>software uses the Load-Exclusive and Store-Exclusive synchronization primitives</p>\n<h5 id=\"A3-4-7-Synchronization-primitives-and-the-memory-order-model\"><a href=\"#A3-4-7-Synchronization-primitives-and-the-memory-order-model\" class=\"headerlink\" title=\"A3.4.7 Synchronization primitives and the memory order model\"></a>A3.4.7 Synchronization primitives and the memory order model</h5><p>The synchronization primitives follow the memory order model of the memory type accessed by the instructions.<br>For this reason:<br>• Portable software for claiming a spin-lock must include a Data Memory Barrier (DMB) operation, performed<br>by a DMB instruction, between claiming the spin-lock and making any access that makes use of the spin-lock.<br>• Portable software for releasing a spin-lock must include a DMB instruction before writing to clear the spin-lock.<br>This requirement applies to software using:<br>• the Load-Exclusive/Store-Exclusive instruction pairs, for example LDREX/STREX<br>• the deprecated synchronization primitives, SWP/SWPB.</p>\n<p><a href=\"https://blog.csdn.net/wangbinyantai/article/details/78986974\" target=\"_blank\" rel=\"noopener\">ISB &gt; DSB &gt; DMB</a></p>\n<h5 id=\"A3-4-8-Use-of-WFE-and-SEV-instructions-by-spin-locks\"><a href=\"#A3-4-8-Use-of-WFE-and-SEV-instructions-by-spin-locks\" class=\"headerlink\" title=\"A3.4.8 Use of WFE and SEV instructions by spin-locks\"></a>A3.4.8 Use of WFE and SEV instructions by spin-locks</h5><p>ARMv7 and ARMv6K provide Wait For Event and Send Event instructions, WFE and SEV, that can assist with<br>reducing power consumption and bus contention caused by processors repeatedly attempting to obtain a spin-lock.<br>These instructions can be used at the application level, but a complete understanding of what they do depends on<br>system level understanding of exceptions.</p>\n<h4 id=\"A3-5-Memory-types-and-attributes-and-the-memory-order-model\"><a href=\"#A3-5-Memory-types-and-attributes-and-the-memory-order-model\" class=\"headerlink\" title=\"A3.5 Memory types and attributes and the memory order model\"></a>A3.5 Memory types and attributes and the memory order model</h4><h5 id=\"A3-5-1-Memory-types\"><a href=\"#A3-5-1-Memory-types\" class=\"headerlink\" title=\"A3.5.1 Memory types\"></a>A3.5.1 Memory types</h5><p>exclusive memory types:<br>• Normal<br>• Device<br>• Strongly-ordered.</p>\n<h5 id=\"A3-5-2-Summary-of-ARMv7-memory-attributes\"><a href=\"#A3-5-2-Summary-of-ARMv7-memory-attributes\" class=\"headerlink\" title=\"A3.5.2 Summary of ARMv7 memory attributes\"></a>A3.5.2 Summary of ARMv7 memory attributes</h5><p><strong>Shareability</strong><br>Applies only to Normal memory, and <strong>to Device memory in an implementation that does not include the Large Physical Address Extension.</strong> In an implementation that includes the Large Physical<br>Address Extension, Device memory is always Outer Shareable,<br>When it is possible to assign a shareability attribute to Device memory, ARM deprecates assigning<br>any attribute other than Shareable or Outer Shareable, see Shareable attribute for Device memory<br>regions on page A3-137<br>Whether an ARMv7 implementation distinguishes between Inner Shareable and Outer Shareable<br>memory is IMPLEMENTATION DEFINED.</p>\n<p><strong>Cacheability</strong><br>Applies only to Normal memory, and can be defined independently for Inner and Outer cache<br>regions. Some cacheability attributes can be complemented by a cache allocation hint. This is an<br>indication to the memory system of whether allocating a value to a cache is likely to improve<br>performance. </p>\n<p>Fixme [Table A3-5 Memory attribute summary] page127</p>\n<h5 id=\"A3-5-3-Atomicity-in-the-ARM-architecture\"><a href=\"#A3-5-3-Atomicity-in-the-ARM-architecture\" class=\"headerlink\" title=\"A3.5.3 Atomicity in the ARM architecture\"></a>A3.5.3 Atomicity in the ARM architecture</h5><p>Atomicity is a feature of memory accesses, described as atomic accesses. The ARM architecture description refers<br>to two types of atomicity, defined in:<br>• Single-copy atomicity<br>• Multi-copy atomicity on page A3-130.</p>\n<p><strong>Single-copy atomicity</strong><br>In ARMv7, the single-copy atomic processor accesses are:<br>• All byte accesses.<br>• All halfword accesses to halfword-aligned locations.<br>• All word accesses to word-aligned locations.<br>• Memory accesses caused by a LDREXD/STREXD to a doubleword-aligned location for which the STREXD succeeds<br>cause single-copy atomic updates of the doubleword being accessed.<br>Note<br>The way to atomically load two 32-bit quantities is to perform a LDREXD/STREXD sequence, reading and writing<br>the same value, for which the STREXD succeeds, and use the read values</p>\n<p><strong>Multi-copy atomicity</strong><br>In a multiprocessing system, writes to a memory location are multi-copy atomic</p>\n<p>Writes to Normal memory are not multi-copy atomic. (有缓存机制以及SNOOP等)<br>All writes to Device and Strongly-ordered memory that are single-copy atomic are also multi-copy atomic.</p>\n<h5 id=\"A3-5-4-Concurrent-modification-and-execution-of-instructions\"><a href=\"#A3-5-4-Concurrent-modification-and-execution-of-instructions\" class=\"headerlink\" title=\"A3.5.4 Concurrent modification and execution of instructions\"></a>A3.5.4 Concurrent modification and execution of instructions</h5><p>The ARMv7 architecture limits the set of instructions that can be executed by one thread of execution as they are<br>being modified by another thread of execution without requiring explicit synchronization.</p>\n<p>Except for the instructions identified in this section, the effect of the concurrent modification and execution of an<br>instruction is UNPREDICTABLE. （无条件跳转等命令，不受这个限制）</p>\n<p><strong>In the Thumb instruction set</strong><br>The 16-bit encodings of the B, NOP, BKPT, and SVC instructions</p>\n<p><strong>In the ARM instruction set</strong><br>The B, BL, NOP, BKPT, SVC, HVC, and SMC instructions.</p>\n<h5 id=\"A3-5-5-Normal-memory\"><a href=\"#A3-5-5-Normal-memory\" class=\"headerlink\" title=\"A3.5.5 Normal memory\"></a>A3.5.5 Normal memory</h5><p>Accesses to normal memory region are idempotent, meaning that they exhibit the following properties:<br>• read accesses can be repeated with no side-effects<br>• repeated read accesses return the last value written to the resource being read<br>• read accesses can fetch additional memory locations with no side-effects<br>• write accesses can be repeated with no side-effects in the following cases:<br>    — if the contents of the location accessed are unchanged between the repeated writes<br>    — as the result of an exception, as described in this section<br>• unaligned accesses can be supported<br>• accesses can be merged before accessing the target memory system.</p>\n<p>Normal memory can be read/write or read-only, and a Normal memory region is defined as being either Shareable<br>or Non-shareable.</p>\n<p><strong>Non-shareable Normal memory</strong><br>For a Normal memory region, the Non-shareable attribute identifies Normal memory that is likely to be accessed<br>only by a single processor.</p>\n<p><strong>Shareable, Inner Shareable, and Outer Shareable Normal memory</strong><br>For Normal memory, the Shareable and Outer Shareable memory attributes describe Normal memory that is<br>expected to <strong>be accessed by multiple processors or other system masters:</strong><br>• In a VMSA implementation, Normal memory that has the Shareable attribute but not the Outer Shareable<br>attribute assigned is described as having the Inner Shareable attribute.<br>• In a PMSA implementation, no distinction is made between Inner Shareable and Outer Shareable Normal<br>memory.</p>\n<p>VMSA: Virtual Memory System Architecture<br>PMSA: Protected Memory System Architecture</p>\n<p><strong>Write-Through Cacheable, Write-Back Cacheable and Non-cacheable Normal memory</strong><br>The cacheability attributes provide a mechanism of coherency control with observers that lie outside the shareability<br>domain of a region of memory.<br>• Write-Through Cacheable<br>• Write-Back Cacheable<br>• Non-cacheable.</p>\n<p>The cacheability attributes provide a mechanism of coherency control with observers that lie outside the shareability<br>domain of a region of memory. In some cases, the use of Write-Through Cacheable or Non-cacheable regions of<br>memory might provide a better mechanism for controlling coherency than the use of hardware coherency<br>mechanisms or the use of cache maintenance routines.</p>\n<h5 id=\"A3-5-6-Device-and-Strongly-ordered-memory\"><a href=\"#A3-5-6-Device-and-Strongly-ordered-memory\" class=\"headerlink\" title=\"A3.5.6 Device and Strongly-ordered memory\"></a>A3.5.6 Device and Strongly-ordered memory</h5><p>Examples of memory regions normally marked as being Device or Strongly-ordered memory are Memory-mapped<br>peripherals and I/O locations. <strong>Address locations marked as Device or Strongly-ordered are never held in a cache.</strong></p>\n<p>The architecture permits an Advanced SIMD element or structure load instruction to access bytes in Device or<br>Strongly-ordered memory.</p>\n<p><strong>The architecture does not permit unaligned accesses to Strongly-ordered or Device memory.</strong></p>\n<h6 id=\"Shareable-attribute-for-Device-memory-regions\"><a href=\"#Shareable-attribute-for-Device-memory-regions\" class=\"headerlink\" title=\"Shareable attribute for Device memory regions\"></a>Shareable attribute for Device memory regions</h6><p>In an implementation that does not include the Large Physical Address Extension, Device memory regions can be<br>given the Shareable attribute. When a Device memory region is give the Shareable attribute it can also be given the<br>Outer Shareable attribute. This means that a region of Device memory can be described as one of:<br>• Outer Shareable Device memory<br>• Inner Shareable Device memory<br>• Non-shareable Device memory.</p>\n<p>ARM deprecates the marking of Device memory with a shareability attribute other than Outer Shareable or<br>Shareable. This means <strong>ARM strongly recommends that Device memory is never assigned a shareability attribute of Non-shareable or Inner Shareable.</strong></p>\n<h6 id=\"Device-and-Strongly-ordered-memory-shareability-Large-Physical-Address-Extension\"><a href=\"#Device-and-Strongly-ordered-memory-shareability-Large-Physical-Address-Extension\" class=\"headerlink\" title=\"Device and Strongly-ordered memory shareability, Large Physical Address Extension\"></a>Device and Strongly-ordered memory shareability, Large Physical Address Extension</h6><p>In an implementation that includes the Large Physical Address Extension, the Long-descriptor translation table<br>format does not distinguish between Shareable and Non-shareable Device memory.</p>\n<p>In an implementation that includes the Large Physical Address Extension and is using the Short-descriptor<br>translation table format:<br>• An address-based cache maintenance operation for an addresses in a region with the Strongly-ordered or<br>Device memory type applies to all processors in the same Outer Shareable domain, regardless of any<br>shareability attributes applied to the region.<br>• Device memory transactions to a single peripheral must not be reordered, regardless of any shareability<br>attributes that are applied to the corresponding Device memory region.<br>Any single peripheral has an IMPLEMENTATION DEFINED size of not less than 1KB.</p>\n<h5 id=\"A3-5-7-Memory-access-restrictions\"><a href=\"#A3-5-7-Memory-access-restrictions\" class=\"headerlink\" title=\"A3.5.7 Memory access restrictions\"></a>A3.5.7 Memory access restrictions</h5><p>The following restrictions apply to memory accesses:<br>• For accesses to any two bytes, p and q, that are generated by the same instruction:<br>    — The bytes p and q must have the same memory type and shareability attributes<br>    — Except for possible differences in the cache allocation hints, ARM deprecates having different<br>    cacheability attributes for the bytes p and q.</p>\n<p>• Unaligned data access on page A3-108 identifies the instructions that can make an unaligned memory<br>access,If such an access is to Device or Strongly-ordered memory then:<br>    — if the implementation does not include the Virtualization Extensions, the effect is UNPREDICTABLE<br>    — if the implementation includes the Virtualization Extensions, the access generates an Alignment fault</p>\n<p>• <strong>The accesses of an instruction that causes multiple accesses to Device or Strongly-ordered memory must not cross a 4KB address boundary</strong></p>\n<p>• <strong>Any instruction fetch must access only Normal memory.</strong> If it accesses Device or Strongly-ordered memory,<br>the result is UNPREDICTABLE.</p>\n<h5 id=\"A3-5-8-The-effect-of-the-Security-Extensions\"><a href=\"#A3-5-8-The-effect-of-the-Security-Extensions\" class=\"headerlink\" title=\"A3.5.8 The effect of the Security Extensions\"></a>A3.5.8 The effect of the Security Extensions</h5><p>The Security Extensions can be included as part of an ARMv7-A implementation, with a VMSA. They provide two<br>distinct 4GByte virtual memory spaces:<br>• a Secure virtual memory space<br>• a Non-secure virtual memory space.<br>The Secure virtual memory space is accessed by memory accesses in the Secure state, and the Non-secure virtual<br>memory space is accessed by memory accesses in the Non-secure state.<br>By providing different virtual memory spaces, the Security Extensions permit memory accesses made from the<br>Non-secure state to be distinguished from those made from the Secure state.</p>\n<h4 id=\"A3-6-Access-rights\"><a href=\"#A3-6-Access-rights\" class=\"headerlink\" title=\"A3.6 Access rights\"></a>A3.6 Access rights</h4><h5 id=\"A3-6-1-Processor-privilege-levels-execution-privilege-and-access-privilege\"><a href=\"#A3-6-1-Processor-privilege-levels-execution-privilege-and-access-privilege\" class=\"headerlink\" title=\"A3.6.1 Processor privilege levels, execution privilege, and access privilege\"></a>A3.6.1 Processor privilege levels, execution privilege, and access privilege</h5><p>ARMv7 architecture defines different levels of execution privilege:<br>• in Secure state, the privilege levels are PL1 and PL0<br>• in Non-secure state, the privilege levels are PL2, PL1, and PL0.</p>\n<p><strong>PL0</strong><br>The privilege level of application software, that executes in User mode. Therefore, software<br>executed in User mode is described as unprivileged software. This software cannot access some<br>features of the architecture. In particular, it cannot change many of the configuration settings.<br>Software executing at PL0 makes only unprivileged memory accesses.</p>\n<p><strong>PL1</strong><br>Software execution in all modes other than User mode and Hyp mode is at PL1. Normally, operating<br>system software executes at PL1. Software executing at PL1 can access all features of the<br>architecture, and can change the configuration settings for those features, except for some features<br>added by the Virtualization Extensions that are only accessible at PL2.<br>Note<br>In many implementation models, system software is unaware of the PL2 level of privilege, and of<br>whether the implementation includes the Virtualization Extensions.<br>The PL1 modes refers to all the modes other than User mode and Hyp mode.<br>Software executing at PL1 makes privileged memory accesses by default, but can also make<br>unprivileged accesses.</p>\n<p><strong>PL2</strong><br>Software executing in Hyp mode executes at PL2.<br>Software executing at PL2 can perform all of the operations accessible at PL1, and can access some<br>additional functionality.<br>Hyp mode is normally used by a hypervisor, that controls, and can switch between, Guest OSs, that<br>execute at PL1.</p>\n<p>Hyp mode is implemented only as part of the Virtualization Extensions, and only in Non-secure<br>state. This means that:<br>• implementations that do not include the Virtualization Extensions have only two privilege<br>levels, PL0 and PL1<br>• execution in Secure state has only two privilege levels, PL0 and PL1</p>\n<h4 id=\"A3-8-Memory-access-order\"><a href=\"#A3-8-Memory-access-order\" class=\"headerlink\" title=\"A3.8 Memory access order\"></a>A3.8 Memory access order</h4><h5 id=\"A3-8-1-Reads-and-writes\"><a href=\"#A3-8-1-Reads-and-writes\" class=\"headerlink\" title=\"A3.8.1 Reads and writes\"></a>A3.8.1 Reads and writes</h5><p>The following can cause memory accesses that are not explicit:<br>• instruction fetches<br>• cache loads and write-backs<br>• translation table walks.</p>\n<h6 id=\"Reads\"><a href=\"#Reads\" class=\"headerlink\" title=\"Reads\"></a>Reads</h6><p>Reads are defined as memory operations that have the semantics of a load.<br>The memory accesses of the following instructions are reads:<br>• LDR, LDRB, LDRH, LDRSB, and LDRSH.<br>• LDRT, LDRBT, LDRHT, LDRSBT, and LDRSHT.<br>• LDREX, LDREXB, LDREXD, and LDREXH.<br>• LDM, LDRD, POP, and RFE.<br>• LDC, LDC2, VLDM, VLDR, VLD1, VLD2, VLD3, VLD4, and VPOP.<br>• The return of status values by STREX, STREXB, STREXD, and STREXH.<br>• SWP and SWPB. These instructions are available only in the ARM instruction set.<br>• TBB and TBH. These instructions are available only in the Thumb instruction set.<br>Hardware-accelerated opcode execution by the Jazelle extension can cause a number of reads to occur, according<br>to the state of the operand stack and the implementation of the Jazelle hardware acceleration.</p>\n<h6 id=\"Writes\"><a href=\"#Writes\" class=\"headerlink\" title=\"Writes\"></a>Writes</h6><p>Writes are defined as memory operations that have the semantics of a store.<br>The memory accesses of the following instructions are Writes:<br>• STR, STRB, and STRH.<br>• STRT, STRBT, and STRHT.<br>• STREX, STREXB, STREXD, and STREXH.<br>• STM, STRD, PUSH, and SRS.<br>• STC, STC2, VPUSH, VSTM, VSTR, VST1, VST2, VST3, and VST4.<br>• SWP and SWPB. These instructions are available only in the ARM instruction set.<br>Hardware-accelerated opcode execution by the Jazelle extension can cause a number of writes to occur, according<br>to the state of the operand stack and the implementation of the Jazelle hardware acceleration.</p>\n<h6 id=\"Synchronization-primitives\"><a href=\"#Synchronization-primitives\" class=\"headerlink\" title=\"Synchronization primitives\"></a>Synchronization primitives</h6><p>Synchronization primitives must ensure correct operation of system semaphores in the memory order model. They are the following instructions:<br>• LDREX, STREX, LDREXB, STREXB, LDREXD, STREXD, LDREXH, STREXH.<br>• SWP, SWPB. From ARMv6, ARM deprecates the use of these instructions.</p>\n<h5 id=\"A3-8-3-Memory-barriers\"><a href=\"#A3-8-3-Memory-barriers\" class=\"headerlink\" title=\"A3.8.3 Memory barriers\"></a>A3.8.3 Memory barriers</h5><p>Memory barrier is the general term applied to an instruction, or sequence of instructions, that forces synchronization<br>events by a processor with respect to retiring load/store instructions.</p>\n<p>The ARM architecture defines a number of memory barriers that provide a range of functionality, including:<br>• ordering of load/store instructions<br>• completion of load/store instructions<br>• context synchronization.</p>\n<p>In ARMv7 the memory barriers are provided as instructions that are available in the ARM and Thumb<br>instruction sets, and in ARMv6 the memory barriers are performed by CP15 register writes. The three memory<br>barriers are:<br>• Data Memory Barrier, see Data Memory Barrier (DMB) on page A3-152<br>• Data Synchronization Barrier, see Data Synchronization Barrier (DSB) on page A3-153<br>• Instruction Synchronization Barrier, see Instruction Synchronization Barrier (ISB) on page A3-153.</p>\n<h6 id=\"Data-Memory-Barrier-DMB\"><a href=\"#Data-Memory-Barrier-DMB\" class=\"headerlink\" title=\"Data Memory Barrier (DMB)\"></a>Data Memory Barrier (DMB)</h6><p>The DMB instruction is a data memory barrier. <strong>DMB only affects memory accesses and data and unified cache maintenance operations,  It has no effect on the ordering of any other instructions executing on the processor.</strong></p>\n<h6 id=\"Data-Synchronization-Barrier-DSB\"><a href=\"#Data-Synchronization-Barrier-DSB\" class=\"headerlink\" title=\"Data Synchronization Barrier (DSB)\"></a>Data Synchronization Barrier (DSB)</h6><p>The DSB instruction is a special memory barrier, that synchronizes the execution stream with memory accesses. <strong>In addition, no instruction that appears in program order after the DSB instruction can execute until the DSB completes.</strong></p>\n<h6 id=\"Instruction-Synchronization-Barrier-ISB\"><a href=\"#Instruction-Synchronization-Barrier-ISB\" class=\"headerlink\" title=\"Instruction Synchronization Barrier (ISB)\"></a>Instruction Synchronization Barrier (ISB)</h6><p><strong>An ISB instruction flushes the pipeline in the processor, so that all instructions that come after the ISB instruction in program order are fetched from cache or memory only after the ISB instruction has completed.</strong></p>\n<p>Using an ISB ensures that the effects of context-changing operations executed before the ISB are visible to the instructions fetched after the ISB instruction. </p>\n<p>Examples of context-changing operations that require the insertion of an ISB instruction to ensure<br>the effects of the operation are visible to instructions fetched after the ISB instruction are:<br>• completed cache, TLB, and branch predictor maintenance operations<br>• changes to system control registers. </p>\n<h4 id=\"A3-9-Caches-and-memory-hierarchy\"><a href=\"#A3-9-Caches-and-memory-hierarchy\" class=\"headerlink\" title=\"A3.9 Caches and memory hierarchy\"></a>A3.9 Caches and memory hierarchy</h4><h5 id=\"A3-9-1-Introduction-to-caches\"><a href=\"#A3-9-1-Introduction-to-caches\" class=\"headerlink\" title=\"A3.9.1 Introduction to caches\"></a>A3.9.1 Introduction to caches</h5><p>A cache is a block of high-speed memory that contains a number of entries, each consisting of:<br>• main memory address information, commonly called a tag<br>• the associated data</p>\n<h5 id=\"A3-9-2-Memory-hierarchy\"><a href=\"#A3-9-2-Memory-hierarchy\" class=\"headerlink\" title=\"A3.9.2 Memory hierarchy\"></a>A3.9.2 Memory hierarchy</h5><p>Memory close to a processor has very low latency, but is limited in size and expensive to implement.To optimize overall<br>performance, an ARMv7 memory system can include multiple levels of cache in a hierarchical memory system. </p>\n<p>Fixme[Figure A3-6 Multiple levels of cache in a memory hierarchy] page 157</p>\n<h5 id=\"A3-9-4-Preloading-caches\"><a href=\"#A3-9-4-Preloading-caches\" class=\"headerlink\" title=\"A3.9.4 Preloading caches\"></a>A3.9.4 Preloading caches</h5><p>The ARM architecture provides memory system hints PLD (Preload Data), PLDW (Preload Data with intent to write),<br>and PLI (Preload Instruction) to permit software to communicate the expected use of memory locations to the<br>hardware. </p>\n<h3 id=\"A4-The-Instruction-Sets\"><a href=\"#A4-The-Instruction-Sets\" class=\"headerlink\" title=\"A4. The Instruction Sets\"></a>A4. The Instruction Sets</h3><h4 id=\"A4-1-About-the-instruction-sets\"><a href=\"#A4-1-About-the-instruction-sets\" class=\"headerlink\" title=\"A4.1 About the instruction sets\"></a>A4.1 About the instruction sets</h4><p>ARMv7 contains two main instruction sets, the ARM and Thumb instruction sets. </p>\n<p>The ARM and Thumb instruction sets can interwork freely, that is, different procedures can be compiled or assembled to different instruction sets, and still be able to call each other efficiently.</p>\n<p><strong>ThumbEE</strong> is a variant of the Thumb instruction set that is designed as a target for <strong>dynamically generated code.</strong><br>However, it cannot interwork freely with the ARM and Thumb instruction sets.</p>\n<p>The two instruction sets differ in how instructions are encoded:<br>• Thumb instructions are either 16-bit or 32-bit, and are aligned on <strong>a two-byte boundary</strong>. 16-bit and 32-bit<br>instructions can be intermixed freely. Many common operations are most efficiently executed using 16-bit<br>instructions. However:<br>    — Most 16-bit instructions can only access the first eight of the ARM core registers, R0-R7. These are<br>    called the low registers. A small number of 16-bit instructions can also access the high registers,<br>    R8-R15.<br>    — Many operations that would require two or more 16-bit instructions can be more efficiently executed<br>    with a single 32-bit instruction.<br>    — All 32-bit instructions can access all of the ARM core registers, R0-R15.</p>\n<p>• ARM instructions are always 32-bit, and are aligned on a four-byte boundary</p>\n<h5 id=\"A4-1-1-Changing-between-Thumb-state-and-ARM-state\"><a href=\"#A4-1-1-Changing-between-Thumb-state-and-ARM-state\" class=\"headerlink\" title=\"A4.1.1 Changing between Thumb state and ARM state\"></a>A4.1.1 Changing between Thumb state and ARM state</h5><h6 id=\"Thumb-to-ARM-state\"><a href=\"#Thumb-to-ARM-state\" class=\"headerlink\" title=\"Thumb to ARM state\"></a>Thumb to ARM state</h6><p>A processor in Thumb state can enter ARM state by executing any of the following instructions: <strong>BX, BLX, or an LDR or LDM that loads the PC.</strong></p>\n<h6 id=\"ARM-to-Thumb-state\"><a href=\"#ARM-to-Thumb-state\" class=\"headerlink\" title=\"ARM to Thumb state\"></a>ARM to Thumb state</h6><p>A processor in ARM state can enter Thumb state by executing any of the same instructions.</p>\n<p>In ARMv7, a processor in ARM state can also enter Thumb state by executing an ADC, ADD, AND, ASR, BIC, EOR, LSL,<br>LSR, MOV, MVN, ORR, ROR, RRX, RSB, RSC, SBC, or SUB instruction that <strong>has the PC as destination register and does not set the condition flags.</strong></p>\n<h6 id=\"others\"><a href=\"#others\" class=\"headerlink\" title=\"others\"></a>others</h6><p>The target instruction set is either encoded directly in the instruction (for the immediate offset version of BLX), or is<br>held as bit[0] of an interworking address. For details, see the description of the BXWritePC() function in Pseudocode<br>details of operations on ARM core registers on page A2-47.<br>bit[0]    1 thumb      thumb is 2 bytes boundary but ARM some support Jazella extension<br>bit[1:0] 00 arm        arm is 4 bytes boundary<br>bit[1:0] 10 unknown</p>\n<p>Exception entries and returns can also change between ARM and Thumb states. For details see Exception handling<br>on page B1-1165.</p>\n<h5 id=\"A4-1-2-Conditional-execution\"><a href=\"#A4-1-2-Conditional-execution\" class=\"headerlink\" title=\"A4.1.2 Conditional execution\"></a>A4.1.2 Conditional execution</h5><p>In the ARM and Thumb instruction sets, most instructions can be conditionally executed</p>\n<p>In the ARM instruction set,  has its normal effect on the programmers’ model operation, memory and coprocessors if the N, Z, C and V condition flags in the APSR satisfy.</p>\n<p>If the flags do not satisfy this condition, the instruction acts as a NOP.</p>\n<p>In the Thumb instruction set, different mechanisms control conditional execution:<br>• For the following Thumb encodings, conditional execution is controlled in a similar way to the ARM<br>instructions:<br>    — A 16-bit conditional branch instruction encoding, with a branch range of –256 to +254 bytes. Before<br>    ARMv6T2, this was the only mechanism for conditional execution in Thumb code.<br>    — A 32-bit conditional branch instruction encoding, with a branch range of approximately ±1MB.</p>\n<p>• The CBZ and CBNZ instructions, Compare and Branch on Zero and Compare and Branch on Nonzero, are 16-bit<br>conditional instructions with a branch range of +4 to +130 bytes.    </p>\n<p>• The 16-bit If-Then instruction makes up to four following instructions conditional, and can make most other<br>Thumb instructions conditional. For details see IT on page A8-390. </p>\n<h4 id=\"A4-3-Branch-instructions\"><a href=\"#A4-3-Branch-instructions\" class=\"headerlink\" title=\"A4.3 Branch instructions\"></a>A4.3 Branch instructions</h4><p>Fixme [Table A4-1 Branch instructions] Page164</p>\n<h4 id=\"A4-4-Data-processing-instructions\"><a href=\"#A4-4-Data-processing-instructions\" class=\"headerlink\" title=\"A4.4 Data-processing instructions\"></a>A4.4 Data-processing instructions</h4><h5 id=\"A4-4-1-Standard-data-processing-instructions\"><a href=\"#A4-4-1-Standard-data-processing-instructions\" class=\"headerlink\" title=\"A4.4.1 Standard data-processing instructions\"></a>A4.4.1 Standard data-processing instructions</h5><p>Fixme [Table A4-2 Standard data-processing instructions] Page166</p>\n<h5 id=\"A4-4-2-Shift-instructions\"><a href=\"#A4-4-2-Shift-instructions\" class=\"headerlink\" title=\"A4.4.2 Shift instructions\"></a>A4.4.2 Shift instructions</h5><p>Fixme [Table A4-3 Shift instructions] Page167</p>\n<h5 id=\"A4-4-3-Multiply-instructions\"><a href=\"#A4-4-3-Multiply-instructions\" class=\"headerlink\" title=\"A4.4.3 Multiply instructions\"></a>A4.4.3 Multiply instructions</h5><p>These instructions can operate on signed or unsigned quantities. In some types of operation, the results are same<br>whether the operands are signed or unsigned.</p>\n<p>Fixme [Table A4-4 General multiply instructions] Page167</p>\n<p>Fixme [Table A4-5 Signed multiply instructions] Page168</p>\n<p>Fixme [Table A4-6 Unsigned multiply instructions] Page168</p>\n<h5 id=\"A4-4-4-Saturating-instructions\"><a href=\"#A4-4-4-Saturating-instructions\" class=\"headerlink\" title=\"A4.4.4 Saturating instructions\"></a>A4.4.4 Saturating instructions</h5><p>饱和指令： 将超出unsigned, signed 的值限制到本身支持的最大值或最小值</p>\n<h5 id=\"A4-4-5-Saturating-addition-and-subtraction-instructions\"><a href=\"#A4-4-5-Saturating-addition-and-subtraction-instructions\" class=\"headerlink\" title=\"A4.4.5 Saturating addition and subtraction instructions\"></a>A4.4.5 Saturating addition and subtraction instructions</h5><h5 id=\"A4-4-6-Packing-and-unpacking-instructions\"><a href=\"#A4-4-6-Packing-and-unpacking-instructions\" class=\"headerlink\" title=\"A4.4.6 Packing and unpacking instructions\"></a>A4.4.6 Packing and unpacking instructions</h5><p>扩展指令： 将[半]字节扩展到[有/无]32位</p>\n<h5 id=\"A4-4-7-Parallel-addition-and-subtraction-instructions\"><a href=\"#A4-4-7-Parallel-addition-and-subtraction-instructions\" class=\"headerlink\" title=\"A4.4.7 Parallel addition and subtraction instructions\"></a>A4.4.7 Parallel addition and subtraction instructions</h5><p>These instructions perform additions and subtractions on the values of two registers and write the result to a<br>destination register, treating the register values as sets of two halfwords or four bytes. That is, they perform SIMD<br>additions or subtractions on the registers. </p>\n<h5 id=\"A4-4-8-Divide-instructions\"><a href=\"#A4-4-8-Divide-instructions\" class=\"headerlink\" title=\"A4.4.8 Divide instructions\"></a>A4.4.8 Divide instructions</h5><p>For descriptions of the instructions see:<br>• SDIV on page A8-600<br>• UDIV on page A8-760</p>\n<p>In the ARMv7-R profile, the SCTLR.DZ bit enables divide by zero fault detection:<br>SCTLR.DZ == 0 Divide-by-zero returns a zero result.<br>SCTLR.DZ == 1 SDIV and UDIV generate an Undefined Instruction exception on a divide-by-zero.<br>The SCTLR.DZ bit is cleared to zero on reset</p>\n<h5 id=\"A4-4-9-Miscellaneous-data-processing-instructions\"><a href=\"#A4-4-9-Miscellaneous-data-processing-instructions\" class=\"headerlink\" title=\"A4.4.9 Miscellaneous data-processing instructions\"></a>A4.4.9 Miscellaneous data-processing instructions</h5><p>Fixme [Table A4-11 Miscellaneous data-processing instructions] page173</p>\n<h4 id=\"A4-5-Status-register-access-instructions\"><a href=\"#A4-5-Status-register-access-instructions\" class=\"headerlink\" title=\"A4.5 Status register access instructions\"></a>A4.5 Status register access instructions</h4><p>The MRS and MSR instructions move the contents of the Application Program Status Register (APSR) to or from an<br>ARM core register, see:<br>• MRS on page A8-496<br>• MSR (immediate) on page A8-498<br>• MSR (register) on page A8-500.</p>\n<p>At system level, software can also:<br>• use these instructions to access the SPSR of the current mode<br>• use the CPS instruction to change the CPSR.M field and the CPSR.{A, I, F} interrupt mask bits.</p>\n<h4 id=\"A4-6-Load-store-instructions\"><a href=\"#A4-6-Load-store-instructions\" class=\"headerlink\" title=\"A4.6 Load/store instructions\"></a>A4.6 Load/store instructions</h4><p>Fixme [Table A4-12 Load/store instructions] Page175</p>\n<h4 id=\"A4-7-Load-store-multiple-instructions\"><a href=\"#A4-7-Load-store-multiple-instructions\" class=\"headerlink\" title=\"A4.7 Load/store multiple instructions\"></a>A4.7 Load/store multiple instructions</h4><p>Load Multiple instructions load a subset, or possibly all, of the ARM core registers from memory.<br>Store Multiple instructions store a subset, or possibly all, of the ARM core registers to memory.</p>\n<p>Fixme [Table A4-13 Load/store multiple instructions] Page177</p>\n<h4 id=\"A4-8-Miscellaneous-instructions\"><a href=\"#A4-8-Miscellaneous-instructions\" class=\"headerlink\" title=\"A4.8 Miscellaneous instructions\"></a>A4.8 Miscellaneous instructions</h4><p>Fixme [Table A4-14 Miscellaneous instructions] Page178</p>\n<h4 id=\"A4-9-Exception-generating-and-exception-handling-instructions\"><a href=\"#A4-9-Exception-generating-and-exception-handling-instructions\" class=\"headerlink\" title=\"A4.9 Exception-generating and exception-handling instructions\"></a>A4.9 Exception-generating and exception-handling instructions</h4><p>The following instructions are intended specifically to cause a synchronous processor exception to occur:<br>• The SVC instruction generates a Supervisor Call exception. For more information, see Supervisor Call (SVC)<br>exception on page B1-1210.<br>• The Breakpoint instruction BKPT provides software breakpoints. For more information, see About debug<br>events on page C3-2038.<br>• In a processor that implements the Security Extensions, when executing at PL1 or higher, the SMC instruction<br>generates a Secure Monitor Call exception. For more information, see Secure Monitor Call (SMC) exception<br>on page B1-1211.<br>• In a processor that implements the Virtualization Extensions, in software executing in a Non-secure PL1<br>mode, the HVC instruction generates a Hypervisor Call exception. For more information, see Hypervisor Call<br>(HVC) exception on page B1-1212.</p>\n<p>Fixme [Table A4-15 Exception-generating and exception-handling instructions] Page179</p>\n<h4 id=\"A4-10-Coprocessor-instructions\"><a href=\"#A4-10-Coprocessor-instructions\" class=\"headerlink\" title=\"A4.10 Coprocessor instructions\"></a>A4.10 Coprocessor instructions</h4><p>There are three types of instruction for communicating with coprocessors. These permit the processor to:<br>• Initiate a coprocessor data-processing operation. For details see CDP, CDP2 on page A8-358.<br>• Transfer ARM core registers to and from coprocessor registers. For details, see:<br>    — MCR, MCR2 on page A8-476<br>    — MCRR, MCRR2 on page A8-478<br>    — MRC, MRC2 on page A8-492<br>    — MRRC, MRRC2 on page A8-494.<br>• Load or store the values of coprocessor registers. For details, see:<br>    — LDC, LDC2 (immediate) on page A8-392<br>    — LDC, LDC2 (literal) on page A8-394<br>    — STC, STC2 on page A8-662.</p>\n<h4 id=\"A4-11-Advanced-SIMD-and-Floating-point-load-store-instructions\"><a href=\"#A4-11-Advanced-SIMD-and-Floating-point-load-store-instructions\" class=\"headerlink\" title=\"A4.11 Advanced SIMD and Floating-point load/store instructions\"></a>A4.11 Advanced SIMD and Floating-point load/store instructions</h4><p>Fixme [Table A4-16 Extension register load/store instructions] Page181<br>Fixme [Table A4-17 Element and structure load/store instructions] Page181</p>\n<h4 id=\"A4-12-Advanced-SIMD-and-Floating-point-register-transfer-instructions\"><a href=\"#A4-12-Advanced-SIMD-and-Floating-point-register-transfer-instructions\" class=\"headerlink\" title=\"A4.12 Advanced SIMD and Floating-point register transfer instructions\"></a>A4.12 Advanced SIMD and Floating-point register transfer instructions</h4><p>Fixme [Table A4-18 Extension register transfer instructions] Page183</p>\n<h4 id=\"A4-13-Advanced-SIMD-data-processing-instructions\"><a href=\"#A4-13-Advanced-SIMD-data-processing-instructions\" class=\"headerlink\" title=\"A4.13 Advanced SIMD data-processing instructions\"></a>A4.13 Advanced SIMD data-processing instructions</h4><p>Advanced SIMD data-processing instructions process registers containing vectors of elements of the same type<br>packed together, enabling the same operation to be performed on multiple items in parallel.</p>\n<p>Fixme [Figure A4-2 Advanced SIMD instruction operating on 64-bit registers] Page184</p>\n<h5 id=\"A4-13-1-Advanced-SIMD-parallel-addition-and-subtraction\"><a href=\"#A4-13-1-Advanced-SIMD-parallel-addition-and-subtraction\" class=\"headerlink\" title=\"A4.13.1 Advanced SIMD parallel addition and subtraction\"></a>A4.13.1 Advanced SIMD parallel addition and subtraction</h5><p>Fixme [Table A4-19 Advanced SIMD parallel add and subtract instructions] Page185</p>\n<h5 id=\"A4-13-2-Bitwise-Advanced-SIMD-data-processing-instructions\"><a href=\"#A4-13-2-Bitwise-Advanced-SIMD-data-processing-instructions\" class=\"headerlink\" title=\"A4.13.2 Bitwise Advanced SIMD data-processing instructions\"></a>A4.13.2 Bitwise Advanced SIMD data-processing instructions</h5><p>Fixme [Table A4-20 Bitwise Advanced SIMD data-processing instructions] Page186</p>\n<h5 id=\"A4-13-3-Advanced-SIMD-comparison-instructions\"><a href=\"#A4-13-3-Advanced-SIMD-comparison-instructions\" class=\"headerlink\" title=\"A4.13.3 Advanced SIMD comparison instructions\"></a>A4.13.3 Advanced SIMD comparison instructions</h5><p>Fixme [Table A4-21 Advanced SIMD comparison instructions] Page186</p>\n<h5 id=\"A4-13-4-Advanced-SIMD-shift-instructions\"><a href=\"#A4-13-4-Advanced-SIMD-shift-instructions\" class=\"headerlink\" title=\"A4.13.4 Advanced SIMD shift instructions\"></a>A4.13.4 Advanced SIMD shift instructions</h5><p>Fixme [Table A4-22 Advanced SIMD shift instructions] Page187</p>\n<h5 id=\"A4-13-5-Advanced-SIMD-multiply-instructions\"><a href=\"#A4-13-5-Advanced-SIMD-multiply-instructions\" class=\"headerlink\" title=\"A4.13.5 Advanced SIMD multiply instructions\"></a>A4.13.5 Advanced SIMD multiply instructions</h5><p>Fixme [Table A4-23 Advanced SIMD multiply instructions] Page188</p>\n<h5 id=\"A4-13-6-Miscellaneous-Advanced-SIMD-data-processing-instructions\"><a href=\"#A4-13-6-Miscellaneous-Advanced-SIMD-data-processing-instructions\" class=\"headerlink\" title=\"A4.13.6 Miscellaneous Advanced SIMD data-processing instructions\"></a>A4.13.6 Miscellaneous Advanced SIMD data-processing instructions</h5><p>Fixme [Table A4-24 Miscellaneous Advanced SIMD data-processing instructions] Page189</p>\n<h4 id=\"A4-14-Floating-point-data-processing-instruction\"><a href=\"#A4-14-Floating-point-data-processing-instruction\" class=\"headerlink\" title=\"A4.14 Floating-point data-processing instruction\"></a>A4.14 Floating-point data-processing instruction</h4><p>Fixme [Table A4-25 Floating-point data-processing instructions] Page191</p>\n<h3 id=\"A5-ARM-Instruction-Set-Encoding\"><a href=\"#A5-ARM-Instruction-Set-Encoding\" class=\"headerlink\" title=\"A5. ARM Instruction Set Encoding\"></a>A5. ARM Instruction Set Encoding</h3><h4 id=\"A5-1-ARM-instruction-set-encoding\"><a href=\"#A5-1-ARM-instruction-set-encoding\" class=\"headerlink\" title=\"A5.1 ARM instruction set encoding\"></a>A5.1 ARM instruction set encoding</h4><p><strong>The ARM instruction stream is a sequence of word-aligned words. Each ARM instruction is a single 32-bit word</strong> in<br>that stream. The encoding of an ARM instruction is:</p>\n<p>Fixme [32 bits instruction structure] page194</p>\n<p>Fixme [Table A5-1 ARM instruction encoding] page194</p>\n<h5 id=\"A5-1-1-The-condition-code-field\"><a href=\"#A5-1-1-The-condition-code-field\" class=\"headerlink\" title=\"A5.1.1 The condition code field\"></a>A5.1.1 The condition code field</h5><p>This field contains one of the values 0b0000-0b1110, as shown in Table A8-1 on page A8-288.<br>Fixme [Table A8-1 Condition codes]page288</p>\n<h4 id=\"A5-2-Data-processing-and-miscellaneous-instructions\"><a href=\"#A5-2-Data-processing-and-miscellaneous-instructions\" class=\"headerlink\" title=\"A5.2 Data-processing and miscellaneous instructions\"></a>A5.2 Data-processing and miscellaneous instructions</h4><p>Fixme [data process instructions structure]page196</p>\n<p>Fixme [Table A5-2 Data-processing and miscellaneous instructions]page196</p>\n<p>其余指令可参照此命令，只是op 的不同。</p>\n<h3 id=\"A6-Thumb-Instruction-Set-Encoding\"><a href=\"#A6-Thumb-Instruction-Set-Encoding\" class=\"headerlink\" title=\"A6. Thumb Instruction Set Encoding\"></a>A6. Thumb Instruction Set Encoding</h3><h4 id=\"A6-1-Thumb-instruction-set-encoding\"><a href=\"#A6-1-Thumb-instruction-set-encoding\" class=\"headerlink\" title=\"A6.1 Thumb instruction set encoding\"></a>A6.1 Thumb instruction set encoding</h4><p>The Thumb instruction stream is a sequence of halfword-aligned halfwords. Each Thumb instruction is either a<br>single 16-bit halfword in that stream, or a 32-bit instruction consisting of two consecutive halfwords in that stream.<br>If the value of bits[15:11] of the halfword being decoded is one of the following, the halfword is the first halfword<br>of a 32-bit instruction:<br>• 0b11101<br>• 0b11110<br>• 0b11111.<br>Otherwise, the halfword is a 16-bit instruction</p>\n<p>疑问点：thumb 是16bit 或32bit对齐，那怎么与32 bit的ARM 指令集怎么区分？<br>当ARM 处于ARM state，CPU 将会按照32 bit ARM指令集去取指并执行，反之使用16、32bit 的thumb 指令集解析。</p>\n<h4 id=\"A6-2-16-bit-Thumb-instruction-encoding\"><a href=\"#A6-2-16-bit-Thumb-instruction-encoding\" class=\"headerlink\" title=\"A6.2 16-bit Thumb instruction encoding\"></a>A6.2 16-bit Thumb instruction encoding</h4><p>Fixme [16-bit thumb instruction encoding]page223</p>\n<p>Fixme [Table A6-1 16-bit Thumb instruction encoding]page223</p>\n<h4 id=\"A6-3-32-bit-Thumb-instruction-encoding\"><a href=\"#A6-3-32-bit-Thumb-instruction-encoding\" class=\"headerlink\" title=\"A6.3 32-bit Thumb instruction encoding\"></a>A6.3 32-bit Thumb instruction encoding</h4><p>Fixme [ 32-bit Thumb instruction encoding]page230</p>\n<p>Fixme [Table A6-9 32-bit Thumb instruction encoding]page230</p>\n<h3 id=\"A7-Advanced-SIMD-and-Floating-point-Instruction-Encoding\"><a href=\"#A7-Advanced-SIMD-and-Floating-point-Instruction-Encoding\" class=\"headerlink\" title=\"A7 Advanced SIMD and Floating-point Instruction Encoding\"></a>A7 Advanced SIMD and Floating-point Instruction Encoding</h3><p>skip</p>\n<h3 id=\"A9-The-ThumbEE-Instruction-Set\"><a href=\"#A9-The-ThumbEE-Instruction-Set\" class=\"headerlink\" title=\"A9 The ThumbEE Instruction Set\"></a>A9 The ThumbEE Instruction Set</h3><h4 id=\"A9-1-About-the-ThumbEE-instruction-set\"><a href=\"#A9-1-About-the-ThumbEE-instruction-set\" class=\"headerlink\" title=\"A9.1 About the ThumbEE instruction set\"></a>A9.1 About the ThumbEE instruction set</h4><p>In general, <strong>instructions in ThumbEE are identical to Thumb instructions</strong>, with the following exceptions:<br>• A small number of instructions are affected by modifications to transitions from ThumbEE state. For more<br>information, see ThumbEE state transitions.</p>\n<p>• <strong>A substantial number of instructions have a null check on the base register before any other operation takes</strong><br>place, but are identical (or almost identical) in all other respects. For more information, see Null checking on<br>page A9-1113.</p>\n<p>• A small number of instructions are modified in additional ways. See Instructions with modifications on<br>page A9-1113.</p>\n<p>• Three Thumb instructions, BLX (immediate), 16-bit LDM, and 16-bit STM, are removed in ThumbEE state.<br>The encoding corresponding to BLX (immediate) in Thumb is UNDEFINED in ThumbEE state.<br>16-bit LDM and STM are replaced by new instructions, for details see Additional ThumbEE instructions on<br>page A9-1123.</p>\n<p>• Two new 32-bit instructions, ENTERX and LEAVEX, are introduced in both the Thumb instruction set and the<br>ThumbEE instruction set. See Additional instructions in Thumb and ThumbEE instruction sets on<br>page A9-1116. These instructions use previously UNDEFINED encodings.</p>\n<p><strong>Attempting to execute ThumbEE instructions at PL2 is UNPREDICTABLE.</strong></p>\n<h5 id=\"A9-1-1-ThumbEE-state-transitions\"><a href=\"#A9-1-1-ThumbEE-state-transitions\" class=\"headerlink\" title=\"A9.1.1 ThumbEE state transitions\"></a>A9.1.1 ThumbEE state transitions</h5><p>Instruction set state transitions to ThumbEE state can occur implicitly as part of a return from exception, or<br>explicitly on execution of an <strong>ENTERX instruction.</strong></p>\n<p>Instruction set state transitions from ThumbEE state can only occur due to an exception, or due to a transition to<br>Thumb state using the <strong>LEAVEX instruction.</strong> Return from exception instructions (RFE and SUBS PC, LR, #imm) are<br>UNPREDICTABLE in ThumbEE state.</p>\n<h5 id=\"A9-1-2-Null-checking\"><a href=\"#A9-1-2-Null-checking\" class=\"headerlink\" title=\"A9.1.2 Null checking\"></a>A9.1.2 Null checking</h5><p>A null check is performed for all load/store instructions when they are executed in ThumbEE state. If the value in<br>the base register is zero, execution branches to the NullCheck handler at HandlerBase – 4.</p>\n<h4 id=\"A9-2-ThumbEE-instruction-set-encoding\"><a href=\"#A9-2-ThumbEE-instruction-set-encoding\" class=\"headerlink\" title=\"A9.2 ThumbEE instruction set encoding\"></a>A9.2 ThumbEE instruction set encoding</h4><p>In general, instructions in the ThumbEE instruction set are encoded in exactly the same way as Thumb instructions<br>described in Chapter A6 Thumb Instruction Set Encoding. The differences are as follows:<br>• There are no 16-bit LDM or STM instructions in the ThumbEE instruction set.<br>• The 16-bit encodings used for LDM and STM in the Thumb instruction set are used for different 16-bit<br>instructions in the ThumbEE instruction set. For details, see 16-bit ThumbEE instructions.<br>• There are two new 32-bit instructions in both Thumb state and ThumbEE state. For details, see Additional<br>instructions in Thumb and ThumbEE instruction sets on page A9-1116.</p>\n<h5 id=\"A9-2-1-16-bit-ThumbEE-instructions\"><a href=\"#A9-2-1-16-bit-ThumbEE-instructions\" class=\"headerlink\" title=\"A9.2.1 16-bit ThumbEE instructions\"></a>A9.2.1 16-bit ThumbEE instructions</h5><p>Fixme [Table A9-2 16-bit ThumbEE instructions]page1115</p>\n<h4 id=\"A9-3-Additional-instructions-in-Thumb-and-ThumbEE-instruction-sets\"><a href=\"#A9-3-Additional-instructions-in-Thumb-and-ThumbEE-instruction-sets\" class=\"headerlink\" title=\"A9.3 Additional instructions in Thumb and ThumbEE instruction sets\"></a>A9.3 Additional instructions in Thumb and ThumbEE instruction sets</h4><p>On a processor with the ThumbEE Extension, there are two additional 32-bit instructions, ENTERX and LEAVEX. These<br>are available in both Thumb state and ThumbEE state.</p>\n<h5 id=\"A9-3-1-ENTERX-LEAVEX\"><a href=\"#A9-3-1-ENTERX-LEAVEX\" class=\"headerlink\" title=\"A9.3.1 ENTERX, LEAVEX\"></a>A9.3.1 ENTERX, LEAVEX</h5><p>ENTERX causes a change from Thumb state to ThumbEE state, or has no effect in ThumbEE state.<br>ENTERX is UNDEFINED in Hyp mode.<br>LEAVEX causes a change from ThumbEE state to Thumb state, or has no effect in Thumb state.</p>\n<h3 id=\"A8-Instruction-Descriptions\"><a href=\"#A8-Instruction-Descriptions\" class=\"headerlink\" title=\"A8 Instruction Descriptions\"></a>A8 Instruction Descriptions</h3><h4 id=\"A8-2-Standard-assembler-syntax-fields\"><a href=\"#A8-2-Standard-assembler-syntax-fields\" class=\"headerlink\" title=\"A8.2 Standard assembler syntax fields\"></a>A8.2 Standard assembler syntax fields</h4><p>The following assembler syntax fields are standard across all or most instructions:</p>\n<p><c> Is an optional field. It specifies the condition under which the instruction is executed. See<br>    Conditional execution on page A8-288 for the range of available conditions and their encoding. If<br>    <c> is omitted, it defaults to always (AL).</c></c></p>\n<p><q> Specifies optional assembler qualifiers on the instruction. The following qualifiers are defined:<br>    .N Meaning narrow, specifies that the assembler must select a 16-bit encoding for the<br>    instruction. If this is not possible, an assembler error is produced.<br>    .W Meaning wide, specifies that the assembler must select a 32-bit encoding for the<br>    instruction. If this is not possible, an assembler error is produced.</q></p>\n<h4 id=\"A8-3-Conditional-execution\"><a href=\"#A8-3-Conditional-execution\" class=\"headerlink\" title=\"A8.3 Conditional execution\"></a>A8.3 Conditional execution</h4><p>Most ARM instructions, and most Thumb instructions from ARMv6T2 onwards, can be executed conditionally,<br>based on the values of the APSR condition flags.</p>\n<p>Fixme [Table A8-1 Condition codes]page288</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Part-A-Application-Level-Architecture\"><a href=\"#Part-A-Application-Level-Architecture\" class=\"headerlink\" title=\"Part A. Application Level Architecture\"></a>Part A. Application Level Architecture</h2><hr>\n<h3 id=\"A1-Introduction-to-the-ARM-Architecture\"><a href=\"#A1-Introduction-to-the-ARM-Architecture\" class=\"headerlink\" title=\"A1. Introduction to the ARM Architecture\"></a>A1. Introduction to the ARM Architecture</h3><hr>","more":"<h4 id=\"A1-4-Architecture-extensions\"><a href=\"#A1-4-Architecture-extensions\" class=\"headerlink\" title=\"A1.4 Architecture extensions\"></a>A1.4 Architecture extensions</h4><p><strong>Jazelle</strong><br>Is the Java bytecode execution extension that extended ARMv5TE to ARMv5TEJ. From<br>ARMv6, the architecture requires at least the trivial Jazelle implementation, but a Jazelle<br>implementation is still often described as a Jazelle extension.<br>The Virtualization Extensions require that the Jazelle implementation is the trivial Jazelle<br>implementation.</p>\n<p><strong>ThumbEE</strong><br>Is an extension that provides the ThumbEE instruction set, a variant of the Thumb<br>instruction set that is designed as a target for dynamically generated code. In the original<br>release of the ARMv7 architecture, the ThumbEE extension was:<br>• A required extension to the ARMv7-A profile.<br>• An optional extension to the ARMv7-R profile.</p>\n<p>From publication of issue C.a of this manual, ARM deprecates any use of ThumbEE<br>instructions. However, ARMv7-A implementations must continue to include ThumbEE<br>support, for backwards compatibility.</p>\n<p><strong>Floating-point</strong><br>Is a floating-point coprocessor extension to the instruction set architectures. For historic<br>reasons, the Floating-point Extension is also called the VFP Extension. </p>\n<p><strong>Advanced SIMD</strong><br>Is an instruction set extension that provides Single Instruction Multiple Data (SIMD)<br>integer and single-precision floating-point vector operations on doubleword and quadword<br>registers.    </p>\n<h3 id=\"A1-4-2-Architecture-extensions\"><a href=\"#A1-4-2-Architecture-extensions\" class=\"headerlink\" title=\"A1.4.2 Architecture extensions\"></a>A1.4.2 Architecture extensions</h3><p>This manual also describes the following extensions to the ARMv7 architecture:<br><strong>Security Extensions</strong></p>\n<p><strong>Multiprocessing Extensions</strong><br>Are an OPTIONAL set of extensions to the ARMv7-A and ARMv7-R profiles, that provides a set of<br>features that enhance multiprocessing functionality.</p>\n<p><strong>Large Physical Address Extension</strong><br>Is an OPTIONAL extension to VMSAv7 that provides an address translation system supporting<br>physical addresses of up to 40 bits at a fine grain of translation.<br>The Large Physical Address Extension requires implementation of the Multiprocessing Extensions.</p>\n<p><strong>Virtualization Extensions</strong><br>Are an OPTIONAL set of extensions to VMSAv7 that provides hardware support for virtualizing the<br>Non-secure state of a VMSAv7 implementation. This supports system use of a virtual machine<br>monitor, also called a hypervisor.</p>\n<p><strong>Generic Timer Extension</strong><br>Is an OPTIONAL extension to any ARMv7-A or ARMv7-R, that provides a system timer, and a<br>low-latency register interface to it.</p>\n<p><strong>Performance Monitors Extension</strong><br>The ARMv7 architecture:<br>• reserves CP15 register space for IMPLEMENTATION DEFINED performance monitors<br>• defines a recommended performance monitors implementation.</p>\n<hr>\n<h3 id=\"A2-Application-Level-Programmers’-Model\"><a href=\"#A2-Application-Level-Programmers’-Model\" class=\"headerlink\" title=\"A2. Application Level Programmers’ Model\"></a>A2. Application Level Programmers’ Model</h3><h4 id=\"A2-1-About-the-Application-level-programmers’-model\"><a href=\"#A2-1-About-the-Application-level-programmers’-model\" class=\"headerlink\" title=\"A2.1 About the Application level programmers’ model\"></a>A2.1 About the Application level programmers’ model</h4><p>Depending on the implemented architecture extensions, the architecture supports multiple levels of execution<br>privilege, that number upwards from PL0, where PL0 is the lowest privilege level and is often described as<br>unprivileged.</p>\n<p>When an operating system supports execution at both PL1 and PL0, an application usually runs unprivileged. This:<br>• permits the operating system to <strong>allocate system resources</strong> to an application in a unique or shared manner<br>• provides <strong>a degree of protection from other processes and tasks</strong>, and so helps protect the operating system<br>from malfunctioning applications.</p>\n<h4 id=\"A2-2-ARM-core-data-types-and-arithmetic\"><a href=\"#A2-2-ARM-core-data-types-and-arithmetic\" class=\"headerlink\" title=\"A2.2 ARM core data types and arithmetic\"></a>A2.2 ARM core data types and arithmetic</h4><p>All ARMv7-A and ARMv7-R processors support the following data types in memory:<br>Byte           8 bits<br>Halfword       16 bits<br>Word           32 bits<br>Doubleword     64 bits.</p>\n<p>Processor registers are 32 bits in size. The instruction set contains instructions supporting the following data types<br>held in registers:<br>• 32-bit pointers<br>• unsigned or signed 32-bit integers<br>• unsigned 16-bit or 8-bit integers, held in zero-extended form<br>• signed 16-bit or 8-bit integers, held in sign-extended form<br>• two 16-bit integers packed into a register<br>• four 8-bit integers packed into a register<br>• unsigned or signed 64-bit integers held in two registers.</p>\n<h4 id=\"A2-3-ARM-core-registers\"><a href=\"#A2-3-ARM-core-registers\" class=\"headerlink\" title=\"A2.3 ARM core registers\"></a>A2.3 ARM core registers</h4><p>In the application level view, an ARM processor has:<br>• thirteen general-purpose 32-bit registers, R0 to R12<br>• three 32-bit registers with special uses, SP, LR, and PC, that can be described as R13 to R15.<br>The special registers are:<br><strong>SP, the stack pointer</strong><br>The processor uses SP as a pointer to the active stack.<br>In the Thumb instruction set, most instructions cannot access SP. The only instructions that can<br>access SP are those designed to use SP as a stack pointer.<br>The ARM instruction set provides more general access to the SP, and it can be used as a<br>general-purpose register. However, ARM deprecates the use of SP for any purpose other than as a<br>stack pointer.Software can refer to SP as R13.</p>\n<p><strong>LR, the link register</strong><br>The link register is a special register that can hold return link information. Some cases described in<br>this manual require this use of the LR. When software does not require the LR for linking, it can use<br>it for other purposes. It can refer to LR as R14.</p>\n<p><strong>PC, the program counter</strong><br>• When executing an ARM instruction, PC reads as the address of the current instruction plus 8.（PC始终指向你要取的指令的地址。ARM三级流水线，下一条指令是包含了预取指令，执行指令）<br>• When executing a Thumb instruction, PC reads as the address of the current instruction plus 4.<br>• Writing an address to PC causes a branch to that address.<br>Most Thumb instructions cannot access PC.<br>The ARM instruction set provides more general access to the PC, and many ARM instructions can<br>use the PC as a general-purpose register. However, ARM deprecates the use of PC for any purpose<br>other than as the program counter. Software can refer to PC as R15.</p>\n<h5 id=\"A2-3-1-Writing-to-the-PC\"><a href=\"#A2-3-1-Writing-to-the-PC\" class=\"headerlink\" title=\"A2.3.1 Writing to the PC\"></a>A2.3.1 Writing to the PC</h5><p>In ARMv7, many data-processing instructions can write to the PC. Writes to the PC are handled as follows:<br>• The B, BL, CBNZ, CBZ, CHKA, HB, HBL, HBLP, HBP, TBB, and TBH instructions remain in the same instruction set state<br>and branch to the value written to the PC.<br>The definition of each of these instructions ensures that the value written to the PC is correctly aligned for<br>the current instruction set state.</p>\n<p>• The BLX (immediate) instruction switches between ARM and Thumb states and branches to the value written<br>to the PC. Its definition ensures that the value written to the PC is correctly aligned for the new instruction<br>set state.</p>\n<p>• The following instructions write a value to the PC, treating that value as an interworking address to branch<br>to, with low-order bits that determine the new instruction set state:<br>    — BLX (register), BX, and BXJ<br>    — LDR instructions with <rt> equal to the PC<br>    — POP and all forms of LDM except LDM (exception return), when the register list includes the PC<br>    — in ARM state only, ADC, ADD, ADR, AND, ASR (immediate), BIC, EOR, LSL (immediate), LSR (immediate), MOV,<br>        MVN, ORR, ROR (immediate), RRX, RSB, RSC, SBC, and SUB instructions with <rd> equal to the PC and without<br>        flag-setting specified.</rd></rt></p>\n<h4 id=\"A2-4-The-Application-Program-Status-Register-APSR\"><a href=\"#A2-4-The-Application-Program-Status-Register-APSR\" class=\"headerlink\" title=\"A2.4 The Application Program Status Register (APSR)\"></a>A2.4 The Application Program Status Register (APSR)</h4><p>Fixme [APSR] Page49</p>\n<p>• Bits that can be set by many instructions:<br>— The Condition flags:<br>    N, bit[31] Negative condition flag. Set to bit[31] of the result of the instruction. If the result is<br>    regarded as a two’s complement signed integer, then the processor sets N to 1 if the result<br>    is negative, and sets N to 0 if it is positive or zero.<br>    Z, bit[30] Zero condition flag. Set to 1 if the result of the instruction is zero, and to 0 otherwise. A<br>    result of zero often indicates an equal result from a comparison.<br>    C, bit[29] Carry condition flag. Set to 1 if the instruction results in a carry condition, for example an<br>    unsigned overflow on an addition.<br>    V, bit[28] Overflow condition flag. Set to 1 if the instruction results in an overflow condition, for<br>    example a signed overflow on an addition.</p>\n<p>— The Overflow or saturation flag:<br>    Q, bit[27] Set to 1 to indicate overflow or saturation occurred in some instructions, normally related<br>    to digital signal processing (DSP). For more information, see Pseudocode details of<br>    saturation on page A2-44.</p>\n<p>— The Greater than or Equal flags:<br>    GE[3:0], bits[19:16]<br>    The instructions described in Parallel addition and subtraction instructions on<br>    page A4-171 update these flags to indicate the results from individual bytes or halfwords<br>    of the operation. These flags can control a later SEL instruction. For more information, see<br>    SEL on page A8-602.</p>\n<p>In ARMv7-A and ARMv7-R, the APSR is the same register as the CPSR, but the APSR must be used only to access<br>the N, Z, C, V, Q, and GE[3:0] bits.</p>\n<h4 id=\"A2-5-Execution-state-registers\"><a href=\"#A2-5-Execution-state-registers\" class=\"headerlink\" title=\"A2.5 Execution state registers\"></a>A2.5 Execution state registers</h4><p>The execution state registers modify the execution of instructions. They control:<br>• Whether instructions are interpreted as Thumb instructions, ARM instructions, ThumbEE instructions, or<br>Java bytecodes. For more information, see Instruction set state register, ISETSTATE.</p>\n<p>• In Thumb state and ThumbEE state only, the condition codes that apply to the next one to four instructions.<br>For more information, see IT block state register, ITSTATE on page A2-51.</p>\n<p>• Whether data is interpreted as big-endian or little-endian. For more information, see Endianness mapping<br>register, ENDIANSTATE on page A2-53.</p>\n<p>In ARMv7-A and ARMv7-R, the execution state registers are part of the Current Program Status Register. For more<br>information, see Program Status Registers (PSRs) on page B1-1147.</p>\n<h5 id=\"A2-5-1-Instruction-set-state-register-ISETSTATE\"><a href=\"#A2-5-1-Instruction-set-state-register-ISETSTATE\" class=\"headerlink\" title=\"A2.5.1 Instruction set state register, ISETSTATE\"></a>A2.5.1 Instruction set state register, ISETSTATE</h5><p>The instruction set state register, ISETSTATE, format is:<br>The J bit and the T bit determine the current instruction set state for the processor. Table A2-1 shows the encoding<br>of these bits.</p>\n<p>Fixme [Table A2-1 J and T bit encoding in ISETSTATE]Page50</p>\n<h5 id=\"A2-5-2-IT-block-state-register-ITSTATE\"><a href=\"#A2-5-2-IT-block-state-register-ITSTATE\" class=\"headerlink\" title=\"A2.5.2 IT block state register, ITSTATE\"></a>A2.5.2 IT block state register, ITSTATE</h5><p>Fixme [Table A2-2 Effect of IT execution state bits]Page52</p>\n<h5 id=\"A2-5-3-Endianness-mapping-register-ENDIANSTATE\"><a href=\"#A2-5-3-Endianness-mapping-register-ENDIANSTATE\" class=\"headerlink\" title=\"A2.5.3 Endianness mapping register, ENDIANSTATE\"></a>A2.5.3 Endianness mapping register, ENDIANSTATE</h5><p>Fixme [Table A2-3 ENDIANSTATE encoding of endianness]Page53</p>\n<h4 id=\"A2-6-Advanced-SIMD-and-Floating-point-Extensions\"><a href=\"#A2-6-Advanced-SIMD-and-Floating-point-Extensions\" class=\"headerlink\" title=\"A2.6 Advanced SIMD and Floating-point Extensions\"></a>A2.6 Advanced SIMD and Floating-point Extensions</h4><p>Advanced SIMD and Floating-point (VFP) are two OPTIONAL extensions to ARMv7.</p>\n<p>The Advanced SIMD Extension performs packed Single Instruction Multiple Data (SIMD) operations, either<br>integer or single-precision floating-point.</p>\n<p>….</p>\n<h4 id=\"A2-11-Jazelle-direct-bytecode-execution-support\"><a href=\"#A2-11-Jazelle-direct-bytecode-execution-support\" class=\"headerlink\" title=\"A2.11 Jazelle direct bytecode execution support\"></a>A2.11 Jazelle direct bytecode execution support</h4><p>The Jazelle extension provides architectural support for hardware acceleration of bytecode execution by a Java Virtual<br>Machine (JVM).</p>\n<p>These requirements for the Jazelle extension mean a JVM can be written to both:<br>• function correctly on all processors that include a Jazelle extension implementation<br>• automatically take advantage of the accelerated bytecode execution provided by a processor that includes a<br>non-trivial implementation.</p>\n<p>The required features of a non-trivial implementation are:<br>• provision of the Jazelle state<br>• a new instruction, BXJ, to enter Jazelle state<br>• system support that enables an operating system to regulate the use of the Jazelle extension hardware<br>• system support that enables a JVM to configure the Jazelle extension hardware to its specific needs.</p>\n<p>…</p>\n<h3 id=\"A3-Application-Level-Memory-Model\"><a href=\"#A3-Application-Level-Memory-Model\" class=\"headerlink\" title=\"A3 Application Level Memory Model\"></a>A3 Application Level Memory Model</h3><p>…</p>\n<h4 id=\"A3-2-Alignment-support\"><a href=\"#A3-2-Alignment-support\" class=\"headerlink\" title=\"A3.2 Alignment support\"></a>A3.2 Alignment support</h4><p>Instructions in the ARM architecture are aligned as follows:<br>• ARM instructions are word-aligned<br>• Thumb and ThumbEE instructions are halfword-aligned<br>• Java bytecodes are byte-aligned.<br>In the ARMv7 architecture, some load and store instructions support unaligned data accesses, as described in<br>Unaligned data access.</p>\n<h5 id=\"A3-2-1-Unaligned-data-access\"><a href=\"#A3-2-1-Unaligned-data-access\" class=\"headerlink\" title=\"A3.2.1 Unaligned data access\"></a>A3.2.1 Unaligned data access</h5><p>An ARMv7 implementation must support unaligned data accesses to Normal memory by some load and store<br>instructions. <strong>Software can set the SCTLR.A bit to control whether a misaligned access to Normal memory by one of these instructions causes an Alignment fault Data Abort exception.</strong></p>\n<p><strong>Unaligned access operations must not be used for accessing memory-mapped registers in a Device or Strongly-ordered memory region.</strong></p>\n<p>Fixme [Table A3-1 Alignment requirements of load/store instructions]  page108</p>\n<h4 id=\"A3-3-Endian-support\"><a href=\"#A3-3-Endian-support\" class=\"headerlink\" title=\"A3.3 Endian support\"></a>A3.3 Endian support</h4><p>Data support big-endian or little-endian.</p>\n<h5 id=\"A3-3-1-Instruction-endianness\"><a href=\"#A3-3-1-Instruction-endianness\" class=\"headerlink\" title=\"A3.3.1 Instruction endianness\"></a>A3.3.1 Instruction endianness</h5><p><strong>In ARMv7-A, the mapping of instruction memory is always little-endian</strong>. In ARMv7-R, instruction endianness can<br>be controlled at the system level, In ARMv7-A, the mapping of instruction memory is always little-endian. In ARMv7-R, instruction endianness can be controlled at the system level, see Instruction endianness static configuration, ARMv7-R only on page A3-112.</p>\n<h5 id=\"A3-3-2-Element-size-and-endianness\"><a href=\"#A3-3-2-Element-size-and-endianness\" class=\"headerlink\" title=\"A3.3.2 Element size and endianness\"></a>A3.3.2 Element size and endianness</h5><p>Fixme [Table A3-2 Element size of load/store instructions] page112</p>\n<h5 id=\"A3-3-4-Endianness-in-Advanced-SIMD\"><a href=\"#A3-3-4-Endianness-in-Advanced-SIMD\" class=\"headerlink\" title=\"A3.3.4 Endianness in Advanced SIMD\"></a>A3.3.4 Endianness in Advanced SIMD</h5><p>Advanced SIMD element load/store instructions transfer vectors of elements between memory and the Advanced<br>SIMD register bank.An instruction specifies both the length of the transfer and the size of the data elements being<br>transferred. This information is used by the processor to load and store data correctly in both big-endian and<br>little-endian systems.</p>\n<p>处理器根据提供的信息，能保证在Advanced SIMD register bank 中的数据是一样的，不论它是否是大端，小端<br>Fixme [Figure A3-2 Advanced SIMD byte order example] page113</p>\n<h4 id=\"A3-4-Synchronization-and-semaphores\"><a href=\"#A3-4-Synchronization-and-semaphores\" class=\"headerlink\" title=\"A3.4 Synchronization and semaphores\"></a>A3.4 Synchronization and semaphores</h4><p>In architecture versions before ARMv6, support for the synchronization of shared memory depends on the SWP and<br>SWPB instructions.These are read-locked-write operations that swap register contents with memory, and are<br>described in SWP, SWPB on page A8-722. These instructions support basic busy/free semaphore mechanisms, but<br>do not support mechanisms that require calculation to be performed on the semaphore between the read and write<br>phases.</p>\n<p>ARMv7 extends support for<br>this mechanism, and provides the following synchronization primitives in the ARM and Thumb instruction sets:<br>• Load-Exclusives:<br>    — LDREX, see LDREX on page A8-432<br>    — LDREXB, see LDREXB on page A8-434<br>    — LDREXD, see LDREXD on page A8-436<br>    — LDREXH, see LDREXH on page A8-438<br>• Store-Exclusives:<br>    — STREX, see STREX on page A8-690<br>    — STREXB, see STREXB on page A8-692<br>    — STREXD, see STREXD on page A8-694<br>    — STREXH, see STREXH on page A8-696<br>• Clear-Exclusive, CLREX, see CLREX on page A8-360.</p>\n<p>Note<br>• ARM strongly recommends that all software uses the synchronization primitives described in this section,<br>rather than SWP or SWPB.</p>\n<h5 id=\"A3-4-1-Exclusive-access-instructions-and-Non-shareable-memory-regions\"><a href=\"#A3-4-1-Exclusive-access-instructions-and-Non-shareable-memory-regions\" class=\"headerlink\" title=\"A3.4.1 Exclusive access instructions and Non-shareable memory regions\"></a>A3.4.1 Exclusive access instructions and Non-shareable memory regions</h5><p>For memory regions that do not have the Shareable attribute, the exclusive access instructions <strong>rely on a local monitor that tags any address</strong> from which the processor executes a Load-Exclusive. Any non-aborted attempt by the<br>same processor to use a Store-Exclusive to modify any address is guaranteed to clear the tag.</p>\n<p>A Load-Exclusive performs a load from memory, and:<br>• the executing processor tags the physical memory address for exclusive access<br>• the local monitor of the executing processor transitions to the Exclusive Access state.</p>\n<p>A Store-Exclusive performs a conditional store to memory, that depends on the state of the local monitor:<br><strong>If the local monitor is in the Exclusive Access state</strong><br>    • If the address of the Store-Exclusive is the same as the address that has been tagged in the<br>    monitor by an earlier Load-Exclusive, then the store occurs, otherwise it is IMPLEMENTATION<br>    DEFINED whether the store occurs.<br>    • A status value is returned to a register:<br>        — if the store took place the status value is 0<br>        — otherwise, the status value is 1.<br>    • The local monitor of the executing processor transitions to the Open Access state.<br><strong>If the local monitor is in the Open Access state</strong><br>    • no store takes place<br>    • a status value of 1 is returned to a register.<br>    • the local monitor remains in the Open Access state.</p>\n<p>Fixme [Figure A3-3 Local monitor state machine diagram]Page 116    </p>\n<p>Fixme [Table A3-3 Effect of Exclusive instructions and write operations on the local monitor]Page 116</p>\n<h5 id=\"A3-4-2-Exclusive-access-instructions-and-Shareable-memory-regions\"><a href=\"#A3-4-2-Exclusive-access-instructions-and-Shareable-memory-regions\" class=\"headerlink\" title=\"A3.4.2 Exclusive access instructions and Shareable memory regions\"></a>A3.4.2 Exclusive access instructions and Shareable memory regions</h5><p>For memory regions that have the Shareable attribute, exclusive access instructions rely on:<br>• <strong>A local monitor for each processor in the system</strong>, that tags any address from which the processor executes a<br>Load-Exclusive. The local monitor can ignore accesses from other processors in the system.</p>\n<p>• <strong>A global monitor that tags a physical address as exclusive access for a particular processor</strong>. This tag is used<br>later to determine whether a Store-Exclusive to that address that has not been failed by the local monitor can<br>occur. Any successful write to the tagged address by any other observer in the shareability domain of the<br>memory location is guaranteed to clear the tag. For each processor in the system, the global monitor:<br>    — can hold at least one tagged address<br>    — maintains a state machine for each tagged address it can hold.</p>\n<p><strong>Operation of the global monitor</strong><br>A Load-Exclusive from Shareable memory performs a load from memory, and causes the <strong>physical address of the access to be tagged as exclusive access for the requesting processor.</strong> This access also causes the exclusive access tag to be removed from any other physical address that has been tagged by the requesting processor.</p>\n<p>The global monitor only supports a single outstanding exclusive access to Shareable memory per processor. A<br>Load-Exclusive by one processor has no effect on the global monitor state for any other processor.</p>\n<p>Fixme [Table A3-4 Effect of load/store operations on global monitor for processor(n)] Page120</p>\n<h5 id=\"A3-4-3-Tagging-and-the-size-of-the-tagged-memory-block\"><a href=\"#A3-4-3-Tagging-and-the-size-of-the-tagged-memory-block\" class=\"headerlink\" title=\"A3.4.3 Tagging and the size of the tagged memory block\"></a>A3.4.3 Tagging and the size of the tagged memory block</h5><p>Tagged_address = Memory_address[31:a]<br>The value of a in this assignment is IMPLEMENTATION DEFINED, between a minimum value of 3 and a maximum<br>value of 11. For example, in an implementation where a is 4, a successful LDREX of address 0x000341B4 gives a tag<br>value of bits[31:4] of the address, giving 0x000341B. This means that the four words of memory from 0x000341B0 to<br>0x000341BF are tagged for exclusive access.</p>\n<p>The size of the tagged memory block is called the Exclusives Reservation Granule. The Exclusives Reservation<br>Granule is IMPLEMENTATION DEFINED in the range 2-512 words:<br>• 2 words in an implementation where a is 3<br>• 512 words in an implementation where a is 11.</p>\n<h5 id=\"A3-4-4-Context-switch-support\"><a href=\"#A3-4-4-Context-switch-support\" class=\"headerlink\" title=\"A3.4.4 Context switch support\"></a>A3.4.4 Context switch support</h5><p>After a context switch, software must ensure that the local monitor is in the Open Access state. This requires it to<br>either:<br>• execute a CLREX instruction<br>• execute a dummy STREX to a memory address allocated for this purpose.</p>\n<p>Note:<br>Using a dummy STREX for this purpose is backwards-compatible with the ARMv6 implementation of the<br>exclusive operations. The CLREX instruction is introduced in ARMv6K.</p>\n<h5 id=\"A3-4-5-Load-Exclusive-and-Store-Exclusive-usage-restrictions\"><a href=\"#A3-4-5-Load-Exclusive-and-Store-Exclusive-usage-restrictions\" class=\"headerlink\" title=\"A3.4.5 Load-Exclusive and Store-Exclusive usage restrictions\"></a>A3.4.5 Load-Exclusive and Store-Exclusive usage restrictions</h5><p>The Load-Exclusive and Store-Exclusive instructions are intended to work together, as a pair, for example a<br>LDREX/STREX pair or a LDREXB/STREXB pair.</p>\n<p>• An implementation of the Load-Exclusive and Store-Exclusive instructions can require that, in any thread of<br>execution, the transaction size of a Store-Exclusive is the same as the transaction size of the preceding<br>Load-Exclusive executed in that thread.</p>\n<p>• An implementation might clear an exclusive monitor between the LDREX and the STREX, without any<br>application-related cause. Software written for such an implementation must, in any single thread of execution, <strong>avoid having any explicit memory accesses, System control register updates, or cache maintenance operations between the LDREX instruction and the associated STREX instruction.</strong></p>\n<p>• In some implementations, an access to Strongly-ordered or Device memory might clear the exclusive<br>monitor. Therefore, <strong>software must not place a load or a store to Strongly-ordered or Device memory between an LDREX and an STREX in a single thread of execution.</strong></p>\n<p>• Implementations can benefit from keeping the LDREX and STREX operations close together in a single thread of<br>execution. This minimizes the likelihood of the exclusive monitor state being cleared between the LDREX<br>instruction and the STREX instruction. Therefore, <strong>for best performance, ARM strongly recommends a limit of 128 bytes between LDREX and STREX instructions in a single thread of execution.</strong></p>\n<p>• After taking a Data Abort exception, the state of the exclusive monitors is UNKNOWN. Therefore ARM<br>strongly recommends that the abort handling software performs a CLREX instruction, or a dummy STREX<br>instruction, to clear the monitor state.</p>\n<p>• The effect of a data or unified cache invalidate, cache clean, or cache clean and invalidate instruction on a<br>local or global exclusive monitor that is in the Exclusive Access state is UNPREDICTABLE. Execution of the<br>instruction might clear the monitor, or it might leave it in the Exclusive Access state.</p>\n<p>• For the memory location being accessed by a LoadExcl/StoreExcl pair, if the memory attributes for the<br>LoadExcl instruction differ from the memory attributes for the StoreExcl instruction, behavior is<br>UNPREDICTABLE.</p>\n<h5 id=\"A3-4-6-Semaphores\"><a href=\"#A3-4-6-Semaphores\" class=\"headerlink\" title=\"A3.4.6 Semaphores\"></a>A3.4.6 Semaphores</h5><p>The Swap (SWP) and Swap Byte (SWPB) instructions must be used with care to ensure that expected behavior is<br>observed.</p>\n<p>Note<br>From ARMv6, ARM deprecates use of the Swap and Swap Byte instructions, and strongly recommends that all new<br>software uses the Load-Exclusive and Store-Exclusive synchronization primitives</p>\n<h5 id=\"A3-4-7-Synchronization-primitives-and-the-memory-order-model\"><a href=\"#A3-4-7-Synchronization-primitives-and-the-memory-order-model\" class=\"headerlink\" title=\"A3.4.7 Synchronization primitives and the memory order model\"></a>A3.4.7 Synchronization primitives and the memory order model</h5><p>The synchronization primitives follow the memory order model of the memory type accessed by the instructions.<br>For this reason:<br>• Portable software for claiming a spin-lock must include a Data Memory Barrier (DMB) operation, performed<br>by a DMB instruction, between claiming the spin-lock and making any access that makes use of the spin-lock.<br>• Portable software for releasing a spin-lock must include a DMB instruction before writing to clear the spin-lock.<br>This requirement applies to software using:<br>• the Load-Exclusive/Store-Exclusive instruction pairs, for example LDREX/STREX<br>• the deprecated synchronization primitives, SWP/SWPB.</p>\n<p><a href=\"https://blog.csdn.net/wangbinyantai/article/details/78986974\" target=\"_blank\" rel=\"noopener\">ISB &gt; DSB &gt; DMB</a></p>\n<h5 id=\"A3-4-8-Use-of-WFE-and-SEV-instructions-by-spin-locks\"><a href=\"#A3-4-8-Use-of-WFE-and-SEV-instructions-by-spin-locks\" class=\"headerlink\" title=\"A3.4.8 Use of WFE and SEV instructions by spin-locks\"></a>A3.4.8 Use of WFE and SEV instructions by spin-locks</h5><p>ARMv7 and ARMv6K provide Wait For Event and Send Event instructions, WFE and SEV, that can assist with<br>reducing power consumption and bus contention caused by processors repeatedly attempting to obtain a spin-lock.<br>These instructions can be used at the application level, but a complete understanding of what they do depends on<br>system level understanding of exceptions.</p>\n<h4 id=\"A3-5-Memory-types-and-attributes-and-the-memory-order-model\"><a href=\"#A3-5-Memory-types-and-attributes-and-the-memory-order-model\" class=\"headerlink\" title=\"A3.5 Memory types and attributes and the memory order model\"></a>A3.5 Memory types and attributes and the memory order model</h4><h5 id=\"A3-5-1-Memory-types\"><a href=\"#A3-5-1-Memory-types\" class=\"headerlink\" title=\"A3.5.1 Memory types\"></a>A3.5.1 Memory types</h5><p>exclusive memory types:<br>• Normal<br>• Device<br>• Strongly-ordered.</p>\n<h5 id=\"A3-5-2-Summary-of-ARMv7-memory-attributes\"><a href=\"#A3-5-2-Summary-of-ARMv7-memory-attributes\" class=\"headerlink\" title=\"A3.5.2 Summary of ARMv7 memory attributes\"></a>A3.5.2 Summary of ARMv7 memory attributes</h5><p><strong>Shareability</strong><br>Applies only to Normal memory, and <strong>to Device memory in an implementation that does not include the Large Physical Address Extension.</strong> In an implementation that includes the Large Physical<br>Address Extension, Device memory is always Outer Shareable,<br>When it is possible to assign a shareability attribute to Device memory, ARM deprecates assigning<br>any attribute other than Shareable or Outer Shareable, see Shareable attribute for Device memory<br>regions on page A3-137<br>Whether an ARMv7 implementation distinguishes between Inner Shareable and Outer Shareable<br>memory is IMPLEMENTATION DEFINED.</p>\n<p><strong>Cacheability</strong><br>Applies only to Normal memory, and can be defined independently for Inner and Outer cache<br>regions. Some cacheability attributes can be complemented by a cache allocation hint. This is an<br>indication to the memory system of whether allocating a value to a cache is likely to improve<br>performance. </p>\n<p>Fixme [Table A3-5 Memory attribute summary] page127</p>\n<h5 id=\"A3-5-3-Atomicity-in-the-ARM-architecture\"><a href=\"#A3-5-3-Atomicity-in-the-ARM-architecture\" class=\"headerlink\" title=\"A3.5.3 Atomicity in the ARM architecture\"></a>A3.5.3 Atomicity in the ARM architecture</h5><p>Atomicity is a feature of memory accesses, described as atomic accesses. The ARM architecture description refers<br>to two types of atomicity, defined in:<br>• Single-copy atomicity<br>• Multi-copy atomicity on page A3-130.</p>\n<p><strong>Single-copy atomicity</strong><br>In ARMv7, the single-copy atomic processor accesses are:<br>• All byte accesses.<br>• All halfword accesses to halfword-aligned locations.<br>• All word accesses to word-aligned locations.<br>• Memory accesses caused by a LDREXD/STREXD to a doubleword-aligned location for which the STREXD succeeds<br>cause single-copy atomic updates of the doubleword being accessed.<br>Note<br>The way to atomically load two 32-bit quantities is to perform a LDREXD/STREXD sequence, reading and writing<br>the same value, for which the STREXD succeeds, and use the read values</p>\n<p><strong>Multi-copy atomicity</strong><br>In a multiprocessing system, writes to a memory location are multi-copy atomic</p>\n<p>Writes to Normal memory are not multi-copy atomic. (有缓存机制以及SNOOP等)<br>All writes to Device and Strongly-ordered memory that are single-copy atomic are also multi-copy atomic.</p>\n<h5 id=\"A3-5-4-Concurrent-modification-and-execution-of-instructions\"><a href=\"#A3-5-4-Concurrent-modification-and-execution-of-instructions\" class=\"headerlink\" title=\"A3.5.4 Concurrent modification and execution of instructions\"></a>A3.5.4 Concurrent modification and execution of instructions</h5><p>The ARMv7 architecture limits the set of instructions that can be executed by one thread of execution as they are<br>being modified by another thread of execution without requiring explicit synchronization.</p>\n<p>Except for the instructions identified in this section, the effect of the concurrent modification and execution of an<br>instruction is UNPREDICTABLE. （无条件跳转等命令，不受这个限制）</p>\n<p><strong>In the Thumb instruction set</strong><br>The 16-bit encodings of the B, NOP, BKPT, and SVC instructions</p>\n<p><strong>In the ARM instruction set</strong><br>The B, BL, NOP, BKPT, SVC, HVC, and SMC instructions.</p>\n<h5 id=\"A3-5-5-Normal-memory\"><a href=\"#A3-5-5-Normal-memory\" class=\"headerlink\" title=\"A3.5.5 Normal memory\"></a>A3.5.5 Normal memory</h5><p>Accesses to normal memory region are idempotent, meaning that they exhibit the following properties:<br>• read accesses can be repeated with no side-effects<br>• repeated read accesses return the last value written to the resource being read<br>• read accesses can fetch additional memory locations with no side-effects<br>• write accesses can be repeated with no side-effects in the following cases:<br>    — if the contents of the location accessed are unchanged between the repeated writes<br>    — as the result of an exception, as described in this section<br>• unaligned accesses can be supported<br>• accesses can be merged before accessing the target memory system.</p>\n<p>Normal memory can be read/write or read-only, and a Normal memory region is defined as being either Shareable<br>or Non-shareable.</p>\n<p><strong>Non-shareable Normal memory</strong><br>For a Normal memory region, the Non-shareable attribute identifies Normal memory that is likely to be accessed<br>only by a single processor.</p>\n<p><strong>Shareable, Inner Shareable, and Outer Shareable Normal memory</strong><br>For Normal memory, the Shareable and Outer Shareable memory attributes describe Normal memory that is<br>expected to <strong>be accessed by multiple processors or other system masters:</strong><br>• In a VMSA implementation, Normal memory that has the Shareable attribute but not the Outer Shareable<br>attribute assigned is described as having the Inner Shareable attribute.<br>• In a PMSA implementation, no distinction is made between Inner Shareable and Outer Shareable Normal<br>memory.</p>\n<p>VMSA: Virtual Memory System Architecture<br>PMSA: Protected Memory System Architecture</p>\n<p><strong>Write-Through Cacheable, Write-Back Cacheable and Non-cacheable Normal memory</strong><br>The cacheability attributes provide a mechanism of coherency control with observers that lie outside the shareability<br>domain of a region of memory.<br>• Write-Through Cacheable<br>• Write-Back Cacheable<br>• Non-cacheable.</p>\n<p>The cacheability attributes provide a mechanism of coherency control with observers that lie outside the shareability<br>domain of a region of memory. In some cases, the use of Write-Through Cacheable or Non-cacheable regions of<br>memory might provide a better mechanism for controlling coherency than the use of hardware coherency<br>mechanisms or the use of cache maintenance routines.</p>\n<h5 id=\"A3-5-6-Device-and-Strongly-ordered-memory\"><a href=\"#A3-5-6-Device-and-Strongly-ordered-memory\" class=\"headerlink\" title=\"A3.5.6 Device and Strongly-ordered memory\"></a>A3.5.6 Device and Strongly-ordered memory</h5><p>Examples of memory regions normally marked as being Device or Strongly-ordered memory are Memory-mapped<br>peripherals and I/O locations. <strong>Address locations marked as Device or Strongly-ordered are never held in a cache.</strong></p>\n<p>The architecture permits an Advanced SIMD element or structure load instruction to access bytes in Device or<br>Strongly-ordered memory.</p>\n<p><strong>The architecture does not permit unaligned accesses to Strongly-ordered or Device memory.</strong></p>\n<h6 id=\"Shareable-attribute-for-Device-memory-regions\"><a href=\"#Shareable-attribute-for-Device-memory-regions\" class=\"headerlink\" title=\"Shareable attribute for Device memory regions\"></a>Shareable attribute for Device memory regions</h6><p>In an implementation that does not include the Large Physical Address Extension, Device memory regions can be<br>given the Shareable attribute. When a Device memory region is give the Shareable attribute it can also be given the<br>Outer Shareable attribute. This means that a region of Device memory can be described as one of:<br>• Outer Shareable Device memory<br>• Inner Shareable Device memory<br>• Non-shareable Device memory.</p>\n<p>ARM deprecates the marking of Device memory with a shareability attribute other than Outer Shareable or<br>Shareable. This means <strong>ARM strongly recommends that Device memory is never assigned a shareability attribute of Non-shareable or Inner Shareable.</strong></p>\n<h6 id=\"Device-and-Strongly-ordered-memory-shareability-Large-Physical-Address-Extension\"><a href=\"#Device-and-Strongly-ordered-memory-shareability-Large-Physical-Address-Extension\" class=\"headerlink\" title=\"Device and Strongly-ordered memory shareability, Large Physical Address Extension\"></a>Device and Strongly-ordered memory shareability, Large Physical Address Extension</h6><p>In an implementation that includes the Large Physical Address Extension, the Long-descriptor translation table<br>format does not distinguish between Shareable and Non-shareable Device memory.</p>\n<p>In an implementation that includes the Large Physical Address Extension and is using the Short-descriptor<br>translation table format:<br>• An address-based cache maintenance operation for an addresses in a region with the Strongly-ordered or<br>Device memory type applies to all processors in the same Outer Shareable domain, regardless of any<br>shareability attributes applied to the region.<br>• Device memory transactions to a single peripheral must not be reordered, regardless of any shareability<br>attributes that are applied to the corresponding Device memory region.<br>Any single peripheral has an IMPLEMENTATION DEFINED size of not less than 1KB.</p>\n<h5 id=\"A3-5-7-Memory-access-restrictions\"><a href=\"#A3-5-7-Memory-access-restrictions\" class=\"headerlink\" title=\"A3.5.7 Memory access restrictions\"></a>A3.5.7 Memory access restrictions</h5><p>The following restrictions apply to memory accesses:<br>• For accesses to any two bytes, p and q, that are generated by the same instruction:<br>    — The bytes p and q must have the same memory type and shareability attributes<br>    — Except for possible differences in the cache allocation hints, ARM deprecates having different<br>    cacheability attributes for the bytes p and q.</p>\n<p>• Unaligned data access on page A3-108 identifies the instructions that can make an unaligned memory<br>access,If such an access is to Device or Strongly-ordered memory then:<br>    — if the implementation does not include the Virtualization Extensions, the effect is UNPREDICTABLE<br>    — if the implementation includes the Virtualization Extensions, the access generates an Alignment fault</p>\n<p>• <strong>The accesses of an instruction that causes multiple accesses to Device or Strongly-ordered memory must not cross a 4KB address boundary</strong></p>\n<p>• <strong>Any instruction fetch must access only Normal memory.</strong> If it accesses Device or Strongly-ordered memory,<br>the result is UNPREDICTABLE.</p>\n<h5 id=\"A3-5-8-The-effect-of-the-Security-Extensions\"><a href=\"#A3-5-8-The-effect-of-the-Security-Extensions\" class=\"headerlink\" title=\"A3.5.8 The effect of the Security Extensions\"></a>A3.5.8 The effect of the Security Extensions</h5><p>The Security Extensions can be included as part of an ARMv7-A implementation, with a VMSA. They provide two<br>distinct 4GByte virtual memory spaces:<br>• a Secure virtual memory space<br>• a Non-secure virtual memory space.<br>The Secure virtual memory space is accessed by memory accesses in the Secure state, and the Non-secure virtual<br>memory space is accessed by memory accesses in the Non-secure state.<br>By providing different virtual memory spaces, the Security Extensions permit memory accesses made from the<br>Non-secure state to be distinguished from those made from the Secure state.</p>\n<h4 id=\"A3-6-Access-rights\"><a href=\"#A3-6-Access-rights\" class=\"headerlink\" title=\"A3.6 Access rights\"></a>A3.6 Access rights</h4><h5 id=\"A3-6-1-Processor-privilege-levels-execution-privilege-and-access-privilege\"><a href=\"#A3-6-1-Processor-privilege-levels-execution-privilege-and-access-privilege\" class=\"headerlink\" title=\"A3.6.1 Processor privilege levels, execution privilege, and access privilege\"></a>A3.6.1 Processor privilege levels, execution privilege, and access privilege</h5><p>ARMv7 architecture defines different levels of execution privilege:<br>• in Secure state, the privilege levels are PL1 and PL0<br>• in Non-secure state, the privilege levels are PL2, PL1, and PL0.</p>\n<p><strong>PL0</strong><br>The privilege level of application software, that executes in User mode. Therefore, software<br>executed in User mode is described as unprivileged software. This software cannot access some<br>features of the architecture. In particular, it cannot change many of the configuration settings.<br>Software executing at PL0 makes only unprivileged memory accesses.</p>\n<p><strong>PL1</strong><br>Software execution in all modes other than User mode and Hyp mode is at PL1. Normally, operating<br>system software executes at PL1. Software executing at PL1 can access all features of the<br>architecture, and can change the configuration settings for those features, except for some features<br>added by the Virtualization Extensions that are only accessible at PL2.<br>Note<br>In many implementation models, system software is unaware of the PL2 level of privilege, and of<br>whether the implementation includes the Virtualization Extensions.<br>The PL1 modes refers to all the modes other than User mode and Hyp mode.<br>Software executing at PL1 makes privileged memory accesses by default, but can also make<br>unprivileged accesses.</p>\n<p><strong>PL2</strong><br>Software executing in Hyp mode executes at PL2.<br>Software executing at PL2 can perform all of the operations accessible at PL1, and can access some<br>additional functionality.<br>Hyp mode is normally used by a hypervisor, that controls, and can switch between, Guest OSs, that<br>execute at PL1.</p>\n<p>Hyp mode is implemented only as part of the Virtualization Extensions, and only in Non-secure<br>state. This means that:<br>• implementations that do not include the Virtualization Extensions have only two privilege<br>levels, PL0 and PL1<br>• execution in Secure state has only two privilege levels, PL0 and PL1</p>\n<h4 id=\"A3-8-Memory-access-order\"><a href=\"#A3-8-Memory-access-order\" class=\"headerlink\" title=\"A3.8 Memory access order\"></a>A3.8 Memory access order</h4><h5 id=\"A3-8-1-Reads-and-writes\"><a href=\"#A3-8-1-Reads-and-writes\" class=\"headerlink\" title=\"A3.8.1 Reads and writes\"></a>A3.8.1 Reads and writes</h5><p>The following can cause memory accesses that are not explicit:<br>• instruction fetches<br>• cache loads and write-backs<br>• translation table walks.</p>\n<h6 id=\"Reads\"><a href=\"#Reads\" class=\"headerlink\" title=\"Reads\"></a>Reads</h6><p>Reads are defined as memory operations that have the semantics of a load.<br>The memory accesses of the following instructions are reads:<br>• LDR, LDRB, LDRH, LDRSB, and LDRSH.<br>• LDRT, LDRBT, LDRHT, LDRSBT, and LDRSHT.<br>• LDREX, LDREXB, LDREXD, and LDREXH.<br>• LDM, LDRD, POP, and RFE.<br>• LDC, LDC2, VLDM, VLDR, VLD1, VLD2, VLD3, VLD4, and VPOP.<br>• The return of status values by STREX, STREXB, STREXD, and STREXH.<br>• SWP and SWPB. These instructions are available only in the ARM instruction set.<br>• TBB and TBH. These instructions are available only in the Thumb instruction set.<br>Hardware-accelerated opcode execution by the Jazelle extension can cause a number of reads to occur, according<br>to the state of the operand stack and the implementation of the Jazelle hardware acceleration.</p>\n<h6 id=\"Writes\"><a href=\"#Writes\" class=\"headerlink\" title=\"Writes\"></a>Writes</h6><p>Writes are defined as memory operations that have the semantics of a store.<br>The memory accesses of the following instructions are Writes:<br>• STR, STRB, and STRH.<br>• STRT, STRBT, and STRHT.<br>• STREX, STREXB, STREXD, and STREXH.<br>• STM, STRD, PUSH, and SRS.<br>• STC, STC2, VPUSH, VSTM, VSTR, VST1, VST2, VST3, and VST4.<br>• SWP and SWPB. These instructions are available only in the ARM instruction set.<br>Hardware-accelerated opcode execution by the Jazelle extension can cause a number of writes to occur, according<br>to the state of the operand stack and the implementation of the Jazelle hardware acceleration.</p>\n<h6 id=\"Synchronization-primitives\"><a href=\"#Synchronization-primitives\" class=\"headerlink\" title=\"Synchronization primitives\"></a>Synchronization primitives</h6><p>Synchronization primitives must ensure correct operation of system semaphores in the memory order model. They are the following instructions:<br>• LDREX, STREX, LDREXB, STREXB, LDREXD, STREXD, LDREXH, STREXH.<br>• SWP, SWPB. From ARMv6, ARM deprecates the use of these instructions.</p>\n<h5 id=\"A3-8-3-Memory-barriers\"><a href=\"#A3-8-3-Memory-barriers\" class=\"headerlink\" title=\"A3.8.3 Memory barriers\"></a>A3.8.3 Memory barriers</h5><p>Memory barrier is the general term applied to an instruction, or sequence of instructions, that forces synchronization<br>events by a processor with respect to retiring load/store instructions.</p>\n<p>The ARM architecture defines a number of memory barriers that provide a range of functionality, including:<br>• ordering of load/store instructions<br>• completion of load/store instructions<br>• context synchronization.</p>\n<p>In ARMv7 the memory barriers are provided as instructions that are available in the ARM and Thumb<br>instruction sets, and in ARMv6 the memory barriers are performed by CP15 register writes. The three memory<br>barriers are:<br>• Data Memory Barrier, see Data Memory Barrier (DMB) on page A3-152<br>• Data Synchronization Barrier, see Data Synchronization Barrier (DSB) on page A3-153<br>• Instruction Synchronization Barrier, see Instruction Synchronization Barrier (ISB) on page A3-153.</p>\n<h6 id=\"Data-Memory-Barrier-DMB\"><a href=\"#Data-Memory-Barrier-DMB\" class=\"headerlink\" title=\"Data Memory Barrier (DMB)\"></a>Data Memory Barrier (DMB)</h6><p>The DMB instruction is a data memory barrier. <strong>DMB only affects memory accesses and data and unified cache maintenance operations,  It has no effect on the ordering of any other instructions executing on the processor.</strong></p>\n<h6 id=\"Data-Synchronization-Barrier-DSB\"><a href=\"#Data-Synchronization-Barrier-DSB\" class=\"headerlink\" title=\"Data Synchronization Barrier (DSB)\"></a>Data Synchronization Barrier (DSB)</h6><p>The DSB instruction is a special memory barrier, that synchronizes the execution stream with memory accesses. <strong>In addition, no instruction that appears in program order after the DSB instruction can execute until the DSB completes.</strong></p>\n<h6 id=\"Instruction-Synchronization-Barrier-ISB\"><a href=\"#Instruction-Synchronization-Barrier-ISB\" class=\"headerlink\" title=\"Instruction Synchronization Barrier (ISB)\"></a>Instruction Synchronization Barrier (ISB)</h6><p><strong>An ISB instruction flushes the pipeline in the processor, so that all instructions that come after the ISB instruction in program order are fetched from cache or memory only after the ISB instruction has completed.</strong></p>\n<p>Using an ISB ensures that the effects of context-changing operations executed before the ISB are visible to the instructions fetched after the ISB instruction. </p>\n<p>Examples of context-changing operations that require the insertion of an ISB instruction to ensure<br>the effects of the operation are visible to instructions fetched after the ISB instruction are:<br>• completed cache, TLB, and branch predictor maintenance operations<br>• changes to system control registers. </p>\n<h4 id=\"A3-9-Caches-and-memory-hierarchy\"><a href=\"#A3-9-Caches-and-memory-hierarchy\" class=\"headerlink\" title=\"A3.9 Caches and memory hierarchy\"></a>A3.9 Caches and memory hierarchy</h4><h5 id=\"A3-9-1-Introduction-to-caches\"><a href=\"#A3-9-1-Introduction-to-caches\" class=\"headerlink\" title=\"A3.9.1 Introduction to caches\"></a>A3.9.1 Introduction to caches</h5><p>A cache is a block of high-speed memory that contains a number of entries, each consisting of:<br>• main memory address information, commonly called a tag<br>• the associated data</p>\n<h5 id=\"A3-9-2-Memory-hierarchy\"><a href=\"#A3-9-2-Memory-hierarchy\" class=\"headerlink\" title=\"A3.9.2 Memory hierarchy\"></a>A3.9.2 Memory hierarchy</h5><p>Memory close to a processor has very low latency, but is limited in size and expensive to implement.To optimize overall<br>performance, an ARMv7 memory system can include multiple levels of cache in a hierarchical memory system. </p>\n<p>Fixme[Figure A3-6 Multiple levels of cache in a memory hierarchy] page 157</p>\n<h5 id=\"A3-9-4-Preloading-caches\"><a href=\"#A3-9-4-Preloading-caches\" class=\"headerlink\" title=\"A3.9.4 Preloading caches\"></a>A3.9.4 Preloading caches</h5><p>The ARM architecture provides memory system hints PLD (Preload Data), PLDW (Preload Data with intent to write),<br>and PLI (Preload Instruction) to permit software to communicate the expected use of memory locations to the<br>hardware. </p>\n<h3 id=\"A4-The-Instruction-Sets\"><a href=\"#A4-The-Instruction-Sets\" class=\"headerlink\" title=\"A4. The Instruction Sets\"></a>A4. The Instruction Sets</h3><h4 id=\"A4-1-About-the-instruction-sets\"><a href=\"#A4-1-About-the-instruction-sets\" class=\"headerlink\" title=\"A4.1 About the instruction sets\"></a>A4.1 About the instruction sets</h4><p>ARMv7 contains two main instruction sets, the ARM and Thumb instruction sets. </p>\n<p>The ARM and Thumb instruction sets can interwork freely, that is, different procedures can be compiled or assembled to different instruction sets, and still be able to call each other efficiently.</p>\n<p><strong>ThumbEE</strong> is a variant of the Thumb instruction set that is designed as a target for <strong>dynamically generated code.</strong><br>However, it cannot interwork freely with the ARM and Thumb instruction sets.</p>\n<p>The two instruction sets differ in how instructions are encoded:<br>• Thumb instructions are either 16-bit or 32-bit, and are aligned on <strong>a two-byte boundary</strong>. 16-bit and 32-bit<br>instructions can be intermixed freely. Many common operations are most efficiently executed using 16-bit<br>instructions. However:<br>    — Most 16-bit instructions can only access the first eight of the ARM core registers, R0-R7. These are<br>    called the low registers. A small number of 16-bit instructions can also access the high registers,<br>    R8-R15.<br>    — Many operations that would require two or more 16-bit instructions can be more efficiently executed<br>    with a single 32-bit instruction.<br>    — All 32-bit instructions can access all of the ARM core registers, R0-R15.</p>\n<p>• ARM instructions are always 32-bit, and are aligned on a four-byte boundary</p>\n<h5 id=\"A4-1-1-Changing-between-Thumb-state-and-ARM-state\"><a href=\"#A4-1-1-Changing-between-Thumb-state-and-ARM-state\" class=\"headerlink\" title=\"A4.1.1 Changing between Thumb state and ARM state\"></a>A4.1.1 Changing between Thumb state and ARM state</h5><h6 id=\"Thumb-to-ARM-state\"><a href=\"#Thumb-to-ARM-state\" class=\"headerlink\" title=\"Thumb to ARM state\"></a>Thumb to ARM state</h6><p>A processor in Thumb state can enter ARM state by executing any of the following instructions: <strong>BX, BLX, or an LDR or LDM that loads the PC.</strong></p>\n<h6 id=\"ARM-to-Thumb-state\"><a href=\"#ARM-to-Thumb-state\" class=\"headerlink\" title=\"ARM to Thumb state\"></a>ARM to Thumb state</h6><p>A processor in ARM state can enter Thumb state by executing any of the same instructions.</p>\n<p>In ARMv7, a processor in ARM state can also enter Thumb state by executing an ADC, ADD, AND, ASR, BIC, EOR, LSL,<br>LSR, MOV, MVN, ORR, ROR, RRX, RSB, RSC, SBC, or SUB instruction that <strong>has the PC as destination register and does not set the condition flags.</strong></p>\n<h6 id=\"others\"><a href=\"#others\" class=\"headerlink\" title=\"others\"></a>others</h6><p>The target instruction set is either encoded directly in the instruction (for the immediate offset version of BLX), or is<br>held as bit[0] of an interworking address. For details, see the description of the BXWritePC() function in Pseudocode<br>details of operations on ARM core registers on page A2-47.<br>bit[0]    1 thumb      thumb is 2 bytes boundary but ARM some support Jazella extension<br>bit[1:0] 00 arm        arm is 4 bytes boundary<br>bit[1:0] 10 unknown</p>\n<p>Exception entries and returns can also change between ARM and Thumb states. For details see Exception handling<br>on page B1-1165.</p>\n<h5 id=\"A4-1-2-Conditional-execution\"><a href=\"#A4-1-2-Conditional-execution\" class=\"headerlink\" title=\"A4.1.2 Conditional execution\"></a>A4.1.2 Conditional execution</h5><p>In the ARM and Thumb instruction sets, most instructions can be conditionally executed</p>\n<p>In the ARM instruction set,  has its normal effect on the programmers’ model operation, memory and coprocessors if the N, Z, C and V condition flags in the APSR satisfy.</p>\n<p>If the flags do not satisfy this condition, the instruction acts as a NOP.</p>\n<p>In the Thumb instruction set, different mechanisms control conditional execution:<br>• For the following Thumb encodings, conditional execution is controlled in a similar way to the ARM<br>instructions:<br>    — A 16-bit conditional branch instruction encoding, with a branch range of –256 to +254 bytes. Before<br>    ARMv6T2, this was the only mechanism for conditional execution in Thumb code.<br>    — A 32-bit conditional branch instruction encoding, with a branch range of approximately ±1MB.</p>\n<p>• The CBZ and CBNZ instructions, Compare and Branch on Zero and Compare and Branch on Nonzero, are 16-bit<br>conditional instructions with a branch range of +4 to +130 bytes.    </p>\n<p>• The 16-bit If-Then instruction makes up to four following instructions conditional, and can make most other<br>Thumb instructions conditional. For details see IT on page A8-390. </p>\n<h4 id=\"A4-3-Branch-instructions\"><a href=\"#A4-3-Branch-instructions\" class=\"headerlink\" title=\"A4.3 Branch instructions\"></a>A4.3 Branch instructions</h4><p>Fixme [Table A4-1 Branch instructions] Page164</p>\n<h4 id=\"A4-4-Data-processing-instructions\"><a href=\"#A4-4-Data-processing-instructions\" class=\"headerlink\" title=\"A4.4 Data-processing instructions\"></a>A4.4 Data-processing instructions</h4><h5 id=\"A4-4-1-Standard-data-processing-instructions\"><a href=\"#A4-4-1-Standard-data-processing-instructions\" class=\"headerlink\" title=\"A4.4.1 Standard data-processing instructions\"></a>A4.4.1 Standard data-processing instructions</h5><p>Fixme [Table A4-2 Standard data-processing instructions] Page166</p>\n<h5 id=\"A4-4-2-Shift-instructions\"><a href=\"#A4-4-2-Shift-instructions\" class=\"headerlink\" title=\"A4.4.2 Shift instructions\"></a>A4.4.2 Shift instructions</h5><p>Fixme [Table A4-3 Shift instructions] Page167</p>\n<h5 id=\"A4-4-3-Multiply-instructions\"><a href=\"#A4-4-3-Multiply-instructions\" class=\"headerlink\" title=\"A4.4.3 Multiply instructions\"></a>A4.4.3 Multiply instructions</h5><p>These instructions can operate on signed or unsigned quantities. In some types of operation, the results are same<br>whether the operands are signed or unsigned.</p>\n<p>Fixme [Table A4-4 General multiply instructions] Page167</p>\n<p>Fixme [Table A4-5 Signed multiply instructions] Page168</p>\n<p>Fixme [Table A4-6 Unsigned multiply instructions] Page168</p>\n<h5 id=\"A4-4-4-Saturating-instructions\"><a href=\"#A4-4-4-Saturating-instructions\" class=\"headerlink\" title=\"A4.4.4 Saturating instructions\"></a>A4.4.4 Saturating instructions</h5><p>饱和指令： 将超出unsigned, signed 的值限制到本身支持的最大值或最小值</p>\n<h5 id=\"A4-4-5-Saturating-addition-and-subtraction-instructions\"><a href=\"#A4-4-5-Saturating-addition-and-subtraction-instructions\" class=\"headerlink\" title=\"A4.4.5 Saturating addition and subtraction instructions\"></a>A4.4.5 Saturating addition and subtraction instructions</h5><h5 id=\"A4-4-6-Packing-and-unpacking-instructions\"><a href=\"#A4-4-6-Packing-and-unpacking-instructions\" class=\"headerlink\" title=\"A4.4.6 Packing and unpacking instructions\"></a>A4.4.6 Packing and unpacking instructions</h5><p>扩展指令： 将[半]字节扩展到[有/无]32位</p>\n<h5 id=\"A4-4-7-Parallel-addition-and-subtraction-instructions\"><a href=\"#A4-4-7-Parallel-addition-and-subtraction-instructions\" class=\"headerlink\" title=\"A4.4.7 Parallel addition and subtraction instructions\"></a>A4.4.7 Parallel addition and subtraction instructions</h5><p>These instructions perform additions and subtractions on the values of two registers and write the result to a<br>destination register, treating the register values as sets of two halfwords or four bytes. That is, they perform SIMD<br>additions or subtractions on the registers. </p>\n<h5 id=\"A4-4-8-Divide-instructions\"><a href=\"#A4-4-8-Divide-instructions\" class=\"headerlink\" title=\"A4.4.8 Divide instructions\"></a>A4.4.8 Divide instructions</h5><p>For descriptions of the instructions see:<br>• SDIV on page A8-600<br>• UDIV on page A8-760</p>\n<p>In the ARMv7-R profile, the SCTLR.DZ bit enables divide by zero fault detection:<br>SCTLR.DZ == 0 Divide-by-zero returns a zero result.<br>SCTLR.DZ == 1 SDIV and UDIV generate an Undefined Instruction exception on a divide-by-zero.<br>The SCTLR.DZ bit is cleared to zero on reset</p>\n<h5 id=\"A4-4-9-Miscellaneous-data-processing-instructions\"><a href=\"#A4-4-9-Miscellaneous-data-processing-instructions\" class=\"headerlink\" title=\"A4.4.9 Miscellaneous data-processing instructions\"></a>A4.4.9 Miscellaneous data-processing instructions</h5><p>Fixme [Table A4-11 Miscellaneous data-processing instructions] page173</p>\n<h4 id=\"A4-5-Status-register-access-instructions\"><a href=\"#A4-5-Status-register-access-instructions\" class=\"headerlink\" title=\"A4.5 Status register access instructions\"></a>A4.5 Status register access instructions</h4><p>The MRS and MSR instructions move the contents of the Application Program Status Register (APSR) to or from an<br>ARM core register, see:<br>• MRS on page A8-496<br>• MSR (immediate) on page A8-498<br>• MSR (register) on page A8-500.</p>\n<p>At system level, software can also:<br>• use these instructions to access the SPSR of the current mode<br>• use the CPS instruction to change the CPSR.M field and the CPSR.{A, I, F} interrupt mask bits.</p>\n<h4 id=\"A4-6-Load-store-instructions\"><a href=\"#A4-6-Load-store-instructions\" class=\"headerlink\" title=\"A4.6 Load/store instructions\"></a>A4.6 Load/store instructions</h4><p>Fixme [Table A4-12 Load/store instructions] Page175</p>\n<h4 id=\"A4-7-Load-store-multiple-instructions\"><a href=\"#A4-7-Load-store-multiple-instructions\" class=\"headerlink\" title=\"A4.7 Load/store multiple instructions\"></a>A4.7 Load/store multiple instructions</h4><p>Load Multiple instructions load a subset, or possibly all, of the ARM core registers from memory.<br>Store Multiple instructions store a subset, or possibly all, of the ARM core registers to memory.</p>\n<p>Fixme [Table A4-13 Load/store multiple instructions] Page177</p>\n<h4 id=\"A4-8-Miscellaneous-instructions\"><a href=\"#A4-8-Miscellaneous-instructions\" class=\"headerlink\" title=\"A4.8 Miscellaneous instructions\"></a>A4.8 Miscellaneous instructions</h4><p>Fixme [Table A4-14 Miscellaneous instructions] Page178</p>\n<h4 id=\"A4-9-Exception-generating-and-exception-handling-instructions\"><a href=\"#A4-9-Exception-generating-and-exception-handling-instructions\" class=\"headerlink\" title=\"A4.9 Exception-generating and exception-handling instructions\"></a>A4.9 Exception-generating and exception-handling instructions</h4><p>The following instructions are intended specifically to cause a synchronous processor exception to occur:<br>• The SVC instruction generates a Supervisor Call exception. For more information, see Supervisor Call (SVC)<br>exception on page B1-1210.<br>• The Breakpoint instruction BKPT provides software breakpoints. For more information, see About debug<br>events on page C3-2038.<br>• In a processor that implements the Security Extensions, when executing at PL1 or higher, the SMC instruction<br>generates a Secure Monitor Call exception. For more information, see Secure Monitor Call (SMC) exception<br>on page B1-1211.<br>• In a processor that implements the Virtualization Extensions, in software executing in a Non-secure PL1<br>mode, the HVC instruction generates a Hypervisor Call exception. For more information, see Hypervisor Call<br>(HVC) exception on page B1-1212.</p>\n<p>Fixme [Table A4-15 Exception-generating and exception-handling instructions] Page179</p>\n<h4 id=\"A4-10-Coprocessor-instructions\"><a href=\"#A4-10-Coprocessor-instructions\" class=\"headerlink\" title=\"A4.10 Coprocessor instructions\"></a>A4.10 Coprocessor instructions</h4><p>There are three types of instruction for communicating with coprocessors. These permit the processor to:<br>• Initiate a coprocessor data-processing operation. For details see CDP, CDP2 on page A8-358.<br>• Transfer ARM core registers to and from coprocessor registers. For details, see:<br>    — MCR, MCR2 on page A8-476<br>    — MCRR, MCRR2 on page A8-478<br>    — MRC, MRC2 on page A8-492<br>    — MRRC, MRRC2 on page A8-494.<br>• Load or store the values of coprocessor registers. For details, see:<br>    — LDC, LDC2 (immediate) on page A8-392<br>    — LDC, LDC2 (literal) on page A8-394<br>    — STC, STC2 on page A8-662.</p>\n<h4 id=\"A4-11-Advanced-SIMD-and-Floating-point-load-store-instructions\"><a href=\"#A4-11-Advanced-SIMD-and-Floating-point-load-store-instructions\" class=\"headerlink\" title=\"A4.11 Advanced SIMD and Floating-point load/store instructions\"></a>A4.11 Advanced SIMD and Floating-point load/store instructions</h4><p>Fixme [Table A4-16 Extension register load/store instructions] Page181<br>Fixme [Table A4-17 Element and structure load/store instructions] Page181</p>\n<h4 id=\"A4-12-Advanced-SIMD-and-Floating-point-register-transfer-instructions\"><a href=\"#A4-12-Advanced-SIMD-and-Floating-point-register-transfer-instructions\" class=\"headerlink\" title=\"A4.12 Advanced SIMD and Floating-point register transfer instructions\"></a>A4.12 Advanced SIMD and Floating-point register transfer instructions</h4><p>Fixme [Table A4-18 Extension register transfer instructions] Page183</p>\n<h4 id=\"A4-13-Advanced-SIMD-data-processing-instructions\"><a href=\"#A4-13-Advanced-SIMD-data-processing-instructions\" class=\"headerlink\" title=\"A4.13 Advanced SIMD data-processing instructions\"></a>A4.13 Advanced SIMD data-processing instructions</h4><p>Advanced SIMD data-processing instructions process registers containing vectors of elements of the same type<br>packed together, enabling the same operation to be performed on multiple items in parallel.</p>\n<p>Fixme [Figure A4-2 Advanced SIMD instruction operating on 64-bit registers] Page184</p>\n<h5 id=\"A4-13-1-Advanced-SIMD-parallel-addition-and-subtraction\"><a href=\"#A4-13-1-Advanced-SIMD-parallel-addition-and-subtraction\" class=\"headerlink\" title=\"A4.13.1 Advanced SIMD parallel addition and subtraction\"></a>A4.13.1 Advanced SIMD parallel addition and subtraction</h5><p>Fixme [Table A4-19 Advanced SIMD parallel add and subtract instructions] Page185</p>\n<h5 id=\"A4-13-2-Bitwise-Advanced-SIMD-data-processing-instructions\"><a href=\"#A4-13-2-Bitwise-Advanced-SIMD-data-processing-instructions\" class=\"headerlink\" title=\"A4.13.2 Bitwise Advanced SIMD data-processing instructions\"></a>A4.13.2 Bitwise Advanced SIMD data-processing instructions</h5><p>Fixme [Table A4-20 Bitwise Advanced SIMD data-processing instructions] Page186</p>\n<h5 id=\"A4-13-3-Advanced-SIMD-comparison-instructions\"><a href=\"#A4-13-3-Advanced-SIMD-comparison-instructions\" class=\"headerlink\" title=\"A4.13.3 Advanced SIMD comparison instructions\"></a>A4.13.3 Advanced SIMD comparison instructions</h5><p>Fixme [Table A4-21 Advanced SIMD comparison instructions] Page186</p>\n<h5 id=\"A4-13-4-Advanced-SIMD-shift-instructions\"><a href=\"#A4-13-4-Advanced-SIMD-shift-instructions\" class=\"headerlink\" title=\"A4.13.4 Advanced SIMD shift instructions\"></a>A4.13.4 Advanced SIMD shift instructions</h5><p>Fixme [Table A4-22 Advanced SIMD shift instructions] Page187</p>\n<h5 id=\"A4-13-5-Advanced-SIMD-multiply-instructions\"><a href=\"#A4-13-5-Advanced-SIMD-multiply-instructions\" class=\"headerlink\" title=\"A4.13.5 Advanced SIMD multiply instructions\"></a>A4.13.5 Advanced SIMD multiply instructions</h5><p>Fixme [Table A4-23 Advanced SIMD multiply instructions] Page188</p>\n<h5 id=\"A4-13-6-Miscellaneous-Advanced-SIMD-data-processing-instructions\"><a href=\"#A4-13-6-Miscellaneous-Advanced-SIMD-data-processing-instructions\" class=\"headerlink\" title=\"A4.13.6 Miscellaneous Advanced SIMD data-processing instructions\"></a>A4.13.6 Miscellaneous Advanced SIMD data-processing instructions</h5><p>Fixme [Table A4-24 Miscellaneous Advanced SIMD data-processing instructions] Page189</p>\n<h4 id=\"A4-14-Floating-point-data-processing-instruction\"><a href=\"#A4-14-Floating-point-data-processing-instruction\" class=\"headerlink\" title=\"A4.14 Floating-point data-processing instruction\"></a>A4.14 Floating-point data-processing instruction</h4><p>Fixme [Table A4-25 Floating-point data-processing instructions] Page191</p>\n<h3 id=\"A5-ARM-Instruction-Set-Encoding\"><a href=\"#A5-ARM-Instruction-Set-Encoding\" class=\"headerlink\" title=\"A5. ARM Instruction Set Encoding\"></a>A5. ARM Instruction Set Encoding</h3><h4 id=\"A5-1-ARM-instruction-set-encoding\"><a href=\"#A5-1-ARM-instruction-set-encoding\" class=\"headerlink\" title=\"A5.1 ARM instruction set encoding\"></a>A5.1 ARM instruction set encoding</h4><p><strong>The ARM instruction stream is a sequence of word-aligned words. Each ARM instruction is a single 32-bit word</strong> in<br>that stream. The encoding of an ARM instruction is:</p>\n<p>Fixme [32 bits instruction structure] page194</p>\n<p>Fixme [Table A5-1 ARM instruction encoding] page194</p>\n<h5 id=\"A5-1-1-The-condition-code-field\"><a href=\"#A5-1-1-The-condition-code-field\" class=\"headerlink\" title=\"A5.1.1 The condition code field\"></a>A5.1.1 The condition code field</h5><p>This field contains one of the values 0b0000-0b1110, as shown in Table A8-1 on page A8-288.<br>Fixme [Table A8-1 Condition codes]page288</p>\n<h4 id=\"A5-2-Data-processing-and-miscellaneous-instructions\"><a href=\"#A5-2-Data-processing-and-miscellaneous-instructions\" class=\"headerlink\" title=\"A5.2 Data-processing and miscellaneous instructions\"></a>A5.2 Data-processing and miscellaneous instructions</h4><p>Fixme [data process instructions structure]page196</p>\n<p>Fixme [Table A5-2 Data-processing and miscellaneous instructions]page196</p>\n<p>其余指令可参照此命令，只是op 的不同。</p>\n<h3 id=\"A6-Thumb-Instruction-Set-Encoding\"><a href=\"#A6-Thumb-Instruction-Set-Encoding\" class=\"headerlink\" title=\"A6. Thumb Instruction Set Encoding\"></a>A6. Thumb Instruction Set Encoding</h3><h4 id=\"A6-1-Thumb-instruction-set-encoding\"><a href=\"#A6-1-Thumb-instruction-set-encoding\" class=\"headerlink\" title=\"A6.1 Thumb instruction set encoding\"></a>A6.1 Thumb instruction set encoding</h4><p>The Thumb instruction stream is a sequence of halfword-aligned halfwords. Each Thumb instruction is either a<br>single 16-bit halfword in that stream, or a 32-bit instruction consisting of two consecutive halfwords in that stream.<br>If the value of bits[15:11] of the halfword being decoded is one of the following, the halfword is the first halfword<br>of a 32-bit instruction:<br>• 0b11101<br>• 0b11110<br>• 0b11111.<br>Otherwise, the halfword is a 16-bit instruction</p>\n<p>疑问点：thumb 是16bit 或32bit对齐，那怎么与32 bit的ARM 指令集怎么区分？<br>当ARM 处于ARM state，CPU 将会按照32 bit ARM指令集去取指并执行，反之使用16、32bit 的thumb 指令集解析。</p>\n<h4 id=\"A6-2-16-bit-Thumb-instruction-encoding\"><a href=\"#A6-2-16-bit-Thumb-instruction-encoding\" class=\"headerlink\" title=\"A6.2 16-bit Thumb instruction encoding\"></a>A6.2 16-bit Thumb instruction encoding</h4><p>Fixme [16-bit thumb instruction encoding]page223</p>\n<p>Fixme [Table A6-1 16-bit Thumb instruction encoding]page223</p>\n<h4 id=\"A6-3-32-bit-Thumb-instruction-encoding\"><a href=\"#A6-3-32-bit-Thumb-instruction-encoding\" class=\"headerlink\" title=\"A6.3 32-bit Thumb instruction encoding\"></a>A6.3 32-bit Thumb instruction encoding</h4><p>Fixme [ 32-bit Thumb instruction encoding]page230</p>\n<p>Fixme [Table A6-9 32-bit Thumb instruction encoding]page230</p>\n<h3 id=\"A7-Advanced-SIMD-and-Floating-point-Instruction-Encoding\"><a href=\"#A7-Advanced-SIMD-and-Floating-point-Instruction-Encoding\" class=\"headerlink\" title=\"A7 Advanced SIMD and Floating-point Instruction Encoding\"></a>A7 Advanced SIMD and Floating-point Instruction Encoding</h3><p>skip</p>\n<h3 id=\"A9-The-ThumbEE-Instruction-Set\"><a href=\"#A9-The-ThumbEE-Instruction-Set\" class=\"headerlink\" title=\"A9 The ThumbEE Instruction Set\"></a>A9 The ThumbEE Instruction Set</h3><h4 id=\"A9-1-About-the-ThumbEE-instruction-set\"><a href=\"#A9-1-About-the-ThumbEE-instruction-set\" class=\"headerlink\" title=\"A9.1 About the ThumbEE instruction set\"></a>A9.1 About the ThumbEE instruction set</h4><p>In general, <strong>instructions in ThumbEE are identical to Thumb instructions</strong>, with the following exceptions:<br>• A small number of instructions are affected by modifications to transitions from ThumbEE state. For more<br>information, see ThumbEE state transitions.</p>\n<p>• <strong>A substantial number of instructions have a null check on the base register before any other operation takes</strong><br>place, but are identical (or almost identical) in all other respects. For more information, see Null checking on<br>page A9-1113.</p>\n<p>• A small number of instructions are modified in additional ways. See Instructions with modifications on<br>page A9-1113.</p>\n<p>• Three Thumb instructions, BLX (immediate), 16-bit LDM, and 16-bit STM, are removed in ThumbEE state.<br>The encoding corresponding to BLX (immediate) in Thumb is UNDEFINED in ThumbEE state.<br>16-bit LDM and STM are replaced by new instructions, for details see Additional ThumbEE instructions on<br>page A9-1123.</p>\n<p>• Two new 32-bit instructions, ENTERX and LEAVEX, are introduced in both the Thumb instruction set and the<br>ThumbEE instruction set. See Additional instructions in Thumb and ThumbEE instruction sets on<br>page A9-1116. These instructions use previously UNDEFINED encodings.</p>\n<p><strong>Attempting to execute ThumbEE instructions at PL2 is UNPREDICTABLE.</strong></p>\n<h5 id=\"A9-1-1-ThumbEE-state-transitions\"><a href=\"#A9-1-1-ThumbEE-state-transitions\" class=\"headerlink\" title=\"A9.1.1 ThumbEE state transitions\"></a>A9.1.1 ThumbEE state transitions</h5><p>Instruction set state transitions to ThumbEE state can occur implicitly as part of a return from exception, or<br>explicitly on execution of an <strong>ENTERX instruction.</strong></p>\n<p>Instruction set state transitions from ThumbEE state can only occur due to an exception, or due to a transition to<br>Thumb state using the <strong>LEAVEX instruction.</strong> Return from exception instructions (RFE and SUBS PC, LR, #imm) are<br>UNPREDICTABLE in ThumbEE state.</p>\n<h5 id=\"A9-1-2-Null-checking\"><a href=\"#A9-1-2-Null-checking\" class=\"headerlink\" title=\"A9.1.2 Null checking\"></a>A9.1.2 Null checking</h5><p>A null check is performed for all load/store instructions when they are executed in ThumbEE state. If the value in<br>the base register is zero, execution branches to the NullCheck handler at HandlerBase – 4.</p>\n<h4 id=\"A9-2-ThumbEE-instruction-set-encoding\"><a href=\"#A9-2-ThumbEE-instruction-set-encoding\" class=\"headerlink\" title=\"A9.2 ThumbEE instruction set encoding\"></a>A9.2 ThumbEE instruction set encoding</h4><p>In general, instructions in the ThumbEE instruction set are encoded in exactly the same way as Thumb instructions<br>described in Chapter A6 Thumb Instruction Set Encoding. The differences are as follows:<br>• There are no 16-bit LDM or STM instructions in the ThumbEE instruction set.<br>• The 16-bit encodings used for LDM and STM in the Thumb instruction set are used for different 16-bit<br>instructions in the ThumbEE instruction set. For details, see 16-bit ThumbEE instructions.<br>• There are two new 32-bit instructions in both Thumb state and ThumbEE state. For details, see Additional<br>instructions in Thumb and ThumbEE instruction sets on page A9-1116.</p>\n<h5 id=\"A9-2-1-16-bit-ThumbEE-instructions\"><a href=\"#A9-2-1-16-bit-ThumbEE-instructions\" class=\"headerlink\" title=\"A9.2.1 16-bit ThumbEE instructions\"></a>A9.2.1 16-bit ThumbEE instructions</h5><p>Fixme [Table A9-2 16-bit ThumbEE instructions]page1115</p>\n<h4 id=\"A9-3-Additional-instructions-in-Thumb-and-ThumbEE-instruction-sets\"><a href=\"#A9-3-Additional-instructions-in-Thumb-and-ThumbEE-instruction-sets\" class=\"headerlink\" title=\"A9.3 Additional instructions in Thumb and ThumbEE instruction sets\"></a>A9.3 Additional instructions in Thumb and ThumbEE instruction sets</h4><p>On a processor with the ThumbEE Extension, there are two additional 32-bit instructions, ENTERX and LEAVEX. These<br>are available in both Thumb state and ThumbEE state.</p>\n<h5 id=\"A9-3-1-ENTERX-LEAVEX\"><a href=\"#A9-3-1-ENTERX-LEAVEX\" class=\"headerlink\" title=\"A9.3.1 ENTERX, LEAVEX\"></a>A9.3.1 ENTERX, LEAVEX</h5><p>ENTERX causes a change from Thumb state to ThumbEE state, or has no effect in ThumbEE state.<br>ENTERX is UNDEFINED in Hyp mode.<br>LEAVEX causes a change from ThumbEE state to Thumb state, or has no effect in Thumb state.</p>\n<h3 id=\"A8-Instruction-Descriptions\"><a href=\"#A8-Instruction-Descriptions\" class=\"headerlink\" title=\"A8 Instruction Descriptions\"></a>A8 Instruction Descriptions</h3><h4 id=\"A8-2-Standard-assembler-syntax-fields\"><a href=\"#A8-2-Standard-assembler-syntax-fields\" class=\"headerlink\" title=\"A8.2 Standard assembler syntax fields\"></a>A8.2 Standard assembler syntax fields</h4><p>The following assembler syntax fields are standard across all or most instructions:</p>\n<p><c> Is an optional field. It specifies the condition under which the instruction is executed. See<br>    Conditional execution on page A8-288 for the range of available conditions and their encoding. If<br>    <c> is omitted, it defaults to always (AL).</c></c></p>\n<p><q> Specifies optional assembler qualifiers on the instruction. The following qualifiers are defined:<br>    .N Meaning narrow, specifies that the assembler must select a 16-bit encoding for the<br>    instruction. If this is not possible, an assembler error is produced.<br>    .W Meaning wide, specifies that the assembler must select a 32-bit encoding for the<br>    instruction. If this is not possible, an assembler error is produced.</q></p>\n<h4 id=\"A8-3-Conditional-execution\"><a href=\"#A8-3-Conditional-execution\" class=\"headerlink\" title=\"A8.3 Conditional execution\"></a>A8.3 Conditional execution</h4><p>Most ARM instructions, and most Thumb instructions from ARMv6T2 onwards, can be executed conditionally,<br>based on the values of the APSR condition flags.</p>\n<p>Fixme [Table A8-1 Condition codes]page288</p>"},{"title":"bootloader","date":"2018-08-25T15:48:53.000Z","_content":"\n## 1. BootLoader\n\n>The computer first executes a relatively small program stored in read-only memory (ROM) along with a small amount of needed data, to access the nonvolatile device or devices from which the operating system programs and data can be loaded into RAM.\n\n[bootloader -- wiki](https://en.wikipedia.org/wiki/Booting#BOOT-LOADER)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootloader.jpg)\n\n<!--more-->\n\n## 2. U-Boot\n\n[Das U-Boot](https://en.wikipedia.org/wiki/Das_U-Boot) -- the Universal Boot Loader\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=3f0275e9828ba61edfeecf29793497cc/a5c27d1ed21b0ef495e2eb7dddc451da81cb3e8e.jpg)\n\n其官网地址为：http://www.denx.de/wiki/U-Boot/WebHome\n\n官网也很贴心的有[指导手册](http://www.denx.de/wiki/DULG/Manual)\n\n>U-Boot是遵循GPL条款的开放源码项目。其源码目录、编译形式与Linux内核很相似，事实上，不少U-Boot源码就是根据相应的Linux内核源程序进行简化而形成的，尤其是一些设备的驱动程序，这从U-Boot源码的注释中能体现这一点。U-Boot不仅仅支持嵌入式Linux系统的引导，它还支持NetBS\nD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android嵌入式操作系统。它还具有丰富的驱动代码及文件系统支持。（UART、Ethernet、SDRAM、Flash，RTC，ext[2|3|4]、FAT，JFFS2、Squashfs、Cramfs、UBIFS等）\n\n[U-Boot GitHub](https://github.com/u-boot/u-boot)\n\nU-Boot的主要作用是：\n- 初始化硬件\n- 建立内存空间映射\n\n### 2.1. Bootup Stages\nBootLoader的启动过程可以使单阶段(single stage)与多阶段(multi-stage)\n一般选择多阶段启动提供更复杂的功能，以及更好的可移植性。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/Bootup%20Stages.jpg)\n\n### 2.1.1. Stage1\n常用汇编代码编写此段代码。例如`u-boot/arch/arm/xxx/start.S`。\nStage1 的主要作用：\n- 设定异常向量(exception vector)\n- 初始化硬件（CPU速度，时钟频率，关中断，Disable I/D Cache，u-boot毕竟很简单）\n- 初始化内存控制器\n- 拷贝Rom或者Flash 等上的程序到Ram中（u-boot运行代码）\n- 初始化堆栈\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_flow_1.jpg)\n\n### 2.1.2. Stage2\n主要是C语言代码，ARM体系一般是在lib_arm/board.c中start_armboot()。Stage2 主要完成：\n- 该阶段使用到的外围硬件初始化（Flash、SD、Ethernet等）\n- 检测RAM 映射\n- 拷贝Kernel 镜像至RAM 中的加载地址\n- 设定启动参数\n- 启动OS\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_flow_2.jpg)\n\n### 2.2. U-Boot Directory\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/directory.jpg)\n\n| 目录 | 特性 | 备注 |\n| :- | :- | :- |\n| board | 平台依赖 | 目标板文件。Flash，Ram等驱动 |\n| cpu | 平台依赖 | 与处理器相关 |\n| lib_arm | 平台依赖 | 处理器体系相关 |\n| post | 通用 | 上电自检文件目录 |\n| fs | 通用 | 文件系统fat，jffs2,nfs,ubifs,ext[2-4]等 |\n| driver | 通用 | 通用设备驱动 |\n| net | 通用 | 网络 |\n| common | 通用 | 内存检测，Nand等常用命令 |\n\n\n\n### 2.3. U-Boot Memory Map\nU-Boot 的内存主要分布图如下图：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/uboot_mem_map.jpg)\n\n\n### 2.4. U-Boot Parameters\n\n| 名称 | 默认值 | 备注 |\n| :- | :- | :- |\n| bootargs | noinitrd root=/dev/mtdblock4 init=/linuxrc console=ttySAC0,115200 | U-Boot 在启动内核之前的等待时间，单位：秒 |\n| bootdelay | 1 | 与处理器相关 |\n| ethaddr | 00:40:5C:26:0A:5B | 网卡的MAC 地址 |\n| ipaddr | 172.20.223.235 | U-Boot 使用的IP 地址 |\n| loadaddr | 0x40000000 | 下载二进制文件时的默认地址 |\n| bootcmd | nand read C0008000 600000 500000; bootm C0008000 | 当使用boot 命令启动系统时所执行的脚本 |\n\n**Parameters Store**\n\ngloba data的RAM地址一般是存放在ARM 的`R8` 通用寄存器中。定义见`include/asm-generial/global_data.h`。\n\n注：**具体的位置可能因为U-Boot 代码的维护更新在变动，具体请参考实际的GitHub 版本**\n\n```c\n#define DECLARE_GLOBAL_DATA_PTR register volatile gd_t*d asm(\"r8\")\n\ngd = (gd_t *)(_armboot_start - CONFIG_SYS_MALLOC_LEN - sizeof(gd_t));\n\ngd->bd = (bd_t *)((char*)gd - sizeof(btd_t));\n```\n\n```c\ntypedef struct global_data {\n\tbd_t *bd;\n\tunsigned long flags;\n\tunsigned int baudrate;\n\tunsigned long cpu_clk;\t\t/* CPU clock in Hz!\t\t*/\n\tunsigned long bus_clk;\n\tunsigned long pci_clk;\n\tunsigned long mem_clk;\n\n#ifdef CONFIG_BOARD_TYPES\n\tunsigned long board_type;\n#endif\n\tunsigned long env_addr;\t\t/* Address  of Environment struct */\n\n\tunsigned long ram_base;\t\t/* Base address of RAM used by U-Boot */\n\tunsigned long ram_top;\t\t/* Top address of RAM used by U-Boot */\n\tunsigned long relocaddr;\t/* Start address of U-Boot in RAM */\n\tphys_size_t ram_size;\t\t/* RAM size */\n\tunsigned long irq_sp;\t\t/* irq stack pointer */\n\tunsigned long start_addr_sp;\t/* start_addr_stackpointer */\n\tunsigned long reloc_off;\n\tstruct global_data *new_gd;\t/* relocated global data */\n\n\tchar env_buf[32];\t\t/* buffer for env_get() before reloc. */\n\n#if CONFIG_VAL(SYS_MALLOC_F_LEN)\n\tunsigned long malloc_base;\t/* base address of early malloc() */\n\tunsigned long malloc_limit;\t/* limit address */\n\tunsigned long malloc_ptr;\t/* current address */\n#endif\n\n    ... ...\n#ifdef CONFIG_BOOTSTAGE\n\tstruct bootstage_data *bootstage;\t/* Bootstage information */\n\tstruct bootstage_data *new_bootstage;\t/* Relocated bootstage info */\n#endif\n} gd_t;\n```\n\nbd_t 保存于板子相关的配置参数。具体可见`include/asm-generial/u-boot.h`。\n\n```c\ntypedef struct bd_info {\n\tunsigned long\tbi_memstart;\t/* start of DRAM memory */\n\tphys_size_t\tbi_memsize;\t/* size\t of DRAM memory in bytes */\n\tunsigned long\tbi_flashstart;\t/* start of FLASH memory */\n\tunsigned long\tbi_flashsize;\t/* size\t of FLASH memory */\n\tunsigned long\tbi_flashoffset; /* reserved area for startup monitor */\n\tunsigned long\tbi_sramstart;\t/* start of SRAM memory */\n\tunsigned long\tbi_sramsize;\t/* size\t of SRAM memory */\n#ifdef CONFIG_ARM\n\tunsigned long\tbi_arm_freq; /* arm frequency */\n\tunsigned long\tbi_dsp_freq; /* dsp core frequency */\n\tunsigned long\tbi_ddr_freq; /* ddr frequency */\n#endif\n\n\tunsigned long\tbi_bootflags;\t/* boot / reboot flag (Unused) */\n\tunsigned long\tbi_ip_addr;\t/* IP Address */\n\tunsigned char\tbi_enetaddr[6];\t/* OLD: see README.enetaddr */\n\tunsigned short\tbi_ethspeed;\t/* Ethernet speed in Mbps */\n\tunsigned long\tbi_intfreq;\t/* Internal Freq, in MHz */\n\tunsigned long\tbi_busfreq;\t/* Bus Freq, in MHz */\n\n\tulong\t        bi_arch_number;\t/* unique id for this board */\n\tulong\t        bi_boot_params;\t/* where this board expects params */\n\n    ... ...\n#ifdef CONFIG_NR_DRAM_BANKS\n\tstruct {\t\t\t/* RAM configuration */\n\t\tphys_addr_t start;\n\t\tphys_size_t size;\n\t} bi_dram[CONFIG_NR_DRAM_BANKS];\n#endif /* CONFIG_NR_DRAM_BANKS */\n} bd_t;\n```\n\n在启动之后一般使用RAM 临时存放启动参数，在使用`saveenv` 命令后将会将之写到类似于Flash 存储介质上。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_parameters_store.jpg)\n\n**Parameters Structure**\nARM 采用了自己体系定义的参数结构。它的定义可以参见`arch/arm/include/asm/setup.h`。\n\n```c\nstruct tag {\n\tstruct tag_header hdr;\n\tunion {\n\t\tstruct tag_core\t\tcore;\n\t\tstruct tag_mem32\tmem;\n\t\tstruct tag_videotext\tvideotext;\n\t\tstruct tag_ramdisk\tramdisk;\n\t\tstruct tag_initrd\tinitrd;\n\t\tstruct tag_serialnr\tserialnr;\n\t\tstruct tag_revision\trevision;\n\t\tstruct tag_videolfb\tvideolfb;\n\t\tstruct tag_cmdline\tcmdline;\n\n\t\t/*\n\t\t * Acorn specific\n\t\t */\n\t\tstruct tag_acorn\tacorn;\n\n\t\t/*\n\t\t * DC21285 specific\n\t\t */\n\t\tstruct tag_memclk\tmemclk;\n\t} u;\n};\n\n#define tag_next(t)\t((struct tag *)((u32 *)(t) + (t)->hdr.size))\n#define tag_size(type) ((sizeof(struct tag_header) + sizeof(struct type)) >> 2)\n\n/* The list ends with an ATAG_NONE node. */\n#define ATAG_NONE\t0x00000000\n\nstruct tag_header {\n\tu32 size;\n\tu32 tag;\n};\n\n/* The list must start with an ATAG_CORE node */\n#define ATAG_CORE\t0x54410001\n\nstruct tag_core {\n\tu32 flags;\t\t/* bit 0 = read-only */\n\tu32 pagesize;\n\tu32 rootdev;\n};\n\n#define ATAG_MEM\t0x54410002\n#define ATAG_VIDEOTEXT\t0x54410003\n... ...\n```\n\nU-Boot就是将各种启动参数串联成类似下图结构给OS。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_parameters_structure.jpg)\n\n注：**必须以ATAG_CORE, ATAG_NONE开头与结尾，Kernel启动时会依据此检测参数的有效性。**\n\n### 2.5. Bootup OS\n\n以ARM 体系启动Kernel需满足以下几点：\n- R0=0， R1=[机器码], R2=[Kernel启动参数起始地址]\n- Disable I/D Cache\n- Disable IRQ，FIQ\n- CPU in SVC 模式\n\n注：SVC 模式为Supervisor Control 模式，操作系统使用的保护模式，此模式下CPU能访问的数据权限更大，局限小。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os.jpg)\n\n`Setting`\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os_need_setting.jpg)\n\n`Parameters`\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os_parameters.jpg)\n\n## Reference\n[BootLoader -- wiki](https://en.wikipedia.org/wiki/Booting#BOOT-LOADER)\n\n[Das U-Boot -- wiki](https://en.wikipedia.org/wiki/Das_U-Boot)\n\n[U-Boot 百度百科](https://baike.baidu.com/item/U-Boot/10377075)\n\n[The DENX U-Boot and Linux Guide (DULG) for canyonlands](http://www.denx.de/wiki/DULG/Manual)\n\n[u-boot的内存分布和全局数据结构](\nhttps://blog.csdn.net/xiaoaid01/article/details/39700509)\n\n[移植u-boot学习笔记2-----分析启动过程之内存分布](\nhttps://blog.csdn.net/qingkongyeyue/article/details/52423350)\n\n[u-boot 运行时内存的分配](\nhttp://www.360doc.com/content/15/1104/09/6828497_510609834.shtml)\n","source":"_posts/bootloader.md","raw":"---\ntitle: bootloader\ndate: 2018-08-25 23:48:53\ntags:\n    - bootloader\n    - u-boot\ncategories:\n    - bootloader\n---\n\n## 1. BootLoader\n\n>The computer first executes a relatively small program stored in read-only memory (ROM) along with a small amount of needed data, to access the nonvolatile device or devices from which the operating system programs and data can be loaded into RAM.\n\n[bootloader -- wiki](https://en.wikipedia.org/wiki/Booting#BOOT-LOADER)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootloader.jpg)\n\n<!--more-->\n\n## 2. U-Boot\n\n[Das U-Boot](https://en.wikipedia.org/wiki/Das_U-Boot) -- the Universal Boot Loader\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=3f0275e9828ba61edfeecf29793497cc/a5c27d1ed21b0ef495e2eb7dddc451da81cb3e8e.jpg)\n\n其官网地址为：http://www.denx.de/wiki/U-Boot/WebHome\n\n官网也很贴心的有[指导手册](http://www.denx.de/wiki/DULG/Manual)\n\n>U-Boot是遵循GPL条款的开放源码项目。其源码目录、编译形式与Linux内核很相似，事实上，不少U-Boot源码就是根据相应的Linux内核源程序进行简化而形成的，尤其是一些设备的驱动程序，这从U-Boot源码的注释中能体现这一点。U-Boot不仅仅支持嵌入式Linux系统的引导，它还支持NetBS\nD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android嵌入式操作系统。它还具有丰富的驱动代码及文件系统支持。（UART、Ethernet、SDRAM、Flash，RTC，ext[2|3|4]、FAT，JFFS2、Squashfs、Cramfs、UBIFS等）\n\n[U-Boot GitHub](https://github.com/u-boot/u-boot)\n\nU-Boot的主要作用是：\n- 初始化硬件\n- 建立内存空间映射\n\n### 2.1. Bootup Stages\nBootLoader的启动过程可以使单阶段(single stage)与多阶段(multi-stage)\n一般选择多阶段启动提供更复杂的功能，以及更好的可移植性。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/Bootup%20Stages.jpg)\n\n### 2.1.1. Stage1\n常用汇编代码编写此段代码。例如`u-boot/arch/arm/xxx/start.S`。\nStage1 的主要作用：\n- 设定异常向量(exception vector)\n- 初始化硬件（CPU速度，时钟频率，关中断，Disable I/D Cache，u-boot毕竟很简单）\n- 初始化内存控制器\n- 拷贝Rom或者Flash 等上的程序到Ram中（u-boot运行代码）\n- 初始化堆栈\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_flow_1.jpg)\n\n### 2.1.2. Stage2\n主要是C语言代码，ARM体系一般是在lib_arm/board.c中start_armboot()。Stage2 主要完成：\n- 该阶段使用到的外围硬件初始化（Flash、SD、Ethernet等）\n- 检测RAM 映射\n- 拷贝Kernel 镜像至RAM 中的加载地址\n- 设定启动参数\n- 启动OS\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_flow_2.jpg)\n\n### 2.2. U-Boot Directory\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/directory.jpg)\n\n| 目录 | 特性 | 备注 |\n| :- | :- | :- |\n| board | 平台依赖 | 目标板文件。Flash，Ram等驱动 |\n| cpu | 平台依赖 | 与处理器相关 |\n| lib_arm | 平台依赖 | 处理器体系相关 |\n| post | 通用 | 上电自检文件目录 |\n| fs | 通用 | 文件系统fat，jffs2,nfs,ubifs,ext[2-4]等 |\n| driver | 通用 | 通用设备驱动 |\n| net | 通用 | 网络 |\n| common | 通用 | 内存检测，Nand等常用命令 |\n\n\n\n### 2.3. U-Boot Memory Map\nU-Boot 的内存主要分布图如下图：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/uboot_mem_map.jpg)\n\n\n### 2.4. U-Boot Parameters\n\n| 名称 | 默认值 | 备注 |\n| :- | :- | :- |\n| bootargs | noinitrd root=/dev/mtdblock4 init=/linuxrc console=ttySAC0,115200 | U-Boot 在启动内核之前的等待时间，单位：秒 |\n| bootdelay | 1 | 与处理器相关 |\n| ethaddr | 00:40:5C:26:0A:5B | 网卡的MAC 地址 |\n| ipaddr | 172.20.223.235 | U-Boot 使用的IP 地址 |\n| loadaddr | 0x40000000 | 下载二进制文件时的默认地址 |\n| bootcmd | nand read C0008000 600000 500000; bootm C0008000 | 当使用boot 命令启动系统时所执行的脚本 |\n\n**Parameters Store**\n\ngloba data的RAM地址一般是存放在ARM 的`R8` 通用寄存器中。定义见`include/asm-generial/global_data.h`。\n\n注：**具体的位置可能因为U-Boot 代码的维护更新在变动，具体请参考实际的GitHub 版本**\n\n```c\n#define DECLARE_GLOBAL_DATA_PTR register volatile gd_t*d asm(\"r8\")\n\ngd = (gd_t *)(_armboot_start - CONFIG_SYS_MALLOC_LEN - sizeof(gd_t));\n\ngd->bd = (bd_t *)((char*)gd - sizeof(btd_t));\n```\n\n```c\ntypedef struct global_data {\n\tbd_t *bd;\n\tunsigned long flags;\n\tunsigned int baudrate;\n\tunsigned long cpu_clk;\t\t/* CPU clock in Hz!\t\t*/\n\tunsigned long bus_clk;\n\tunsigned long pci_clk;\n\tunsigned long mem_clk;\n\n#ifdef CONFIG_BOARD_TYPES\n\tunsigned long board_type;\n#endif\n\tunsigned long env_addr;\t\t/* Address  of Environment struct */\n\n\tunsigned long ram_base;\t\t/* Base address of RAM used by U-Boot */\n\tunsigned long ram_top;\t\t/* Top address of RAM used by U-Boot */\n\tunsigned long relocaddr;\t/* Start address of U-Boot in RAM */\n\tphys_size_t ram_size;\t\t/* RAM size */\n\tunsigned long irq_sp;\t\t/* irq stack pointer */\n\tunsigned long start_addr_sp;\t/* start_addr_stackpointer */\n\tunsigned long reloc_off;\n\tstruct global_data *new_gd;\t/* relocated global data */\n\n\tchar env_buf[32];\t\t/* buffer for env_get() before reloc. */\n\n#if CONFIG_VAL(SYS_MALLOC_F_LEN)\n\tunsigned long malloc_base;\t/* base address of early malloc() */\n\tunsigned long malloc_limit;\t/* limit address */\n\tunsigned long malloc_ptr;\t/* current address */\n#endif\n\n    ... ...\n#ifdef CONFIG_BOOTSTAGE\n\tstruct bootstage_data *bootstage;\t/* Bootstage information */\n\tstruct bootstage_data *new_bootstage;\t/* Relocated bootstage info */\n#endif\n} gd_t;\n```\n\nbd_t 保存于板子相关的配置参数。具体可见`include/asm-generial/u-boot.h`。\n\n```c\ntypedef struct bd_info {\n\tunsigned long\tbi_memstart;\t/* start of DRAM memory */\n\tphys_size_t\tbi_memsize;\t/* size\t of DRAM memory in bytes */\n\tunsigned long\tbi_flashstart;\t/* start of FLASH memory */\n\tunsigned long\tbi_flashsize;\t/* size\t of FLASH memory */\n\tunsigned long\tbi_flashoffset; /* reserved area for startup monitor */\n\tunsigned long\tbi_sramstart;\t/* start of SRAM memory */\n\tunsigned long\tbi_sramsize;\t/* size\t of SRAM memory */\n#ifdef CONFIG_ARM\n\tunsigned long\tbi_arm_freq; /* arm frequency */\n\tunsigned long\tbi_dsp_freq; /* dsp core frequency */\n\tunsigned long\tbi_ddr_freq; /* ddr frequency */\n#endif\n\n\tunsigned long\tbi_bootflags;\t/* boot / reboot flag (Unused) */\n\tunsigned long\tbi_ip_addr;\t/* IP Address */\n\tunsigned char\tbi_enetaddr[6];\t/* OLD: see README.enetaddr */\n\tunsigned short\tbi_ethspeed;\t/* Ethernet speed in Mbps */\n\tunsigned long\tbi_intfreq;\t/* Internal Freq, in MHz */\n\tunsigned long\tbi_busfreq;\t/* Bus Freq, in MHz */\n\n\tulong\t        bi_arch_number;\t/* unique id for this board */\n\tulong\t        bi_boot_params;\t/* where this board expects params */\n\n    ... ...\n#ifdef CONFIG_NR_DRAM_BANKS\n\tstruct {\t\t\t/* RAM configuration */\n\t\tphys_addr_t start;\n\t\tphys_size_t size;\n\t} bi_dram[CONFIG_NR_DRAM_BANKS];\n#endif /* CONFIG_NR_DRAM_BANKS */\n} bd_t;\n```\n\n在启动之后一般使用RAM 临时存放启动参数，在使用`saveenv` 命令后将会将之写到类似于Flash 存储介质上。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_parameters_store.jpg)\n\n**Parameters Structure**\nARM 采用了自己体系定义的参数结构。它的定义可以参见`arch/arm/include/asm/setup.h`。\n\n```c\nstruct tag {\n\tstruct tag_header hdr;\n\tunion {\n\t\tstruct tag_core\t\tcore;\n\t\tstruct tag_mem32\tmem;\n\t\tstruct tag_videotext\tvideotext;\n\t\tstruct tag_ramdisk\tramdisk;\n\t\tstruct tag_initrd\tinitrd;\n\t\tstruct tag_serialnr\tserialnr;\n\t\tstruct tag_revision\trevision;\n\t\tstruct tag_videolfb\tvideolfb;\n\t\tstruct tag_cmdline\tcmdline;\n\n\t\t/*\n\t\t * Acorn specific\n\t\t */\n\t\tstruct tag_acorn\tacorn;\n\n\t\t/*\n\t\t * DC21285 specific\n\t\t */\n\t\tstruct tag_memclk\tmemclk;\n\t} u;\n};\n\n#define tag_next(t)\t((struct tag *)((u32 *)(t) + (t)->hdr.size))\n#define tag_size(type) ((sizeof(struct tag_header) + sizeof(struct type)) >> 2)\n\n/* The list ends with an ATAG_NONE node. */\n#define ATAG_NONE\t0x00000000\n\nstruct tag_header {\n\tu32 size;\n\tu32 tag;\n};\n\n/* The list must start with an ATAG_CORE node */\n#define ATAG_CORE\t0x54410001\n\nstruct tag_core {\n\tu32 flags;\t\t/* bit 0 = read-only */\n\tu32 pagesize;\n\tu32 rootdev;\n};\n\n#define ATAG_MEM\t0x54410002\n#define ATAG_VIDEOTEXT\t0x54410003\n... ...\n```\n\nU-Boot就是将各种启动参数串联成类似下图结构给OS。\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_parameters_structure.jpg)\n\n注：**必须以ATAG_CORE, ATAG_NONE开头与结尾，Kernel启动时会依据此检测参数的有效性。**\n\n### 2.5. Bootup OS\n\n以ARM 体系启动Kernel需满足以下几点：\n- R0=0， R1=[机器码], R2=[Kernel启动参数起始地址]\n- Disable I/D Cache\n- Disable IRQ，FIQ\n- CPU in SVC 模式\n\n注：SVC 模式为Supervisor Control 模式，操作系统使用的保护模式，此模式下CPU能访问的数据权限更大，局限小。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os.jpg)\n\n`Setting`\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os_need_setting.jpg)\n\n`Parameters`\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os_parameters.jpg)\n\n## Reference\n[BootLoader -- wiki](https://en.wikipedia.org/wiki/Booting#BOOT-LOADER)\n\n[Das U-Boot -- wiki](https://en.wikipedia.org/wiki/Das_U-Boot)\n\n[U-Boot 百度百科](https://baike.baidu.com/item/U-Boot/10377075)\n\n[The DENX U-Boot and Linux Guide (DULG) for canyonlands](http://www.denx.de/wiki/DULG/Manual)\n\n[u-boot的内存分布和全局数据结构](\nhttps://blog.csdn.net/xiaoaid01/article/details/39700509)\n\n[移植u-boot学习笔记2-----分析启动过程之内存分布](\nhttps://blog.csdn.net/qingkongyeyue/article/details/52423350)\n\n[u-boot 运行时内存的分配](\nhttp://www.360doc.com/content/15/1104/09/6828497_510609834.shtml)\n","slug":"bootloader","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pq001dzkgrqnvy9zj4","content":"<h2 id=\"1-BootLoader\"><a href=\"#1-BootLoader\" class=\"headerlink\" title=\"1. BootLoader\"></a>1. BootLoader</h2><blockquote>\n<p>The computer first executes a relatively small program stored in read-only memory (ROM) along with a small amount of needed data, to access the nonvolatile device or devices from which the operating system programs and data can be loaded into RAM.</p>\n</blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Booting#BOOT-LOADER\" target=\"_blank\" rel=\"noopener\">bootloader – wiki</a></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootloader.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"2-U-Boot\"><a href=\"#2-U-Boot\" class=\"headerlink\" title=\"2. U-Boot\"></a>2. U-Boot</h2><p><a href=\"https://en.wikipedia.org/wiki/Das_U-Boot\" target=\"_blank\" rel=\"noopener\">Das U-Boot</a> – the Universal Boot Loader<br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=3f0275e9828ba61edfeecf29793497cc/a5c27d1ed21b0ef495e2eb7dddc451da81cb3e8e.jpg\" alt=\"\"></p>\n<p>其官网地址为：<a href=\"http://www.denx.de/wiki/U-Boot/WebHome\" target=\"_blank\" rel=\"noopener\">http://www.denx.de/wiki/U-Boot/WebHome</a></p>\n<p>官网也很贴心的有<a href=\"http://www.denx.de/wiki/DULG/Manual\" target=\"_blank\" rel=\"noopener\">指导手册</a></p>\n<blockquote>\n<p>U-Boot是遵循GPL条款的开放源码项目。其源码目录、编译形式与Linux内核很相似，事实上，不少U-Boot源码就是根据相应的Linux内核源程序进行简化而形成的，尤其是一些设备的驱动程序，这从U-Boot源码的注释中能体现这一点。U-Boot不仅仅支持嵌入式Linux系统的引导，它还支持NetBS<br>D, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android嵌入式操作系统。它还具有丰富的驱动代码及文件系统支持。（UART、Ethernet、SDRAM、Flash，RTC，ext[2|3|4]、FAT，JFFS2、Squashfs、Cramfs、UBIFS等）</p>\n</blockquote>\n<p><a href=\"https://github.com/u-boot/u-boot\" target=\"_blank\" rel=\"noopener\">U-Boot GitHub</a></p>\n<p>U-Boot的主要作用是：</p>\n<ul>\n<li>初始化硬件</li>\n<li>建立内存空间映射</li>\n</ul>\n<h3 id=\"2-1-Bootup-Stages\"><a href=\"#2-1-Bootup-Stages\" class=\"headerlink\" title=\"2.1. Bootup Stages\"></a>2.1. Bootup Stages</h3><p>BootLoader的启动过程可以使单阶段(single stage)与多阶段(multi-stage)<br>一般选择多阶段启动提供更复杂的功能，以及更好的可移植性。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/Bootup%20Stages.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-1-Stage1\"><a href=\"#2-1-1-Stage1\" class=\"headerlink\" title=\"2.1.1. Stage1\"></a>2.1.1. Stage1</h3><p>常用汇编代码编写此段代码。例如<code>u-boot/arch/arm/xxx/start.S</code>。<br>Stage1 的主要作用：</p>\n<ul>\n<li>设定异常向量(exception vector)</li>\n<li>初始化硬件（CPU速度，时钟频率，关中断，Disable I/D Cache，u-boot毕竟很简单）</li>\n<li>初始化内存控制器</li>\n<li>拷贝Rom或者Flash 等上的程序到Ram中（u-boot运行代码）</li>\n<li>初始化堆栈</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_flow_1.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-2-Stage2\"><a href=\"#2-1-2-Stage2\" class=\"headerlink\" title=\"2.1.2. Stage2\"></a>2.1.2. Stage2</h3><p>主要是C语言代码，ARM体系一般是在lib_arm/board.c中start_armboot()。Stage2 主要完成：</p>\n<ul>\n<li>该阶段使用到的外围硬件初始化（Flash、SD、Ethernet等）</li>\n<li>检测RAM 映射</li>\n<li>拷贝Kernel 镜像至RAM 中的加载地址</li>\n<li>设定启动参数</li>\n<li>启动OS</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_flow_2.jpg\" alt=\"\"></p>\n<h3 id=\"2-2-U-Boot-Directory\"><a href=\"#2-2-U-Boot-Directory\" class=\"headerlink\" title=\"2.2. U-Boot Directory\"></a>2.2. U-Boot Directory</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/directory.jpg\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">目录</th>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">board</td>\n<td style=\"text-align:left\">平台依赖</td>\n<td style=\"text-align:left\">目标板文件。Flash，Ram等驱动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">cpu</td>\n<td style=\"text-align:left\">平台依赖</td>\n<td style=\"text-align:left\">与处理器相关</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">lib_arm</td>\n<td style=\"text-align:left\">平台依赖</td>\n<td style=\"text-align:left\">处理器体系相关</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">post</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">上电自检文件目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fs</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">文件系统fat，jffs2,nfs,ubifs,ext[2-4]等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">driver</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">通用设备驱动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">net</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">网络</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">common</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">内存检测，Nand等常用命令</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-3-U-Boot-Memory-Map\"><a href=\"#2-3-U-Boot-Memory-Map\" class=\"headerlink\" title=\"2.3. U-Boot Memory Map\"></a>2.3. U-Boot Memory Map</h3><p>U-Boot 的内存主要分布图如下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/uboot_mem_map.jpg\" alt=\"\"></p>\n<h3 id=\"2-4-U-Boot-Parameters\"><a href=\"#2-4-U-Boot-Parameters\" class=\"headerlink\" title=\"2.4. U-Boot Parameters\"></a>2.4. U-Boot Parameters</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">bootargs</td>\n<td style=\"text-align:left\">noinitrd root=/dev/mtdblock4 init=/linuxrc console=ttySAC0,115200</td>\n<td style=\"text-align:left\">U-Boot 在启动内核之前的等待时间，单位：秒</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">bootdelay</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">与处理器相关</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ethaddr</td>\n<td style=\"text-align:left\">00:40:5C:26:0A:5B</td>\n<td style=\"text-align:left\">网卡的MAC 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ipaddr</td>\n<td style=\"text-align:left\">172.20.223.235</td>\n<td style=\"text-align:left\">U-Boot 使用的IP 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">loadaddr</td>\n<td style=\"text-align:left\">0x40000000</td>\n<td style=\"text-align:left\">下载二进制文件时的默认地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">bootcmd</td>\n<td style=\"text-align:left\">nand read C0008000 600000 500000; bootm C0008000</td>\n<td style=\"text-align:left\">当使用boot 命令启动系统时所执行的脚本</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Parameters Store</strong></p>\n<p>globa data的RAM地址一般是存放在ARM 的<code>R8</code> 通用寄存器中。定义见<code>include/asm-generial/global_data.h</code>。</p>\n<p>注：<strong>具体的位置可能因为U-Boot 代码的维护更新在变动，具体请参考实际的GitHub 版本</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DECLARE_GLOBAL_DATA_PTR register volatile gd_t*d asm(<span class=\"meta-string\">\"r8\"</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">gd = (<span class=\"keyword\">gd_t</span> *)(_armboot_start - CONFIG_SYS_MALLOC_LEN - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">gd_t</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">gd-&gt;bd = (<span class=\"keyword\">bd_t</span> *)((<span class=\"keyword\">char</span>*)gd - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">btd_t</span>));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">global_data</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">bd_t</span> *bd;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> baudrate;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> cpu_clk;\t\t<span class=\"comment\">/* CPU clock in Hz!\t\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> bus_clk;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pci_clk;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> mem_clk;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_BOARD_TYPES</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> board_type;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> env_addr;\t\t<span class=\"comment\">/* Address  of Environment struct */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ram_base;\t\t<span class=\"comment\">/* Base address of RAM used by U-Boot */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ram_top;\t\t<span class=\"comment\">/* Top address of RAM used by U-Boot */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> relocaddr;\t<span class=\"comment\">/* Start address of U-Boot in RAM */</span></span><br><span class=\"line\">\t<span class=\"keyword\">phys_size_t</span> ram_size;\t\t<span class=\"comment\">/* RAM size */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> irq_sp;\t\t<span class=\"comment\">/* irq stack pointer */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start_addr_sp;\t<span class=\"comment\">/* start_addr_stackpointer */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> reloc_off;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">global_data</span> *<span class=\"title\">new_gd</span>;</span>\t<span class=\"comment\">/* relocated global data */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> env_buf[<span class=\"number\">32</span>];\t\t<span class=\"comment\">/* buffer for env_get() before reloc. */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> malloc_base;\t<span class=\"comment\">/* base address of early malloc() */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> malloc_limit;\t<span class=\"comment\">/* limit address */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> malloc_ptr;\t<span class=\"comment\">/* current address */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_BOOTSTAGE</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bootstage_data</span> *<span class=\"title\">bootstage</span>;</span>\t<span class=\"comment\">/* Bootstage information */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bootstage_data</span> *<span class=\"title\">new_bootstage</span>;</span>\t<span class=\"comment\">/* Relocated bootstage info */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125; <span class=\"keyword\">gd_t</span>;</span><br></pre></td></tr></table></figure>\n<p>bd_t 保存于板子相关的配置参数。具体可见<code>include/asm-generial/u-boot.h</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bd_info</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_memstart;\t<span class=\"comment\">/* start of DRAM memory */</span></span><br><span class=\"line\">\t<span class=\"keyword\">phys_size_t</span>\tbi_memsize;\t<span class=\"comment\">/* size\t of DRAM memory in bytes */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_flashstart;\t<span class=\"comment\">/* start of FLASH memory */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_flashsize;\t<span class=\"comment\">/* size\t of FLASH memory */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_flashoffset; <span class=\"comment\">/* reserved area for startup monitor */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_sramstart;\t<span class=\"comment\">/* start of SRAM memory */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_sramsize;\t<span class=\"comment\">/* size\t of SRAM memory */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_ARM</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_arm_freq; <span class=\"comment\">/* arm frequency */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_dsp_freq; <span class=\"comment\">/* dsp core frequency */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_ddr_freq; <span class=\"comment\">/* ddr frequency */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_bootflags;\t<span class=\"comment\">/* boot / reboot flag (Unused) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_ip_addr;\t<span class=\"comment\">/* IP Address */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\tbi_enetaddr[<span class=\"number\">6</span>];\t<span class=\"comment\">/* OLD: see README.enetaddr */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>\tbi_ethspeed;\t<span class=\"comment\">/* Ethernet speed in Mbps */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_intfreq;\t<span class=\"comment\">/* Internal Freq, in MHz */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_busfreq;\t<span class=\"comment\">/* Bus Freq, in MHz */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tulong\t        bi_arch_number;\t<span class=\"comment\">/* unique id for this board */</span></span><br><span class=\"line\">\tulong\t        bi_boot_params;\t<span class=\"comment\">/* where this board expects params */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_NR_DRAM_BANKS</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span>\t\t\t<span class=\"comment\">/* RAM configuration */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">phys_addr_t</span> start;</span><br><span class=\"line\">\t\t<span class=\"keyword\">phys_size_t</span> size;</span><br><span class=\"line\">\t&#125; bi_dram[CONFIG_NR_DRAM_BANKS];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* CONFIG_NR_DRAM_BANKS */</span></span></span><br><span class=\"line\">&#125; <span class=\"keyword\">bd_t</span>;</span><br></pre></td></tr></table></figure>\n<p>在启动之后一般使用RAM 临时存放启动参数，在使用<code>saveenv</code> 命令后将会将之写到类似于Flash 存储介质上。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_parameters_store.jpg\" alt=\"\"></p>\n<p><strong>Parameters Structure</strong><br>ARM 采用了自己体系定义的参数结构。它的定义可以参见<code>arch/arm/include/asm/setup.h</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_header</span> <span class=\"title\">hdr</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_core</span>\t\t<span class=\"title\">core</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_mem32</span>\t<span class=\"title\">mem</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_videotext</span>\t<span class=\"title\">videotext</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_ramdisk</span>\t<span class=\"title\">ramdisk</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_initrd</span>\t<span class=\"title\">initrd</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_serialnr</span>\t<span class=\"title\">serialnr</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_revision</span>\t<span class=\"title\">revision</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_videolfb</span>\t<span class=\"title\">videolfb</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_cmdline</span>\t<span class=\"title\">cmdline</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Acorn specific</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_acorn</span>\t<span class=\"title\">acorn</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * DC21285 specific</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_memclk</span>\t<span class=\"title\">memclk</span>;</span></span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> tag_next(t)\t((struct tag *)((u32 *)(t) + (t)-&gt;hdr.size))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> tag_size(type) ((sizeof(struct tag_header) + sizeof(struct type)) &gt;&gt; 2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* The list ends with an ATAG_NONE node. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ATAG_NONE\t0x00000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_header</span> &#123;</span></span><br><span class=\"line\">\tu32 size;</span><br><span class=\"line\">\tu32 tag;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* The list must start with an ATAG_CORE node */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ATAG_CORE\t0x54410001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_core</span> &#123;</span></span><br><span class=\"line\">\tu32 flags;\t\t<span class=\"comment\">/* bit 0 = read-only */</span></span><br><span class=\"line\">\tu32 pagesize;</span><br><span class=\"line\">\tu32 rootdev;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ATAG_MEM\t0x54410002</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ATAG_VIDEOTEXT\t0x54410003</span></span><br><span class=\"line\">... ...</span><br></pre></td></tr></table></figure>\n<p>U-Boot就是将各种启动参数串联成类似下图结构给OS。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_parameters_structure.jpg\" alt=\"\"></p>\n<p>注：<strong>必须以ATAG_CORE, ATAG_NONE开头与结尾，Kernel启动时会依据此检测参数的有效性。</strong></p>\n<h3 id=\"2-5-Bootup-OS\"><a href=\"#2-5-Bootup-OS\" class=\"headerlink\" title=\"2.5. Bootup OS\"></a>2.5. Bootup OS</h3><p>以ARM 体系启动Kernel需满足以下几点：</p>\n<ul>\n<li>R0=0， R1=[机器码], R2=[Kernel启动参数起始地址]</li>\n<li>Disable I/D Cache</li>\n<li>Disable IRQ，FIQ</li>\n<li>CPU in SVC 模式</li>\n</ul>\n<p>注：SVC 模式为Supervisor Control 模式，操作系统使用的保护模式，此模式下CPU能访问的数据权限更大，局限小。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os.jpg\" alt=\"\"></p>\n<p><code>Setting</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os_need_setting.jpg\" alt=\"\"></p>\n<p><code>Parameters</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os_parameters.jpg\" alt=\"\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://en.wikipedia.org/wiki/Booting#BOOT-LOADER\" target=\"_blank\" rel=\"noopener\">BootLoader – wiki</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Das_U-Boot\" target=\"_blank\" rel=\"noopener\">Das U-Boot – wiki</a></p>\n<p><a href=\"https://baike.baidu.com/item/U-Boot/10377075\" target=\"_blank\" rel=\"noopener\">U-Boot 百度百科</a></p>\n<p><a href=\"http://www.denx.de/wiki/DULG/Manual\" target=\"_blank\" rel=\"noopener\">The DENX U-Boot and Linux Guide (DULG) for canyonlands</a></p>\n<p><a href=\"https://blog.csdn.net/xiaoaid01/article/details/39700509\" target=\"_blank\" rel=\"noopener\">u-boot的内存分布和全局数据结构</a></p>\n<p><a href=\"https://blog.csdn.net/qingkongyeyue/article/details/52423350\" target=\"_blank\" rel=\"noopener\">移植u-boot学习笔记2—–分析启动过程之内存分布</a></p>\n<p><a href=\"http://www.360doc.com/content/15/1104/09/6828497_510609834.shtml\" target=\"_blank\" rel=\"noopener\">u-boot 运行时内存的分配</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-BootLoader\"><a href=\"#1-BootLoader\" class=\"headerlink\" title=\"1. BootLoader\"></a>1. BootLoader</h2><blockquote>\n<p>The computer first executes a relatively small program stored in read-only memory (ROM) along with a small amount of needed data, to access the nonvolatile device or devices from which the operating system programs and data can be loaded into RAM.</p>\n</blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Booting#BOOT-LOADER\" target=\"_blank\" rel=\"noopener\">bootloader – wiki</a></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootloader.jpg\" alt=\"\"></p>","more":"<h2 id=\"2-U-Boot\"><a href=\"#2-U-Boot\" class=\"headerlink\" title=\"2. U-Boot\"></a>2. U-Boot</h2><p><a href=\"https://en.wikipedia.org/wiki/Das_U-Boot\" target=\"_blank\" rel=\"noopener\">Das U-Boot</a> – the Universal Boot Loader<br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=3f0275e9828ba61edfeecf29793497cc/a5c27d1ed21b0ef495e2eb7dddc451da81cb3e8e.jpg\" alt=\"\"></p>\n<p>其官网地址为：<a href=\"http://www.denx.de/wiki/U-Boot/WebHome\" target=\"_blank\" rel=\"noopener\">http://www.denx.de/wiki/U-Boot/WebHome</a></p>\n<p>官网也很贴心的有<a href=\"http://www.denx.de/wiki/DULG/Manual\" target=\"_blank\" rel=\"noopener\">指导手册</a></p>\n<blockquote>\n<p>U-Boot是遵循GPL条款的开放源码项目。其源码目录、编译形式与Linux内核很相似，事实上，不少U-Boot源码就是根据相应的Linux内核源程序进行简化而形成的，尤其是一些设备的驱动程序，这从U-Boot源码的注释中能体现这一点。U-Boot不仅仅支持嵌入式Linux系统的引导，它还支持NetBS<br>D, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android嵌入式操作系统。它还具有丰富的驱动代码及文件系统支持。（UART、Ethernet、SDRAM、Flash，RTC，ext[2|3|4]、FAT，JFFS2、Squashfs、Cramfs、UBIFS等）</p>\n</blockquote>\n<p><a href=\"https://github.com/u-boot/u-boot\" target=\"_blank\" rel=\"noopener\">U-Boot GitHub</a></p>\n<p>U-Boot的主要作用是：</p>\n<ul>\n<li>初始化硬件</li>\n<li>建立内存空间映射</li>\n</ul>\n<h3 id=\"2-1-Bootup-Stages\"><a href=\"#2-1-Bootup-Stages\" class=\"headerlink\" title=\"2.1. Bootup Stages\"></a>2.1. Bootup Stages</h3><p>BootLoader的启动过程可以使单阶段(single stage)与多阶段(multi-stage)<br>一般选择多阶段启动提供更复杂的功能，以及更好的可移植性。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/Bootup%20Stages.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-1-Stage1\"><a href=\"#2-1-1-Stage1\" class=\"headerlink\" title=\"2.1.1. Stage1\"></a>2.1.1. Stage1</h3><p>常用汇编代码编写此段代码。例如<code>u-boot/arch/arm/xxx/start.S</code>。<br>Stage1 的主要作用：</p>\n<ul>\n<li>设定异常向量(exception vector)</li>\n<li>初始化硬件（CPU速度，时钟频率，关中断，Disable I/D Cache，u-boot毕竟很简单）</li>\n<li>初始化内存控制器</li>\n<li>拷贝Rom或者Flash 等上的程序到Ram中（u-boot运行代码）</li>\n<li>初始化堆栈</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_flow_1.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-2-Stage2\"><a href=\"#2-1-2-Stage2\" class=\"headerlink\" title=\"2.1.2. Stage2\"></a>2.1.2. Stage2</h3><p>主要是C语言代码，ARM体系一般是在lib_arm/board.c中start_armboot()。Stage2 主要完成：</p>\n<ul>\n<li>该阶段使用到的外围硬件初始化（Flash、SD、Ethernet等）</li>\n<li>检测RAM 映射</li>\n<li>拷贝Kernel 镜像至RAM 中的加载地址</li>\n<li>设定启动参数</li>\n<li>启动OS</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_flow_2.jpg\" alt=\"\"></p>\n<h3 id=\"2-2-U-Boot-Directory\"><a href=\"#2-2-U-Boot-Directory\" class=\"headerlink\" title=\"2.2. U-Boot Directory\"></a>2.2. U-Boot Directory</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/directory.jpg\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">目录</th>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">board</td>\n<td style=\"text-align:left\">平台依赖</td>\n<td style=\"text-align:left\">目标板文件。Flash，Ram等驱动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">cpu</td>\n<td style=\"text-align:left\">平台依赖</td>\n<td style=\"text-align:left\">与处理器相关</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">lib_arm</td>\n<td style=\"text-align:left\">平台依赖</td>\n<td style=\"text-align:left\">处理器体系相关</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">post</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">上电自检文件目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fs</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">文件系统fat，jffs2,nfs,ubifs,ext[2-4]等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">driver</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">通用设备驱动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">net</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">网络</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">common</td>\n<td style=\"text-align:left\">通用</td>\n<td style=\"text-align:left\">内存检测，Nand等常用命令</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-3-U-Boot-Memory-Map\"><a href=\"#2-3-U-Boot-Memory-Map\" class=\"headerlink\" title=\"2.3. U-Boot Memory Map\"></a>2.3. U-Boot Memory Map</h3><p>U-Boot 的内存主要分布图如下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/uboot_mem_map.jpg\" alt=\"\"></p>\n<h3 id=\"2-4-U-Boot-Parameters\"><a href=\"#2-4-U-Boot-Parameters\" class=\"headerlink\" title=\"2.4. U-Boot Parameters\"></a>2.4. U-Boot Parameters</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">bootargs</td>\n<td style=\"text-align:left\">noinitrd root=/dev/mtdblock4 init=/linuxrc console=ttySAC0,115200</td>\n<td style=\"text-align:left\">U-Boot 在启动内核之前的等待时间，单位：秒</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">bootdelay</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">与处理器相关</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ethaddr</td>\n<td style=\"text-align:left\">00:40:5C:26:0A:5B</td>\n<td style=\"text-align:left\">网卡的MAC 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ipaddr</td>\n<td style=\"text-align:left\">172.20.223.235</td>\n<td style=\"text-align:left\">U-Boot 使用的IP 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">loadaddr</td>\n<td style=\"text-align:left\">0x40000000</td>\n<td style=\"text-align:left\">下载二进制文件时的默认地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">bootcmd</td>\n<td style=\"text-align:left\">nand read C0008000 600000 500000; bootm C0008000</td>\n<td style=\"text-align:left\">当使用boot 命令启动系统时所执行的脚本</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Parameters Store</strong></p>\n<p>globa data的RAM地址一般是存放在ARM 的<code>R8</code> 通用寄存器中。定义见<code>include/asm-generial/global_data.h</code>。</p>\n<p>注：<strong>具体的位置可能因为U-Boot 代码的维护更新在变动，具体请参考实际的GitHub 版本</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DECLARE_GLOBAL_DATA_PTR register volatile gd_t*d asm(<span class=\"meta-string\">\"r8\"</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">gd = (<span class=\"keyword\">gd_t</span> *)(_armboot_start - CONFIG_SYS_MALLOC_LEN - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">gd_t</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">gd-&gt;bd = (<span class=\"keyword\">bd_t</span> *)((<span class=\"keyword\">char</span>*)gd - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">btd_t</span>));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">global_data</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">bd_t</span> *bd;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> baudrate;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> cpu_clk;\t\t<span class=\"comment\">/* CPU clock in Hz!\t\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> bus_clk;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pci_clk;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> mem_clk;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_BOARD_TYPES</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> board_type;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> env_addr;\t\t<span class=\"comment\">/* Address  of Environment struct */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ram_base;\t\t<span class=\"comment\">/* Base address of RAM used by U-Boot */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ram_top;\t\t<span class=\"comment\">/* Top address of RAM used by U-Boot */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> relocaddr;\t<span class=\"comment\">/* Start address of U-Boot in RAM */</span></span><br><span class=\"line\">\t<span class=\"keyword\">phys_size_t</span> ram_size;\t\t<span class=\"comment\">/* RAM size */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> irq_sp;\t\t<span class=\"comment\">/* irq stack pointer */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start_addr_sp;\t<span class=\"comment\">/* start_addr_stackpointer */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> reloc_off;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">global_data</span> *<span class=\"title\">new_gd</span>;</span>\t<span class=\"comment\">/* relocated global data */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> env_buf[<span class=\"number\">32</span>];\t\t<span class=\"comment\">/* buffer for env_get() before reloc. */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> malloc_base;\t<span class=\"comment\">/* base address of early malloc() */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> malloc_limit;\t<span class=\"comment\">/* limit address */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> malloc_ptr;\t<span class=\"comment\">/* current address */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_BOOTSTAGE</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bootstage_data</span> *<span class=\"title\">bootstage</span>;</span>\t<span class=\"comment\">/* Bootstage information */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bootstage_data</span> *<span class=\"title\">new_bootstage</span>;</span>\t<span class=\"comment\">/* Relocated bootstage info */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125; <span class=\"keyword\">gd_t</span>;</span><br></pre></td></tr></table></figure>\n<p>bd_t 保存于板子相关的配置参数。具体可见<code>include/asm-generial/u-boot.h</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bd_info</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_memstart;\t<span class=\"comment\">/* start of DRAM memory */</span></span><br><span class=\"line\">\t<span class=\"keyword\">phys_size_t</span>\tbi_memsize;\t<span class=\"comment\">/* size\t of DRAM memory in bytes */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_flashstart;\t<span class=\"comment\">/* start of FLASH memory */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_flashsize;\t<span class=\"comment\">/* size\t of FLASH memory */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_flashoffset; <span class=\"comment\">/* reserved area for startup monitor */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_sramstart;\t<span class=\"comment\">/* start of SRAM memory */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_sramsize;\t<span class=\"comment\">/* size\t of SRAM memory */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_ARM</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_arm_freq; <span class=\"comment\">/* arm frequency */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_dsp_freq; <span class=\"comment\">/* dsp core frequency */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_ddr_freq; <span class=\"comment\">/* ddr frequency */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_bootflags;\t<span class=\"comment\">/* boot / reboot flag (Unused) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_ip_addr;\t<span class=\"comment\">/* IP Address */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\tbi_enetaddr[<span class=\"number\">6</span>];\t<span class=\"comment\">/* OLD: see README.enetaddr */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>\tbi_ethspeed;\t<span class=\"comment\">/* Ethernet speed in Mbps */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_intfreq;\t<span class=\"comment\">/* Internal Freq, in MHz */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tbi_busfreq;\t<span class=\"comment\">/* Bus Freq, in MHz */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tulong\t        bi_arch_number;\t<span class=\"comment\">/* unique id for this board */</span></span><br><span class=\"line\">\tulong\t        bi_boot_params;\t<span class=\"comment\">/* where this board expects params */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_NR_DRAM_BANKS</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span>\t\t\t<span class=\"comment\">/* RAM configuration */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">phys_addr_t</span> start;</span><br><span class=\"line\">\t\t<span class=\"keyword\">phys_size_t</span> size;</span><br><span class=\"line\">\t&#125; bi_dram[CONFIG_NR_DRAM_BANKS];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* CONFIG_NR_DRAM_BANKS */</span></span></span><br><span class=\"line\">&#125; <span class=\"keyword\">bd_t</span>;</span><br></pre></td></tr></table></figure>\n<p>在启动之后一般使用RAM 临时存放启动参数，在使用<code>saveenv</code> 命令后将会将之写到类似于Flash 存储介质上。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_parameters_store.jpg\" alt=\"\"></p>\n<p><strong>Parameters Structure</strong><br>ARM 采用了自己体系定义的参数结构。它的定义可以参见<code>arch/arm/include/asm/setup.h</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_header</span> <span class=\"title\">hdr</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_core</span>\t\t<span class=\"title\">core</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_mem32</span>\t<span class=\"title\">mem</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_videotext</span>\t<span class=\"title\">videotext</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_ramdisk</span>\t<span class=\"title\">ramdisk</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_initrd</span>\t<span class=\"title\">initrd</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_serialnr</span>\t<span class=\"title\">serialnr</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_revision</span>\t<span class=\"title\">revision</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_videolfb</span>\t<span class=\"title\">videolfb</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_cmdline</span>\t<span class=\"title\">cmdline</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Acorn specific</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_acorn</span>\t<span class=\"title\">acorn</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * DC21285 specific</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_memclk</span>\t<span class=\"title\">memclk</span>;</span></span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> tag_next(t)\t((struct tag *)((u32 *)(t) + (t)-&gt;hdr.size))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> tag_size(type) ((sizeof(struct tag_header) + sizeof(struct type)) &gt;&gt; 2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* The list ends with an ATAG_NONE node. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ATAG_NONE\t0x00000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_header</span> &#123;</span></span><br><span class=\"line\">\tu32 size;</span><br><span class=\"line\">\tu32 tag;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* The list must start with an ATAG_CORE node */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ATAG_CORE\t0x54410001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_core</span> &#123;</span></span><br><span class=\"line\">\tu32 flags;\t\t<span class=\"comment\">/* bit 0 = read-only */</span></span><br><span class=\"line\">\tu32 pagesize;</span><br><span class=\"line\">\tu32 rootdev;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ATAG_MEM\t0x54410002</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ATAG_VIDEOTEXT\t0x54410003</span></span><br><span class=\"line\">... ...</span><br></pre></td></tr></table></figure>\n<p>U-Boot就是将各种启动参数串联成类似下图结构给OS。<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_parameters_structure.jpg\" alt=\"\"></p>\n<p>注：<strong>必须以ATAG_CORE, ATAG_NONE开头与结尾，Kernel启动时会依据此检测参数的有效性。</strong></p>\n<h3 id=\"2-5-Bootup-OS\"><a href=\"#2-5-Bootup-OS\" class=\"headerlink\" title=\"2.5. Bootup OS\"></a>2.5. Bootup OS</h3><p>以ARM 体系启动Kernel需满足以下几点：</p>\n<ul>\n<li>R0=0， R1=[机器码], R2=[Kernel启动参数起始地址]</li>\n<li>Disable I/D Cache</li>\n<li>Disable IRQ，FIQ</li>\n<li>CPU in SVC 模式</li>\n</ul>\n<p>注：SVC 模式为Supervisor Control 模式，操作系统使用的保护模式，此模式下CPU能访问的数据权限更大，局限小。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os.jpg\" alt=\"\"></p>\n<p><code>Setting</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os_need_setting.jpg\" alt=\"\"></p>\n<p><code>Parameters</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/bootloader/bootup_os_parameters.jpg\" alt=\"\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://en.wikipedia.org/wiki/Booting#BOOT-LOADER\" target=\"_blank\" rel=\"noopener\">BootLoader – wiki</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Das_U-Boot\" target=\"_blank\" rel=\"noopener\">Das U-Boot – wiki</a></p>\n<p><a href=\"https://baike.baidu.com/item/U-Boot/10377075\" target=\"_blank\" rel=\"noopener\">U-Boot 百度百科</a></p>\n<p><a href=\"http://www.denx.de/wiki/DULG/Manual\" target=\"_blank\" rel=\"noopener\">The DENX U-Boot and Linux Guide (DULG) for canyonlands</a></p>\n<p><a href=\"https://blog.csdn.net/xiaoaid01/article/details/39700509\" target=\"_blank\" rel=\"noopener\">u-boot的内存分布和全局数据结构</a></p>\n<p><a href=\"https://blog.csdn.net/qingkongyeyue/article/details/52423350\" target=\"_blank\" rel=\"noopener\">移植u-boot学习笔记2—–分析启动过程之内存分布</a></p>\n<p><a href=\"http://www.360doc.com/content/15/1104/09/6828497_510609834.shtml\" target=\"_blank\" rel=\"noopener\">u-boot 运行时内存的分配</a></p>"},{"title":"buildbot","date":"2019-07-02T02:25:56.000Z","_content":"\n在openwrt 官网上看到buildbot， 他以此来完成在pull 代码之后，自动编译的工作并产出报告或者邮件通知等。\n[buildbot官网](http://buildbot.net/)\n\n持续集成（Continuous Integration，CI）的主要优势是，能够通过软件的自动化构建以及测试和软件度量标准（可选）精简品质保证周期。每次更改源代码并为项目生命期提供即时反馈和报告。\n\n<!--more-->\n\n### 1. buildbot 简介  \nBuildBot是一个开源的基于python的持续集成系统，BuildBot用python写的，该python程序只依赖python环境和Twisted（一个python网络框架），可以在很多平台运行。 自动化构建一般包括自动下载源码，编译，测试，打包。他的工作原理可以参见下图:  \n![](http://buildbot.net/img/overview.png)\n\nBuildbot的原理是git，SVN等源码服务器上代码发生变化后，buildmaster（服务端）通知连接到它上的buildslave（客户端）从git或SVN服务器上自动下载源码，编译，测试，打包。最后把各个buildslave的自动化构建的结果搜集起来在web上展现，或通过email,IRC等方式通知相应的项目开发人员。\n\nBuildBot的常用架构是一个Master和一堆Slave，Master负责对接VCS，然后管理调度各个Slave各司其职，收集Slave传回来的数据并且整理成报告。Slave负责按照Master发过来的命令跑各种任务，并将环境信息，结果，log文件等收集起来报告给Master。\n- master  master就是Buildbot的核心，我们使用Buildbot所需要做的各种工作也是在Master上进行。Buildbot的使用方式就是在Master上编辑master.cfg文件，这其实是一个Python文件。使用者在里面定义对接的VCS，Schedule和Build的各种条件以及具体的Build任务，结果的收集报告方式等。\n- slave 当slave连接到master后就会不断跟master进行通信。当有任务时，master会将命令逐个发送给slave执行。\n\n### 2. Openwrt buildbot\n我们可以访问如下链接， 可以看到openwrt 的buildbot 的情况。\n- Phase 1: [target/subtargets](https://phase1.builds.lede-project.org/builders)  \n- Phase 2: [packages](https://phase2.builds.lede-project.org/builders)  \n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/waterfall.png)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/grid.png)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/console%20view.png)\n\n### 3. 其他常见持续集成工具  \n常见的持续集成工具有：  \n- [Jenkins](https://jenkins.io/zh/) （java 方向）  \n- [Hudson](http://hudson-ci.org/) (java 方向，jenkins 的前身)  \n- [strider](http://stridercd.com/)  \n- [travis](https://travis-ci.com/) （对开源项目免费）  \n- [codeship](https://codeship.com/)（对开源项目免费）  \n\n部署工具(将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器)  \n- [ansible](https://www.ansible.com/)  \n- [chef](https://www.chef.io/products/chef-infra/)  \n- [puppet](https://puppet.com/)  \n  \n### 参看资料   \n[Buildbot Tutorial](https://docs.buildbot.net/current/tutorial/)  \n[Buildbot初探](https://www.cnblogs.com/lkiversonlk/p/4878129.html)   \n[使用 Buildot 实现持续集成](https://www.ibm.com/developerworks/cn/linux/l-buildbot/index.html)   \n[buildbot自动化测试工具安装及快速入门](https://blog.csdn.net/LSMEGR/article/details/53618045)  \n[持续集成的魅力：工具推荐](https://www.cnblogs.com/xing901022/p/4414263.html)  \n[六款不容错过的开源持续集成工具](http://cloud.51cto.com/art/201508/487605.htm)  \n[持续集成是什么？](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)  ","source":"_posts/buildbot.md","raw":"---\ntitle: buildbot\ndate: 2019-07-02 10:25:56\ntags:\n    - buildbot\n    - openwrt\n    - CI\ncategories:\n    - CI\n---\n\n在openwrt 官网上看到buildbot， 他以此来完成在pull 代码之后，自动编译的工作并产出报告或者邮件通知等。\n[buildbot官网](http://buildbot.net/)\n\n持续集成（Continuous Integration，CI）的主要优势是，能够通过软件的自动化构建以及测试和软件度量标准（可选）精简品质保证周期。每次更改源代码并为项目生命期提供即时反馈和报告。\n\n<!--more-->\n\n### 1. buildbot 简介  \nBuildBot是一个开源的基于python的持续集成系统，BuildBot用python写的，该python程序只依赖python环境和Twisted（一个python网络框架），可以在很多平台运行。 自动化构建一般包括自动下载源码，编译，测试，打包。他的工作原理可以参见下图:  \n![](http://buildbot.net/img/overview.png)\n\nBuildbot的原理是git，SVN等源码服务器上代码发生变化后，buildmaster（服务端）通知连接到它上的buildslave（客户端）从git或SVN服务器上自动下载源码，编译，测试，打包。最后把各个buildslave的自动化构建的结果搜集起来在web上展现，或通过email,IRC等方式通知相应的项目开发人员。\n\nBuildBot的常用架构是一个Master和一堆Slave，Master负责对接VCS，然后管理调度各个Slave各司其职，收集Slave传回来的数据并且整理成报告。Slave负责按照Master发过来的命令跑各种任务，并将环境信息，结果，log文件等收集起来报告给Master。\n- master  master就是Buildbot的核心，我们使用Buildbot所需要做的各种工作也是在Master上进行。Buildbot的使用方式就是在Master上编辑master.cfg文件，这其实是一个Python文件。使用者在里面定义对接的VCS，Schedule和Build的各种条件以及具体的Build任务，结果的收集报告方式等。\n- slave 当slave连接到master后就会不断跟master进行通信。当有任务时，master会将命令逐个发送给slave执行。\n\n### 2. Openwrt buildbot\n我们可以访问如下链接， 可以看到openwrt 的buildbot 的情况。\n- Phase 1: [target/subtargets](https://phase1.builds.lede-project.org/builders)  \n- Phase 2: [packages](https://phase2.builds.lede-project.org/builders)  \n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/waterfall.png)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/grid.png)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/console%20view.png)\n\n### 3. 其他常见持续集成工具  \n常见的持续集成工具有：  \n- [Jenkins](https://jenkins.io/zh/) （java 方向）  \n- [Hudson](http://hudson-ci.org/) (java 方向，jenkins 的前身)  \n- [strider](http://stridercd.com/)  \n- [travis](https://travis-ci.com/) （对开源项目免费）  \n- [codeship](https://codeship.com/)（对开源项目免费）  \n\n部署工具(将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器)  \n- [ansible](https://www.ansible.com/)  \n- [chef](https://www.chef.io/products/chef-infra/)  \n- [puppet](https://puppet.com/)  \n  \n### 参看资料   \n[Buildbot Tutorial](https://docs.buildbot.net/current/tutorial/)  \n[Buildbot初探](https://www.cnblogs.com/lkiversonlk/p/4878129.html)   \n[使用 Buildot 实现持续集成](https://www.ibm.com/developerworks/cn/linux/l-buildbot/index.html)   \n[buildbot自动化测试工具安装及快速入门](https://blog.csdn.net/LSMEGR/article/details/53618045)  \n[持续集成的魅力：工具推荐](https://www.cnblogs.com/xing901022/p/4414263.html)  \n[六款不容错过的开源持续集成工具](http://cloud.51cto.com/art/201508/487605.htm)  \n[持续集成是什么？](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)  ","slug":"buildbot","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pr001gzkgrs4yibgdb","content":"<p>在openwrt 官网上看到buildbot， 他以此来完成在pull 代码之后，自动编译的工作并产出报告或者邮件通知等。<br><a href=\"http://buildbot.net/\" target=\"_blank\" rel=\"noopener\">buildbot官网</a></p>\n<p>持续集成（Continuous Integration，CI）的主要优势是，能够通过软件的自动化构建以及测试和软件度量标准（可选）精简品质保证周期。每次更改源代码并为项目生命期提供即时反馈和报告。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-buildbot-简介\"><a href=\"#1-buildbot-简介\" class=\"headerlink\" title=\"1. buildbot 简介\"></a>1. buildbot 简介</h3><p>BuildBot是一个开源的基于python的持续集成系统，BuildBot用python写的，该python程序只依赖python环境和Twisted（一个python网络框架），可以在很多平台运行。 自动化构建一般包括自动下载源码，编译，测试，打包。他的工作原理可以参见下图:<br><img src=\"http://buildbot.net/img/overview.png\" alt=\"\"></p>\n<p>Buildbot的原理是git，SVN等源码服务器上代码发生变化后，buildmaster（服务端）通知连接到它上的buildslave（客户端）从git或SVN服务器上自动下载源码，编译，测试，打包。最后把各个buildslave的自动化构建的结果搜集起来在web上展现，或通过email,IRC等方式通知相应的项目开发人员。</p>\n<p>BuildBot的常用架构是一个Master和一堆Slave，Master负责对接VCS，然后管理调度各个Slave各司其职，收集Slave传回来的数据并且整理成报告。Slave负责按照Master发过来的命令跑各种任务，并将环境信息，结果，log文件等收集起来报告给Master。</p>\n<ul>\n<li>master  master就是Buildbot的核心，我们使用Buildbot所需要做的各种工作也是在Master上进行。Buildbot的使用方式就是在Master上编辑master.cfg文件，这其实是一个Python文件。使用者在里面定义对接的VCS，Schedule和Build的各种条件以及具体的Build任务，结果的收集报告方式等。</li>\n<li>slave 当slave连接到master后就会不断跟master进行通信。当有任务时，master会将命令逐个发送给slave执行。</li>\n</ul>\n<h3 id=\"2-Openwrt-buildbot\"><a href=\"#2-Openwrt-buildbot\" class=\"headerlink\" title=\"2. Openwrt buildbot\"></a>2. Openwrt buildbot</h3><p>我们可以访问如下链接， 可以看到openwrt 的buildbot 的情况。</p>\n<ul>\n<li>Phase 1: <a href=\"https://phase1.builds.lede-project.org/builders\" target=\"_blank\" rel=\"noopener\">target/subtargets</a>  </li>\n<li>Phase 2: <a href=\"https://phase2.builds.lede-project.org/builders\" target=\"_blank\" rel=\"noopener\">packages</a>  </li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/waterfall.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/grid.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/console%20view.png\" alt=\"\"></p>\n<h3 id=\"3-其他常见持续集成工具\"><a href=\"#3-其他常见持续集成工具\" class=\"headerlink\" title=\"3. 其他常见持续集成工具\"></a>3. 其他常见持续集成工具</h3><p>常见的持续集成工具有：  </p>\n<ul>\n<li><a href=\"https://jenkins.io/zh/\" target=\"_blank\" rel=\"noopener\">Jenkins</a> （java 方向）  </li>\n<li><a href=\"http://hudson-ci.org/\" target=\"_blank\" rel=\"noopener\">Hudson</a> (java 方向，jenkins 的前身)  </li>\n<li><a href=\"http://stridercd.com/\" target=\"_blank\" rel=\"noopener\">strider</a>  </li>\n<li><a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">travis</a> （对开源项目免费）  </li>\n<li><a href=\"https://codeship.com/\" target=\"_blank\" rel=\"noopener\">codeship</a>（对开源项目免费）  </li>\n</ul>\n<p>部署工具(将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器)  </p>\n<ul>\n<li><a href=\"https://www.ansible.com/\" target=\"_blank\" rel=\"noopener\">ansible</a>  </li>\n<li><a href=\"https://www.chef.io/products/chef-infra/\" target=\"_blank\" rel=\"noopener\">chef</a>  </li>\n<li><a href=\"https://puppet.com/\" target=\"_blank\" rel=\"noopener\">puppet</a>  </li>\n</ul>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://docs.buildbot.net/current/tutorial/\" target=\"_blank\" rel=\"noopener\">Buildbot Tutorial</a><br><a href=\"https://www.cnblogs.com/lkiversonlk/p/4878129.html\" target=\"_blank\" rel=\"noopener\">Buildbot初探</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/l-buildbot/index.html\" target=\"_blank\" rel=\"noopener\">使用 Buildot 实现持续集成</a><br><a href=\"https://blog.csdn.net/LSMEGR/article/details/53618045\" target=\"_blank\" rel=\"noopener\">buildbot自动化测试工具安装及快速入门</a><br><a href=\"https://www.cnblogs.com/xing901022/p/4414263.html\" target=\"_blank\" rel=\"noopener\">持续集成的魅力：工具推荐</a><br><a href=\"http://cloud.51cto.com/art/201508/487605.htm\" target=\"_blank\" rel=\"noopener\">六款不容错过的开源持续集成工具</a><br><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">持续集成是什么？</a>  </p>\n","site":{"data":{}},"excerpt":"<p>在openwrt 官网上看到buildbot， 他以此来完成在pull 代码之后，自动编译的工作并产出报告或者邮件通知等。<br><a href=\"http://buildbot.net/\" target=\"_blank\" rel=\"noopener\">buildbot官网</a></p>\n<p>持续集成（Continuous Integration，CI）的主要优势是，能够通过软件的自动化构建以及测试和软件度量标准（可选）精简品质保证周期。每次更改源代码并为项目生命期提供即时反馈和报告。</p>","more":"<h3 id=\"1-buildbot-简介\"><a href=\"#1-buildbot-简介\" class=\"headerlink\" title=\"1. buildbot 简介\"></a>1. buildbot 简介</h3><p>BuildBot是一个开源的基于python的持续集成系统，BuildBot用python写的，该python程序只依赖python环境和Twisted（一个python网络框架），可以在很多平台运行。 自动化构建一般包括自动下载源码，编译，测试，打包。他的工作原理可以参见下图:<br><img src=\"http://buildbot.net/img/overview.png\" alt=\"\"></p>\n<p>Buildbot的原理是git，SVN等源码服务器上代码发生变化后，buildmaster（服务端）通知连接到它上的buildslave（客户端）从git或SVN服务器上自动下载源码，编译，测试，打包。最后把各个buildslave的自动化构建的结果搜集起来在web上展现，或通过email,IRC等方式通知相应的项目开发人员。</p>\n<p>BuildBot的常用架构是一个Master和一堆Slave，Master负责对接VCS，然后管理调度各个Slave各司其职，收集Slave传回来的数据并且整理成报告。Slave负责按照Master发过来的命令跑各种任务，并将环境信息，结果，log文件等收集起来报告给Master。</p>\n<ul>\n<li>master  master就是Buildbot的核心，我们使用Buildbot所需要做的各种工作也是在Master上进行。Buildbot的使用方式就是在Master上编辑master.cfg文件，这其实是一个Python文件。使用者在里面定义对接的VCS，Schedule和Build的各种条件以及具体的Build任务，结果的收集报告方式等。</li>\n<li>slave 当slave连接到master后就会不断跟master进行通信。当有任务时，master会将命令逐个发送给slave执行。</li>\n</ul>\n<h3 id=\"2-Openwrt-buildbot\"><a href=\"#2-Openwrt-buildbot\" class=\"headerlink\" title=\"2. Openwrt buildbot\"></a>2. Openwrt buildbot</h3><p>我们可以访问如下链接， 可以看到openwrt 的buildbot 的情况。</p>\n<ul>\n<li>Phase 1: <a href=\"https://phase1.builds.lede-project.org/builders\" target=\"_blank\" rel=\"noopener\">target/subtargets</a>  </li>\n<li>Phase 2: <a href=\"https://phase2.builds.lede-project.org/builders\" target=\"_blank\" rel=\"noopener\">packages</a>  </li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/waterfall.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/grid.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/buildbot/console%20view.png\" alt=\"\"></p>\n<h3 id=\"3-其他常见持续集成工具\"><a href=\"#3-其他常见持续集成工具\" class=\"headerlink\" title=\"3. 其他常见持续集成工具\"></a>3. 其他常见持续集成工具</h3><p>常见的持续集成工具有：  </p>\n<ul>\n<li><a href=\"https://jenkins.io/zh/\" target=\"_blank\" rel=\"noopener\">Jenkins</a> （java 方向）  </li>\n<li><a href=\"http://hudson-ci.org/\" target=\"_blank\" rel=\"noopener\">Hudson</a> (java 方向，jenkins 的前身)  </li>\n<li><a href=\"http://stridercd.com/\" target=\"_blank\" rel=\"noopener\">strider</a>  </li>\n<li><a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">travis</a> （对开源项目免费）  </li>\n<li><a href=\"https://codeship.com/\" target=\"_blank\" rel=\"noopener\">codeship</a>（对开源项目免费）  </li>\n</ul>\n<p>部署工具(将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器)  </p>\n<ul>\n<li><a href=\"https://www.ansible.com/\" target=\"_blank\" rel=\"noopener\">ansible</a>  </li>\n<li><a href=\"https://www.chef.io/products/chef-infra/\" target=\"_blank\" rel=\"noopener\">chef</a>  </li>\n<li><a href=\"https://puppet.com/\" target=\"_blank\" rel=\"noopener\">puppet</a>  </li>\n</ul>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://docs.buildbot.net/current/tutorial/\" target=\"_blank\" rel=\"noopener\">Buildbot Tutorial</a><br><a href=\"https://www.cnblogs.com/lkiversonlk/p/4878129.html\" target=\"_blank\" rel=\"noopener\">Buildbot初探</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/l-buildbot/index.html\" target=\"_blank\" rel=\"noopener\">使用 Buildot 实现持续集成</a><br><a href=\"https://blog.csdn.net/LSMEGR/article/details/53618045\" target=\"_blank\" rel=\"noopener\">buildbot自动化测试工具安装及快速入门</a><br><a href=\"https://www.cnblogs.com/xing901022/p/4414263.html\" target=\"_blank\" rel=\"noopener\">持续集成的魅力：工具推荐</a><br><a href=\"http://cloud.51cto.com/art/201508/487605.htm\" target=\"_blank\" rel=\"noopener\">六款不容错过的开源持续集成工具</a><br><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">持续集成是什么？</a>  </p>"},{"title":"bootgraph","date":"2020-04-09T09:35:35.000Z","_content":"\nbootgraph 主要用于量度kernel init function 的占用时间。\n\n<!--more-->\n## 1. Prepare\n### 1.1. 配置Kernel\nEnabel kernel 如下配置： CONFIG_PRINTK_TIME & CONFIG_KALLSYMS\n![CONFIG_PRINTK_TIME](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/CONFIG_PRINTK_TIME.png)\n\n![CONFIG_KALLSYMS](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/CONFIG_KALLSYMS.png)\n\n### 1.2. 启动参数设定\n```bash\nbootargs = \"initcall_debug\"\n```\n\n## 2. Usage\n### 2.1. platform\n平台正常启动后， 使用如下命令收集LOG：\n\n```bash\ndmesg > boot.log\n```\n\n### 2.2. host\n在Linux src 下使用脚本生成图片：\n```bash\nlinux/scripts/bootgraph.pl boot.log > boot.svg\n```\n\n## 3. Example\n[boot_log](https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/boot.log)\n[bootgraph_boot_svg](https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/boot.svg)\n\n![bootgraph_example](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/bootgraph_example.png)\n\n## Reference\n[A Pragmatic Guide to Boot-Time Optimization - Chris Simmonds, Consultant](https://www.bilibili.com/video/BV1y4411X7e2)","source":"_posts/bootgraph.md","raw":"---\ntitle: bootgraph\ndate: 2020-04-09 17:35:35\ntags: optimization\ncategories: tools\n---\n\nbootgraph 主要用于量度kernel init function 的占用时间。\n\n<!--more-->\n## 1. Prepare\n### 1.1. 配置Kernel\nEnabel kernel 如下配置： CONFIG_PRINTK_TIME & CONFIG_KALLSYMS\n![CONFIG_PRINTK_TIME](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/CONFIG_PRINTK_TIME.png)\n\n![CONFIG_KALLSYMS](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/CONFIG_KALLSYMS.png)\n\n### 1.2. 启动参数设定\n```bash\nbootargs = \"initcall_debug\"\n```\n\n## 2. Usage\n### 2.1. platform\n平台正常启动后， 使用如下命令收集LOG：\n\n```bash\ndmesg > boot.log\n```\n\n### 2.2. host\n在Linux src 下使用脚本生成图片：\n```bash\nlinux/scripts/bootgraph.pl boot.log > boot.svg\n```\n\n## 3. Example\n[boot_log](https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/boot.log)\n[bootgraph_boot_svg](https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/boot.svg)\n\n![bootgraph_example](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/bootgraph_example.png)\n\n## Reference\n[A Pragmatic Guide to Boot-Time Optimization - Chris Simmonds, Consultant](https://www.bilibili.com/video/BV1y4411X7e2)","slug":"bootgraph","published":1,"updated":"2020-04-09T10:20:49.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pt001jzkgrwnpkoidz","content":"<p>bootgraph 主要用于量度kernel init function 的占用时间。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-Prepare\"><a href=\"#1-Prepare\" class=\"headerlink\" title=\"1. Prepare\"></a>1. Prepare</h2><h3 id=\"1-1-配置Kernel\"><a href=\"#1-1-配置Kernel\" class=\"headerlink\" title=\"1.1. 配置Kernel\"></a>1.1. 配置Kernel</h3><p>Enabel kernel 如下配置： CONFIG_PRINTK_TIME &amp; CONFIG_KALLSYMS<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/CONFIG_PRINTK_TIME.png\" alt=\"CONFIG_PRINTK_TIME\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/CONFIG_KALLSYMS.png\" alt=\"CONFIG_KALLSYMS\"></p>\n<h3 id=\"1-2-启动参数设定\"><a href=\"#1-2-启动参数设定\" class=\"headerlink\" title=\"1.2. 启动参数设定\"></a>1.2. 启动参数设定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bootargs = <span class=\"string\">\"initcall_debug\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-Usage\"><a href=\"#2-Usage\" class=\"headerlink\" title=\"2. Usage\"></a>2. Usage</h2><h3 id=\"2-1-platform\"><a href=\"#2-1-platform\" class=\"headerlink\" title=\"2.1. platform\"></a>2.1. platform</h3><p>平台正常启动后， 使用如下命令收集LOG：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmesg &gt; boot.log</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-host\"><a href=\"#2-2-host\" class=\"headerlink\" title=\"2.2. host\"></a>2.2. host</h3><p>在Linux src 下使用脚本生成图片：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linux/scripts/bootgraph.pl boot.log &gt; boot.svg</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-Example\"><a href=\"#3-Example\" class=\"headerlink\" title=\"3. Example\"></a>3. Example</h2><p><a href=\"https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/boot.log\" target=\"_blank\" rel=\"noopener\">boot_log</a><br><a href=\"https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/boot.svg\" target=\"_blank\" rel=\"noopener\">bootgraph_boot_svg</a></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/bootgraph_example.png\" alt=\"bootgraph_example\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.bilibili.com/video/BV1y4411X7e2\" target=\"_blank\" rel=\"noopener\">A Pragmatic Guide to Boot-Time Optimization - Chris Simmonds, Consultant</a></p>\n","site":{"data":{}},"excerpt":"<p>bootgraph 主要用于量度kernel init function 的占用时间。</p>","more":"<h2 id=\"1-Prepare\"><a href=\"#1-Prepare\" class=\"headerlink\" title=\"1. Prepare\"></a>1. Prepare</h2><h3 id=\"1-1-配置Kernel\"><a href=\"#1-1-配置Kernel\" class=\"headerlink\" title=\"1.1. 配置Kernel\"></a>1.1. 配置Kernel</h3><p>Enabel kernel 如下配置： CONFIG_PRINTK_TIME &amp; CONFIG_KALLSYMS<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/CONFIG_PRINTK_TIME.png\" alt=\"CONFIG_PRINTK_TIME\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/CONFIG_KALLSYMS.png\" alt=\"CONFIG_KALLSYMS\"></p>\n<h3 id=\"1-2-启动参数设定\"><a href=\"#1-2-启动参数设定\" class=\"headerlink\" title=\"1.2. 启动参数设定\"></a>1.2. 启动参数设定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bootargs = <span class=\"string\">\"initcall_debug\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-Usage\"><a href=\"#2-Usage\" class=\"headerlink\" title=\"2. Usage\"></a>2. Usage</h2><h3 id=\"2-1-platform\"><a href=\"#2-1-platform\" class=\"headerlink\" title=\"2.1. platform\"></a>2.1. platform</h3><p>平台正常启动后， 使用如下命令收集LOG：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmesg &gt; boot.log</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-host\"><a href=\"#2-2-host\" class=\"headerlink\" title=\"2.2. host\"></a>2.2. host</h3><p>在Linux src 下使用脚本生成图片：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linux/scripts/bootgraph.pl boot.log &gt; boot.svg</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-Example\"><a href=\"#3-Example\" class=\"headerlink\" title=\"3. Example\"></a>3. Example</h2><p><a href=\"https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/boot.log\" target=\"_blank\" rel=\"noopener\">boot_log</a><br><a href=\"https://github.com/JShell07/jshell07.github.io/blob/master/images/tools/boot_time/boot.svg\" target=\"_blank\" rel=\"noopener\">bootgraph_boot_svg</a></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/boot_time/bootgraph_example.png\" alt=\"bootgraph_example\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.bilibili.com/video/BV1y4411X7e2\" target=\"_blank\" rel=\"noopener\">A Pragmatic Guide to Boot-Time Optimization - Chris Simmonds, Consultant</a></p>"},{"title":"incr.zsh","date":"2017-08-14T15:55:39.000Z","_content":"\n# incr.zsh\nincr.zsh -- zsh模式下自动补全指令或目录\n本身zsh 模式下，在我们双击Table 按键时候，会出现依次轮休的效果。但是，习惯于bash 的table 显示，个人不是很喜欢这个设定。\n\nEnable incr.zsh 的zsh 模式效果图如下：\n![](http://mimosa-pudica.net/img/zsh.gif)\n---\n<!-- more -->\nincr.zsh 的优点：\n- 自动补全\n- 大小写纠正\n- 待发掘...\n\n# Enable Steps\n1. download incr.zsh\n4. enable incr.zsh\n\n## download incr.zsh\n下载incr.zsh文件可以从[incr.zsh官网](http://mimosa-pudica.net/zsh-incremental.html)获得，也可以直接复制如下代码：\n\n``` zsh\n# Incremental completion for zsh\n# by y.fujii <y-fujii at mimosa-pudica.net>, public domain\n\nautoload -U compinit\nzle -N self-insert self-insert-incr\nzle -N vi-cmd-mode-incr\nzle -N vi-backward-delete-char-incr\nzle -N backward-delete-char-incr\nzle -N expand-or-complete-prefix-incr\ncompinit\n\nbindkey -M viins '^[' vi-cmd-mode-incr\nbindkey -M viins '^h' vi-backward-delete-char-incr\nbindkey -M viins '^?' vi-backward-delete-char-incr\nbindkey -M viins '^i' expand-or-complete-prefix-incr\nbindkey -M emacs '^h' backward-delete-char-incr\nbindkey -M emacs '^?' backward-delete-char-incr\nbindkey -M emacs '^i' expand-or-complete-prefix-incr\n\nunsetopt automenu\ncompdef -d scp\ncompdef -d tar\ncompdef -d make\ncompdef -d java\ncompdef -d svn\ncompdef -d cvs\n\n# TODO:\n#     cp dir/\n\nnow_predict=0\n\nfunction limit-completion\n{\n\tif ((compstate[nmatches] <= 1)); then\n\t\tzle -M \"\"\n\telif ((compstate[list_lines] > 6)); then\n\t\tcompstate[list]=\"\"\n\t\tzle -M \"too many matches.\"\n\tfi\n}\n\nfunction correct-prediction\n{\n\tif ((now_predict == 1)); then\n\t\tif [[ \"$BUFFER\" != \"$buffer_prd\" ]] || ((CURSOR != cursor_org)); then\n\t\t\tnow_predict=0\n\t\tfi\n\tfi\n}\n\nfunction remove-prediction\n{\n\tif ((now_predict == 1)); then\n\t\tBUFFER=\"$buffer_org\"\n\t\tnow_predict=0\n\tfi\n}\n\nfunction show-prediction\n{\n\t# assert(now_predict == 0)\n\tif\n\t\t((PENDING == 0)) &&\n\t\t((CURSOR > 1)) &&\n\t\t[[ \"$PREBUFFER\" == \"\" ]] &&\n\t\t[[ \"$BUFFER[CURSOR]\" != \" \" ]]\n\tthen\n\t\tcursor_org=\"$CURSOR\"\n\t\tbuffer_org=\"$BUFFER\"\n\t\tcomppostfuncs=(limit-completion)\n\t\tzle complete-word\n\t\tcursor_prd=\"$CURSOR\"\n\t\tbuffer_prd=\"$BUFFER\"\n\t\tif [[ \"$buffer_org[1,cursor_org]\" == \"$buffer_prd[1,cursor_org]\" ]]; then\n\t\t\tCURSOR=\"$cursor_org\"\n\t\t\tif [[ \"$buffer_org\" != \"$buffer_prd\" ]] || ((cursor_org != cursor_prd)); then\n\t\t\t\tnow_predict=1\n\t\t\tfi\n\t\telse\n\t\t\tBUFFER=\"$buffer_org\"\n\t\t\tCURSOR=\"$cursor_org\"\n\t\tfi\n\t\techo -n \"\\e[32m\"\n\telse\n\t\tzle -M \"\"\n\tfi\n}\n\nfunction preexec\n{\n\techo -n \"\\e[39m\"\n}\n\nfunction vi-cmd-mode-incr\n{\n\tcorrect-prediction\n\tremove-prediction\n\tzle vi-cmd-mode\n}\n\nfunction self-insert-incr\n{\n\tcorrect-prediction\n\tremove-prediction\n\tif zle .self-insert; then\n\t\tshow-prediction\n\tfi\n}\n\nfunction vi-backward-delete-char-incr\n{\n\tcorrect-prediction\n\tremove-prediction\n\tif zle vi-backward-delete-char; then\n\t\tshow-prediction\n\tfi\n}\n\nfunction backward-delete-char-incr\n{\n\tcorrect-prediction\n\tremove-prediction\n\tif zle backward-delete-char; then\n\t\tshow-prediction\n\tfi\n}\n\nfunction expand-or-complete-prefix-incr\n{\n\tcorrect-prediction\n\tif ((now_predict == 1)); then\n\t\tCURSOR=\"$cursor_prd\"\n\t\tnow_predict=0\n\t\tcomppostfuncs=(limit-completion)\n\t\tzle list-choices\n\telse\n\t\tremove-prediction\n\t\tzle expand-or-complete-prefix\n\tfi\n}\n```\n\n## enable incr.zsh\n新建文件夹incr,将incr.zsh放于其中，之后将该文件夹放于*~/.oh-my-zsh/plugins/* 下。\n**确保incr.zsh  具有\"x\" 权限**\n\n修改.zshrc 文件， enable incr.zsh\n``` bash\nsource ~/.oh-my-zsh/plugins/incr/incr*.zsh\n```","source":"_posts/incr-zsh.md","raw":"---\ntitle: incr.zsh\ndate: 2017-08-14 23:55:39\ntags: zsh\ncategories: tools\n---\n\n# incr.zsh\nincr.zsh -- zsh模式下自动补全指令或目录\n本身zsh 模式下，在我们双击Table 按键时候，会出现依次轮休的效果。但是，习惯于bash 的table 显示，个人不是很喜欢这个设定。\n\nEnable incr.zsh 的zsh 模式效果图如下：\n![](http://mimosa-pudica.net/img/zsh.gif)\n---\n<!-- more -->\nincr.zsh 的优点：\n- 自动补全\n- 大小写纠正\n- 待发掘...\n\n# Enable Steps\n1. download incr.zsh\n4. enable incr.zsh\n\n## download incr.zsh\n下载incr.zsh文件可以从[incr.zsh官网](http://mimosa-pudica.net/zsh-incremental.html)获得，也可以直接复制如下代码：\n\n``` zsh\n# Incremental completion for zsh\n# by y.fujii <y-fujii at mimosa-pudica.net>, public domain\n\nautoload -U compinit\nzle -N self-insert self-insert-incr\nzle -N vi-cmd-mode-incr\nzle -N vi-backward-delete-char-incr\nzle -N backward-delete-char-incr\nzle -N expand-or-complete-prefix-incr\ncompinit\n\nbindkey -M viins '^[' vi-cmd-mode-incr\nbindkey -M viins '^h' vi-backward-delete-char-incr\nbindkey -M viins '^?' vi-backward-delete-char-incr\nbindkey -M viins '^i' expand-or-complete-prefix-incr\nbindkey -M emacs '^h' backward-delete-char-incr\nbindkey -M emacs '^?' backward-delete-char-incr\nbindkey -M emacs '^i' expand-or-complete-prefix-incr\n\nunsetopt automenu\ncompdef -d scp\ncompdef -d tar\ncompdef -d make\ncompdef -d java\ncompdef -d svn\ncompdef -d cvs\n\n# TODO:\n#     cp dir/\n\nnow_predict=0\n\nfunction limit-completion\n{\n\tif ((compstate[nmatches] <= 1)); then\n\t\tzle -M \"\"\n\telif ((compstate[list_lines] > 6)); then\n\t\tcompstate[list]=\"\"\n\t\tzle -M \"too many matches.\"\n\tfi\n}\n\nfunction correct-prediction\n{\n\tif ((now_predict == 1)); then\n\t\tif [[ \"$BUFFER\" != \"$buffer_prd\" ]] || ((CURSOR != cursor_org)); then\n\t\t\tnow_predict=0\n\t\tfi\n\tfi\n}\n\nfunction remove-prediction\n{\n\tif ((now_predict == 1)); then\n\t\tBUFFER=\"$buffer_org\"\n\t\tnow_predict=0\n\tfi\n}\n\nfunction show-prediction\n{\n\t# assert(now_predict == 0)\n\tif\n\t\t((PENDING == 0)) &&\n\t\t((CURSOR > 1)) &&\n\t\t[[ \"$PREBUFFER\" == \"\" ]] &&\n\t\t[[ \"$BUFFER[CURSOR]\" != \" \" ]]\n\tthen\n\t\tcursor_org=\"$CURSOR\"\n\t\tbuffer_org=\"$BUFFER\"\n\t\tcomppostfuncs=(limit-completion)\n\t\tzle complete-word\n\t\tcursor_prd=\"$CURSOR\"\n\t\tbuffer_prd=\"$BUFFER\"\n\t\tif [[ \"$buffer_org[1,cursor_org]\" == \"$buffer_prd[1,cursor_org]\" ]]; then\n\t\t\tCURSOR=\"$cursor_org\"\n\t\t\tif [[ \"$buffer_org\" != \"$buffer_prd\" ]] || ((cursor_org != cursor_prd)); then\n\t\t\t\tnow_predict=1\n\t\t\tfi\n\t\telse\n\t\t\tBUFFER=\"$buffer_org\"\n\t\t\tCURSOR=\"$cursor_org\"\n\t\tfi\n\t\techo -n \"\\e[32m\"\n\telse\n\t\tzle -M \"\"\n\tfi\n}\n\nfunction preexec\n{\n\techo -n \"\\e[39m\"\n}\n\nfunction vi-cmd-mode-incr\n{\n\tcorrect-prediction\n\tremove-prediction\n\tzle vi-cmd-mode\n}\n\nfunction self-insert-incr\n{\n\tcorrect-prediction\n\tremove-prediction\n\tif zle .self-insert; then\n\t\tshow-prediction\n\tfi\n}\n\nfunction vi-backward-delete-char-incr\n{\n\tcorrect-prediction\n\tremove-prediction\n\tif zle vi-backward-delete-char; then\n\t\tshow-prediction\n\tfi\n}\n\nfunction backward-delete-char-incr\n{\n\tcorrect-prediction\n\tremove-prediction\n\tif zle backward-delete-char; then\n\t\tshow-prediction\n\tfi\n}\n\nfunction expand-or-complete-prefix-incr\n{\n\tcorrect-prediction\n\tif ((now_predict == 1)); then\n\t\tCURSOR=\"$cursor_prd\"\n\t\tnow_predict=0\n\t\tcomppostfuncs=(limit-completion)\n\t\tzle list-choices\n\telse\n\t\tremove-prediction\n\t\tzle expand-or-complete-prefix\n\tfi\n}\n```\n\n## enable incr.zsh\n新建文件夹incr,将incr.zsh放于其中，之后将该文件夹放于*~/.oh-my-zsh/plugins/* 下。\n**确保incr.zsh  具有\"x\" 权限**\n\n修改.zshrc 文件， enable incr.zsh\n``` bash\nsource ~/.oh-my-zsh/plugins/incr/incr*.zsh\n```","slug":"incr-zsh","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pu001kzkgrma99fprh","content":"<h1 id=\"incr-zsh\"><a href=\"#incr-zsh\" class=\"headerlink\" title=\"incr.zsh\"></a>incr.zsh</h1><p>incr.zsh – zsh模式下自动补全指令或目录<br>本身zsh 模式下，在我们双击Table 按键时候，会出现依次轮休的效果。但是，习惯于bash 的table 显示，个人不是很喜欢这个设定。</p>\n<p>Enable incr.zsh 的zsh 模式效果图如下：</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://mimosa-pudica.net/img/zsh.gif\" alt=\"\"></h2><a id=\"more\"></a>\n<p>incr.zsh 的优点：</p>\n<ul>\n<li>自动补全</li>\n<li>大小写纠正</li>\n<li>待发掘…</li>\n</ul>\n<h1 id=\"Enable-Steps\"><a href=\"#Enable-Steps\" class=\"headerlink\" title=\"Enable Steps\"></a>Enable Steps</h1><ol>\n<li>download incr.zsh</li>\n<li>enable incr.zsh</li>\n</ol>\n<h2 id=\"download-incr-zsh\"><a href=\"#download-incr-zsh\" class=\"headerlink\" title=\"download incr.zsh\"></a>download incr.zsh</h2><p>下载incr.zsh文件可以从<a href=\"http://mimosa-pudica.net/zsh-incremental.html\" target=\"_blank\" rel=\"noopener\">incr.zsh官网</a>获得，也可以直接复制如下代码：</p>\n<figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Incremental completion for zsh</span></span><br><span class=\"line\"><span class=\"comment\"># by y.fujii &lt;y-fujii at mimosa-pudica.net&gt;, public domain</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">autoload</span> -U compinit</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N self-insert self-insert-incr</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N vi-cmd-mode-incr</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N vi-backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N expand-or-complete-prefix-incr</span><br><span class=\"line\">compinit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M viins <span class=\"string\">'^['</span> vi-cmd-mode-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M viins <span class=\"string\">'^h'</span> vi-backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M viins <span class=\"string\">'^?'</span> vi-backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M viins <span class=\"string\">'^i'</span> expand-or-complete-prefix-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M emacs <span class=\"string\">'^h'</span> backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M emacs <span class=\"string\">'^?'</span> backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M emacs <span class=\"string\">'^i'</span> expand-or-complete-prefix-incr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unsetopt</span> automenu</span><br><span class=\"line\">compdef -d scp</span><br><span class=\"line\">compdef -d tar</span><br><span class=\"line\">compdef -d make</span><br><span class=\"line\">compdef -d java</span><br><span class=\"line\">compdef -d svn</span><br><span class=\"line\">compdef -d cvs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\"><span class=\"comment\">#     cp dir/</span></span><br><span class=\"line\"></span><br><span class=\"line\">now_predict=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"built_in\">limit</span>-completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((compstate[nmatches] &lt;= 1)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> -M <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> ((compstate[list_lines] &gt; 6)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tcompstate[list]=<span class=\"string\">\"\"</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> -M <span class=\"string\">\"too many matches.\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> correct-prediction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((now_predict == 1)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [[ <span class=\"string\">\"<span class=\"variable\">$BUFFER</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$buffer_prd</span>\"</span> ]] || ((CURSOR != cursor_org)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\tnow_predict=0</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> remove-prediction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((now_predict == 1)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tBUFFER=<span class=\"string\">\"<span class=\"variable\">$buffer_org</span>\"</span></span><br><span class=\"line\">\t\tnow_predict=0</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> show-prediction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\"># assert(now_predict == 0)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span></span><br><span class=\"line\">\t\t((PENDING == 0)) &amp;&amp;</span><br><span class=\"line\">\t\t((CURSOR &gt; 1)) &amp;&amp;</span><br><span class=\"line\">\t\t[[ <span class=\"string\">\"<span class=\"variable\">$PREBUFFER</span>\"</span> == <span class=\"string\">\"\"</span> ]] &amp;&amp;</span><br><span class=\"line\">\t\t[[ <span class=\"string\">\"<span class=\"variable\">$BUFFER</span>[CURSOR]\"</span> != <span class=\"string\">\" \"</span> ]]</span><br><span class=\"line\">\t<span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tcursor_org=<span class=\"string\">\"<span class=\"variable\">$CURSOR</span>\"</span></span><br><span class=\"line\">\t\tbuffer_org=<span class=\"string\">\"<span class=\"variable\">$BUFFER</span>\"</span></span><br><span class=\"line\">\t\tcomppostfuncs=(<span class=\"built_in\">limit</span>-completion)</span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> complete-word</span><br><span class=\"line\">\t\tcursor_prd=<span class=\"string\">\"<span class=\"variable\">$CURSOR</span>\"</span></span><br><span class=\"line\">\t\tbuffer_prd=<span class=\"string\">\"<span class=\"variable\">$BUFFER</span>\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [[ <span class=\"string\">\"<span class=\"variable\">$buffer_org</span>[1,cursor_org]\"</span> == <span class=\"string\">\"<span class=\"variable\">$buffer_prd</span>[1,cursor_org]\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\tCURSOR=<span class=\"string\">\"<span class=\"variable\">$cursor_org</span>\"</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> [[ <span class=\"string\">\"<span class=\"variable\">$buffer_org</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$buffer_prd</span>\"</span> ]] || ((cursor_org != cursor_prd)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t\tnow_predict=1</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tBUFFER=<span class=\"string\">\"<span class=\"variable\">$buffer_org</span>\"</span></span><br><span class=\"line\">\t\t\tCURSOR=<span class=\"string\">\"<span class=\"variable\">$cursor_org</span>\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">echo</span> -n <span class=\"string\">\"\\e[32m\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> -M <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> preexec</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> -n <span class=\"string\">\"\\e[39m\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> vi-cmd-mode-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\tremove-prediction</span><br><span class=\"line\">\t<span class=\"built_in\">zle</span> vi-cmd-mode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> self-insert-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\tremove-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">zle</span> .self-insert; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tshow-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> vi-backward-delete-char-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\tremove-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">zle</span> vi-backward-delete-char; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tshow-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> backward-delete-char-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\tremove-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">zle</span> backward-delete-char; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tshow-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> expand-or-complete-prefix-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((now_predict == 1)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tCURSOR=<span class=\"string\">\"<span class=\"variable\">$cursor_prd</span>\"</span></span><br><span class=\"line\">\t\tnow_predict=0</span><br><span class=\"line\">\t\tcomppostfuncs=(<span class=\"built_in\">limit</span>-completion)</span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> list-choices</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tremove-prediction</span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> expand-or-complete-prefix</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"enable-incr-zsh\"><a href=\"#enable-incr-zsh\" class=\"headerlink\" title=\"enable incr.zsh\"></a>enable incr.zsh</h2><p>新建文件夹incr,将incr.zsh放于其中，之后将该文件夹放于<em>~/.oh-my-zsh/plugins/</em> 下。<br><strong>确保incr.zsh  具有”x” 权限</strong></p>\n<p>修改.zshrc 文件， enable incr.zsh<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.oh-my-zsh/plugins/incr/incr*.zsh</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"incr-zsh\"><a href=\"#incr-zsh\" class=\"headerlink\" title=\"incr.zsh\"></a>incr.zsh</h1><p>incr.zsh – zsh模式下自动补全指令或目录<br>本身zsh 模式下，在我们双击Table 按键时候，会出现依次轮休的效果。但是，习惯于bash 的table 显示，个人不是很喜欢这个设定。</p>\n<p>Enable incr.zsh 的zsh 模式效果图如下：</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://mimosa-pudica.net/img/zsh.gif\" alt=\"\"></h2>","more":"<p>incr.zsh 的优点：</p>\n<ul>\n<li>自动补全</li>\n<li>大小写纠正</li>\n<li>待发掘…</li>\n</ul>\n<h1 id=\"Enable-Steps\"><a href=\"#Enable-Steps\" class=\"headerlink\" title=\"Enable Steps\"></a>Enable Steps</h1><ol>\n<li>download incr.zsh</li>\n<li>enable incr.zsh</li>\n</ol>\n<h2 id=\"download-incr-zsh\"><a href=\"#download-incr-zsh\" class=\"headerlink\" title=\"download incr.zsh\"></a>download incr.zsh</h2><p>下载incr.zsh文件可以从<a href=\"http://mimosa-pudica.net/zsh-incremental.html\" target=\"_blank\" rel=\"noopener\">incr.zsh官网</a>获得，也可以直接复制如下代码：</p>\n<figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Incremental completion for zsh</span></span><br><span class=\"line\"><span class=\"comment\"># by y.fujii &lt;y-fujii at mimosa-pudica.net&gt;, public domain</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">autoload</span> -U compinit</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N self-insert self-insert-incr</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N vi-cmd-mode-incr</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N vi-backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">zle</span> -N expand-or-complete-prefix-incr</span><br><span class=\"line\">compinit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M viins <span class=\"string\">'^['</span> vi-cmd-mode-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M viins <span class=\"string\">'^h'</span> vi-backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M viins <span class=\"string\">'^?'</span> vi-backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M viins <span class=\"string\">'^i'</span> expand-or-complete-prefix-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M emacs <span class=\"string\">'^h'</span> backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M emacs <span class=\"string\">'^?'</span> backward-delete-char-incr</span><br><span class=\"line\"><span class=\"built_in\">bindkey</span> -M emacs <span class=\"string\">'^i'</span> expand-or-complete-prefix-incr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unsetopt</span> automenu</span><br><span class=\"line\">compdef -d scp</span><br><span class=\"line\">compdef -d tar</span><br><span class=\"line\">compdef -d make</span><br><span class=\"line\">compdef -d java</span><br><span class=\"line\">compdef -d svn</span><br><span class=\"line\">compdef -d cvs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\"><span class=\"comment\">#     cp dir/</span></span><br><span class=\"line\"></span><br><span class=\"line\">now_predict=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"built_in\">limit</span>-completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((compstate[nmatches] &lt;= 1)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> -M <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> ((compstate[list_lines] &gt; 6)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tcompstate[list]=<span class=\"string\">\"\"</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> -M <span class=\"string\">\"too many matches.\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> correct-prediction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((now_predict == 1)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [[ <span class=\"string\">\"<span class=\"variable\">$BUFFER</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$buffer_prd</span>\"</span> ]] || ((CURSOR != cursor_org)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\tnow_predict=0</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> remove-prediction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((now_predict == 1)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tBUFFER=<span class=\"string\">\"<span class=\"variable\">$buffer_org</span>\"</span></span><br><span class=\"line\">\t\tnow_predict=0</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> show-prediction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\"># assert(now_predict == 0)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span></span><br><span class=\"line\">\t\t((PENDING == 0)) &amp;&amp;</span><br><span class=\"line\">\t\t((CURSOR &gt; 1)) &amp;&amp;</span><br><span class=\"line\">\t\t[[ <span class=\"string\">\"<span class=\"variable\">$PREBUFFER</span>\"</span> == <span class=\"string\">\"\"</span> ]] &amp;&amp;</span><br><span class=\"line\">\t\t[[ <span class=\"string\">\"<span class=\"variable\">$BUFFER</span>[CURSOR]\"</span> != <span class=\"string\">\" \"</span> ]]</span><br><span class=\"line\">\t<span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tcursor_org=<span class=\"string\">\"<span class=\"variable\">$CURSOR</span>\"</span></span><br><span class=\"line\">\t\tbuffer_org=<span class=\"string\">\"<span class=\"variable\">$BUFFER</span>\"</span></span><br><span class=\"line\">\t\tcomppostfuncs=(<span class=\"built_in\">limit</span>-completion)</span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> complete-word</span><br><span class=\"line\">\t\tcursor_prd=<span class=\"string\">\"<span class=\"variable\">$CURSOR</span>\"</span></span><br><span class=\"line\">\t\tbuffer_prd=<span class=\"string\">\"<span class=\"variable\">$BUFFER</span>\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [[ <span class=\"string\">\"<span class=\"variable\">$buffer_org</span>[1,cursor_org]\"</span> == <span class=\"string\">\"<span class=\"variable\">$buffer_prd</span>[1,cursor_org]\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\tCURSOR=<span class=\"string\">\"<span class=\"variable\">$cursor_org</span>\"</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> [[ <span class=\"string\">\"<span class=\"variable\">$buffer_org</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$buffer_prd</span>\"</span> ]] || ((cursor_org != cursor_prd)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t\tnow_predict=1</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tBUFFER=<span class=\"string\">\"<span class=\"variable\">$buffer_org</span>\"</span></span><br><span class=\"line\">\t\t\tCURSOR=<span class=\"string\">\"<span class=\"variable\">$cursor_org</span>\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">echo</span> -n <span class=\"string\">\"\\e[32m\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> -M <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> preexec</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> -n <span class=\"string\">\"\\e[39m\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> vi-cmd-mode-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\tremove-prediction</span><br><span class=\"line\">\t<span class=\"built_in\">zle</span> vi-cmd-mode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> self-insert-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\tremove-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">zle</span> .self-insert; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tshow-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> vi-backward-delete-char-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\tremove-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">zle</span> vi-backward-delete-char; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tshow-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> backward-delete-char-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\tremove-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">zle</span> backward-delete-char; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tshow-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> expand-or-complete-prefix-incr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcorrect-prediction</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((now_predict == 1)); <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\tCURSOR=<span class=\"string\">\"<span class=\"variable\">$cursor_prd</span>\"</span></span><br><span class=\"line\">\t\tnow_predict=0</span><br><span class=\"line\">\t\tcomppostfuncs=(<span class=\"built_in\">limit</span>-completion)</span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> list-choices</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tremove-prediction</span><br><span class=\"line\">\t\t<span class=\"built_in\">zle</span> expand-or-complete-prefix</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"enable-incr-zsh\"><a href=\"#enable-incr-zsh\" class=\"headerlink\" title=\"enable incr.zsh\"></a>enable incr.zsh</h2><p>新建文件夹incr,将incr.zsh放于其中，之后将该文件夹放于<em>~/.oh-my-zsh/plugins/</em> 下。<br><strong>确保incr.zsh  具有”x” 权限</strong></p>\n<p>修改.zshrc 文件， enable incr.zsh<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.oh-my-zsh/plugins/incr/incr*.zsh</span><br></pre></td></tr></table></figure></p>"},{"title":"hexo_add_search","date":"2019-07-04T01:29:56.000Z","_content":"\n## 1. 前言\n\n当博文慢慢变多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博客上去，所以添加一个本站内搜索功能是很有必要的。\n\n<!--more-->\n\n## 2. 安装插件\n\n```\nnpm install hexo-generator-searchdb --save\n```\n\n修改blog下的_config.yml文件，进行编辑。\n\n```\nsearch:\n    path: search.xml\n    field: post\n    format: html\n    limit: 10000\n````\n\n\n修改主题配置文件blog/themes/next下的_config.yml文件，进行编辑。\n\n```\nlocal_search:\n    enable: true\n```\n\n## 参看资料\n[hexo博客添加搜索功能](https://blog.csdn.net/qq_40265501/article/details/80030627)\n\n[Hexo博客添加站内搜索](https://www.ezlippi.com/blog/2017/02/hexo-search.html)\n\n[Hexo 博客添加本地搜索](https://www.chunqiuyiyu.com/2018/07/hexo-local-search.html)\n","source":"_posts/hexo-add-search.md","raw":"---\ntitle: hexo_add_search\ndate: 2019-07-04 09:29:56\ntags: hexo\ncategories: hexo\n---\n\n## 1. 前言\n\n当博文慢慢变多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博客上去，所以添加一个本站内搜索功能是很有必要的。\n\n<!--more-->\n\n## 2. 安装插件\n\n```\nnpm install hexo-generator-searchdb --save\n```\n\n修改blog下的_config.yml文件，进行编辑。\n\n```\nsearch:\n    path: search.xml\n    field: post\n    format: html\n    limit: 10000\n````\n\n\n修改主题配置文件blog/themes/next下的_config.yml文件，进行编辑。\n\n```\nlocal_search:\n    enable: true\n```\n\n## 参看资料\n[hexo博客添加搜索功能](https://blog.csdn.net/qq_40265501/article/details/80030627)\n\n[Hexo博客添加站内搜索](https://www.ezlippi.com/blog/2017/02/hexo-search.html)\n\n[Hexo 博客添加本地搜索](https://www.chunqiuyiyu.com/2018/07/hexo-local-search.html)\n","slug":"hexo-add-search","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pw001pzkgrae83yn75","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>当博文慢慢变多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博客上去，所以添加一个本站内搜索功能是很有必要的。</p>\n<a id=\"more\"></a>\n<h2 id=\"2-安装插件\"><a href=\"#2-安装插件\" class=\"headerlink\" title=\"2. 安装插件\"></a>2. 安装插件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>\n<p>修改blog下的_config.yml文件，进行编辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">    path: search.xml</span><br><span class=\"line\">    field: post</span><br><span class=\"line\">    format: html</span><br><span class=\"line\">    limit: 10000</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>修改主题配置文件blog/themes/next下的_config.yml文件，进行编辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">    enable: true</span><br></pre></td></tr></table></figure>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://blog.csdn.net/qq_40265501/article/details/80030627\" target=\"_blank\" rel=\"noopener\">hexo博客添加搜索功能</a></p>\n<p><a href=\"https://www.ezlippi.com/blog/2017/02/hexo-search.html\" target=\"_blank\" rel=\"noopener\">Hexo博客添加站内搜索</a></p>\n<p><a href=\"https://www.chunqiuyiyu.com/2018/07/hexo-local-search.html\" target=\"_blank\" rel=\"noopener\">Hexo 博客添加本地搜索</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>当博文慢慢变多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博客上去，所以添加一个本站内搜索功能是很有必要的。</p>","more":"<h2 id=\"2-安装插件\"><a href=\"#2-安装插件\" class=\"headerlink\" title=\"2. 安装插件\"></a>2. 安装插件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>\n<p>修改blog下的_config.yml文件，进行编辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">    path: search.xml</span><br><span class=\"line\">    field: post</span><br><span class=\"line\">    format: html</span><br><span class=\"line\">    limit: 10000</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>修改主题配置文件blog/themes/next下的_config.yml文件，进行编辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">    enable: true</span><br></pre></td></tr></table></figure>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://blog.csdn.net/qq_40265501/article/details/80030627\" target=\"_blank\" rel=\"noopener\">hexo博客添加搜索功能</a></p>\n<p><a href=\"https://www.ezlippi.com/blog/2017/02/hexo-search.html\" target=\"_blank\" rel=\"noopener\">Hexo博客添加站内搜索</a></p>\n<p><a href=\"https://www.chunqiuyiyu.com/2018/07/hexo-local-search.html\" target=\"_blank\" rel=\"noopener\">Hexo 博客添加本地搜索</a></p>"},{"title":"ipv6","date":"2019-07-03T09:06:50.000Z","_content":"\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=0978f1eb9016fdfacc61cebcd5e6e731/f636afc379310a551d8ed434ba4543a983261043.jpg)\n\n[ipv6](https://baike.baidu.com/item/IPv6/172297) 号称可以为全世界的每一粒沙子编上一个地址。\n\n<!--more-->\n\n## 1. 地址分类\n\n![](https://img-my.csdn.net/uploads/201112/21/0_1324448169JjgZ.gif)\n\n### 1.1. 单播地址\n单播地址还可以分成如下几类：\n- 全球单播地址\n- 本地单播地址\n  + 链路本地地址(fe80)\n  + 唯一本地地址(fc00)\n  + ~~站点本地地址(fec0), 已弃用，被唯一本地地址代替~~\n- 兼容性地址 \n- 特殊地址\n  + 未指定地址\n  + 环回地址\n\n子类 | 地址前缀（二进制） | ipv6前缀标识\n :- | :- | :-\n全球单播地址 | 其他形式 | -\n链路本地地址 | 111 111 1010 | FE80::/10\n唯一本地地址 | 1111 110\t| FC00::/7（包括FD00::/8和不常用的FC00::/8）\n环回地址\t| 00…1(128 bits)\t| ::1/128\n未指定地址\t| 00…0(128 bits)\t| ::/128\n\n#### 1.1.1 全球单播地址\n__等同于IPv4中的公网地址__，可以在IPv6 Internet上进行全局路由和访问。\n\n#### 1.1.2 本地单播地址\n#### 1.1.2.1. 链路本地地址\n仅用于单个链路（链路层不能跨VLAN），不能在不同子网中路由。\n\n#### 1.1.2.2. 唯一本地地址\n唯一本地地址是本地全局的，**它应用于本地通信，但不通过Internet路由，将其范围限制为组织的边界。**\n\n#### 1.1.3. 兼容性地址\n>在IPv6的转换机制中还包括了一种通过IPv4路由接口以隧道方式动态传递IPv6包的技术。这样的IPv6结点会被分配一个在低32位中带有全球IPv4单播地址的IPv6全局单播地址。另有一种嵌入IPv4的IPv6地址，用于局域网内部，这类地址用于把IPv4结点当作IPv6结点。此外，还有一种称为“6to4”的IPv6地址，用于在两个通过Internet同时运行IPv4和IPv6的结点之间进行通信。\n\n#### 1.1.4. 特殊地址\n包括未指定地址和环回地址。\n\n### 1.2. 组播地址\nIPv6组播地址可识别多个接口，对应于一组接口的地址（通常分属不同节点）。__<font color=red>发送到组播地址的数据包被送到由该地址标识的每个接口。</font>__\n\n地址前缀（二进制） | ipv6前缀标识\n :- | :-\n11111111 | ff00::/8\n\n### 1.3. 任播地址\n一个IPv6任播地址与组播地址一样也可以识别多个接口，对应一组接口的地址。大多数情况下，这些接口属于不同的节点。__<font color=red>发送到任播地址的数据包被送到由该地址标识的其中一个接口（该地址识别的最近接口，最近接口定义的根据是因为路由距离最近）。</font>__\n\n地址前缀（二进制） | ipv6前缀标识\n :- | :-\n从单播地址空间中进行分配 | 使用单播地址的格式\n\n## 2. 组成结构\n### 2.1. 表示方法\nIPv6的地址长度为128位，是IPv4地址长度的4倍。于是IPv4点分十进制格式不再适用，采用十六进制表示。IPv6有3种表示方法：\n\n#### 2.1.1. 冒分十六进制表示法\n格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789\n\n#### 2.1.2. 0位压缩表示法\n在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，\n例如：\n>FF01:0:0:0:0:0:0:1101 → FF01::1101\n>0:0:0:0:0:0:0:1       → ::1\n>0:0:0:0:0:0:0:0       → ::\n\n#### 2.1.3. 内嵌IPv4地址表示法\n为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d。例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用\n\n## 参看资料\n[ipv6 百度百科](https://baike.baidu.com/item/IPv6/172297)\n\n[ipv6地址的分类(关于FE80开头, FEC0开头的IPV6地址等的介绍)](https://blog.csdn.net/fdl19881/article/details/7091138)\n\n[了解IPv6链路本地地址](https://www.cisco.com/c/zh_cn/support/docs/ip/ip-version-6-ipv6/113328-ipv6-lla.html)","source":"_posts/ipv6.md","raw":"---\ntitle: ipv6\ndate: 2019-07-03 17:06:50\ntags: ipv6\ncategories: ipv6\n---\n\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=0978f1eb9016fdfacc61cebcd5e6e731/f636afc379310a551d8ed434ba4543a983261043.jpg)\n\n[ipv6](https://baike.baidu.com/item/IPv6/172297) 号称可以为全世界的每一粒沙子编上一个地址。\n\n<!--more-->\n\n## 1. 地址分类\n\n![](https://img-my.csdn.net/uploads/201112/21/0_1324448169JjgZ.gif)\n\n### 1.1. 单播地址\n单播地址还可以分成如下几类：\n- 全球单播地址\n- 本地单播地址\n  + 链路本地地址(fe80)\n  + 唯一本地地址(fc00)\n  + ~~站点本地地址(fec0), 已弃用，被唯一本地地址代替~~\n- 兼容性地址 \n- 特殊地址\n  + 未指定地址\n  + 环回地址\n\n子类 | 地址前缀（二进制） | ipv6前缀标识\n :- | :- | :-\n全球单播地址 | 其他形式 | -\n链路本地地址 | 111 111 1010 | FE80::/10\n唯一本地地址 | 1111 110\t| FC00::/7（包括FD00::/8和不常用的FC00::/8）\n环回地址\t| 00…1(128 bits)\t| ::1/128\n未指定地址\t| 00…0(128 bits)\t| ::/128\n\n#### 1.1.1 全球单播地址\n__等同于IPv4中的公网地址__，可以在IPv6 Internet上进行全局路由和访问。\n\n#### 1.1.2 本地单播地址\n#### 1.1.2.1. 链路本地地址\n仅用于单个链路（链路层不能跨VLAN），不能在不同子网中路由。\n\n#### 1.1.2.2. 唯一本地地址\n唯一本地地址是本地全局的，**它应用于本地通信，但不通过Internet路由，将其范围限制为组织的边界。**\n\n#### 1.1.3. 兼容性地址\n>在IPv6的转换机制中还包括了一种通过IPv4路由接口以隧道方式动态传递IPv6包的技术。这样的IPv6结点会被分配一个在低32位中带有全球IPv4单播地址的IPv6全局单播地址。另有一种嵌入IPv4的IPv6地址，用于局域网内部，这类地址用于把IPv4结点当作IPv6结点。此外，还有一种称为“6to4”的IPv6地址，用于在两个通过Internet同时运行IPv4和IPv6的结点之间进行通信。\n\n#### 1.1.4. 特殊地址\n包括未指定地址和环回地址。\n\n### 1.2. 组播地址\nIPv6组播地址可识别多个接口，对应于一组接口的地址（通常分属不同节点）。__<font color=red>发送到组播地址的数据包被送到由该地址标识的每个接口。</font>__\n\n地址前缀（二进制） | ipv6前缀标识\n :- | :-\n11111111 | ff00::/8\n\n### 1.3. 任播地址\n一个IPv6任播地址与组播地址一样也可以识别多个接口，对应一组接口的地址。大多数情况下，这些接口属于不同的节点。__<font color=red>发送到任播地址的数据包被送到由该地址标识的其中一个接口（该地址识别的最近接口，最近接口定义的根据是因为路由距离最近）。</font>__\n\n地址前缀（二进制） | ipv6前缀标识\n :- | :-\n从单播地址空间中进行分配 | 使用单播地址的格式\n\n## 2. 组成结构\n### 2.1. 表示方法\nIPv6的地址长度为128位，是IPv4地址长度的4倍。于是IPv4点分十进制格式不再适用，采用十六进制表示。IPv6有3种表示方法：\n\n#### 2.1.1. 冒分十六进制表示法\n格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789\n\n#### 2.1.2. 0位压缩表示法\n在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，\n例如：\n>FF01:0:0:0:0:0:0:1101 → FF01::1101\n>0:0:0:0:0:0:0:1       → ::1\n>0:0:0:0:0:0:0:0       → ::\n\n#### 2.1.3. 内嵌IPv4地址表示法\n为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d。例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用\n\n## 参看资料\n[ipv6 百度百科](https://baike.baidu.com/item/IPv6/172297)\n\n[ipv6地址的分类(关于FE80开头, FEC0开头的IPV6地址等的介绍)](https://blog.csdn.net/fdl19881/article/details/7091138)\n\n[了解IPv6链路本地地址](https://www.cisco.com/c/zh_cn/support/docs/ip/ip-version-6-ipv6/113328-ipv6-lla.html)","slug":"ipv6","published":1,"updated":"2019-07-22T02:14:10.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0py001rzkgr2n3axnme","content":"<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=0978f1eb9016fdfacc61cebcd5e6e731/f636afc379310a551d8ed434ba4543a983261043.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/IPv6/172297\" target=\"_blank\" rel=\"noopener\">ipv6</a> 号称可以为全世界的每一粒沙子编上一个地址。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-地址分类\"><a href=\"#1-地址分类\" class=\"headerlink\" title=\"1. 地址分类\"></a>1. 地址分类</h2><p><img src=\"https://img-my.csdn.net/uploads/201112/21/0_1324448169JjgZ.gif\" alt=\"\"></p>\n<h3 id=\"1-1-单播地址\"><a href=\"#1-1-单播地址\" class=\"headerlink\" title=\"1.1. 单播地址\"></a>1.1. 单播地址</h3><p>单播地址还可以分成如下几类：</p>\n<ul>\n<li>全球单播地址</li>\n<li>本地单播地址<ul>\n<li>链路本地地址(fe80)</li>\n<li>唯一本地地址(fc00)</li>\n<li><del>站点本地地址(fec0), 已弃用，被唯一本地地址代替</del></li>\n</ul>\n</li>\n<li>兼容性地址 </li>\n<li>特殊地址<ul>\n<li>未指定地址</li>\n<li>环回地址</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子类</th>\n<th style=\"text-align:left\">地址前缀（二进制）</th>\n<th style=\"text-align:left\">ipv6前缀标识</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">全球单播地址</td>\n<td style=\"text-align:left\">其他形式</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">链路本地地址</td>\n<td style=\"text-align:left\">111 111 1010</td>\n<td style=\"text-align:left\">FE80::/10</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">唯一本地地址</td>\n<td style=\"text-align:left\">1111 110</td>\n<td style=\"text-align:left\">FC00::/7（包括FD00::/8和不常用的FC00::/8）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">环回地址</td>\n<td style=\"text-align:left\">00…1(128 bits)</td>\n<td style=\"text-align:left\">::1/128</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">未指定地址</td>\n<td style=\"text-align:left\">00…0(128 bits)</td>\n<td style=\"text-align:left\">::/128</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1-1-1-全球单播地址\"><a href=\"#1-1-1-全球单播地址\" class=\"headerlink\" title=\"1.1.1 全球单播地址\"></a>1.1.1 全球单播地址</h4><p><strong>等同于IPv4中的公网地址</strong>，可以在IPv6 Internet上进行全局路由和访问。</p>\n<h4 id=\"1-1-2-本地单播地址\"><a href=\"#1-1-2-本地单播地址\" class=\"headerlink\" title=\"1.1.2 本地单播地址\"></a>1.1.2 本地单播地址</h4><h4 id=\"1-1-2-1-链路本地地址\"><a href=\"#1-1-2-1-链路本地地址\" class=\"headerlink\" title=\"1.1.2.1. 链路本地地址\"></a>1.1.2.1. 链路本地地址</h4><p>仅用于单个链路（链路层不能跨VLAN），不能在不同子网中路由。</p>\n<h4 id=\"1-1-2-2-唯一本地地址\"><a href=\"#1-1-2-2-唯一本地地址\" class=\"headerlink\" title=\"1.1.2.2. 唯一本地地址\"></a>1.1.2.2. 唯一本地地址</h4><p>唯一本地地址是本地全局的，<strong>它应用于本地通信，但不通过Internet路由，将其范围限制为组织的边界。</strong></p>\n<h4 id=\"1-1-3-兼容性地址\"><a href=\"#1-1-3-兼容性地址\" class=\"headerlink\" title=\"1.1.3. 兼容性地址\"></a>1.1.3. 兼容性地址</h4><blockquote>\n<p>在IPv6的转换机制中还包括了一种通过IPv4路由接口以隧道方式动态传递IPv6包的技术。这样的IPv6结点会被分配一个在低32位中带有全球IPv4单播地址的IPv6全局单播地址。另有一种嵌入IPv4的IPv6地址，用于局域网内部，这类地址用于把IPv4结点当作IPv6结点。此外，还有一种称为“6to4”的IPv6地址，用于在两个通过Internet同时运行IPv4和IPv6的结点之间进行通信。</p>\n</blockquote>\n<h4 id=\"1-1-4-特殊地址\"><a href=\"#1-1-4-特殊地址\" class=\"headerlink\" title=\"1.1.4. 特殊地址\"></a>1.1.4. 特殊地址</h4><p>包括未指定地址和环回地址。</p>\n<h3 id=\"1-2-组播地址\"><a href=\"#1-2-组播地址\" class=\"headerlink\" title=\"1.2. 组播地址\"></a>1.2. 组播地址</h3><p>IPv6组播地址可识别多个接口，对应于一组接口的地址（通常分属不同节点）。<strong><font color=\"red\">发送到组播地址的数据包被送到由该地址标识的每个接口。</font></strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址前缀（二进制）</th>\n<th style=\"text-align:left\">ipv6前缀标识</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">11111111</td>\n<td style=\"text-align:left\">ff00::/8</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-3-任播地址\"><a href=\"#1-3-任播地址\" class=\"headerlink\" title=\"1.3. 任播地址\"></a>1.3. 任播地址</h3><p>一个IPv6任播地址与组播地址一样也可以识别多个接口，对应一组接口的地址。大多数情况下，这些接口属于不同的节点。<strong><font color=\"red\">发送到任播地址的数据包被送到由该地址标识的其中一个接口（该地址识别的最近接口，最近接口定义的根据是因为路由距离最近）。</font></strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址前缀（二进制）</th>\n<th style=\"text-align:left\">ipv6前缀标识</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">从单播地址空间中进行分配</td>\n<td style=\"text-align:left\">使用单播地址的格式</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-组成结构\"><a href=\"#2-组成结构\" class=\"headerlink\" title=\"2. 组成结构\"></a>2. 组成结构</h2><h3 id=\"2-1-表示方法\"><a href=\"#2-1-表示方法\" class=\"headerlink\" title=\"2.1. 表示方法\"></a>2.1. 表示方法</h3><p>IPv6的地址长度为128位，是IPv4地址长度的4倍。于是IPv4点分十进制格式不再适用，采用十六进制表示。IPv6有3种表示方法：</p>\n<h4 id=\"2-1-1-冒分十六进制表示法\"><a href=\"#2-1-1-冒分十六进制表示法\" class=\"headerlink\" title=\"2.1.1. 冒分十六进制表示法\"></a>2.1.1. 冒分十六进制表示法</h4><p>格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</p>\n<h4 id=\"2-1-2-0位压缩表示法\"><a href=\"#2-1-2-0位压缩表示法\" class=\"headerlink\" title=\"2.1.2. 0位压缩表示法\"></a>2.1.2. 0位压缩表示法</h4><p>在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，<br>例如：</p>\n<blockquote>\n<p>FF01:0:0:0:0:0:0:1101 → FF01::1101<br>0:0:0:0:0:0:0:1       → ::1<br>0:0:0:0:0:0:0:0       → ::</p>\n</blockquote>\n<h4 id=\"2-1-3-内嵌IPv4地址表示法\"><a href=\"#2-1-3-内嵌IPv4地址表示法\" class=\"headerlink\" title=\"2.1.3. 内嵌IPv4地址表示法\"></a>2.1.3. 内嵌IPv4地址表示法</h4><p>为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d。例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用</p>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://baike.baidu.com/item/IPv6/172297\" target=\"_blank\" rel=\"noopener\">ipv6 百度百科</a></p>\n<p><a href=\"https://blog.csdn.net/fdl19881/article/details/7091138\" target=\"_blank\" rel=\"noopener\">ipv6地址的分类(关于FE80开头, FEC0开头的IPV6地址等的介绍)</a></p>\n<p><a href=\"https://www.cisco.com/c/zh_cn/support/docs/ip/ip-version-6-ipv6/113328-ipv6-lla.html\" target=\"_blank\" rel=\"noopener\">了解IPv6链路本地地址</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=0978f1eb9016fdfacc61cebcd5e6e731/f636afc379310a551d8ed434ba4543a983261043.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/IPv6/172297\" target=\"_blank\" rel=\"noopener\">ipv6</a> 号称可以为全世界的每一粒沙子编上一个地址。</p>","more":"<h2 id=\"1-地址分类\"><a href=\"#1-地址分类\" class=\"headerlink\" title=\"1. 地址分类\"></a>1. 地址分类</h2><p><img src=\"https://img-my.csdn.net/uploads/201112/21/0_1324448169JjgZ.gif\" alt=\"\"></p>\n<h3 id=\"1-1-单播地址\"><a href=\"#1-1-单播地址\" class=\"headerlink\" title=\"1.1. 单播地址\"></a>1.1. 单播地址</h3><p>单播地址还可以分成如下几类：</p>\n<ul>\n<li>全球单播地址</li>\n<li>本地单播地址<ul>\n<li>链路本地地址(fe80)</li>\n<li>唯一本地地址(fc00)</li>\n<li><del>站点本地地址(fec0), 已弃用，被唯一本地地址代替</del></li>\n</ul>\n</li>\n<li>兼容性地址 </li>\n<li>特殊地址<ul>\n<li>未指定地址</li>\n<li>环回地址</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子类</th>\n<th style=\"text-align:left\">地址前缀（二进制）</th>\n<th style=\"text-align:left\">ipv6前缀标识</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">全球单播地址</td>\n<td style=\"text-align:left\">其他形式</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">链路本地地址</td>\n<td style=\"text-align:left\">111 111 1010</td>\n<td style=\"text-align:left\">FE80::/10</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">唯一本地地址</td>\n<td style=\"text-align:left\">1111 110</td>\n<td style=\"text-align:left\">FC00::/7（包括FD00::/8和不常用的FC00::/8）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">环回地址</td>\n<td style=\"text-align:left\">00…1(128 bits)</td>\n<td style=\"text-align:left\">::1/128</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">未指定地址</td>\n<td style=\"text-align:left\">00…0(128 bits)</td>\n<td style=\"text-align:left\">::/128</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1-1-1-全球单播地址\"><a href=\"#1-1-1-全球单播地址\" class=\"headerlink\" title=\"1.1.1 全球单播地址\"></a>1.1.1 全球单播地址</h4><p><strong>等同于IPv4中的公网地址</strong>，可以在IPv6 Internet上进行全局路由和访问。</p>\n<h4 id=\"1-1-2-本地单播地址\"><a href=\"#1-1-2-本地单播地址\" class=\"headerlink\" title=\"1.1.2 本地单播地址\"></a>1.1.2 本地单播地址</h4><h4 id=\"1-1-2-1-链路本地地址\"><a href=\"#1-1-2-1-链路本地地址\" class=\"headerlink\" title=\"1.1.2.1. 链路本地地址\"></a>1.1.2.1. 链路本地地址</h4><p>仅用于单个链路（链路层不能跨VLAN），不能在不同子网中路由。</p>\n<h4 id=\"1-1-2-2-唯一本地地址\"><a href=\"#1-1-2-2-唯一本地地址\" class=\"headerlink\" title=\"1.1.2.2. 唯一本地地址\"></a>1.1.2.2. 唯一本地地址</h4><p>唯一本地地址是本地全局的，<strong>它应用于本地通信，但不通过Internet路由，将其范围限制为组织的边界。</strong></p>\n<h4 id=\"1-1-3-兼容性地址\"><a href=\"#1-1-3-兼容性地址\" class=\"headerlink\" title=\"1.1.3. 兼容性地址\"></a>1.1.3. 兼容性地址</h4><blockquote>\n<p>在IPv6的转换机制中还包括了一种通过IPv4路由接口以隧道方式动态传递IPv6包的技术。这样的IPv6结点会被分配一个在低32位中带有全球IPv4单播地址的IPv6全局单播地址。另有一种嵌入IPv4的IPv6地址，用于局域网内部，这类地址用于把IPv4结点当作IPv6结点。此外，还有一种称为“6to4”的IPv6地址，用于在两个通过Internet同时运行IPv4和IPv6的结点之间进行通信。</p>\n</blockquote>\n<h4 id=\"1-1-4-特殊地址\"><a href=\"#1-1-4-特殊地址\" class=\"headerlink\" title=\"1.1.4. 特殊地址\"></a>1.1.4. 特殊地址</h4><p>包括未指定地址和环回地址。</p>\n<h3 id=\"1-2-组播地址\"><a href=\"#1-2-组播地址\" class=\"headerlink\" title=\"1.2. 组播地址\"></a>1.2. 组播地址</h3><p>IPv6组播地址可识别多个接口，对应于一组接口的地址（通常分属不同节点）。<strong><font color=\"red\">发送到组播地址的数据包被送到由该地址标识的每个接口。</font></strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址前缀（二进制）</th>\n<th style=\"text-align:left\">ipv6前缀标识</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">11111111</td>\n<td style=\"text-align:left\">ff00::/8</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-3-任播地址\"><a href=\"#1-3-任播地址\" class=\"headerlink\" title=\"1.3. 任播地址\"></a>1.3. 任播地址</h3><p>一个IPv6任播地址与组播地址一样也可以识别多个接口，对应一组接口的地址。大多数情况下，这些接口属于不同的节点。<strong><font color=\"red\">发送到任播地址的数据包被送到由该地址标识的其中一个接口（该地址识别的最近接口，最近接口定义的根据是因为路由距离最近）。</font></strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址前缀（二进制）</th>\n<th style=\"text-align:left\">ipv6前缀标识</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">从单播地址空间中进行分配</td>\n<td style=\"text-align:left\">使用单播地址的格式</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-组成结构\"><a href=\"#2-组成结构\" class=\"headerlink\" title=\"2. 组成结构\"></a>2. 组成结构</h2><h3 id=\"2-1-表示方法\"><a href=\"#2-1-表示方法\" class=\"headerlink\" title=\"2.1. 表示方法\"></a>2.1. 表示方法</h3><p>IPv6的地址长度为128位，是IPv4地址长度的4倍。于是IPv4点分十进制格式不再适用，采用十六进制表示。IPv6有3种表示方法：</p>\n<h4 id=\"2-1-1-冒分十六进制表示法\"><a href=\"#2-1-1-冒分十六进制表示法\" class=\"headerlink\" title=\"2.1.1. 冒分十六进制表示法\"></a>2.1.1. 冒分十六进制表示法</h4><p>格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</p>\n<h4 id=\"2-1-2-0位压缩表示法\"><a href=\"#2-1-2-0位压缩表示法\" class=\"headerlink\" title=\"2.1.2. 0位压缩表示法\"></a>2.1.2. 0位压缩表示法</h4><p>在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，<br>例如：</p>\n<blockquote>\n<p>FF01:0:0:0:0:0:0:1101 → FF01::1101<br>0:0:0:0:0:0:0:1       → ::1<br>0:0:0:0:0:0:0:0       → ::</p>\n</blockquote>\n<h4 id=\"2-1-3-内嵌IPv4地址表示法\"><a href=\"#2-1-3-内嵌IPv4地址表示法\" class=\"headerlink\" title=\"2.1.3. 内嵌IPv4地址表示法\"></a>2.1.3. 内嵌IPv4地址表示法</h4><p>为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d。例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用</p>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://baike.baidu.com/item/IPv6/172297\" target=\"_blank\" rel=\"noopener\">ipv6 百度百科</a></p>\n<p><a href=\"https://blog.csdn.net/fdl19881/article/details/7091138\" target=\"_blank\" rel=\"noopener\">ipv6地址的分类(关于FE80开头, FEC0开头的IPV6地址等的介绍)</a></p>\n<p><a href=\"https://www.cisco.com/c/zh_cn/support/docs/ip/ip-version-6-ipv6/113328-ipv6-lla.html\" target=\"_blank\" rel=\"noopener\">了解IPv6链路本地地址</a></p>"},{"title":"kernel_crypto_III","date":"2019-08-07T06:46:14.000Z","_content":"\n### 1. Method with cryptographic\n用户空间的方式有如下方式：\n- netlink (AF_ALG)  socket 的形式（kernel 已经merge进入主线） \n- ioctl （OpenBSD 的形式， kenrel 没有merge此部分代码  ）\n- openssl\n\n我们常见的userspace 与kernel space 之间通信的方式有：\n- IOCTL\n- /proc\n- /sys\n- netlink\n\n我们主张使用socket 的方式，更为优雅与灵活。有人在此基础上封装了lib， [libkcapi](http://www.chronox.de/libkcapi.html)\n\n<!--more-->\n\n### 2. netlink(socket)\n#### 2.1. data structure\n<linux/if_alg.h>\n```c\n#include <linux/types.h>\nstruct sockaddr_alg {\n        __u16   salg_family;\n        __u8    salg_type[14];\n        __u32   salg_feat;\n        __u32   salg_mask;\n        __u8    salg_name[64];\n};\nstruct af_alg_iv {\n        __u32   ivlen;\n        __u8    iv[0];\n};\n/* Socket options */\n#define ALG_SET_KEY                     1\n#define ALG_SET_IV                      2\n#define ALG_SET_OP                      3\n\n/* Operations */\n#define ALG_OP_DECRYPT                  0\n#define ALG_OP_ENCRYPT                  1\n```\n\nCurrently, the following ciphers are accessible:\n- Message digest including keyed message digest (HMAC, CMAC)  \n- Symmetric ciphers  \n- AEAD ciphers  \n- Random Number Generators  \n\n我们可以使用如下的sockaddr_alg 的实例联系到具体的算法上。\n\n```c\n/* salg_type support:\n    - hash\n    - skcipher\n    - ahead\n    - rnd\n*/\n\nstruct sockaddr_alg sa = {\n    .salg_family = AF_ALG,\n    .salg_type = \"skcipher\", /* this selects the symmetric cipher */\n    .salg_name = \"cbc(aes)\" /* this is the cipher name */\n};\n```\n\nsocket 中的family AF_ALG, setsockopt 使用 SOL_ALG。如果header 中没有申明，可以使用如下定义：  \n```c\n#ifndef AF_ALG\n#define AF_ALG 38\n#endif\n#ifndef SOL_ALG\n#define SOL_ALG 279\n#endif\n```\n#### 2.2. Kernel internal \n在kenrel 内部注册了AF_ALG family 类型的socket。在kernel/crypto/af_alg.c\n\n```c\nstatic struct proto alg_proto = {\n\t.name\t\t\t= \"ALG\",\n\t.memory_allocated\t= &alg_memory_allocated,\n};\n\n#define PF_ALG\t\tAF_ALG\n\nstatic const struct net_proto_family alg_family = {\n\t.family\t=\tPF_ALG,\n\t.create\t=\talg_create,\n};\n\nstatic int __init af_alg_init(void)\n{\n\tint err = proto_register(&alg_proto, 0);\n\n\terr = sock_register(&alg_family);\n\t\n\treturn err;\n}\n```\n\n在kernel/crypto/algif_skcipher.c， 类似的algif_hash.c 注册了hash 类型的对象。\n```c\nstatic struct proto_ops algif_skcipher_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\tskcipher_sendmsg,\n\t.sendpage\t=\tskcipher_sendpage,\n\t.recvmsg\t=\tskcipher_recvmsg,\n\t.poll\t\t=\tskcipher_poll,\n};\n\nstatic const struct af_alg_type algif_type_skcipher = {\n\t.bind\t\t=\tskcipher_bind,\n\t.release\t=\tskcipher_release,\n\t.setkey\t\t=\tskcipher_setkey,\n\t.accept\t\t=\tskcipher_accept_parent,\n\t.ops\t\t=\t&algif_skcipher_ops,\n\t.name\t\t=\t\"skcipher\",\n};\n\nstatic int __init algif_skcipher_init(void)\n{\n\treturn af_alg_register_type(&algif_type_skcipher);\n}\n```\n\n![kernel af_alg system call image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/af_alg%20kernel%20flow.png)\n\n#### 2.3. usage flow\n我们使用如下流程进行使用：\n1. create socket with AF_ALG  \n2. bind socket with sockaddr_alg addr. \n3. set key, setsocketopt()\n4. accept with socket. accept system call return new file descriptor.\n5. use new fd to sendmsg(), recvmsg()\n\n__Setsockopt Interface__\n我们可以是用setsockopt（） 系统调用进行设定。\n\n```c\n#include <sys/types.h>          /* See NOTES */\n#include <sys/socket.h>\n\nint getsockopt(int sockfd, int level, int optname,\n                void *optval, socklen_t *optlen);\nint setsockopt(int sockfd, int level, int optname,\n                const void *optval, socklen_t optlen);\n```\n\n#### 2.4. usage\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <linux/if_alg.h>\n\n#ifndef AF_ALG\n#define AF_ALG 38\n#define SOL_ALG 279\n#endif\n\nextern errno;\n\n#define PRINT_ROW_LEN 15\nvoid print_hex_dump(char *src, int n)\n{\n    int i;\n    for(i=0; i<n; i++) {\n        printf(\"%02x \", src[i]);\n      if (i % PRINT_ROW_LEN == 0 && i != 0)\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint setkey(int sockfd, char * key, int keylen)\n{\n    int err = setsockopt(sockfd, SOL_ALG, ALG_SET_KEY, key, keylen);\n    \n    if (err) {\n      perror(\"setsockopt err\");\n      goto out;\n    }\n    printf(\"setkey success\\n\");\nout:\n    err = errno;\n    return err;    \n}\n\nint sendmsg_to_cipher(int sockfd, int cmsg_type, int operation, char * src, int len)\n{\n    int err = 0;\n    struct msghdr msg;\n    struct iovec iov;\n    struct cmsghdr* cmsg = malloc(CMSG_SPACE(sizeof(operation)));\n    if (cmsg == NULL) {\n        perror(\"malloc setop_cmsg err\");\n        goto out;\n    }\n    cmsg->cmsg_len = CMSG_SPACE(sizeof(operation));\n    cmsg->cmsg_level = SOL_ALG;\n    cmsg->cmsg_type = cmsg_type;\n    memcpy(CMSG_DATA(cmsg), &operation, sizeof(operation));\n\n    iov.iov_base = src;\n    iov.iov_len = len;\n\n    msg.msg_name = NULL;\n    msg.msg_namelen = 0;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_control = cmsg;\n    msg.msg_controllen = CMSG_SPACE(sizeof(unsigned int));\n    msg.msg_flags = 0;\n    err = sendmsg(sockfd, &msg, 0);\n    if (err == -1) {\n        perror(\"sendmsg operation err\");\n        goto send_msg_err;\n    }\n    printf(\"sendmsg success\\n\");\n\nsend_msg_err:\n    free(cmsg);\nout:\n    err = errno;\n    return err;\n}\n\nint recvmsg_from_cipher(int sockfd, char *src, int len)\n{\n  int err = 0;\n  struct msghdr msg;\n  struct iovec iov;\n\n  iov.iov_base = src;\n  iov.iov_len = len;\n\n  msg.msg_name = NULL;\n  msg.msg_namelen = 0;\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  err = recvmsg(sockfd, &msg, 0);\n  if (err == -1) {\n    perror(\"recvmsg operation err\");\n    goto out;\n  }\n  printf(\"recvmsg data: \\n\");\n  print_hex_dump(src, len);\n\nout:\n  err = errno;\n  return err;\n}\n\nint main(void)\n{\n\tint opfd, tfmfd, err =0;\n    char plaintext_buf[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, \n                        0x99, 0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11};\n    char key_buf[] = {0xff, 0xd7, 0x40, 0x57, 0x47, 0x68, 0x5e, 0xd6, 0xe0, \n                        0x0b, 0xc6, 0x82, 0xa7, 0x72, 0x86, 0x09};\n    char encrypt_buf[32];\n    char decrypt_buf[32];\n\n\tstruct sockaddr_alg sa = {\n\t\t.salg_family = AF_ALG,\n\t\t.salg_type = \"skcipher\",\n\t\t.salg_name = \"AES128_ECB_CLR_CLR\"\n\t};\n\n\ttfmfd = socket(AF_ALG, SOCK_SEQPACKET, 0);\n    if(tfmfd == -1) {\n        perror(\"socket err\");\n        goto socket_err;\n    }\n\n\terr = bind(tfmfd, (struct sockaddr *)&sa, sizeof(sa));\n    if(err) {\n        perror(\"bind error\");\n        goto bind_err;\n    }\n\n    printf(\"plaintext buf: \\n\");\n    print_hex_dump(plaintext_buf, sizeof(plaintext_buf));\n\n    /* setkey, we need to set key before connect */\n    err = setkey(tfmfd, key_buf, sizeof(key_buf));\n    if(err)\n        goto setkey_err;\n\n\topfd = accept(tfmfd, NULL, 0);\n    if(opfd == -1) {\n        perror(\"accept err!\");\n        goto accept_err;\n    }\n    /* set iv */\n\n    /* set encryption */\n    err = sendmsg_to_cipher(opfd, ALG_SET_OP,\n                      ALG_OP_ENCRYPT, plaintext_buf, sizeof(plaintext_buf));\n    if(err)\n        goto sendmsg_err;\n\n    err = recvmsg_from_cipher(opfd, encrypt_buf, sizeof(plaintext_buf));\n    if (err)\n      goto recvmsg_err;\n\n    /* set decryption */\n    err = sendmsg_to_cipher(opfd, ALG_SET_OP, ALG_OP_DECRYPT, encrypt_buf,\n                            sizeof(plaintext_buf));\n    if (err)\n      goto sendmsg_err;\n\n    err = recvmsg_from_cipher(opfd, decrypt_buf, sizeof(plaintext_buf));\n    if (err)\n      goto recvmsg_err;\n\nrecvmsg_err:\nsendmsg_err:\n    close(opfd);\naccept_err:\nsetkey_err:\nbind_err:\n    close(tfmfd);\nsocket_err:\n    return err;\n}\n```\n\n### 3. openssl\n#### 3.1. afalg engine\n我们再1.1.0 版本后的openssl/engines 可以找到e_afalg.c 模块。在1.1.1c 版本中支持的afalg 只有三种：\n- aes_128_cbc\n- aes_192_cbc\n- aes_256_cbc\n\n```c\nstatic int afalg_ciphers(ENGINE *e, const EVP_CIPHER **cipher,\n                         const int **nids, int nid)\n{\n    int r = 1;\n\n    if (cipher == NULL) {\n        *nids = afalg_cipher_nids;\n        return (sizeof(afalg_cipher_nids) / sizeof(afalg_cipher_nids[0]));\n    }\n\n    switch (nid) {\n    case NID_aes_128_cbc:\n    case NID_aes_192_cbc:\n    case NID_aes_256_cbc:\n        *cipher = afalg_aes_cbc(nid);\n        break;\n    default:\n        *cipher = NULL;\n        r = 0;\n    }\n    return r;\n}\n```\n\nopenssl 内部的afalg engine 其实与自己写的userspace code 类似，都是使用netlink AF_ALG family socket。\n\n```c\nstatic ossl_inline void afalg_set_op_sk(struct cmsghdr *cmsg,\n                                   const ALG_OP_TYPE op)\n{\n    cmsg->cmsg_level = SOL_ALG;\n    cmsg->cmsg_type = ALG_SET_OP;\n    cmsg->cmsg_len = CMSG_LEN(ALG_OP_LEN);\n    memcpy(CMSG_DATA(cmsg), &op, ALG_OP_LEN);\n}\n\nstatic void afalg_set_iv_sk(struct cmsghdr *cmsg, const unsigned char *iv,\n                            const unsigned int len)\n{\n    struct af_alg_iv *aiv;\n\n    cmsg->cmsg_level = SOL_ALG;\n    cmsg->cmsg_type = ALG_SET_IV;\n    cmsg->cmsg_len = CMSG_LEN(ALG_IV_LEN(len));\n    aiv = (struct af_alg_iv *)CMSG_DATA(cmsg);\n    aiv->ivlen = len;\n    memcpy(aiv->iv, iv, len);\n}\n\nstatic ossl_inline int afalg_set_key(afalg_ctx *actx, const unsigned char *key,\n                                const int klen)\n{\n    int ret;\n    ret = setsockopt(actx->bfd, SOL_ALG, ALG_SET_KEY, key, klen);\n\n    return 1;\n}\n\nstatic int afalg_create_sk(afalg_ctx *actx, const char *ciphertype,\n                                const char *ciphername)\n{\n    struct sockaddr_alg sa;\n    int r = -1;\n\n    actx->bfd = actx->sfd = -1;\n\n    memset(&sa, 0, sizeof(sa));\n    sa.salg_family = AF_ALG;\n    strncpy((char *) sa.salg_type, ciphertype, ALG_MAX_SALG_TYPE);\n    sa.salg_type[ALG_MAX_SALG_TYPE-1] = '\\0';\n    strncpy((char *) sa.salg_name, ciphername, ALG_MAX_SALG_NAME);\n    sa.salg_name[ALG_MAX_SALG_NAME-1] = '\\0';\n\n    actx->bfd = socket(AF_ALG, SOCK_SEQPACKET, 0);\n\n    r = bind(actx->bfd, (struct sockaddr *)&sa, sizeof(sa));\n\n    actx->sfd = accept(actx->bfd, NULL, 0);\n\n    return 1;\n}\n```\n\nopenssl 中体现的优点在于：\n- 使用EVP 抽象统一all engines， 比如afalg, crypdev 等\n- 使用async io\n- 支持zero copy (vmsplice(), splice() 函数使用)\n\n#### 3.2. performance\n使用openssl speed 模块可以测试速度。\n>time openssl speed -evp aes-128-cbc -elapsed \n>time openssl speed -evp aes-128-cbc -elapsed -engine afalg\n\nMethod | Result\n:-: | :-\nSoftware Crypto | type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes <br> <font color=red>aes-128-cbc 13681.29k 16959.06k 18170.71k 18484.91k 18590.38k 18573.99k</font> <br><br> real 0m 18.67s <br> user 0m 18.10s <br> sys 0m 0.19s <br>\nHardware Crypto | type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes <br><font color=red>\taes-128-cbc 293.11k 1052.46k 4073.64k 11785.59k 27314.86k 30938.45k</font> <br><br> real 0m 18.24s <br> user 0m 0.73s<br> sys 0m 10.80s\n\n\n### 参看资料\n\n[User Space Interface](https://01.org/linuxgraphics/gfx-docs/drm/crypto/userspace-if.html)\n\n[Crypto API (Linux)\n](https://blog.csdn.net/yazhouren/article/details/53035690)\n\n[userspace if_alg example code](https://blog.csdn.net/yazhouren/article/details/53035742)\n\n[libkcapi, crypto user space library](http://www.chronox.de/libkcapi.html)","source":"_posts/kernel-crypto-III.md","raw":"---\ntitle: kernel_crypto_III\ndate: 2019-08-07 14:46:14\ntags: cryptographic\ncategories: drivers\n---\n\n### 1. Method with cryptographic\n用户空间的方式有如下方式：\n- netlink (AF_ALG)  socket 的形式（kernel 已经merge进入主线） \n- ioctl （OpenBSD 的形式， kenrel 没有merge此部分代码  ）\n- openssl\n\n我们常见的userspace 与kernel space 之间通信的方式有：\n- IOCTL\n- /proc\n- /sys\n- netlink\n\n我们主张使用socket 的方式，更为优雅与灵活。有人在此基础上封装了lib， [libkcapi](http://www.chronox.de/libkcapi.html)\n\n<!--more-->\n\n### 2. netlink(socket)\n#### 2.1. data structure\n<linux/if_alg.h>\n```c\n#include <linux/types.h>\nstruct sockaddr_alg {\n        __u16   salg_family;\n        __u8    salg_type[14];\n        __u32   salg_feat;\n        __u32   salg_mask;\n        __u8    salg_name[64];\n};\nstruct af_alg_iv {\n        __u32   ivlen;\n        __u8    iv[0];\n};\n/* Socket options */\n#define ALG_SET_KEY                     1\n#define ALG_SET_IV                      2\n#define ALG_SET_OP                      3\n\n/* Operations */\n#define ALG_OP_DECRYPT                  0\n#define ALG_OP_ENCRYPT                  1\n```\n\nCurrently, the following ciphers are accessible:\n- Message digest including keyed message digest (HMAC, CMAC)  \n- Symmetric ciphers  \n- AEAD ciphers  \n- Random Number Generators  \n\n我们可以使用如下的sockaddr_alg 的实例联系到具体的算法上。\n\n```c\n/* salg_type support:\n    - hash\n    - skcipher\n    - ahead\n    - rnd\n*/\n\nstruct sockaddr_alg sa = {\n    .salg_family = AF_ALG,\n    .salg_type = \"skcipher\", /* this selects the symmetric cipher */\n    .salg_name = \"cbc(aes)\" /* this is the cipher name */\n};\n```\n\nsocket 中的family AF_ALG, setsockopt 使用 SOL_ALG。如果header 中没有申明，可以使用如下定义：  \n```c\n#ifndef AF_ALG\n#define AF_ALG 38\n#endif\n#ifndef SOL_ALG\n#define SOL_ALG 279\n#endif\n```\n#### 2.2. Kernel internal \n在kenrel 内部注册了AF_ALG family 类型的socket。在kernel/crypto/af_alg.c\n\n```c\nstatic struct proto alg_proto = {\n\t.name\t\t\t= \"ALG\",\n\t.memory_allocated\t= &alg_memory_allocated,\n};\n\n#define PF_ALG\t\tAF_ALG\n\nstatic const struct net_proto_family alg_family = {\n\t.family\t=\tPF_ALG,\n\t.create\t=\talg_create,\n};\n\nstatic int __init af_alg_init(void)\n{\n\tint err = proto_register(&alg_proto, 0);\n\n\terr = sock_register(&alg_family);\n\t\n\treturn err;\n}\n```\n\n在kernel/crypto/algif_skcipher.c， 类似的algif_hash.c 注册了hash 类型的对象。\n```c\nstatic struct proto_ops algif_skcipher_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\tskcipher_sendmsg,\n\t.sendpage\t=\tskcipher_sendpage,\n\t.recvmsg\t=\tskcipher_recvmsg,\n\t.poll\t\t=\tskcipher_poll,\n};\n\nstatic const struct af_alg_type algif_type_skcipher = {\n\t.bind\t\t=\tskcipher_bind,\n\t.release\t=\tskcipher_release,\n\t.setkey\t\t=\tskcipher_setkey,\n\t.accept\t\t=\tskcipher_accept_parent,\n\t.ops\t\t=\t&algif_skcipher_ops,\n\t.name\t\t=\t\"skcipher\",\n};\n\nstatic int __init algif_skcipher_init(void)\n{\n\treturn af_alg_register_type(&algif_type_skcipher);\n}\n```\n\n![kernel af_alg system call image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/af_alg%20kernel%20flow.png)\n\n#### 2.3. usage flow\n我们使用如下流程进行使用：\n1. create socket with AF_ALG  \n2. bind socket with sockaddr_alg addr. \n3. set key, setsocketopt()\n4. accept with socket. accept system call return new file descriptor.\n5. use new fd to sendmsg(), recvmsg()\n\n__Setsockopt Interface__\n我们可以是用setsockopt（） 系统调用进行设定。\n\n```c\n#include <sys/types.h>          /* See NOTES */\n#include <sys/socket.h>\n\nint getsockopt(int sockfd, int level, int optname,\n                void *optval, socklen_t *optlen);\nint setsockopt(int sockfd, int level, int optname,\n                const void *optval, socklen_t optlen);\n```\n\n#### 2.4. usage\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <linux/if_alg.h>\n\n#ifndef AF_ALG\n#define AF_ALG 38\n#define SOL_ALG 279\n#endif\n\nextern errno;\n\n#define PRINT_ROW_LEN 15\nvoid print_hex_dump(char *src, int n)\n{\n    int i;\n    for(i=0; i<n; i++) {\n        printf(\"%02x \", src[i]);\n      if (i % PRINT_ROW_LEN == 0 && i != 0)\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint setkey(int sockfd, char * key, int keylen)\n{\n    int err = setsockopt(sockfd, SOL_ALG, ALG_SET_KEY, key, keylen);\n    \n    if (err) {\n      perror(\"setsockopt err\");\n      goto out;\n    }\n    printf(\"setkey success\\n\");\nout:\n    err = errno;\n    return err;    \n}\n\nint sendmsg_to_cipher(int sockfd, int cmsg_type, int operation, char * src, int len)\n{\n    int err = 0;\n    struct msghdr msg;\n    struct iovec iov;\n    struct cmsghdr* cmsg = malloc(CMSG_SPACE(sizeof(operation)));\n    if (cmsg == NULL) {\n        perror(\"malloc setop_cmsg err\");\n        goto out;\n    }\n    cmsg->cmsg_len = CMSG_SPACE(sizeof(operation));\n    cmsg->cmsg_level = SOL_ALG;\n    cmsg->cmsg_type = cmsg_type;\n    memcpy(CMSG_DATA(cmsg), &operation, sizeof(operation));\n\n    iov.iov_base = src;\n    iov.iov_len = len;\n\n    msg.msg_name = NULL;\n    msg.msg_namelen = 0;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_control = cmsg;\n    msg.msg_controllen = CMSG_SPACE(sizeof(unsigned int));\n    msg.msg_flags = 0;\n    err = sendmsg(sockfd, &msg, 0);\n    if (err == -1) {\n        perror(\"sendmsg operation err\");\n        goto send_msg_err;\n    }\n    printf(\"sendmsg success\\n\");\n\nsend_msg_err:\n    free(cmsg);\nout:\n    err = errno;\n    return err;\n}\n\nint recvmsg_from_cipher(int sockfd, char *src, int len)\n{\n  int err = 0;\n  struct msghdr msg;\n  struct iovec iov;\n\n  iov.iov_base = src;\n  iov.iov_len = len;\n\n  msg.msg_name = NULL;\n  msg.msg_namelen = 0;\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  err = recvmsg(sockfd, &msg, 0);\n  if (err == -1) {\n    perror(\"recvmsg operation err\");\n    goto out;\n  }\n  printf(\"recvmsg data: \\n\");\n  print_hex_dump(src, len);\n\nout:\n  err = errno;\n  return err;\n}\n\nint main(void)\n{\n\tint opfd, tfmfd, err =0;\n    char plaintext_buf[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, \n                        0x99, 0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11};\n    char key_buf[] = {0xff, 0xd7, 0x40, 0x57, 0x47, 0x68, 0x5e, 0xd6, 0xe0, \n                        0x0b, 0xc6, 0x82, 0xa7, 0x72, 0x86, 0x09};\n    char encrypt_buf[32];\n    char decrypt_buf[32];\n\n\tstruct sockaddr_alg sa = {\n\t\t.salg_family = AF_ALG,\n\t\t.salg_type = \"skcipher\",\n\t\t.salg_name = \"AES128_ECB_CLR_CLR\"\n\t};\n\n\ttfmfd = socket(AF_ALG, SOCK_SEQPACKET, 0);\n    if(tfmfd == -1) {\n        perror(\"socket err\");\n        goto socket_err;\n    }\n\n\terr = bind(tfmfd, (struct sockaddr *)&sa, sizeof(sa));\n    if(err) {\n        perror(\"bind error\");\n        goto bind_err;\n    }\n\n    printf(\"plaintext buf: \\n\");\n    print_hex_dump(plaintext_buf, sizeof(plaintext_buf));\n\n    /* setkey, we need to set key before connect */\n    err = setkey(tfmfd, key_buf, sizeof(key_buf));\n    if(err)\n        goto setkey_err;\n\n\topfd = accept(tfmfd, NULL, 0);\n    if(opfd == -1) {\n        perror(\"accept err!\");\n        goto accept_err;\n    }\n    /* set iv */\n\n    /* set encryption */\n    err = sendmsg_to_cipher(opfd, ALG_SET_OP,\n                      ALG_OP_ENCRYPT, plaintext_buf, sizeof(plaintext_buf));\n    if(err)\n        goto sendmsg_err;\n\n    err = recvmsg_from_cipher(opfd, encrypt_buf, sizeof(plaintext_buf));\n    if (err)\n      goto recvmsg_err;\n\n    /* set decryption */\n    err = sendmsg_to_cipher(opfd, ALG_SET_OP, ALG_OP_DECRYPT, encrypt_buf,\n                            sizeof(plaintext_buf));\n    if (err)\n      goto sendmsg_err;\n\n    err = recvmsg_from_cipher(opfd, decrypt_buf, sizeof(plaintext_buf));\n    if (err)\n      goto recvmsg_err;\n\nrecvmsg_err:\nsendmsg_err:\n    close(opfd);\naccept_err:\nsetkey_err:\nbind_err:\n    close(tfmfd);\nsocket_err:\n    return err;\n}\n```\n\n### 3. openssl\n#### 3.1. afalg engine\n我们再1.1.0 版本后的openssl/engines 可以找到e_afalg.c 模块。在1.1.1c 版本中支持的afalg 只有三种：\n- aes_128_cbc\n- aes_192_cbc\n- aes_256_cbc\n\n```c\nstatic int afalg_ciphers(ENGINE *e, const EVP_CIPHER **cipher,\n                         const int **nids, int nid)\n{\n    int r = 1;\n\n    if (cipher == NULL) {\n        *nids = afalg_cipher_nids;\n        return (sizeof(afalg_cipher_nids) / sizeof(afalg_cipher_nids[0]));\n    }\n\n    switch (nid) {\n    case NID_aes_128_cbc:\n    case NID_aes_192_cbc:\n    case NID_aes_256_cbc:\n        *cipher = afalg_aes_cbc(nid);\n        break;\n    default:\n        *cipher = NULL;\n        r = 0;\n    }\n    return r;\n}\n```\n\nopenssl 内部的afalg engine 其实与自己写的userspace code 类似，都是使用netlink AF_ALG family socket。\n\n```c\nstatic ossl_inline void afalg_set_op_sk(struct cmsghdr *cmsg,\n                                   const ALG_OP_TYPE op)\n{\n    cmsg->cmsg_level = SOL_ALG;\n    cmsg->cmsg_type = ALG_SET_OP;\n    cmsg->cmsg_len = CMSG_LEN(ALG_OP_LEN);\n    memcpy(CMSG_DATA(cmsg), &op, ALG_OP_LEN);\n}\n\nstatic void afalg_set_iv_sk(struct cmsghdr *cmsg, const unsigned char *iv,\n                            const unsigned int len)\n{\n    struct af_alg_iv *aiv;\n\n    cmsg->cmsg_level = SOL_ALG;\n    cmsg->cmsg_type = ALG_SET_IV;\n    cmsg->cmsg_len = CMSG_LEN(ALG_IV_LEN(len));\n    aiv = (struct af_alg_iv *)CMSG_DATA(cmsg);\n    aiv->ivlen = len;\n    memcpy(aiv->iv, iv, len);\n}\n\nstatic ossl_inline int afalg_set_key(afalg_ctx *actx, const unsigned char *key,\n                                const int klen)\n{\n    int ret;\n    ret = setsockopt(actx->bfd, SOL_ALG, ALG_SET_KEY, key, klen);\n\n    return 1;\n}\n\nstatic int afalg_create_sk(afalg_ctx *actx, const char *ciphertype,\n                                const char *ciphername)\n{\n    struct sockaddr_alg sa;\n    int r = -1;\n\n    actx->bfd = actx->sfd = -1;\n\n    memset(&sa, 0, sizeof(sa));\n    sa.salg_family = AF_ALG;\n    strncpy((char *) sa.salg_type, ciphertype, ALG_MAX_SALG_TYPE);\n    sa.salg_type[ALG_MAX_SALG_TYPE-1] = '\\0';\n    strncpy((char *) sa.salg_name, ciphername, ALG_MAX_SALG_NAME);\n    sa.salg_name[ALG_MAX_SALG_NAME-1] = '\\0';\n\n    actx->bfd = socket(AF_ALG, SOCK_SEQPACKET, 0);\n\n    r = bind(actx->bfd, (struct sockaddr *)&sa, sizeof(sa));\n\n    actx->sfd = accept(actx->bfd, NULL, 0);\n\n    return 1;\n}\n```\n\nopenssl 中体现的优点在于：\n- 使用EVP 抽象统一all engines， 比如afalg, crypdev 等\n- 使用async io\n- 支持zero copy (vmsplice(), splice() 函数使用)\n\n#### 3.2. performance\n使用openssl speed 模块可以测试速度。\n>time openssl speed -evp aes-128-cbc -elapsed \n>time openssl speed -evp aes-128-cbc -elapsed -engine afalg\n\nMethod | Result\n:-: | :-\nSoftware Crypto | type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes <br> <font color=red>aes-128-cbc 13681.29k 16959.06k 18170.71k 18484.91k 18590.38k 18573.99k</font> <br><br> real 0m 18.67s <br> user 0m 18.10s <br> sys 0m 0.19s <br>\nHardware Crypto | type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes <br><font color=red>\taes-128-cbc 293.11k 1052.46k 4073.64k 11785.59k 27314.86k 30938.45k</font> <br><br> real 0m 18.24s <br> user 0m 0.73s<br> sys 0m 10.80s\n\n\n### 参看资料\n\n[User Space Interface](https://01.org/linuxgraphics/gfx-docs/drm/crypto/userspace-if.html)\n\n[Crypto API (Linux)\n](https://blog.csdn.net/yazhouren/article/details/53035690)\n\n[userspace if_alg example code](https://blog.csdn.net/yazhouren/article/details/53035742)\n\n[libkcapi, crypto user space library](http://www.chronox.de/libkcapi.html)","slug":"kernel-crypto-III","published":1,"updated":"2019-08-22T05:51:48.821Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0pz001vzkgrutke55rc","content":"<h3 id=\"1-Method-with-cryptographic\"><a href=\"#1-Method-with-cryptographic\" class=\"headerlink\" title=\"1. Method with cryptographic\"></a>1. Method with cryptographic</h3><p>用户空间的方式有如下方式：</p>\n<ul>\n<li>netlink (AF_ALG)  socket 的形式（kernel 已经merge进入主线） </li>\n<li>ioctl （OpenBSD 的形式， kenrel 没有merge此部分代码  ）</li>\n<li>openssl</li>\n</ul>\n<p>我们常见的userspace 与kernel space 之间通信的方式有：</p>\n<ul>\n<li>IOCTL</li>\n<li>/proc</li>\n<li>/sys</li>\n<li>netlink</li>\n</ul>\n<p>我们主张使用socket 的方式，更为优雅与灵活。有人在此基础上封装了lib， <a href=\"http://www.chronox.de/libkcapi.html\" target=\"_blank\" rel=\"noopener\">libkcapi</a></p>\n<a id=\"more\"></a>\n<h3 id=\"2-netlink-socket\"><a href=\"#2-netlink-socket\" class=\"headerlink\" title=\"2. netlink(socket)\"></a>2. netlink(socket)</h3><h4 id=\"2-1-data-structure\"><a href=\"#2-1-data-structure\" class=\"headerlink\" title=\"2.1. data structure\"></a>2.1. data structure</h4><p>&lt;linux/if_alg.h&gt;<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_alg</span> &#123;</span></span><br><span class=\"line\">        __u16   salg_family;</span><br><span class=\"line\">        __u8    salg_type[<span class=\"number\">14</span>];</span><br><span class=\"line\">        __u32   salg_feat;</span><br><span class=\"line\">        __u32   salg_mask;</span><br><span class=\"line\">        __u8    salg_name[<span class=\"number\">64</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">af_alg_iv</span> &#123;</span></span><br><span class=\"line\">        __u32   ivlen;</span><br><span class=\"line\">        __u8    iv[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/* Socket options */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_SET_KEY                     1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_SET_IV                      2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_SET_OP                      3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Operations */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_OP_DECRYPT                  0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_OP_ENCRYPT                  1</span></span><br></pre></td></tr></table></figure></p>\n<p>Currently, the following ciphers are accessible:</p>\n<ul>\n<li>Message digest including keyed message digest (HMAC, CMAC)  </li>\n<li>Symmetric ciphers  </li>\n<li>AEAD ciphers  </li>\n<li>Random Number Generators  </li>\n</ul>\n<p>我们可以使用如下的sockaddr_alg 的实例联系到具体的算法上。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* salg_type support:</span></span><br><span class=\"line\"><span class=\"comment\">    - hash</span></span><br><span class=\"line\"><span class=\"comment\">    - skcipher</span></span><br><span class=\"line\"><span class=\"comment\">    - ahead</span></span><br><span class=\"line\"><span class=\"comment\">    - rnd</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_alg</span> <span class=\"title\">sa</span> = &#123;</span></span><br><span class=\"line\">    .salg_family = AF_ALG,</span><br><span class=\"line\">    .salg_type = <span class=\"string\">\"skcipher\"</span>, <span class=\"comment\">/* this selects the symmetric cipher */</span></span><br><span class=\"line\">    .salg_name = <span class=\"string\">\"cbc(aes)\"</span> <span class=\"comment\">/* this is the cipher name */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>socket 中的family AF_ALG, setsockopt 使用 SOL_ALG。如果header 中没有申明，可以使用如下定义：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> AF_ALG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AF_ALG 38</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> SOL_ALG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOL_ALG 279</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-2-Kernel-internal\"><a href=\"#2-2-Kernel-internal\" class=\"headerlink\" title=\"2.2. Kernel internal\"></a>2.2. Kernel internal</h4><p>在kenrel 内部注册了AF_ALG family 类型的socket。在kernel/crypto/af_alg.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proto</span> <span class=\"title\">alg_proto</span> = &#123;</span></span><br><span class=\"line\">\t.name\t\t\t= <span class=\"string\">\"ALG\"</span>,</span><br><span class=\"line\">\t.memory_allocated\t= &amp;alg_memory_allocated,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PF_ALG\t\tAF_ALG</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_proto_family</span> <span class=\"title\">alg_family</span> = &#123;</span></span><br><span class=\"line\">\t.family\t=\tPF_ALG,</span><br><span class=\"line\">\t.create\t=\talg_create,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">af_alg_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err = proto_register(&amp;alg_proto, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = sock_register(&amp;alg_family);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在kernel/crypto/algif_skcipher.c， 类似的algif_hash.c 注册了hash 类型的对象。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proto_ops</span> <span class=\"title\">algif_skcipher_ops</span> = &#123;</span></span><br><span class=\"line\">\t.family\t\t=\tPF_ALG,</span><br><span class=\"line\"></span><br><span class=\"line\">\t.release\t=\taf_alg_release,</span><br><span class=\"line\">\t.sendmsg\t=\tskcipher_sendmsg,</span><br><span class=\"line\">\t.sendpage\t=\tskcipher_sendpage,</span><br><span class=\"line\">\t.recvmsg\t=\tskcipher_recvmsg,</span><br><span class=\"line\">\t.poll\t\t=\tskcipher_poll,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">af_alg_type</span> <span class=\"title\">algif_type_skcipher</span> = &#123;</span></span><br><span class=\"line\">\t.bind\t\t=\tskcipher_bind,</span><br><span class=\"line\">\t.release\t=\tskcipher_release,</span><br><span class=\"line\">\t.setkey\t\t=\tskcipher_setkey,</span><br><span class=\"line\">\t.accept\t\t=\tskcipher_accept_parent,</span><br><span class=\"line\">\t.ops\t\t=\t&amp;algif_skcipher_ops,</span><br><span class=\"line\">\t.name\t\t=\t<span class=\"string\">\"skcipher\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">algif_skcipher_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> af_alg_register_type(&amp;algif_type_skcipher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/af_alg%20kernel%20flow.png\" alt=\"kernel af_alg system call image\"></p>\n<h4 id=\"2-3-usage-flow\"><a href=\"#2-3-usage-flow\" class=\"headerlink\" title=\"2.3. usage flow\"></a>2.3. usage flow</h4><p>我们使用如下流程进行使用：</p>\n<ol>\n<li>create socket with AF_ALG  </li>\n<li>bind socket with sockaddr_alg addr. </li>\n<li>set key, setsocketopt()</li>\n<li>accept with socket. accept system call return new file descriptor.</li>\n<li>use new fd to sendmsg(), recvmsg()</li>\n</ol>\n<p><strong>Setsockopt Interface</strong><br>我们可以是用setsockopt（） 系统调用进行设定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> optname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                <span class=\"keyword\">void</span> *optval, <span class=\"keyword\">socklen_t</span> *optlen)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> optname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *optval, <span class=\"keyword\">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-usage\"><a href=\"#2-4-usage\" class=\"headerlink\" title=\"2.4. usage\"></a>2.4. usage</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_alg.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> AF_ALG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AF_ALG 38</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOL_ALG 279</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> errno;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_ROW_LEN 15</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_hex_dump</span><span class=\"params\">(<span class=\"keyword\">char</span> *src, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%02x \"</span>, src[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i % PRINT_ROW_LEN == <span class=\"number\">0</span> &amp;&amp; i != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setkey</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">char</span> * key, <span class=\"keyword\">int</span> keylen)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err = setsockopt(sockfd, SOL_ALG, ALG_SET_KEY, key, keylen);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      perror(<span class=\"string\">\"setsockopt err\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"setkey success\\n\"</span>);</span><br><span class=\"line\">out:</span><br><span class=\"line\">    err = errno;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sendmsg_to_cipher</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> cmsg_type, <span class=\"keyword\">int</span> operation, <span class=\"keyword\">char</span> * src, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msghdr</span> <span class=\"title\">msg</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> <span class=\"title\">iov</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmsghdr</span>* <span class=\"title\">cmsg</span> = <span class=\"title\">malloc</span>(<span class=\"title\">CMSG_SPACE</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">operation</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cmsg == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"malloc setop_cmsg err\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cmsg-&gt;cmsg_len = CMSG_SPACE(<span class=\"keyword\">sizeof</span>(operation));</span><br><span class=\"line\">    cmsg-&gt;cmsg_level = SOL_ALG;</span><br><span class=\"line\">    cmsg-&gt;cmsg_type = cmsg_type;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(CMSG_DATA(cmsg), &amp;operation, <span class=\"keyword\">sizeof</span>(operation));</span><br><span class=\"line\"></span><br><span class=\"line\">    iov.iov_base = src;</span><br><span class=\"line\">    iov.iov_len = len;</span><br><span class=\"line\"></span><br><span class=\"line\">    msg.msg_name = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    msg.msg_namelen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    msg.msg_iov = &amp;iov;</span><br><span class=\"line\">    msg.msg_iovlen = <span class=\"number\">1</span>;</span><br><span class=\"line\">    msg.msg_control = cmsg;</span><br><span class=\"line\">    msg.msg_controllen = CMSG_SPACE(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>));</span><br><span class=\"line\">    msg.msg_flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    err = sendmsg(sockfd, &amp;msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"sendmsg operation err\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> send_msg_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"sendmsg success\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">send_msg_err:</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(cmsg);</span><br><span class=\"line\">out:</span><br><span class=\"line\">    err = errno;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">recvmsg_from_cipher</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">char</span> *src, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> err = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msghdr</span> <span class=\"title\">msg</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> <span class=\"title\">iov</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  iov.iov_base = src;</span><br><span class=\"line\">  iov.iov_len = len;</span><br><span class=\"line\"></span><br><span class=\"line\">  msg.msg_name = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  msg.msg_namelen = <span class=\"number\">0</span>;</span><br><span class=\"line\">  msg.msg_iov = &amp;iov;</span><br><span class=\"line\">  msg.msg_iovlen = <span class=\"number\">1</span>;</span><br><span class=\"line\">  msg.msg_control = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  msg.msg_controllen = <span class=\"number\">0</span>;</span><br><span class=\"line\">  msg.msg_flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">  err = recvmsg(sockfd, &amp;msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"recvmsg operation err\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"recvmsg data: \\n\"</span>);</span><br><span class=\"line\">  print_hex_dump(src, len);</span><br><span class=\"line\"></span><br><span class=\"line\">out:</span><br><span class=\"line\">  err = errno;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> opfd, tfmfd, err =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> plaintext_buf[] = &#123;<span class=\"number\">0x11</span>, <span class=\"number\">0x22</span>, <span class=\"number\">0x33</span>, <span class=\"number\">0x44</span>, <span class=\"number\">0x55</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x77</span>, <span class=\"number\">0x88</span>, </span><br><span class=\"line\">                        <span class=\"number\">0x99</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0xaa</span>, <span class=\"number\">0xbb</span>, <span class=\"number\">0xcc</span>, <span class=\"number\">0xdd</span>, <span class=\"number\">0xee</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x11</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> key_buf[] = &#123;<span class=\"number\">0xff</span>, <span class=\"number\">0xd7</span>, <span class=\"number\">0x40</span>, <span class=\"number\">0x57</span>, <span class=\"number\">0x47</span>, <span class=\"number\">0x68</span>, <span class=\"number\">0x5e</span>, <span class=\"number\">0xd6</span>, <span class=\"number\">0xe0</span>, </span><br><span class=\"line\">                        <span class=\"number\">0x0b</span>, <span class=\"number\">0xc6</span>, <span class=\"number\">0x82</span>, <span class=\"number\">0xa7</span>, <span class=\"number\">0x72</span>, <span class=\"number\">0x86</span>, <span class=\"number\">0x09</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> encrypt_buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> decrypt_buf[<span class=\"number\">32</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_alg</span> <span class=\"title\">sa</span> = &#123;</span></span><br><span class=\"line\">\t\t.salg_family = AF_ALG,</span><br><span class=\"line\">\t\t.salg_type = <span class=\"string\">\"skcipher\"</span>,</span><br><span class=\"line\">\t\t.salg_name = <span class=\"string\">\"AES128_ECB_CLR_CLR\"</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttfmfd = socket(AF_ALG, SOCK_SEQPACKET, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tfmfd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"socket err\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> socket_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = bind(tfmfd, (struct sockaddr *)&amp;sa, <span class=\"keyword\">sizeof</span>(sa));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"bind error\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> bind_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"plaintext buf: \\n\"</span>);</span><br><span class=\"line\">    print_hex_dump(plaintext_buf, <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* setkey, we need to set key before connect */</span></span><br><span class=\"line\">    err = setkey(tfmfd, key_buf, <span class=\"keyword\">sizeof</span>(key_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> setkey_err;</span><br><span class=\"line\"></span><br><span class=\"line\">\topfd = accept(tfmfd, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(opfd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"accept err!\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> accept_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* set iv */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* set encryption */</span></span><br><span class=\"line\">    err = sendmsg_to_cipher(opfd, ALG_SET_OP,</span><br><span class=\"line\">                      ALG_OP_ENCRYPT, plaintext_buf, <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> sendmsg_err;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = recvmsg_from_cipher(opfd, encrypt_buf, <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> recvmsg_err;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* set decryption */</span></span><br><span class=\"line\">    err = sendmsg_to_cipher(opfd, ALG_SET_OP, ALG_OP_DECRYPT, encrypt_buf,</span><br><span class=\"line\">                            <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> sendmsg_err;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = recvmsg_from_cipher(opfd, decrypt_buf, <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> recvmsg_err;</span><br><span class=\"line\"></span><br><span class=\"line\">recvmsg_err:</span><br><span class=\"line\">sendmsg_err:</span><br><span class=\"line\">    close(opfd);</span><br><span class=\"line\">accept_err:</span><br><span class=\"line\">setkey_err:</span><br><span class=\"line\">bind_err:</span><br><span class=\"line\">    close(tfmfd);</span><br><span class=\"line\">socket_err:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-openssl\"><a href=\"#3-openssl\" class=\"headerlink\" title=\"3. openssl\"></a>3. openssl</h3><h4 id=\"3-1-afalg-engine\"><a href=\"#3-1-afalg-engine\" class=\"headerlink\" title=\"3.1. afalg engine\"></a>3.1. afalg engine</h4><p>我们再1.1.0 版本后的openssl/engines 可以找到e_afalg.c 模块。在1.1.1c 版本中支持的afalg 只有三种：</p>\n<ul>\n<li>aes_128_cbc</li>\n<li>aes_192_cbc</li>\n<li>aes_256_cbc</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">afalg_ciphers</span><span class=\"params\">(ENGINE *e, <span class=\"keyword\">const</span> EVP_CIPHER **cipher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                         <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> **nids, <span class=\"keyword\">int</span> nid)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cipher == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        *nids = afalg_cipher_nids;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">sizeof</span>(afalg_cipher_nids) / <span class=\"keyword\">sizeof</span>(afalg_cipher_nids[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (nid) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> NID_aes_128_cbc:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> NID_aes_192_cbc:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> NID_aes_256_cbc:</span><br><span class=\"line\">        *cipher = afalg_aes_cbc(nid);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        *cipher = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>openssl 内部的afalg engine 其实与自己写的userspace code 类似，都是使用netlink AF_ALG family socket。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ossl_inline <span class=\"keyword\">void</span> <span class=\"title\">afalg_set_op_sk</span><span class=\"params\">(struct cmsghdr *cmsg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">const</span> ALG_OP_TYPE op)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cmsg-&gt;cmsg_level = SOL_ALG;</span><br><span class=\"line\">    cmsg-&gt;cmsg_type = ALG_SET_OP;</span><br><span class=\"line\">    cmsg-&gt;cmsg_len = CMSG_LEN(ALG_OP_LEN);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(CMSG_DATA(cmsg), &amp;op, ALG_OP_LEN);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">afalg_set_iv_sk</span><span class=\"params\">(struct cmsghdr *cmsg, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *iv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">af_alg_iv</span> *<span class=\"title\">aiv</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    cmsg-&gt;cmsg_level = SOL_ALG;</span><br><span class=\"line\">    cmsg-&gt;cmsg_type = ALG_SET_IV;</span><br><span class=\"line\">    cmsg-&gt;cmsg_len = CMSG_LEN(ALG_IV_LEN(len));</span><br><span class=\"line\">    aiv = (struct af_alg_iv *)CMSG_DATA(cmsg);</span><br><span class=\"line\">    aiv-&gt;ivlen = len;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(aiv-&gt;iv, iv, len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ossl_inline <span class=\"keyword\">int</span> <span class=\"title\">afalg_set_key</span><span class=\"params\">(afalg_ctx *actx, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *key,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> klen)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\">    ret = setsockopt(actx-&gt;bfd, SOL_ALG, ALG_SET_KEY, key, klen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">afalg_create_sk</span><span class=\"params\">(afalg_ctx *actx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ciphertype,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ciphername)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_alg</span> <span class=\"title\">sa</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    actx-&gt;bfd = actx-&gt;sfd = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;sa, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(sa));</span><br><span class=\"line\">    sa.salg_family = AF_ALG;</span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>((<span class=\"keyword\">char</span> *) sa.salg_type, ciphertype, ALG_MAX_SALG_TYPE);</span><br><span class=\"line\">    sa.salg_type[ALG_MAX_SALG_TYPE<span class=\"number\">-1</span>] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>((<span class=\"keyword\">char</span> *) sa.salg_name, ciphername, ALG_MAX_SALG_NAME);</span><br><span class=\"line\">    sa.salg_name[ALG_MAX_SALG_NAME<span class=\"number\">-1</span>] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    actx-&gt;bfd = socket(AF_ALG, SOCK_SEQPACKET, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    r = bind(actx-&gt;bfd, (struct sockaddr *)&amp;sa, <span class=\"keyword\">sizeof</span>(sa));</span><br><span class=\"line\"></span><br><span class=\"line\">    actx-&gt;sfd = accept(actx-&gt;bfd, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>openssl 中体现的优点在于：</p>\n<ul>\n<li>使用EVP 抽象统一all engines， 比如afalg, crypdev 等</li>\n<li>使用async io</li>\n<li>支持zero copy (vmsplice(), splice() 函数使用)</li>\n</ul>\n<h4 id=\"3-2-performance\"><a href=\"#3-2-performance\" class=\"headerlink\" title=\"3.2. performance\"></a>3.2. performance</h4><p>使用openssl speed 模块可以测试速度。</p>\n<blockquote>\n<p>time openssl speed -evp aes-128-cbc -elapsed<br>time openssl speed -evp aes-128-cbc -elapsed -engine afalg</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Method</th>\n<th style=\"text-align:left\">Result</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Software Crypto</td>\n<td style=\"text-align:left\">type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes <br> <font color=\"red\">aes-128-cbc 13681.29k 16959.06k 18170.71k 18484.91k 18590.38k 18573.99k</font> <br><br> real 0m 18.67s <br> user 0m 18.10s <br> sys 0m 0.19s <br></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Hardware Crypto</td>\n<td style=\"text-align:left\">type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes <br><font color=\"red\">    aes-128-cbc 293.11k 1052.46k 4073.64k 11785.59k 27314.86k 30938.45k</font> <br><br> real 0m 18.24s <br> user 0m 0.73s<br> sys 0m 10.80s</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://01.org/linuxgraphics/gfx-docs/drm/crypto/userspace-if.html\" target=\"_blank\" rel=\"noopener\">User Space Interface</a></p>\n<p><a href=\"https://blog.csdn.net/yazhouren/article/details/53035690\" target=\"_blank\" rel=\"noopener\">Crypto API (Linux)\n</a></p>\n<p><a href=\"https://blog.csdn.net/yazhouren/article/details/53035742\" target=\"_blank\" rel=\"noopener\">userspace if_alg example code</a></p>\n<p><a href=\"http://www.chronox.de/libkcapi.html\" target=\"_blank\" rel=\"noopener\">libkcapi, crypto user space library</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-Method-with-cryptographic\"><a href=\"#1-Method-with-cryptographic\" class=\"headerlink\" title=\"1. Method with cryptographic\"></a>1. Method with cryptographic</h3><p>用户空间的方式有如下方式：</p>\n<ul>\n<li>netlink (AF_ALG)  socket 的形式（kernel 已经merge进入主线） </li>\n<li>ioctl （OpenBSD 的形式， kenrel 没有merge此部分代码  ）</li>\n<li>openssl</li>\n</ul>\n<p>我们常见的userspace 与kernel space 之间通信的方式有：</p>\n<ul>\n<li>IOCTL</li>\n<li>/proc</li>\n<li>/sys</li>\n<li>netlink</li>\n</ul>\n<p>我们主张使用socket 的方式，更为优雅与灵活。有人在此基础上封装了lib， <a href=\"http://www.chronox.de/libkcapi.html\" target=\"_blank\" rel=\"noopener\">libkcapi</a></p>","more":"<h3 id=\"2-netlink-socket\"><a href=\"#2-netlink-socket\" class=\"headerlink\" title=\"2. netlink(socket)\"></a>2. netlink(socket)</h3><h4 id=\"2-1-data-structure\"><a href=\"#2-1-data-structure\" class=\"headerlink\" title=\"2.1. data structure\"></a>2.1. data structure</h4><p>&lt;linux/if_alg.h&gt;<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_alg</span> &#123;</span></span><br><span class=\"line\">        __u16   salg_family;</span><br><span class=\"line\">        __u8    salg_type[<span class=\"number\">14</span>];</span><br><span class=\"line\">        __u32   salg_feat;</span><br><span class=\"line\">        __u32   salg_mask;</span><br><span class=\"line\">        __u8    salg_name[<span class=\"number\">64</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">af_alg_iv</span> &#123;</span></span><br><span class=\"line\">        __u32   ivlen;</span><br><span class=\"line\">        __u8    iv[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/* Socket options */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_SET_KEY                     1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_SET_IV                      2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_SET_OP                      3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Operations */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_OP_DECRYPT                  0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALG_OP_ENCRYPT                  1</span></span><br></pre></td></tr></table></figure></p>\n<p>Currently, the following ciphers are accessible:</p>\n<ul>\n<li>Message digest including keyed message digest (HMAC, CMAC)  </li>\n<li>Symmetric ciphers  </li>\n<li>AEAD ciphers  </li>\n<li>Random Number Generators  </li>\n</ul>\n<p>我们可以使用如下的sockaddr_alg 的实例联系到具体的算法上。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* salg_type support:</span></span><br><span class=\"line\"><span class=\"comment\">    - hash</span></span><br><span class=\"line\"><span class=\"comment\">    - skcipher</span></span><br><span class=\"line\"><span class=\"comment\">    - ahead</span></span><br><span class=\"line\"><span class=\"comment\">    - rnd</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_alg</span> <span class=\"title\">sa</span> = &#123;</span></span><br><span class=\"line\">    .salg_family = AF_ALG,</span><br><span class=\"line\">    .salg_type = <span class=\"string\">\"skcipher\"</span>, <span class=\"comment\">/* this selects the symmetric cipher */</span></span><br><span class=\"line\">    .salg_name = <span class=\"string\">\"cbc(aes)\"</span> <span class=\"comment\">/* this is the cipher name */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>socket 中的family AF_ALG, setsockopt 使用 SOL_ALG。如果header 中没有申明，可以使用如下定义：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> AF_ALG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AF_ALG 38</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> SOL_ALG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOL_ALG 279</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-2-Kernel-internal\"><a href=\"#2-2-Kernel-internal\" class=\"headerlink\" title=\"2.2. Kernel internal\"></a>2.2. Kernel internal</h4><p>在kenrel 内部注册了AF_ALG family 类型的socket。在kernel/crypto/af_alg.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proto</span> <span class=\"title\">alg_proto</span> = &#123;</span></span><br><span class=\"line\">\t.name\t\t\t= <span class=\"string\">\"ALG\"</span>,</span><br><span class=\"line\">\t.memory_allocated\t= &amp;alg_memory_allocated,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PF_ALG\t\tAF_ALG</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_proto_family</span> <span class=\"title\">alg_family</span> = &#123;</span></span><br><span class=\"line\">\t.family\t=\tPF_ALG,</span><br><span class=\"line\">\t.create\t=\talg_create,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">af_alg_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err = proto_register(&amp;alg_proto, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = sock_register(&amp;alg_family);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在kernel/crypto/algif_skcipher.c， 类似的algif_hash.c 注册了hash 类型的对象。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proto_ops</span> <span class=\"title\">algif_skcipher_ops</span> = &#123;</span></span><br><span class=\"line\">\t.family\t\t=\tPF_ALG,</span><br><span class=\"line\"></span><br><span class=\"line\">\t.release\t=\taf_alg_release,</span><br><span class=\"line\">\t.sendmsg\t=\tskcipher_sendmsg,</span><br><span class=\"line\">\t.sendpage\t=\tskcipher_sendpage,</span><br><span class=\"line\">\t.recvmsg\t=\tskcipher_recvmsg,</span><br><span class=\"line\">\t.poll\t\t=\tskcipher_poll,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">af_alg_type</span> <span class=\"title\">algif_type_skcipher</span> = &#123;</span></span><br><span class=\"line\">\t.bind\t\t=\tskcipher_bind,</span><br><span class=\"line\">\t.release\t=\tskcipher_release,</span><br><span class=\"line\">\t.setkey\t\t=\tskcipher_setkey,</span><br><span class=\"line\">\t.accept\t\t=\tskcipher_accept_parent,</span><br><span class=\"line\">\t.ops\t\t=\t&amp;algif_skcipher_ops,</span><br><span class=\"line\">\t.name\t\t=\t<span class=\"string\">\"skcipher\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">algif_skcipher_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> af_alg_register_type(&amp;algif_type_skcipher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/af_alg%20kernel%20flow.png\" alt=\"kernel af_alg system call image\"></p>\n<h4 id=\"2-3-usage-flow\"><a href=\"#2-3-usage-flow\" class=\"headerlink\" title=\"2.3. usage flow\"></a>2.3. usage flow</h4><p>我们使用如下流程进行使用：</p>\n<ol>\n<li>create socket with AF_ALG  </li>\n<li>bind socket with sockaddr_alg addr. </li>\n<li>set key, setsocketopt()</li>\n<li>accept with socket. accept system call return new file descriptor.</li>\n<li>use new fd to sendmsg(), recvmsg()</li>\n</ol>\n<p><strong>Setsockopt Interface</strong><br>我们可以是用setsockopt（） 系统调用进行设定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> optname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                <span class=\"keyword\">void</span> *optval, <span class=\"keyword\">socklen_t</span> *optlen)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> optname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *optval, <span class=\"keyword\">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-usage\"><a href=\"#2-4-usage\" class=\"headerlink\" title=\"2.4. usage\"></a>2.4. usage</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_alg.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> AF_ALG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AF_ALG 38</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOL_ALG 279</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> errno;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_ROW_LEN 15</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_hex_dump</span><span class=\"params\">(<span class=\"keyword\">char</span> *src, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%02x \"</span>, src[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i % PRINT_ROW_LEN == <span class=\"number\">0</span> &amp;&amp; i != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setkey</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">char</span> * key, <span class=\"keyword\">int</span> keylen)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err = setsockopt(sockfd, SOL_ALG, ALG_SET_KEY, key, keylen);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      perror(<span class=\"string\">\"setsockopt err\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"setkey success\\n\"</span>);</span><br><span class=\"line\">out:</span><br><span class=\"line\">    err = errno;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sendmsg_to_cipher</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> cmsg_type, <span class=\"keyword\">int</span> operation, <span class=\"keyword\">char</span> * src, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msghdr</span> <span class=\"title\">msg</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> <span class=\"title\">iov</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmsghdr</span>* <span class=\"title\">cmsg</span> = <span class=\"title\">malloc</span>(<span class=\"title\">CMSG_SPACE</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">operation</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cmsg == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"malloc setop_cmsg err\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cmsg-&gt;cmsg_len = CMSG_SPACE(<span class=\"keyword\">sizeof</span>(operation));</span><br><span class=\"line\">    cmsg-&gt;cmsg_level = SOL_ALG;</span><br><span class=\"line\">    cmsg-&gt;cmsg_type = cmsg_type;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(CMSG_DATA(cmsg), &amp;operation, <span class=\"keyword\">sizeof</span>(operation));</span><br><span class=\"line\"></span><br><span class=\"line\">    iov.iov_base = src;</span><br><span class=\"line\">    iov.iov_len = len;</span><br><span class=\"line\"></span><br><span class=\"line\">    msg.msg_name = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    msg.msg_namelen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    msg.msg_iov = &amp;iov;</span><br><span class=\"line\">    msg.msg_iovlen = <span class=\"number\">1</span>;</span><br><span class=\"line\">    msg.msg_control = cmsg;</span><br><span class=\"line\">    msg.msg_controllen = CMSG_SPACE(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>));</span><br><span class=\"line\">    msg.msg_flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    err = sendmsg(sockfd, &amp;msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"sendmsg operation err\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> send_msg_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"sendmsg success\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">send_msg_err:</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(cmsg);</span><br><span class=\"line\">out:</span><br><span class=\"line\">    err = errno;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">recvmsg_from_cipher</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">char</span> *src, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> err = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msghdr</span> <span class=\"title\">msg</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> <span class=\"title\">iov</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  iov.iov_base = src;</span><br><span class=\"line\">  iov.iov_len = len;</span><br><span class=\"line\"></span><br><span class=\"line\">  msg.msg_name = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  msg.msg_namelen = <span class=\"number\">0</span>;</span><br><span class=\"line\">  msg.msg_iov = &amp;iov;</span><br><span class=\"line\">  msg.msg_iovlen = <span class=\"number\">1</span>;</span><br><span class=\"line\">  msg.msg_control = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  msg.msg_controllen = <span class=\"number\">0</span>;</span><br><span class=\"line\">  msg.msg_flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">  err = recvmsg(sockfd, &amp;msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"recvmsg operation err\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"recvmsg data: \\n\"</span>);</span><br><span class=\"line\">  print_hex_dump(src, len);</span><br><span class=\"line\"></span><br><span class=\"line\">out:</span><br><span class=\"line\">  err = errno;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> opfd, tfmfd, err =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> plaintext_buf[] = &#123;<span class=\"number\">0x11</span>, <span class=\"number\">0x22</span>, <span class=\"number\">0x33</span>, <span class=\"number\">0x44</span>, <span class=\"number\">0x55</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x77</span>, <span class=\"number\">0x88</span>, </span><br><span class=\"line\">                        <span class=\"number\">0x99</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0xaa</span>, <span class=\"number\">0xbb</span>, <span class=\"number\">0xcc</span>, <span class=\"number\">0xdd</span>, <span class=\"number\">0xee</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x11</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> key_buf[] = &#123;<span class=\"number\">0xff</span>, <span class=\"number\">0xd7</span>, <span class=\"number\">0x40</span>, <span class=\"number\">0x57</span>, <span class=\"number\">0x47</span>, <span class=\"number\">0x68</span>, <span class=\"number\">0x5e</span>, <span class=\"number\">0xd6</span>, <span class=\"number\">0xe0</span>, </span><br><span class=\"line\">                        <span class=\"number\">0x0b</span>, <span class=\"number\">0xc6</span>, <span class=\"number\">0x82</span>, <span class=\"number\">0xa7</span>, <span class=\"number\">0x72</span>, <span class=\"number\">0x86</span>, <span class=\"number\">0x09</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> encrypt_buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> decrypt_buf[<span class=\"number\">32</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_alg</span> <span class=\"title\">sa</span> = &#123;</span></span><br><span class=\"line\">\t\t.salg_family = AF_ALG,</span><br><span class=\"line\">\t\t.salg_type = <span class=\"string\">\"skcipher\"</span>,</span><br><span class=\"line\">\t\t.salg_name = <span class=\"string\">\"AES128_ECB_CLR_CLR\"</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttfmfd = socket(AF_ALG, SOCK_SEQPACKET, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tfmfd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"socket err\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> socket_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = bind(tfmfd, (struct sockaddr *)&amp;sa, <span class=\"keyword\">sizeof</span>(sa));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"bind error\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> bind_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"plaintext buf: \\n\"</span>);</span><br><span class=\"line\">    print_hex_dump(plaintext_buf, <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* setkey, we need to set key before connect */</span></span><br><span class=\"line\">    err = setkey(tfmfd, key_buf, <span class=\"keyword\">sizeof</span>(key_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> setkey_err;</span><br><span class=\"line\"></span><br><span class=\"line\">\topfd = accept(tfmfd, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(opfd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"accept err!\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> accept_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* set iv */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* set encryption */</span></span><br><span class=\"line\">    err = sendmsg_to_cipher(opfd, ALG_SET_OP,</span><br><span class=\"line\">                      ALG_OP_ENCRYPT, plaintext_buf, <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> sendmsg_err;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = recvmsg_from_cipher(opfd, encrypt_buf, <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> recvmsg_err;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* set decryption */</span></span><br><span class=\"line\">    err = sendmsg_to_cipher(opfd, ALG_SET_OP, ALG_OP_DECRYPT, encrypt_buf,</span><br><span class=\"line\">                            <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> sendmsg_err;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = recvmsg_from_cipher(opfd, decrypt_buf, <span class=\"keyword\">sizeof</span>(plaintext_buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> recvmsg_err;</span><br><span class=\"line\"></span><br><span class=\"line\">recvmsg_err:</span><br><span class=\"line\">sendmsg_err:</span><br><span class=\"line\">    close(opfd);</span><br><span class=\"line\">accept_err:</span><br><span class=\"line\">setkey_err:</span><br><span class=\"line\">bind_err:</span><br><span class=\"line\">    close(tfmfd);</span><br><span class=\"line\">socket_err:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-openssl\"><a href=\"#3-openssl\" class=\"headerlink\" title=\"3. openssl\"></a>3. openssl</h3><h4 id=\"3-1-afalg-engine\"><a href=\"#3-1-afalg-engine\" class=\"headerlink\" title=\"3.1. afalg engine\"></a>3.1. afalg engine</h4><p>我们再1.1.0 版本后的openssl/engines 可以找到e_afalg.c 模块。在1.1.1c 版本中支持的afalg 只有三种：</p>\n<ul>\n<li>aes_128_cbc</li>\n<li>aes_192_cbc</li>\n<li>aes_256_cbc</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">afalg_ciphers</span><span class=\"params\">(ENGINE *e, <span class=\"keyword\">const</span> EVP_CIPHER **cipher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                         <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> **nids, <span class=\"keyword\">int</span> nid)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cipher == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        *nids = afalg_cipher_nids;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">sizeof</span>(afalg_cipher_nids) / <span class=\"keyword\">sizeof</span>(afalg_cipher_nids[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (nid) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> NID_aes_128_cbc:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> NID_aes_192_cbc:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> NID_aes_256_cbc:</span><br><span class=\"line\">        *cipher = afalg_aes_cbc(nid);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        *cipher = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>openssl 内部的afalg engine 其实与自己写的userspace code 类似，都是使用netlink AF_ALG family socket。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ossl_inline <span class=\"keyword\">void</span> <span class=\"title\">afalg_set_op_sk</span><span class=\"params\">(struct cmsghdr *cmsg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">const</span> ALG_OP_TYPE op)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cmsg-&gt;cmsg_level = SOL_ALG;</span><br><span class=\"line\">    cmsg-&gt;cmsg_type = ALG_SET_OP;</span><br><span class=\"line\">    cmsg-&gt;cmsg_len = CMSG_LEN(ALG_OP_LEN);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(CMSG_DATA(cmsg), &amp;op, ALG_OP_LEN);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">afalg_set_iv_sk</span><span class=\"params\">(struct cmsghdr *cmsg, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *iv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">af_alg_iv</span> *<span class=\"title\">aiv</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    cmsg-&gt;cmsg_level = SOL_ALG;</span><br><span class=\"line\">    cmsg-&gt;cmsg_type = ALG_SET_IV;</span><br><span class=\"line\">    cmsg-&gt;cmsg_len = CMSG_LEN(ALG_IV_LEN(len));</span><br><span class=\"line\">    aiv = (struct af_alg_iv *)CMSG_DATA(cmsg);</span><br><span class=\"line\">    aiv-&gt;ivlen = len;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(aiv-&gt;iv, iv, len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ossl_inline <span class=\"keyword\">int</span> <span class=\"title\">afalg_set_key</span><span class=\"params\">(afalg_ctx *actx, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *key,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> klen)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\">    ret = setsockopt(actx-&gt;bfd, SOL_ALG, ALG_SET_KEY, key, klen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">afalg_create_sk</span><span class=\"params\">(afalg_ctx *actx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ciphertype,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ciphername)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_alg</span> <span class=\"title\">sa</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    actx-&gt;bfd = actx-&gt;sfd = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;sa, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(sa));</span><br><span class=\"line\">    sa.salg_family = AF_ALG;</span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>((<span class=\"keyword\">char</span> *) sa.salg_type, ciphertype, ALG_MAX_SALG_TYPE);</span><br><span class=\"line\">    sa.salg_type[ALG_MAX_SALG_TYPE<span class=\"number\">-1</span>] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>((<span class=\"keyword\">char</span> *) sa.salg_name, ciphername, ALG_MAX_SALG_NAME);</span><br><span class=\"line\">    sa.salg_name[ALG_MAX_SALG_NAME<span class=\"number\">-1</span>] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    actx-&gt;bfd = socket(AF_ALG, SOCK_SEQPACKET, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    r = bind(actx-&gt;bfd, (struct sockaddr *)&amp;sa, <span class=\"keyword\">sizeof</span>(sa));</span><br><span class=\"line\"></span><br><span class=\"line\">    actx-&gt;sfd = accept(actx-&gt;bfd, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>openssl 中体现的优点在于：</p>\n<ul>\n<li>使用EVP 抽象统一all engines， 比如afalg, crypdev 等</li>\n<li>使用async io</li>\n<li>支持zero copy (vmsplice(), splice() 函数使用)</li>\n</ul>\n<h4 id=\"3-2-performance\"><a href=\"#3-2-performance\" class=\"headerlink\" title=\"3.2. performance\"></a>3.2. performance</h4><p>使用openssl speed 模块可以测试速度。</p>\n<blockquote>\n<p>time openssl speed -evp aes-128-cbc -elapsed<br>time openssl speed -evp aes-128-cbc -elapsed -engine afalg</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Method</th>\n<th style=\"text-align:left\">Result</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Software Crypto</td>\n<td style=\"text-align:left\">type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes <br> <font color=\"red\">aes-128-cbc 13681.29k 16959.06k 18170.71k 18484.91k 18590.38k 18573.99k</font> <br><br> real 0m 18.67s <br> user 0m 18.10s <br> sys 0m 0.19s <br></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Hardware Crypto</td>\n<td style=\"text-align:left\">type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes <br><font color=\"red\">    aes-128-cbc 293.11k 1052.46k 4073.64k 11785.59k 27314.86k 30938.45k</font> <br><br> real 0m 18.24s <br> user 0m 0.73s<br> sys 0m 10.80s</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://01.org/linuxgraphics/gfx-docs/drm/crypto/userspace-if.html\" target=\"_blank\" rel=\"noopener\">User Space Interface</a></p>\n<p><a href=\"https://blog.csdn.net/yazhouren/article/details/53035690\" target=\"_blank\" rel=\"noopener\">Crypto API (Linux)\n</a></p>\n<p><a href=\"https://blog.csdn.net/yazhouren/article/details/53035742\" target=\"_blank\" rel=\"noopener\">userspace if_alg example code</a></p>\n<p><a href=\"http://www.chronox.de/libkcapi.html\" target=\"_blank\" rel=\"noopener\">libkcapi, crypto user space library</a></p>"},{"title":"kernel_crypto_II","date":"2019-08-06T12:04:59.000Z","_content":"\n### 1. cipher 基础\n在Kernel crytographic 的cipher 还有如下几类：\n- ablkcipher_tfm(asynchronous multi-block cipher transform)  \n- blkcipher_tfm(synchronous multi-block cipher transform)   \n- cipher_tfm(Single block cipher transform)\n\n更为安全的是使用ahead 加密形式， 可以见此篇文章。[什么是AEAD加密](https://zhuanlan.zhihu.com/p/28566058)\n\n<!--more-->\n\n在kernel中cipher 都为skcipher(Symmetric Key cipher, 对称性加密算法)\n\n后面我们以kernel/drivers/crypto/atmel-aes.c 进行分析ablkcipher 的驱动。\n\n### 2. cipher alg register\natmel aes 驱动初始流程可见下图：\n![driver init flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/aes-init-flow.png)\n\n```c\nstatic struct crypto_alg aes_algs[] = {\n{\n\t.cra_name\t\t= \"ecb(aes)\",\n\t.cra_driver_name\t= \"atmel-ecb-aes\",\n\t.cra_priority\t\t= 100,\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,\n\t.cra_blocksize\t\t= AES_BLOCK_SIZE,\n\t.cra_ctxsize\t\t= sizeof(struct atmel_aes_ctx),\n\t.cra_alignmask\t\t= 0xf,\n\t.cra_type\t\t= &crypto_ablkcipher_type,\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= atmel_aes_cra_init,\n\t.cra_exit\t\t= atmel_aes_cra_exit,\n\t.cra_u.ablkcipher = {\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.setkey\t\t= atmel_aes_setkey,\n\t\t.encrypt\t= atmel_aes_ecb_encrypt,\n\t\t.decrypt\t= atmel_aes_ecb_decrypt,\n\t}\n},\n{\n\t.cra_name\t\t= \"cbc(aes)\",\n\t.cra_driver_name\t= \"atmel-cbc-aes\",\n\t.cra_priority\t\t= 100,\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,\n\t.cra_blocksize\t\t= AES_BLOCK_SIZE,\n\t.cra_ctxsize\t\t= sizeof(struct atmel_aes_ctx),\n\t.cra_alignmask\t\t= 0xf,\n\t.cra_type\t\t= &crypto_ablkcipher_type,\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= atmel_aes_cra_init,\n\t.cra_exit\t\t= atmel_aes_cra_exit,\n\t.cra_u.ablkcipher = {\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t= atmel_aes_setkey,\n\t\t.encrypt\t= atmel_aes_cbc_encrypt,\n\t\t.decrypt\t= atmel_aes_cbc_decrypt,\n\t}\n},\n};\n```\n\n### 2. encrypt flow\n每当encryp 时， 我们将使用ablkcipher_enqueue_request() \n把`ablkcipher_request *req` 添加到队列上。在判断HW engine 是空闲可用时，再从queue 上取出并进行HW 的加解密操作。decrypt 的流程如此类似，区别在于设定HW 的mode 设定。\n\n![hw encrypt flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/aes-hw-encrypt-flow.png)\n\n### 2.1. data structure\n```c\nstruct crypto_queue {\n\tstruct list_head list;\n\tstruct list_head *backlog;\n\tunsigned int qlen;\n\tunsigned int max_qlen;\n};\n\nstruct ablkcipher_request {\n\tstruct crypto_async_request base;\n\tunsigned int nbytes;\n\tvoid *info;\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\tvoid *__ctx[] CRYPTO_MINALIGN_ATTR;\n};\n```\n\n在中断完成后，atmel_aes_done_task（）-> atmel_aes_finish_req() -> req->base.complete(&req->base, err) 这样会调用到complete（） 完成函数，实现了异步的通知行为。\n\n```c\nstatic void atmel_aes_done_task(unsigned long data)\n{\n\tstruct atmel_aes_dev *dd = (struct atmel_aes_dev *) data;\n\tint err;\n\n\tif (!(dd->flags & AES_FLAGS_DMA)) {\n\t\tatmel_aes_read_n(dd, AES_ODATAR(0), (u32 *) dd->buf_out,\n\t\t\t\tdd->bufcnt >> 2);\n\n\t\tif (sg_copy_from_buffer(dd->out_sg, dd->nb_out_sg,\n\t\t\tdd->buf_out, dd->bufcnt))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -EINVAL;\n\n\t\tgoto cpu_end;\n\t}\n\n\terr = atmel_aes_crypt_dma_stop(dd);\n\n\terr = dd->err ? : err;\n\n\tif (dd->total && !err) {\n\t\tif (dd->flags & AES_FLAGS_FAST) {\n\t\t\tdd->in_sg = sg_next(dd->in_sg);\n\t\t\tdd->out_sg = sg_next(dd->out_sg);\n\t\t\tif (!dd->in_sg || !dd->out_sg)\n\t\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (!err)\n\t\t\terr = atmel_aes_crypt_dma_start(dd);\n\t\tif (!err)\n\t\t\treturn; /* DMA started. Not fininishing. */\n\t}\n\ncpu_end:\n\tatmel_aes_finish_req(dd, err);\n\tatmel_aes_handle_queue(dd, NULL);\n}\n\nstatic void atmel_aes_finish_req(struct atmel_aes_dev *dd, int err)\n{\n\tstruct ablkcipher_request *req = dd->req;\n\n\tclk_disable_unprepare(dd->iclk);\n\tdd->flags &= ~AES_FLAGS_BUSY;\n\n\treq->base.complete(&req->base, err);\n}\n```\n\n我们可以参看kernel/crypto/testmgr.c 中的测试代码，它的使用案例。\n\n>init_completion(&result.completion);\nablkcipher_request_alloc(tfm, GFP_KERNEL);\nablkcipher_request_set_callback(req,CRYPTO_TFM_REQ_MAY_BACKLOG, tcrypt_complete, &result);\ncrypto_ablkcipher_clear_flags(tfm, ~0);\ncrypto_ablkcipher_setkey(tfm, template[i].key, template[i].klen);\nablkcipher_request_set_crypt(req, sg, sgout, template[i].ilen, iv);\ncrypto_ablkcipher_encrypt(req);\ncrypto_ablkcipher_decrypt(req);\n\n```c\nstatic void tcrypt_complete(struct crypto_async_request *req, int err)\n{\n\tstruct tcrypt_result *res = req->data;\n\n\tif (err == -EINPROGRESS)\n\t\treturn;\n\n\tres->err = err;\n\tcomplete(&res->completion);\n}\n\nstatic int __test_skcipher(struct crypto_ablkcipher *tfm, int enc,\n\t\t\t   struct cipher_testvec *template, unsigned int tcount,\n\t\t\t   const bool diff_dst, const int align_offset)\n{\n\tconst char *algo =\n\t\tcrypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));\n\tunsigned int i, j, k, n, temp;\n\tchar *q;\n\tstruct ablkcipher_request *req;\n\tstruct scatterlist sg[8];\n\tstruct scatterlist sgout[8];\n\tconst char *e, *d;\n\tstruct tcrypt_result result;\n\tvoid *data;\n\tchar iv[MAX_IVLEN];\n\tchar *xbuf[XBUFSIZE];\n\tchar *xoutbuf[XBUFSIZE];\n\tint ret = -ENOMEM;\n\n\tinit_completion(&result.completion);\n\n\treq = ablkcipher_request_alloc(tfm, GFP_KERNEL);\n\t\n\tablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\ttcrypt_complete, &result);\n\n\tj = 0;\n\tfor (i = 0; i < tcount; i++) {\n\t\tif (template[i].np && !template[i].also_non_np)\n\t\t\tcontinue;\n\n\t\tif (template[i].iv)\n\t\t\tmemcpy(iv, template[i].iv, MAX_IVLEN);\n\t\telse\n\t\t\tmemset(iv, 0, MAX_IVLEN);\n\n\t\tj++;\n\t\t\n\n\t\tdata = xbuf[0];\n\t\tdata += align_offset;\n\t\tmemcpy(data, template[i].input, template[i].ilen);\n\t\tcrypto_ablkcipher_clear_flags(tfm, ~0);\n\t\tret = crypto_ablkcipher_setkey(tfm, template[i].key,\n\t\t\t\t\t       template[i].klen);\n\n\t\tsg_init_one(&sg[0], data, template[i].ilen);\n\n\t\tablkcipher_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,\n\t\t\t\t\t     template[i].ilen, iv);\n\t\tret = enc ? crypto_ablkcipher_encrypt(req) :\n\t\t\t    crypto_ablkcipher_decrypt(req);\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -EINPROGRESS:\n\t\tcase -EBUSY:\n\t\t\tret = wait_for_completion_interruptible(\n\t\t\t\t&result.completion);\n\t\t\tif (!ret && !((ret = result.err))) {\n\t\t\t\treinit_completion(&result.completion);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tpr_err(\"alg: skcipher%s: %s failed on test %d for %s: ret=%d\\n\",\n\t\t\t       d, e, j, algo, -ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tq = data;\n\t\tif (memcmp(q, template[i].result, template[i].rlen)) {\n\t\t\tpr_err(\"alg: skcipher%s: Test %d failed on %s for %s\\n\",\n\t\t\t       d, j, e, algo);\n\t\t\thexdump(q, template[i].rlen);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\nout:\n\tablkcipher_request_free(req);\n\treturn ret;\n}\n```\n### 参看资料\n[3.18.11/drivers/crypto/atmel-aes.c](https://elixir.bootlin.com/linux/v3.18.11/source/drivers/crypto/atmel-aes.c)","source":"_posts/kernel-crypto-II.md","raw":"---\ntitle: kernel_crypto_II\ndate: 2019-08-06 20:04:59\ntags: cryptographic\ncategories: drivers\n---\n\n### 1. cipher 基础\n在Kernel crytographic 的cipher 还有如下几类：\n- ablkcipher_tfm(asynchronous multi-block cipher transform)  \n- blkcipher_tfm(synchronous multi-block cipher transform)   \n- cipher_tfm(Single block cipher transform)\n\n更为安全的是使用ahead 加密形式， 可以见此篇文章。[什么是AEAD加密](https://zhuanlan.zhihu.com/p/28566058)\n\n<!--more-->\n\n在kernel中cipher 都为skcipher(Symmetric Key cipher, 对称性加密算法)\n\n后面我们以kernel/drivers/crypto/atmel-aes.c 进行分析ablkcipher 的驱动。\n\n### 2. cipher alg register\natmel aes 驱动初始流程可见下图：\n![driver init flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/aes-init-flow.png)\n\n```c\nstatic struct crypto_alg aes_algs[] = {\n{\n\t.cra_name\t\t= \"ecb(aes)\",\n\t.cra_driver_name\t= \"atmel-ecb-aes\",\n\t.cra_priority\t\t= 100,\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,\n\t.cra_blocksize\t\t= AES_BLOCK_SIZE,\n\t.cra_ctxsize\t\t= sizeof(struct atmel_aes_ctx),\n\t.cra_alignmask\t\t= 0xf,\n\t.cra_type\t\t= &crypto_ablkcipher_type,\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= atmel_aes_cra_init,\n\t.cra_exit\t\t= atmel_aes_cra_exit,\n\t.cra_u.ablkcipher = {\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.setkey\t\t= atmel_aes_setkey,\n\t\t.encrypt\t= atmel_aes_ecb_encrypt,\n\t\t.decrypt\t= atmel_aes_ecb_decrypt,\n\t}\n},\n{\n\t.cra_name\t\t= \"cbc(aes)\",\n\t.cra_driver_name\t= \"atmel-cbc-aes\",\n\t.cra_priority\t\t= 100,\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,\n\t.cra_blocksize\t\t= AES_BLOCK_SIZE,\n\t.cra_ctxsize\t\t= sizeof(struct atmel_aes_ctx),\n\t.cra_alignmask\t\t= 0xf,\n\t.cra_type\t\t= &crypto_ablkcipher_type,\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= atmel_aes_cra_init,\n\t.cra_exit\t\t= atmel_aes_cra_exit,\n\t.cra_u.ablkcipher = {\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t= atmel_aes_setkey,\n\t\t.encrypt\t= atmel_aes_cbc_encrypt,\n\t\t.decrypt\t= atmel_aes_cbc_decrypt,\n\t}\n},\n};\n```\n\n### 2. encrypt flow\n每当encryp 时， 我们将使用ablkcipher_enqueue_request() \n把`ablkcipher_request *req` 添加到队列上。在判断HW engine 是空闲可用时，再从queue 上取出并进行HW 的加解密操作。decrypt 的流程如此类似，区别在于设定HW 的mode 设定。\n\n![hw encrypt flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/aes-hw-encrypt-flow.png)\n\n### 2.1. data structure\n```c\nstruct crypto_queue {\n\tstruct list_head list;\n\tstruct list_head *backlog;\n\tunsigned int qlen;\n\tunsigned int max_qlen;\n};\n\nstruct ablkcipher_request {\n\tstruct crypto_async_request base;\n\tunsigned int nbytes;\n\tvoid *info;\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\tvoid *__ctx[] CRYPTO_MINALIGN_ATTR;\n};\n```\n\n在中断完成后，atmel_aes_done_task（）-> atmel_aes_finish_req() -> req->base.complete(&req->base, err) 这样会调用到complete（） 完成函数，实现了异步的通知行为。\n\n```c\nstatic void atmel_aes_done_task(unsigned long data)\n{\n\tstruct atmel_aes_dev *dd = (struct atmel_aes_dev *) data;\n\tint err;\n\n\tif (!(dd->flags & AES_FLAGS_DMA)) {\n\t\tatmel_aes_read_n(dd, AES_ODATAR(0), (u32 *) dd->buf_out,\n\t\t\t\tdd->bufcnt >> 2);\n\n\t\tif (sg_copy_from_buffer(dd->out_sg, dd->nb_out_sg,\n\t\t\tdd->buf_out, dd->bufcnt))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -EINVAL;\n\n\t\tgoto cpu_end;\n\t}\n\n\terr = atmel_aes_crypt_dma_stop(dd);\n\n\terr = dd->err ? : err;\n\n\tif (dd->total && !err) {\n\t\tif (dd->flags & AES_FLAGS_FAST) {\n\t\t\tdd->in_sg = sg_next(dd->in_sg);\n\t\t\tdd->out_sg = sg_next(dd->out_sg);\n\t\t\tif (!dd->in_sg || !dd->out_sg)\n\t\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (!err)\n\t\t\terr = atmel_aes_crypt_dma_start(dd);\n\t\tif (!err)\n\t\t\treturn; /* DMA started. Not fininishing. */\n\t}\n\ncpu_end:\n\tatmel_aes_finish_req(dd, err);\n\tatmel_aes_handle_queue(dd, NULL);\n}\n\nstatic void atmel_aes_finish_req(struct atmel_aes_dev *dd, int err)\n{\n\tstruct ablkcipher_request *req = dd->req;\n\n\tclk_disable_unprepare(dd->iclk);\n\tdd->flags &= ~AES_FLAGS_BUSY;\n\n\treq->base.complete(&req->base, err);\n}\n```\n\n我们可以参看kernel/crypto/testmgr.c 中的测试代码，它的使用案例。\n\n>init_completion(&result.completion);\nablkcipher_request_alloc(tfm, GFP_KERNEL);\nablkcipher_request_set_callback(req,CRYPTO_TFM_REQ_MAY_BACKLOG, tcrypt_complete, &result);\ncrypto_ablkcipher_clear_flags(tfm, ~0);\ncrypto_ablkcipher_setkey(tfm, template[i].key, template[i].klen);\nablkcipher_request_set_crypt(req, sg, sgout, template[i].ilen, iv);\ncrypto_ablkcipher_encrypt(req);\ncrypto_ablkcipher_decrypt(req);\n\n```c\nstatic void tcrypt_complete(struct crypto_async_request *req, int err)\n{\n\tstruct tcrypt_result *res = req->data;\n\n\tif (err == -EINPROGRESS)\n\t\treturn;\n\n\tres->err = err;\n\tcomplete(&res->completion);\n}\n\nstatic int __test_skcipher(struct crypto_ablkcipher *tfm, int enc,\n\t\t\t   struct cipher_testvec *template, unsigned int tcount,\n\t\t\t   const bool diff_dst, const int align_offset)\n{\n\tconst char *algo =\n\t\tcrypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));\n\tunsigned int i, j, k, n, temp;\n\tchar *q;\n\tstruct ablkcipher_request *req;\n\tstruct scatterlist sg[8];\n\tstruct scatterlist sgout[8];\n\tconst char *e, *d;\n\tstruct tcrypt_result result;\n\tvoid *data;\n\tchar iv[MAX_IVLEN];\n\tchar *xbuf[XBUFSIZE];\n\tchar *xoutbuf[XBUFSIZE];\n\tint ret = -ENOMEM;\n\n\tinit_completion(&result.completion);\n\n\treq = ablkcipher_request_alloc(tfm, GFP_KERNEL);\n\t\n\tablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\ttcrypt_complete, &result);\n\n\tj = 0;\n\tfor (i = 0; i < tcount; i++) {\n\t\tif (template[i].np && !template[i].also_non_np)\n\t\t\tcontinue;\n\n\t\tif (template[i].iv)\n\t\t\tmemcpy(iv, template[i].iv, MAX_IVLEN);\n\t\telse\n\t\t\tmemset(iv, 0, MAX_IVLEN);\n\n\t\tj++;\n\t\t\n\n\t\tdata = xbuf[0];\n\t\tdata += align_offset;\n\t\tmemcpy(data, template[i].input, template[i].ilen);\n\t\tcrypto_ablkcipher_clear_flags(tfm, ~0);\n\t\tret = crypto_ablkcipher_setkey(tfm, template[i].key,\n\t\t\t\t\t       template[i].klen);\n\n\t\tsg_init_one(&sg[0], data, template[i].ilen);\n\n\t\tablkcipher_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,\n\t\t\t\t\t     template[i].ilen, iv);\n\t\tret = enc ? crypto_ablkcipher_encrypt(req) :\n\t\t\t    crypto_ablkcipher_decrypt(req);\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -EINPROGRESS:\n\t\tcase -EBUSY:\n\t\t\tret = wait_for_completion_interruptible(\n\t\t\t\t&result.completion);\n\t\t\tif (!ret && !((ret = result.err))) {\n\t\t\t\treinit_completion(&result.completion);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tpr_err(\"alg: skcipher%s: %s failed on test %d for %s: ret=%d\\n\",\n\t\t\t       d, e, j, algo, -ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tq = data;\n\t\tif (memcmp(q, template[i].result, template[i].rlen)) {\n\t\t\tpr_err(\"alg: skcipher%s: Test %d failed on %s for %s\\n\",\n\t\t\t       d, j, e, algo);\n\t\t\thexdump(q, template[i].rlen);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\nout:\n\tablkcipher_request_free(req);\n\treturn ret;\n}\n```\n### 参看资料\n[3.18.11/drivers/crypto/atmel-aes.c](https://elixir.bootlin.com/linux/v3.18.11/source/drivers/crypto/atmel-aes.c)","slug":"kernel-crypto-II","published":1,"updated":"2019-08-26T09:33:00.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0q1001xzkgrcdb0abep","content":"<h3 id=\"1-cipher-基础\"><a href=\"#1-cipher-基础\" class=\"headerlink\" title=\"1. cipher 基础\"></a>1. cipher 基础</h3><p>在Kernel crytographic 的cipher 还有如下几类：</p>\n<ul>\n<li>ablkcipher_tfm(asynchronous multi-block cipher transform)  </li>\n<li>blkcipher_tfm(synchronous multi-block cipher transform)   </li>\n<li>cipher_tfm(Single block cipher transform)</li>\n</ul>\n<p>更为安全的是使用ahead 加密形式， 可以见此篇文章。<a href=\"https://zhuanlan.zhihu.com/p/28566058\" target=\"_blank\" rel=\"noopener\">什么是AEAD加密</a></p>\n<a id=\"more\"></a>\n<p>在kernel中cipher 都为skcipher(Symmetric Key cipher, 对称性加密算法)</p>\n<p>后面我们以kernel/drivers/crypto/atmel-aes.c 进行分析ablkcipher 的驱动。</p>\n<h3 id=\"2-cipher-alg-register\"><a href=\"#2-cipher-alg-register\" class=\"headerlink\" title=\"2. cipher alg register\"></a>2. cipher alg register</h3><p>atmel aes 驱动初始流程可见下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/aes-init-flow.png\" alt=\"driver init flow\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_alg</span> <span class=\"title\">aes_algs</span>[] = &#123;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t.cra_name\t\t= <span class=\"string\">\"ecb(aes)\"</span>,</span><br><span class=\"line\">\t.cra_driver_name\t= <span class=\"string\">\"atmel-ecb-aes\"</span>,</span><br><span class=\"line\">\t.cra_priority\t\t= <span class=\"number\">100</span>,</span><br><span class=\"line\">\t.cra_flags\t\t= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,</span><br><span class=\"line\">\t.cra_blocksize\t\t= AES_BLOCK_SIZE,</span><br><span class=\"line\">\t.cra_ctxsize\t\t= <span class=\"keyword\">sizeof</span>(struct atmel_aes_ctx),</span><br><span class=\"line\">\t.cra_alignmask\t\t= <span class=\"number\">0xf</span>,</span><br><span class=\"line\">\t.cra_type\t\t= &amp;crypto_ablkcipher_type,</span><br><span class=\"line\">\t.cra_module\t\t= THIS_MODULE,</span><br><span class=\"line\">\t.cra_init\t\t= atmel_aes_cra_init,</span><br><span class=\"line\">\t.cra_exit\t\t= atmel_aes_cra_exit,</span><br><span class=\"line\">\t.cra_u.ablkcipher = &#123;</span><br><span class=\"line\">\t\t.min_keysize\t= AES_MIN_KEY_SIZE,</span><br><span class=\"line\">\t\t.max_keysize\t= AES_MAX_KEY_SIZE,</span><br><span class=\"line\">\t\t.setkey\t\t= atmel_aes_setkey,</span><br><span class=\"line\">\t\t.encrypt\t= atmel_aes_ecb_encrypt,</span><br><span class=\"line\">\t\t.decrypt\t= atmel_aes_ecb_decrypt,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t.cra_name\t\t= <span class=\"string\">\"cbc(aes)\"</span>,</span><br><span class=\"line\">\t.cra_driver_name\t= <span class=\"string\">\"atmel-cbc-aes\"</span>,</span><br><span class=\"line\">\t.cra_priority\t\t= <span class=\"number\">100</span>,</span><br><span class=\"line\">\t.cra_flags\t\t= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,</span><br><span class=\"line\">\t.cra_blocksize\t\t= AES_BLOCK_SIZE,</span><br><span class=\"line\">\t.cra_ctxsize\t\t= <span class=\"keyword\">sizeof</span>(struct atmel_aes_ctx),</span><br><span class=\"line\">\t.cra_alignmask\t\t= <span class=\"number\">0xf</span>,</span><br><span class=\"line\">\t.cra_type\t\t= &amp;crypto_ablkcipher_type,</span><br><span class=\"line\">\t.cra_module\t\t= THIS_MODULE,</span><br><span class=\"line\">\t.cra_init\t\t= atmel_aes_cra_init,</span><br><span class=\"line\">\t.cra_exit\t\t= atmel_aes_cra_exit,</span><br><span class=\"line\">\t.cra_u.ablkcipher = &#123;</span><br><span class=\"line\">\t\t.min_keysize\t= AES_MIN_KEY_SIZE,</span><br><span class=\"line\">\t\t.max_keysize\t= AES_MAX_KEY_SIZE,</span><br><span class=\"line\">\t\t.ivsize\t\t= AES_BLOCK_SIZE,</span><br><span class=\"line\">\t\t.setkey\t\t= atmel_aes_setkey,</span><br><span class=\"line\">\t\t.encrypt\t= atmel_aes_cbc_encrypt,</span><br><span class=\"line\">\t\t.decrypt\t= atmel_aes_cbc_decrypt,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-encrypt-flow\"><a href=\"#2-encrypt-flow\" class=\"headerlink\" title=\"2. encrypt flow\"></a>2. encrypt flow</h3><p>每当encryp 时， 我们将使用ablkcipher_enqueue_request()<br>把<code>ablkcipher_request *req</code> 添加到队列上。在判断HW engine 是空闲可用时，再从queue 上取出并进行HW 的加解密操作。decrypt 的流程如此类似，区别在于设定HW 的mode 设定。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/aes-hw-encrypt-flow.png\" alt=\"hw encrypt flow\"></p>\n<h3 id=\"2-1-data-structure\"><a href=\"#2-1-data-structure\" class=\"headerlink\" title=\"2.1. data structure\"></a>2.1. data structure</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_queue</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> *<span class=\"title\">backlog</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> qlen;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> max_qlen;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_request</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_async_request</span> <span class=\"title\">base</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *info;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> *<span class=\"title\">src</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> *<span class=\"title\">dst</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *__ctx[] CRYPTO_MINALIGN_ATTR;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在中断完成后，atmel_aes_done_task（）-&gt; atmel_aes_finish_req() -&gt; req-&gt;base.complete(&amp;req-&gt;base, err) 这样会调用到complete（） 完成函数，实现了异步的通知行为。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">atmel_aes_done_task</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">atmel_aes_dev</span> *<span class=\"title\">dd</span> = (<span class=\"title\">struct</span> <span class=\"title\">atmel_aes_dev</span> *) <span class=\"title\">data</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!(dd-&gt;flags &amp; AES_FLAGS_DMA)) &#123;</span><br><span class=\"line\">\t\tatmel_aes_read_n(dd, AES_ODATAR(<span class=\"number\">0</span>), (u32 *) dd-&gt;buf_out,</span><br><span class=\"line\">\t\t\t\tdd-&gt;bufcnt &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sg_copy_from_buffer(dd-&gt;out_sg, dd-&gt;nb_out_sg,</span><br><span class=\"line\">\t\t\tdd-&gt;buf_out, dd-&gt;bufcnt))</span><br><span class=\"line\">\t\t\terr = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\terr = -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> cpu_end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = atmel_aes_crypt_dma_stop(dd);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = dd-&gt;err ? : err;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dd-&gt;total &amp;&amp; !err) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dd-&gt;flags &amp; AES_FLAGS_FAST) &#123;</span><br><span class=\"line\">\t\t\tdd-&gt;in_sg = sg_next(dd-&gt;in_sg);</span><br><span class=\"line\">\t\t\tdd-&gt;out_sg = sg_next(dd-&gt;out_sg);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!dd-&gt;in_sg || !dd-&gt;out_sg)</span><br><span class=\"line\">\t\t\t\terr = -EINVAL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!err)</span><br><span class=\"line\">\t\t\terr = atmel_aes_crypt_dma_start(dd);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">/* DMA started. Not fininishing. */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_end:</span><br><span class=\"line\">\tatmel_aes_finish_req(dd, err);</span><br><span class=\"line\">\tatmel_aes_handle_queue(dd, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">atmel_aes_finish_req</span><span class=\"params\">(struct atmel_aes_dev *dd, <span class=\"keyword\">int</span> err)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_request</span> *<span class=\"title\">req</span> = <span class=\"title\">dd</span>-&gt;<span class=\"title\">req</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tclk_disable_unprepare(dd-&gt;iclk);</span><br><span class=\"line\">\tdd-&gt;flags &amp;= ~AES_FLAGS_BUSY;</span><br><span class=\"line\"></span><br><span class=\"line\">\treq-&gt;base.complete(&amp;req-&gt;base, err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以参看kernel/crypto/testmgr.c 中的测试代码，它的使用案例。</p>\n<blockquote>\n<p>init_completion(&amp;result.completion);<br>ablkcipher_request_alloc(tfm, GFP_KERNEL);<br>ablkcipher_request_set_callback(req,CRYPTO_TFM_REQ_MAY_BACKLOG, tcrypt_complete, &amp;result);<br>crypto_ablkcipher_clear_flags(tfm, ~0);<br>crypto_ablkcipher_setkey(tfm, template[i].key, template[i].klen);<br>ablkcipher_request_set_crypt(req, sg, sgout, template[i].ilen, iv);<br>crypto_ablkcipher_encrypt(req);<br>crypto_ablkcipher_decrypt(req);</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tcrypt_complete</span><span class=\"params\">(struct crypto_async_request *req, <span class=\"keyword\">int</span> err)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcrypt_result</span> *<span class=\"title\">res</span> = <span class=\"title\">req</span>-&gt;<span class=\"title\">data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (err == -EINPROGRESS)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tres-&gt;err = err;</span><br><span class=\"line\">\tcomplete(&amp;res-&gt;completion);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __test_skcipher(struct crypto_ablkcipher *tfm, <span class=\"keyword\">int</span> enc,</span><br><span class=\"line\">\t\t\t   struct cipher_testvec *<span class=\"keyword\">template</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> tcount,</span><br><span class=\"line\">\t\t\t   <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> diff_dst, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> align_offset)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *algo =</span><br><span class=\"line\">\t\tcrypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i, j, k, n, temp;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *q;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_request</span> *<span class=\"title\">req</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> <span class=\"title\">sg</span>[8];</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> <span class=\"title\">sgout</span>[8];</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *e, *d;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcrypt_result</span> <span class=\"title\">result</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> iv[MAX_IVLEN];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *xbuf[XBUFSIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *xoutbuf[XBUFSIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ret = -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">\tinit_completion(&amp;result.completion);</span><br><span class=\"line\"></span><br><span class=\"line\">\treq = ablkcipher_request_alloc(tfm, GFP_KERNEL);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span><br><span class=\"line\">\t\t\t\t\ttcrypt_complete, &amp;result);</span><br><span class=\"line\"></span><br><span class=\"line\">\tj = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tcount; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">template</span>[i].np &amp;&amp; !<span class=\"keyword\">template</span>[i].also_non_np)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">template</span>[i].iv)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(iv, <span class=\"keyword\">template</span>[i].iv, MAX_IVLEN);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memset</span>(iv, <span class=\"number\">0</span>, MAX_IVLEN);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdata = xbuf[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tdata += align_offset;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memcpy</span>(data, <span class=\"keyword\">template</span>[i].input, <span class=\"keyword\">template</span>[i].ilen);</span><br><span class=\"line\">\t\tcrypto_ablkcipher_clear_flags(tfm, ~<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tret = crypto_ablkcipher_setkey(tfm, <span class=\"keyword\">template</span>[i].key,</span><br><span class=\"line\">\t\t\t\t\t       <span class=\"keyword\">template</span>[i].klen);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsg_init_one(&amp;sg[<span class=\"number\">0</span>], data, <span class=\"keyword\">template</span>[i].ilen);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tablkcipher_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,</span><br><span class=\"line\">\t\t\t\t\t     <span class=\"keyword\">template</span>[i].ilen, iv);</span><br><span class=\"line\">\t\tret = enc ? crypto_ablkcipher_encrypt(req) :</span><br><span class=\"line\">\t\t\t    crypto_ablkcipher_decrypt(req);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (ret) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> -EINPROGRESS:</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> -EBUSY:</span><br><span class=\"line\">\t\t\tret = wait_for_completion_interruptible(</span><br><span class=\"line\">\t\t\t\t&amp;result.completion);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ret &amp;&amp; !((ret = result.err))) &#123;</span><br><span class=\"line\">\t\t\t\treinit_completion(&amp;result.completion);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* fall through */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tpr_err(<span class=\"string\">\"alg: skcipher%s: %s failed on test %d for %s: ret=%d\\n\"</span>,</span><br><span class=\"line\">\t\t\t       d, e, j, algo, -ret);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tq = data;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">memcmp</span>(q, <span class=\"keyword\">template</span>[i].result, <span class=\"keyword\">template</span>[i].rlen)) &#123;</span><br><span class=\"line\">\t\t\tpr_err(<span class=\"string\">\"alg: skcipher%s: Test %d failed on %s for %s\\n\"</span>,</span><br><span class=\"line\">\t\t\t       d, j, e, algo);</span><br><span class=\"line\">\t\t\thexdump(q, <span class=\"keyword\">template</span>[i].rlen);</span><br><span class=\"line\">\t\t\tret = -EINVAL;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tret = <span class=\"number\">0</span>;</span><br><span class=\"line\">out:</span><br><span class=\"line\">\tablkcipher_request_free(req);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://elixir.bootlin.com/linux/v3.18.11/source/drivers/crypto/atmel-aes.c\" target=\"_blank\" rel=\"noopener\">3.18.11/drivers/crypto/atmel-aes.c</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-cipher-基础\"><a href=\"#1-cipher-基础\" class=\"headerlink\" title=\"1. cipher 基础\"></a>1. cipher 基础</h3><p>在Kernel crytographic 的cipher 还有如下几类：</p>\n<ul>\n<li>ablkcipher_tfm(asynchronous multi-block cipher transform)  </li>\n<li>blkcipher_tfm(synchronous multi-block cipher transform)   </li>\n<li>cipher_tfm(Single block cipher transform)</li>\n</ul>\n<p>更为安全的是使用ahead 加密形式， 可以见此篇文章。<a href=\"https://zhuanlan.zhihu.com/p/28566058\" target=\"_blank\" rel=\"noopener\">什么是AEAD加密</a></p>","more":"<p>在kernel中cipher 都为skcipher(Symmetric Key cipher, 对称性加密算法)</p>\n<p>后面我们以kernel/drivers/crypto/atmel-aes.c 进行分析ablkcipher 的驱动。</p>\n<h3 id=\"2-cipher-alg-register\"><a href=\"#2-cipher-alg-register\" class=\"headerlink\" title=\"2. cipher alg register\"></a>2. cipher alg register</h3><p>atmel aes 驱动初始流程可见下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/aes-init-flow.png\" alt=\"driver init flow\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_alg</span> <span class=\"title\">aes_algs</span>[] = &#123;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t.cra_name\t\t= <span class=\"string\">\"ecb(aes)\"</span>,</span><br><span class=\"line\">\t.cra_driver_name\t= <span class=\"string\">\"atmel-ecb-aes\"</span>,</span><br><span class=\"line\">\t.cra_priority\t\t= <span class=\"number\">100</span>,</span><br><span class=\"line\">\t.cra_flags\t\t= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,</span><br><span class=\"line\">\t.cra_blocksize\t\t= AES_BLOCK_SIZE,</span><br><span class=\"line\">\t.cra_ctxsize\t\t= <span class=\"keyword\">sizeof</span>(struct atmel_aes_ctx),</span><br><span class=\"line\">\t.cra_alignmask\t\t= <span class=\"number\">0xf</span>,</span><br><span class=\"line\">\t.cra_type\t\t= &amp;crypto_ablkcipher_type,</span><br><span class=\"line\">\t.cra_module\t\t= THIS_MODULE,</span><br><span class=\"line\">\t.cra_init\t\t= atmel_aes_cra_init,</span><br><span class=\"line\">\t.cra_exit\t\t= atmel_aes_cra_exit,</span><br><span class=\"line\">\t.cra_u.ablkcipher = &#123;</span><br><span class=\"line\">\t\t.min_keysize\t= AES_MIN_KEY_SIZE,</span><br><span class=\"line\">\t\t.max_keysize\t= AES_MAX_KEY_SIZE,</span><br><span class=\"line\">\t\t.setkey\t\t= atmel_aes_setkey,</span><br><span class=\"line\">\t\t.encrypt\t= atmel_aes_ecb_encrypt,</span><br><span class=\"line\">\t\t.decrypt\t= atmel_aes_ecb_decrypt,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t.cra_name\t\t= <span class=\"string\">\"cbc(aes)\"</span>,</span><br><span class=\"line\">\t.cra_driver_name\t= <span class=\"string\">\"atmel-cbc-aes\"</span>,</span><br><span class=\"line\">\t.cra_priority\t\t= <span class=\"number\">100</span>,</span><br><span class=\"line\">\t.cra_flags\t\t= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,</span><br><span class=\"line\">\t.cra_blocksize\t\t= AES_BLOCK_SIZE,</span><br><span class=\"line\">\t.cra_ctxsize\t\t= <span class=\"keyword\">sizeof</span>(struct atmel_aes_ctx),</span><br><span class=\"line\">\t.cra_alignmask\t\t= <span class=\"number\">0xf</span>,</span><br><span class=\"line\">\t.cra_type\t\t= &amp;crypto_ablkcipher_type,</span><br><span class=\"line\">\t.cra_module\t\t= THIS_MODULE,</span><br><span class=\"line\">\t.cra_init\t\t= atmel_aes_cra_init,</span><br><span class=\"line\">\t.cra_exit\t\t= atmel_aes_cra_exit,</span><br><span class=\"line\">\t.cra_u.ablkcipher = &#123;</span><br><span class=\"line\">\t\t.min_keysize\t= AES_MIN_KEY_SIZE,</span><br><span class=\"line\">\t\t.max_keysize\t= AES_MAX_KEY_SIZE,</span><br><span class=\"line\">\t\t.ivsize\t\t= AES_BLOCK_SIZE,</span><br><span class=\"line\">\t\t.setkey\t\t= atmel_aes_setkey,</span><br><span class=\"line\">\t\t.encrypt\t= atmel_aes_cbc_encrypt,</span><br><span class=\"line\">\t\t.decrypt\t= atmel_aes_cbc_decrypt,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-encrypt-flow\"><a href=\"#2-encrypt-flow\" class=\"headerlink\" title=\"2. encrypt flow\"></a>2. encrypt flow</h3><p>每当encryp 时， 我们将使用ablkcipher_enqueue_request()<br>把<code>ablkcipher_request *req</code> 添加到队列上。在判断HW engine 是空闲可用时，再从queue 上取出并进行HW 的加解密操作。decrypt 的流程如此类似，区别在于设定HW 的mode 设定。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/aes-hw-encrypt-flow.png\" alt=\"hw encrypt flow\"></p>\n<h3 id=\"2-1-data-structure\"><a href=\"#2-1-data-structure\" class=\"headerlink\" title=\"2.1. data structure\"></a>2.1. data structure</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_queue</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> *<span class=\"title\">backlog</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> qlen;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> max_qlen;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_request</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_async_request</span> <span class=\"title\">base</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *info;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> *<span class=\"title\">src</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> *<span class=\"title\">dst</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *__ctx[] CRYPTO_MINALIGN_ATTR;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在中断完成后，atmel_aes_done_task（）-&gt; atmel_aes_finish_req() -&gt; req-&gt;base.complete(&amp;req-&gt;base, err) 这样会调用到complete（） 完成函数，实现了异步的通知行为。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">atmel_aes_done_task</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">atmel_aes_dev</span> *<span class=\"title\">dd</span> = (<span class=\"title\">struct</span> <span class=\"title\">atmel_aes_dev</span> *) <span class=\"title\">data</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!(dd-&gt;flags &amp; AES_FLAGS_DMA)) &#123;</span><br><span class=\"line\">\t\tatmel_aes_read_n(dd, AES_ODATAR(<span class=\"number\">0</span>), (u32 *) dd-&gt;buf_out,</span><br><span class=\"line\">\t\t\t\tdd-&gt;bufcnt &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sg_copy_from_buffer(dd-&gt;out_sg, dd-&gt;nb_out_sg,</span><br><span class=\"line\">\t\t\tdd-&gt;buf_out, dd-&gt;bufcnt))</span><br><span class=\"line\">\t\t\terr = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\terr = -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> cpu_end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = atmel_aes_crypt_dma_stop(dd);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = dd-&gt;err ? : err;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dd-&gt;total &amp;&amp; !err) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dd-&gt;flags &amp; AES_FLAGS_FAST) &#123;</span><br><span class=\"line\">\t\t\tdd-&gt;in_sg = sg_next(dd-&gt;in_sg);</span><br><span class=\"line\">\t\t\tdd-&gt;out_sg = sg_next(dd-&gt;out_sg);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!dd-&gt;in_sg || !dd-&gt;out_sg)</span><br><span class=\"line\">\t\t\t\terr = -EINVAL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!err)</span><br><span class=\"line\">\t\t\terr = atmel_aes_crypt_dma_start(dd);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">/* DMA started. Not fininishing. */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_end:</span><br><span class=\"line\">\tatmel_aes_finish_req(dd, err);</span><br><span class=\"line\">\tatmel_aes_handle_queue(dd, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">atmel_aes_finish_req</span><span class=\"params\">(struct atmel_aes_dev *dd, <span class=\"keyword\">int</span> err)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_request</span> *<span class=\"title\">req</span> = <span class=\"title\">dd</span>-&gt;<span class=\"title\">req</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tclk_disable_unprepare(dd-&gt;iclk);</span><br><span class=\"line\">\tdd-&gt;flags &amp;= ~AES_FLAGS_BUSY;</span><br><span class=\"line\"></span><br><span class=\"line\">\treq-&gt;base.complete(&amp;req-&gt;base, err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以参看kernel/crypto/testmgr.c 中的测试代码，它的使用案例。</p>\n<blockquote>\n<p>init_completion(&amp;result.completion);<br>ablkcipher_request_alloc(tfm, GFP_KERNEL);<br>ablkcipher_request_set_callback(req,CRYPTO_TFM_REQ_MAY_BACKLOG, tcrypt_complete, &amp;result);<br>crypto_ablkcipher_clear_flags(tfm, ~0);<br>crypto_ablkcipher_setkey(tfm, template[i].key, template[i].klen);<br>ablkcipher_request_set_crypt(req, sg, sgout, template[i].ilen, iv);<br>crypto_ablkcipher_encrypt(req);<br>crypto_ablkcipher_decrypt(req);</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tcrypt_complete</span><span class=\"params\">(struct crypto_async_request *req, <span class=\"keyword\">int</span> err)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcrypt_result</span> *<span class=\"title\">res</span> = <span class=\"title\">req</span>-&gt;<span class=\"title\">data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (err == -EINPROGRESS)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tres-&gt;err = err;</span><br><span class=\"line\">\tcomplete(&amp;res-&gt;completion);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __test_skcipher(struct crypto_ablkcipher *tfm, <span class=\"keyword\">int</span> enc,</span><br><span class=\"line\">\t\t\t   struct cipher_testvec *<span class=\"keyword\">template</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> tcount,</span><br><span class=\"line\">\t\t\t   <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> diff_dst, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> align_offset)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *algo =</span><br><span class=\"line\">\t\tcrypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i, j, k, n, temp;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *q;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_request</span> *<span class=\"title\">req</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> <span class=\"title\">sg</span>[8];</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> <span class=\"title\">sgout</span>[8];</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *e, *d;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcrypt_result</span> <span class=\"title\">result</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> iv[MAX_IVLEN];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *xbuf[XBUFSIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *xoutbuf[XBUFSIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ret = -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">\tinit_completion(&amp;result.completion);</span><br><span class=\"line\"></span><br><span class=\"line\">\treq = ablkcipher_request_alloc(tfm, GFP_KERNEL);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span><br><span class=\"line\">\t\t\t\t\ttcrypt_complete, &amp;result);</span><br><span class=\"line\"></span><br><span class=\"line\">\tj = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tcount; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">template</span>[i].np &amp;&amp; !<span class=\"keyword\">template</span>[i].also_non_np)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">template</span>[i].iv)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(iv, <span class=\"keyword\">template</span>[i].iv, MAX_IVLEN);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memset</span>(iv, <span class=\"number\">0</span>, MAX_IVLEN);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdata = xbuf[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tdata += align_offset;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memcpy</span>(data, <span class=\"keyword\">template</span>[i].input, <span class=\"keyword\">template</span>[i].ilen);</span><br><span class=\"line\">\t\tcrypto_ablkcipher_clear_flags(tfm, ~<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tret = crypto_ablkcipher_setkey(tfm, <span class=\"keyword\">template</span>[i].key,</span><br><span class=\"line\">\t\t\t\t\t       <span class=\"keyword\">template</span>[i].klen);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsg_init_one(&amp;sg[<span class=\"number\">0</span>], data, <span class=\"keyword\">template</span>[i].ilen);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tablkcipher_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,</span><br><span class=\"line\">\t\t\t\t\t     <span class=\"keyword\">template</span>[i].ilen, iv);</span><br><span class=\"line\">\t\tret = enc ? crypto_ablkcipher_encrypt(req) :</span><br><span class=\"line\">\t\t\t    crypto_ablkcipher_decrypt(req);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (ret) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> -EINPROGRESS:</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> -EBUSY:</span><br><span class=\"line\">\t\t\tret = wait_for_completion_interruptible(</span><br><span class=\"line\">\t\t\t\t&amp;result.completion);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ret &amp;&amp; !((ret = result.err))) &#123;</span><br><span class=\"line\">\t\t\t\treinit_completion(&amp;result.completion);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* fall through */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tpr_err(<span class=\"string\">\"alg: skcipher%s: %s failed on test %d for %s: ret=%d\\n\"</span>,</span><br><span class=\"line\">\t\t\t       d, e, j, algo, -ret);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tq = data;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">memcmp</span>(q, <span class=\"keyword\">template</span>[i].result, <span class=\"keyword\">template</span>[i].rlen)) &#123;</span><br><span class=\"line\">\t\t\tpr_err(<span class=\"string\">\"alg: skcipher%s: Test %d failed on %s for %s\\n\"</span>,</span><br><span class=\"line\">\t\t\t       d, j, e, algo);</span><br><span class=\"line\">\t\t\thexdump(q, <span class=\"keyword\">template</span>[i].rlen);</span><br><span class=\"line\">\t\t\tret = -EINVAL;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tret = <span class=\"number\">0</span>;</span><br><span class=\"line\">out:</span><br><span class=\"line\">\tablkcipher_request_free(req);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://elixir.bootlin.com/linux/v3.18.11/source/drivers/crypto/atmel-aes.c\" target=\"_blank\" rel=\"noopener\">3.18.11/drivers/crypto/atmel-aes.c</a></p>"},{"title":"kernel_dma_mem","date":"2019-06-28T05:55:44.000Z","_content":"\n在Kernel 中对于DMA 的一致性主要在驱动中会有需求，因为提供给硬件的地址，必须是总线地址即硬件地址且是连续的。为此，kernel提供了两种方式的DMA 映射：\n- 一致性DMA 映射（Coherent DMA Map）  \n- 流式DMA 映射（Streaming DMA Map） \n\n<!--more-->\n\n## 1. 一致性DMA 映射\n### 1.1. 一致性DMA\nkernel 提供了如下函数：\n``` c\n\nvoid *dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t       dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t       struct dma_attrs *attrs);\n\n#define dma_free_coherent(d, s, c, h) dma_free_attrs(d, s, c, h, NULL)\n\nvoid dma_free_coherent(struct device *dev, size_t size,\n\t\t\t\t     void *cpu_addr, dma_addr_t dma_handle,\n\t\t\t\t     struct dma_attrs *attrs);\n```\n\ndma_alloc_coherent（）-> arm_dma_alloc()\n```c\nvoid *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t    gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n\tvoid *memory;\n\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}\n\nstatic void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t\t gfp_t gfp, pgprot_t prot, bool is_coherent, const void *caller)\n{\n    ...\n    if (is_coherent || nommu())\n\t\taddr = __alloc_simple_buffer(dev, size, gfp, &page);\n\telse if (!(gfp & __GFP_WAIT))\n\t\taddr = __alloc_from_pool(size, &page);\n\telse if (!dev_get_cma_area(dev))\n\t\taddr = __alloc_remap_buffer(dev, size, gfp, prot, &page, caller);\n\telse\n\t\taddr = __alloc_from_contiguous(dev, size, prot, &page, caller);\n    \n}\n```\n\n根据配置，我们选择__alloc_remap_buffer（） 函数进行alloc， CMA 的方式了解请看下面的参看资料中的连接。[CMA模块学习笔记](http://www.wowotech.net/memory_management/cma.html)\n\n在__alloc_remap_buffer（） 会进行alloc_pages 操作，并在__dma_alloc_remap（）函数中进行page 属性的重新设定，标示为**nocache**, 这样就保证了CPU 与MEM 之间数据的一致性。\n```c\nstatic void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,\n\t\t\t\t pgprot_t prot, struct page **ret_page,\n\t\t\t\t const void *caller)\n{\n\tstruct page *page;\n\tvoid *ptr;\n\tpage = __dma_alloc_buffer(dev, size, gfp);\n\tif (!page)\n\t\treturn NULL;\n\n\tptr = __dma_alloc_remap(page, size, gfp, prot, caller);\n\tif (!ptr) {\n\t\t__dma_free_buffer(page, size);\n\t\treturn NULL;\n\t}\n\n\t*ret_page = page;\n\treturn ptr;\n}\n\nstatic void *\n__dma_alloc_remap(struct page *page, size_t size, gfp_t gfp, pgprot_t prot,\n\tconst void *caller)\n{\n\t/*\n\t * DMA allocation can be mapped to user space, so lets\n\t * set VM_USERMAP flags too.\n\t */\n\treturn dma_common_contiguous_remap(page, size,\n\t\t\tVM_ARM_DMA_CONSISTENT | VM_USERMAP,\n\t\t\tprot, caller);\n}\n```\n\n\n### 1.2 DMA 池\n```c\ndma_pool_create(name, dev, size, align, alloc);\ndma_pool_destroy(pool) pci_pool_destroy(pool);\ndma_pool_alloc(pool, flags, handle) pci_pool_alloc(pool, flags, handle);\ndma_pool_free(pool, vaddr, addr) pci_pool_free(pool, vaddr, addr);\n```\n\n## 2. 流式DMA 映射\n流式映射，kernel 还分为了两种形式：\n- 多page \n- 单个page \n\n### 2.1. 多个page 流式映射\nLDD3 上也叫做分散/聚集映射，原理大致与单个page 映射相同， 不同点在于多个循环映射 __struct scatterlist *sg__ 里面聚集的pages \n\ndma_data_direction分为如下几种：\n> - DMA_BIDIRECTIONAL （双向）\n> - DMA_FROM_DEVICE  \n> - DMA_TO_DEVICE  \n> - DMA_NONE \n\n```c\nenum dma_data_direction {\n\tDMA_BIDIRECTIONAL = 0,\n\tDMA_TO_DEVICE = 1,\n\tDMA_FROM_DEVICE = 2,\n\tDMA_NONE = 3,\n};\n```\n\n```c\nint dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\t   int nents, enum dma_data_direction dir,\n\t\t\t\t   struct dma_attrs *attrs);\n\nvoid dma_unmap_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\t      int nents, enum dma_data_direction dir,\n\t\t\t\t      struct dma_attrs *attrs);\n```\n\n**注意：在dma_unmap_sg 之前，CPU 是不能操作page的， 原因在于这些addr 都是cached 地址，只有在保证地址被flush 到主存中才能让CPU 操作**\n\nKernel 封装了如下函数，帮助我们显示的刷新cache 的数据，保证数据cache, memory 之间的一致性。\n\n使用dma_sync_sg_for_cpu（）函数，将使用权给CPU（之后Device 不能访问，否则数据不一致），\n使用dma_sync_sg_for_device（）函数，将使用权给Device（CPU 不能访问）。\n\n```c\nvoid\ndma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\n\t\t    int nelems, enum dma_data_direction dir);\n\nvoid\ndma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,\n\t\t       int nelems, enum dma_data_direction dir)  ;\n```\n究其原因，是因为流式DMA缓冲区是cached，在map时刷了下cache，在设备DMA完成unmap时再刷cache（根据数据流向写回或者无效），来保证了cache数据一致性，在unmap之前CPU操作缓冲区是不能保证数据一致的。因此kernel需要严格保证操作时序。\n当然kernel也提供函数dma_sync_sg_for_cpu与dma_sync_sg_for_device，可以在未释放时操作缓冲区，很明显这2个函数实现中肯定是再次进行刷新cache的操作保证数据一致性。\n\n### 2.2. 单个page 流式映射\n```c\ndma_map_single(dev, addr, size, dir);\ndma_unmap_single(dev, hnd, size, dir);\n```\n\n与前面分散/聚集的多页映射一样， 我们不能在Device 访问期间，CPU 在访问，两者不能交互访问。\n```c\nvoid dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr,\n\t\t\t\t\t   size_t size,\n\t\t\t\t\t   enum dma_data_direction dir);\n\nvoid dma_sync_single_for_device(struct device *dev,\n\t\t\t\t\t      dma_addr_t addr, size_t size,\n\t\t\t\t\t      enum dma_data_direction dir); \n```                       \n\ndma_map_single ==> __dma_map_page ==> __dma_page_cpu_to_dev ==> ___dma_page_cpu_to_dev \n```c\nstatic void __dma_page_cpu_to_dev(struct page *page, unsigned long off,\n\tsize_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr;\n\n\tdma_cache_maint_page(page, off, size, dir, dmac_map_area);\n\n\tpaddr = page_to_phys(page) + off;\n\tif (dir == DMA_FROM_DEVICE) {\n\t\touter_inv_range(paddr, paddr + size);\n\t} else {\n\t\touter_clean_range(paddr, paddr + size);\n\t}\n\t/* FIXME: non-speculating: flush on bidirectional mappings? */\n}\n```\n\ndmac_map_area 在我们配置的ARMV7 是指向的rch/arm/mm/cache-v7.S 文件中\n```asm\nENTRY(v7_dma_map_area)\n\tadd\tr1, r1, r0\n\tteq\tr2, #DMA_FROM_DEVICE\n\tbeq\tv7_dma_inv_range\n\tb\tv7_dma_clean_range\nENDPROC(v7_dma_map_area)\n\nENTRY(v7_dma_unmap_area)\n\tadd\tr1, r1, r0\n\tteq\tr2, #DMA_TO_DEVICE\n\tbne\tv7_dma_inv_range\n\tret\tlr\nENDPROC(v7_dma_unmap_area)\n```\n我们由此可以看出dma_map_sigle() 最终是使用汇编指令clean 或者invalidate cache 里面的数据，保证cache 与mem 之间的一致性。因此，在给Device 访问后，禁止CPU 访问，除非使用dma_sync_single_for_cpu（）函数，以此来将cache 数据invalidate。\n\n## 参看资料\nhttps://blog.csdn.net/skyflying2012/article/\nhttps://my.oschina.net/yepanl/blog/3053881\nhttp://www.wowotech.net/memory_management/cma.html","source":"_posts/kernel-dma-mem.md","raw":"---\ntitle: kernel_dma_mem\ndate: 2019-06-28 13:55:44\ntags:\n    - memory\n    - kernel\ncategories:\n    - memory\n---\n\n在Kernel 中对于DMA 的一致性主要在驱动中会有需求，因为提供给硬件的地址，必须是总线地址即硬件地址且是连续的。为此，kernel提供了两种方式的DMA 映射：\n- 一致性DMA 映射（Coherent DMA Map）  \n- 流式DMA 映射（Streaming DMA Map） \n\n<!--more-->\n\n## 1. 一致性DMA 映射\n### 1.1. 一致性DMA\nkernel 提供了如下函数：\n``` c\n\nvoid *dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t       dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t       struct dma_attrs *attrs);\n\n#define dma_free_coherent(d, s, c, h) dma_free_attrs(d, s, c, h, NULL)\n\nvoid dma_free_coherent(struct device *dev, size_t size,\n\t\t\t\t     void *cpu_addr, dma_addr_t dma_handle,\n\t\t\t\t     struct dma_attrs *attrs);\n```\n\ndma_alloc_coherent（）-> arm_dma_alloc()\n```c\nvoid *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t    gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n\tvoid *memory;\n\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}\n\nstatic void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t\t gfp_t gfp, pgprot_t prot, bool is_coherent, const void *caller)\n{\n    ...\n    if (is_coherent || nommu())\n\t\taddr = __alloc_simple_buffer(dev, size, gfp, &page);\n\telse if (!(gfp & __GFP_WAIT))\n\t\taddr = __alloc_from_pool(size, &page);\n\telse if (!dev_get_cma_area(dev))\n\t\taddr = __alloc_remap_buffer(dev, size, gfp, prot, &page, caller);\n\telse\n\t\taddr = __alloc_from_contiguous(dev, size, prot, &page, caller);\n    \n}\n```\n\n根据配置，我们选择__alloc_remap_buffer（） 函数进行alloc， CMA 的方式了解请看下面的参看资料中的连接。[CMA模块学习笔记](http://www.wowotech.net/memory_management/cma.html)\n\n在__alloc_remap_buffer（） 会进行alloc_pages 操作，并在__dma_alloc_remap（）函数中进行page 属性的重新设定，标示为**nocache**, 这样就保证了CPU 与MEM 之间数据的一致性。\n```c\nstatic void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,\n\t\t\t\t pgprot_t prot, struct page **ret_page,\n\t\t\t\t const void *caller)\n{\n\tstruct page *page;\n\tvoid *ptr;\n\tpage = __dma_alloc_buffer(dev, size, gfp);\n\tif (!page)\n\t\treturn NULL;\n\n\tptr = __dma_alloc_remap(page, size, gfp, prot, caller);\n\tif (!ptr) {\n\t\t__dma_free_buffer(page, size);\n\t\treturn NULL;\n\t}\n\n\t*ret_page = page;\n\treturn ptr;\n}\n\nstatic void *\n__dma_alloc_remap(struct page *page, size_t size, gfp_t gfp, pgprot_t prot,\n\tconst void *caller)\n{\n\t/*\n\t * DMA allocation can be mapped to user space, so lets\n\t * set VM_USERMAP flags too.\n\t */\n\treturn dma_common_contiguous_remap(page, size,\n\t\t\tVM_ARM_DMA_CONSISTENT | VM_USERMAP,\n\t\t\tprot, caller);\n}\n```\n\n\n### 1.2 DMA 池\n```c\ndma_pool_create(name, dev, size, align, alloc);\ndma_pool_destroy(pool) pci_pool_destroy(pool);\ndma_pool_alloc(pool, flags, handle) pci_pool_alloc(pool, flags, handle);\ndma_pool_free(pool, vaddr, addr) pci_pool_free(pool, vaddr, addr);\n```\n\n## 2. 流式DMA 映射\n流式映射，kernel 还分为了两种形式：\n- 多page \n- 单个page \n\n### 2.1. 多个page 流式映射\nLDD3 上也叫做分散/聚集映射，原理大致与单个page 映射相同， 不同点在于多个循环映射 __struct scatterlist *sg__ 里面聚集的pages \n\ndma_data_direction分为如下几种：\n> - DMA_BIDIRECTIONAL （双向）\n> - DMA_FROM_DEVICE  \n> - DMA_TO_DEVICE  \n> - DMA_NONE \n\n```c\nenum dma_data_direction {\n\tDMA_BIDIRECTIONAL = 0,\n\tDMA_TO_DEVICE = 1,\n\tDMA_FROM_DEVICE = 2,\n\tDMA_NONE = 3,\n};\n```\n\n```c\nint dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\t   int nents, enum dma_data_direction dir,\n\t\t\t\t   struct dma_attrs *attrs);\n\nvoid dma_unmap_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\t      int nents, enum dma_data_direction dir,\n\t\t\t\t      struct dma_attrs *attrs);\n```\n\n**注意：在dma_unmap_sg 之前，CPU 是不能操作page的， 原因在于这些addr 都是cached 地址，只有在保证地址被flush 到主存中才能让CPU 操作**\n\nKernel 封装了如下函数，帮助我们显示的刷新cache 的数据，保证数据cache, memory 之间的一致性。\n\n使用dma_sync_sg_for_cpu（）函数，将使用权给CPU（之后Device 不能访问，否则数据不一致），\n使用dma_sync_sg_for_device（）函数，将使用权给Device（CPU 不能访问）。\n\n```c\nvoid\ndma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\n\t\t    int nelems, enum dma_data_direction dir);\n\nvoid\ndma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,\n\t\t       int nelems, enum dma_data_direction dir)  ;\n```\n究其原因，是因为流式DMA缓冲区是cached，在map时刷了下cache，在设备DMA完成unmap时再刷cache（根据数据流向写回或者无效），来保证了cache数据一致性，在unmap之前CPU操作缓冲区是不能保证数据一致的。因此kernel需要严格保证操作时序。\n当然kernel也提供函数dma_sync_sg_for_cpu与dma_sync_sg_for_device，可以在未释放时操作缓冲区，很明显这2个函数实现中肯定是再次进行刷新cache的操作保证数据一致性。\n\n### 2.2. 单个page 流式映射\n```c\ndma_map_single(dev, addr, size, dir);\ndma_unmap_single(dev, hnd, size, dir);\n```\n\n与前面分散/聚集的多页映射一样， 我们不能在Device 访问期间，CPU 在访问，两者不能交互访问。\n```c\nvoid dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr,\n\t\t\t\t\t   size_t size,\n\t\t\t\t\t   enum dma_data_direction dir);\n\nvoid dma_sync_single_for_device(struct device *dev,\n\t\t\t\t\t      dma_addr_t addr, size_t size,\n\t\t\t\t\t      enum dma_data_direction dir); \n```                       \n\ndma_map_single ==> __dma_map_page ==> __dma_page_cpu_to_dev ==> ___dma_page_cpu_to_dev \n```c\nstatic void __dma_page_cpu_to_dev(struct page *page, unsigned long off,\n\tsize_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr;\n\n\tdma_cache_maint_page(page, off, size, dir, dmac_map_area);\n\n\tpaddr = page_to_phys(page) + off;\n\tif (dir == DMA_FROM_DEVICE) {\n\t\touter_inv_range(paddr, paddr + size);\n\t} else {\n\t\touter_clean_range(paddr, paddr + size);\n\t}\n\t/* FIXME: non-speculating: flush on bidirectional mappings? */\n}\n```\n\ndmac_map_area 在我们配置的ARMV7 是指向的rch/arm/mm/cache-v7.S 文件中\n```asm\nENTRY(v7_dma_map_area)\n\tadd\tr1, r1, r0\n\tteq\tr2, #DMA_FROM_DEVICE\n\tbeq\tv7_dma_inv_range\n\tb\tv7_dma_clean_range\nENDPROC(v7_dma_map_area)\n\nENTRY(v7_dma_unmap_area)\n\tadd\tr1, r1, r0\n\tteq\tr2, #DMA_TO_DEVICE\n\tbne\tv7_dma_inv_range\n\tret\tlr\nENDPROC(v7_dma_unmap_area)\n```\n我们由此可以看出dma_map_sigle() 最终是使用汇编指令clean 或者invalidate cache 里面的数据，保证cache 与mem 之间的一致性。因此，在给Device 访问后，禁止CPU 访问，除非使用dma_sync_single_for_cpu（）函数，以此来将cache 数据invalidate。\n\n## 参看资料\nhttps://blog.csdn.net/skyflying2012/article/\nhttps://my.oschina.net/yepanl/blog/3053881\nhttp://www.wowotech.net/memory_management/cma.html","slug":"kernel-dma-mem","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0q30022zkgr1jf1fdaw","content":"<p>在Kernel 中对于DMA 的一致性主要在驱动中会有需求，因为提供给硬件的地址，必须是总线地址即硬件地址且是连续的。为此，kernel提供了两种方式的DMA 映射：</p>\n<ul>\n<li>一致性DMA 映射（Coherent DMA Map）  </li>\n<li>流式DMA 映射（Streaming DMA Map） </li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"1-一致性DMA-映射\"><a href=\"#1-一致性DMA-映射\" class=\"headerlink\" title=\"1. 一致性DMA 映射\"></a>1. 一致性DMA 映射</h2><h3 id=\"1-1-一致性DMA\"><a href=\"#1-1-一致性DMA\" class=\"headerlink\" title=\"1.1. 一致性DMA\"></a>1.1. 一致性DMA</h3><p>kernel 提供了如下函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">dma_alloc_coherent</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t       <span class=\"keyword\">dma_addr_t</span> *dma_handle, <span class=\"keyword\">gfp_t</span> flag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t       struct dma_attrs *attrs)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> dma_free_coherent(d, s, c, h) dma_free_attrs(d, s, c, h, NULL)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dma_free_coherent</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t     <span class=\"keyword\">void</span> *cpu_addr, <span class=\"keyword\">dma_addr_t</span> dma_handle,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t     struct dma_attrs *attrs)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>dma_alloc_coherent（）-&gt; arm_dma_alloc()<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">arm_dma_alloc</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">dma_addr_t</span> *handle,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t    <span class=\"keyword\">gfp_t</span> gfp, struct dma_attrs *attrs)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pgprot_t</span> prot = __get_dma_pgprot(attrs, PAGE_KERNEL);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *memory;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dma_alloc_from_coherent(dev, size, handle, &amp;memory))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> memory;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __dma_alloc(dev, size, handle, gfp, prot, <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t   __builtin_return_address(<span class=\"number\">0</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *__dma_alloc(struct device *dev, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">dma_addr_t</span> *handle,</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">gfp_t</span> gfp, <span class=\"keyword\">pgprot_t</span> prot, <span class=\"keyword\">bool</span> is_coherent, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *caller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_coherent || nommu())</span><br><span class=\"line\">\t\taddr = __alloc_simple_buffer(dev, size, gfp, &amp;page);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!(gfp &amp; __GFP_WAIT))</span><br><span class=\"line\">\t\taddr = __alloc_from_pool(size, &amp;page);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!dev_get_cma_area(dev))</span><br><span class=\"line\">\t\taddr = __alloc_remap_buffer(dev, size, gfp, prot, &amp;page, caller);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\taddr = __alloc_from_contiguous(dev, size, prot, &amp;page, caller);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>根据配置，我们选择__alloc_remap_buffer（） 函数进行alloc， CMA 的方式了解请看下面的参看资料中的连接。<a href=\"http://www.wowotech.net/memory_management/cma.html\" target=\"_blank\" rel=\"noopener\">CMA模块学习笔记</a></p>\n<p>在<strong>alloc_remap_buffer（） 会进行alloc_pages 操作，并在</strong>dma_alloc_remap（）函数中进行page 属性的重新设定，标示为<strong>nocache</strong>, 这样就保证了CPU 与MEM 之间数据的一致性。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *__alloc_remap_buffer(struct device *dev, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">gfp_t</span> gfp,</span><br><span class=\"line\">\t\t\t\t <span class=\"keyword\">pgprot_t</span> prot, struct page **ret_page,</span><br><span class=\"line\">\t\t\t\t <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *caller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">\tpage = __dma_alloc_buffer(dev, size, gfp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!page)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tptr = __dma_alloc_remap(page, size, gfp, prot, caller);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ptr) &#123;</span><br><span class=\"line\">\t\t__dma_free_buffer(page, size);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*ret_page = page;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *</span><br><span class=\"line\">__dma_alloc_remap(struct page *page, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">gfp_t</span> gfp, <span class=\"keyword\">pgprot_t</span> prot,</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *caller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * DMA allocation can be mapped to user space, so lets</span></span><br><span class=\"line\"><span class=\"comment\">\t * set VM_USERMAP flags too.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dma_common_contiguous_remap(page, size,</span><br><span class=\"line\">\t\t\tVM_ARM_DMA_CONSISTENT | VM_USERMAP,</span><br><span class=\"line\">\t\t\tprot, caller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-2-DMA-池\"><a href=\"#1-2-DMA-池\" class=\"headerlink\" title=\"1.2 DMA 池\"></a>1.2 DMA 池</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dma_pool_create(name, dev, size, align, alloc);</span><br><span class=\"line\">dma_pool_destroy(pool) pci_pool_destroy(pool);</span><br><span class=\"line\">dma_pool_alloc(pool, flags, handle) pci_pool_alloc(pool, flags, handle);</span><br><span class=\"line\">dma_pool_free(pool, vaddr, addr) pci_pool_free(pool, vaddr, addr);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-流式DMA-映射\"><a href=\"#2-流式DMA-映射\" class=\"headerlink\" title=\"2. 流式DMA 映射\"></a>2. 流式DMA 映射</h2><p>流式映射，kernel 还分为了两种形式：</p>\n<ul>\n<li>多page </li>\n<li>单个page </li>\n</ul>\n<h3 id=\"2-1-多个page-流式映射\"><a href=\"#2-1-多个page-流式映射\" class=\"headerlink\" title=\"2.1. 多个page 流式映射\"></a>2.1. 多个page 流式映射</h3><p>LDD3 上也叫做分散/聚集映射，原理大致与单个page 映射相同， 不同点在于多个循环映射 <strong>struct scatterlist *sg</strong> 里面聚集的pages </p>\n<p>dma_data_direction分为如下几种：</p>\n<blockquote>\n<ul>\n<li>DMA_BIDIRECTIONAL （双向）</li>\n<li>DMA_FROM_DEVICE  </li>\n<li>DMA_TO_DEVICE  </li>\n<li>DMA_NONE </li>\n</ul>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> dma_data_direction &#123;</span><br><span class=\"line\">\tDMA_BIDIRECTIONAL = <span class=\"number\">0</span>,</span><br><span class=\"line\">\tDMA_TO_DEVICE = <span class=\"number\">1</span>,</span><br><span class=\"line\">\tDMA_FROM_DEVICE = <span class=\"number\">2</span>,</span><br><span class=\"line\">\tDMA_NONE = <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dma_map_sg</span><span class=\"params\">(struct device *dev, struct scatterlist *sg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t   <span class=\"keyword\">int</span> nents, <span class=\"keyword\">enum</span> dma_data_direction dir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t   struct dma_attrs *attrs)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dma_unmap_sg</span><span class=\"params\">(struct device *dev, struct scatterlist *sg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t      <span class=\"keyword\">int</span> nents, <span class=\"keyword\">enum</span> dma_data_direction dir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t      struct dma_attrs *attrs)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：在dma_unmap_sg 之前，CPU 是不能操作page的， 原因在于这些addr 都是cached 地址，只有在保证地址被flush 到主存中才能让CPU 操作</strong></p>\n<p>Kernel 封装了如下函数，帮助我们显示的刷新cache 的数据，保证数据cache, memory 之间的一致性。</p>\n<p>使用dma_sync_sg_for_cpu（）函数，将使用权给CPU（之后Device 不能访问，否则数据不一致），<br>使用dma_sync_sg_for_device（）函数，将使用权给Device（CPU 不能访问）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span></span><br><span class=\"line\">dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,</span><br><span class=\"line\">\t\t    <span class=\"keyword\">int</span> nelems, <span class=\"keyword\">enum</span> dma_data_direction dir);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span></span><br><span class=\"line\">dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,</span><br><span class=\"line\">\t\t       <span class=\"keyword\">int</span> nelems, <span class=\"keyword\">enum</span> dma_data_direction dir)  ;</span><br></pre></td></tr></table></figure>\n<p>究其原因，是因为流式DMA缓冲区是cached，在map时刷了下cache，在设备DMA完成unmap时再刷cache（根据数据流向写回或者无效），来保证了cache数据一致性，在unmap之前CPU操作缓冲区是不能保证数据一致的。因此kernel需要严格保证操作时序。<br>当然kernel也提供函数dma_sync_sg_for_cpu与dma_sync_sg_for_device，可以在未释放时操作缓冲区，很明显这2个函数实现中肯定是再次进行刷新cache的操作保证数据一致性。</p>\n<h3 id=\"2-2-单个page-流式映射\"><a href=\"#2-2-单个page-流式映射\" class=\"headerlink\" title=\"2.2. 单个page 流式映射\"></a>2.2. 单个page 流式映射</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dma_map_single(dev, addr, size, dir);</span><br><span class=\"line\">dma_unmap_single(dev, hnd, size, dir);</span><br></pre></td></tr></table></figure>\n<p>与前面分散/聚集的多页映射一样， 我们不能在Device 访问期间，CPU 在访问，两者不能交互访问。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dma_sync_single_for_cpu</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">dma_addr_t</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t   <span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t   <span class=\"keyword\">enum</span> dma_data_direction dir)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dma_sync_single_for_device</span><span class=\"params\">(struct device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t      <span class=\"keyword\">dma_addr_t</span> addr, <span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t      <span class=\"keyword\">enum</span> dma_data_direction dir)</span></span>; </span><br><span class=\"line\">```                       </span><br><span class=\"line\"></span><br><span class=\"line\">dma_map_single ==&gt; __dma_map_page ==&gt; __dma_page_cpu_to_dev ==&gt; ___dma_page_cpu_to_dev </span><br><span class=\"line\">```c</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __dma_page_cpu_to_dev(struct page *page, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> off,</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> size, <span class=\"keyword\">enum</span> dma_data_direction dir)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">phys_addr_t</span> paddr;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdma_cache_maint_page(page, off, size, dir, dmac_map_area);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpaddr = page_to_phys(page) + off;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dir == DMA_FROM_DEVICE) &#123;</span><br><span class=\"line\">\t\touter_inv_range(paddr, paddr + size);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\touter_clean_range(paddr, paddr + size);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/* <span class=\"doctag\">FIXME:</span> non-speculating: flush on bidirectional mappings? */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>dmac_map_area 在我们配置的ARMV7 是指向的rch/arm/mm/cache-v7.S 文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRY(v7_dma_map_area)</span><br><span class=\"line\">\tadd\tr1, r1, r0</span><br><span class=\"line\">\tteq\tr2, #DMA_FROM_DEVICE</span><br><span class=\"line\">\tbeq\tv7_dma_inv_range</span><br><span class=\"line\">\tb\tv7_dma_clean_range</span><br><span class=\"line\">ENDPROC(v7_dma_map_area)</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRY(v7_dma_unmap_area)</span><br><span class=\"line\">\tadd\tr1, r1, r0</span><br><span class=\"line\">\tteq\tr2, #DMA_TO_DEVICE</span><br><span class=\"line\">\tbne\tv7_dma_inv_range</span><br><span class=\"line\">\tret\tlr</span><br><span class=\"line\">ENDPROC(v7_dma_unmap_area)</span><br></pre></td></tr></table></figure></p>\n<p>我们由此可以看出dma_map_sigle() 最终是使用汇编指令clean 或者invalidate cache 里面的数据，保证cache 与mem 之间的一致性。因此，在给Device 访问后，禁止CPU 访问，除非使用dma_sync_single_for_cpu（）函数，以此来将cache 数据invalidate。</p>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://blog.csdn.net/skyflying2012/article/\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/skyflying2012/article/</a><br><a href=\"https://my.oschina.net/yepanl/blog/3053881\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/yepanl/blog/3053881</a><br><a href=\"http://www.wowotech.net/memory_management/cma.html\" target=\"_blank\" rel=\"noopener\">http://www.wowotech.net/memory_management/cma.html</a></p>\n","site":{"data":{}},"excerpt":"<p>在Kernel 中对于DMA 的一致性主要在驱动中会有需求，因为提供给硬件的地址，必须是总线地址即硬件地址且是连续的。为此，kernel提供了两种方式的DMA 映射：</p>\n<ul>\n<li>一致性DMA 映射（Coherent DMA Map）  </li>\n<li>流式DMA 映射（Streaming DMA Map） </li>\n</ul>","more":"<h2 id=\"1-一致性DMA-映射\"><a href=\"#1-一致性DMA-映射\" class=\"headerlink\" title=\"1. 一致性DMA 映射\"></a>1. 一致性DMA 映射</h2><h3 id=\"1-1-一致性DMA\"><a href=\"#1-1-一致性DMA\" class=\"headerlink\" title=\"1.1. 一致性DMA\"></a>1.1. 一致性DMA</h3><p>kernel 提供了如下函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">dma_alloc_coherent</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t       <span class=\"keyword\">dma_addr_t</span> *dma_handle, <span class=\"keyword\">gfp_t</span> flag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t       struct dma_attrs *attrs)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> dma_free_coherent(d, s, c, h) dma_free_attrs(d, s, c, h, NULL)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dma_free_coherent</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t     <span class=\"keyword\">void</span> *cpu_addr, <span class=\"keyword\">dma_addr_t</span> dma_handle,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t     struct dma_attrs *attrs)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>dma_alloc_coherent（）-&gt; arm_dma_alloc()<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">arm_dma_alloc</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">dma_addr_t</span> *handle,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t    <span class=\"keyword\">gfp_t</span> gfp, struct dma_attrs *attrs)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pgprot_t</span> prot = __get_dma_pgprot(attrs, PAGE_KERNEL);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *memory;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dma_alloc_from_coherent(dev, size, handle, &amp;memory))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> memory;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __dma_alloc(dev, size, handle, gfp, prot, <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t   __builtin_return_address(<span class=\"number\">0</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *__dma_alloc(struct device *dev, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">dma_addr_t</span> *handle,</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">gfp_t</span> gfp, <span class=\"keyword\">pgprot_t</span> prot, <span class=\"keyword\">bool</span> is_coherent, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *caller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_coherent || nommu())</span><br><span class=\"line\">\t\taddr = __alloc_simple_buffer(dev, size, gfp, &amp;page);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!(gfp &amp; __GFP_WAIT))</span><br><span class=\"line\">\t\taddr = __alloc_from_pool(size, &amp;page);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!dev_get_cma_area(dev))</span><br><span class=\"line\">\t\taddr = __alloc_remap_buffer(dev, size, gfp, prot, &amp;page, caller);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\taddr = __alloc_from_contiguous(dev, size, prot, &amp;page, caller);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>根据配置，我们选择__alloc_remap_buffer（） 函数进行alloc， CMA 的方式了解请看下面的参看资料中的连接。<a href=\"http://www.wowotech.net/memory_management/cma.html\" target=\"_blank\" rel=\"noopener\">CMA模块学习笔记</a></p>\n<p>在<strong>alloc_remap_buffer（） 会进行alloc_pages 操作，并在</strong>dma_alloc_remap（）函数中进行page 属性的重新设定，标示为<strong>nocache</strong>, 这样就保证了CPU 与MEM 之间数据的一致性。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *__alloc_remap_buffer(struct device *dev, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">gfp_t</span> gfp,</span><br><span class=\"line\">\t\t\t\t <span class=\"keyword\">pgprot_t</span> prot, struct page **ret_page,</span><br><span class=\"line\">\t\t\t\t <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *caller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">\tpage = __dma_alloc_buffer(dev, size, gfp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!page)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tptr = __dma_alloc_remap(page, size, gfp, prot, caller);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ptr) &#123;</span><br><span class=\"line\">\t\t__dma_free_buffer(page, size);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*ret_page = page;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *</span><br><span class=\"line\">__dma_alloc_remap(struct page *page, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">gfp_t</span> gfp, <span class=\"keyword\">pgprot_t</span> prot,</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *caller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * DMA allocation can be mapped to user space, so lets</span></span><br><span class=\"line\"><span class=\"comment\">\t * set VM_USERMAP flags too.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dma_common_contiguous_remap(page, size,</span><br><span class=\"line\">\t\t\tVM_ARM_DMA_CONSISTENT | VM_USERMAP,</span><br><span class=\"line\">\t\t\tprot, caller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-2-DMA-池\"><a href=\"#1-2-DMA-池\" class=\"headerlink\" title=\"1.2 DMA 池\"></a>1.2 DMA 池</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dma_pool_create(name, dev, size, align, alloc);</span><br><span class=\"line\">dma_pool_destroy(pool) pci_pool_destroy(pool);</span><br><span class=\"line\">dma_pool_alloc(pool, flags, handle) pci_pool_alloc(pool, flags, handle);</span><br><span class=\"line\">dma_pool_free(pool, vaddr, addr) pci_pool_free(pool, vaddr, addr);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-流式DMA-映射\"><a href=\"#2-流式DMA-映射\" class=\"headerlink\" title=\"2. 流式DMA 映射\"></a>2. 流式DMA 映射</h2><p>流式映射，kernel 还分为了两种形式：</p>\n<ul>\n<li>多page </li>\n<li>单个page </li>\n</ul>\n<h3 id=\"2-1-多个page-流式映射\"><a href=\"#2-1-多个page-流式映射\" class=\"headerlink\" title=\"2.1. 多个page 流式映射\"></a>2.1. 多个page 流式映射</h3><p>LDD3 上也叫做分散/聚集映射，原理大致与单个page 映射相同， 不同点在于多个循环映射 <strong>struct scatterlist *sg</strong> 里面聚集的pages </p>\n<p>dma_data_direction分为如下几种：</p>\n<blockquote>\n<ul>\n<li>DMA_BIDIRECTIONAL （双向）</li>\n<li>DMA_FROM_DEVICE  </li>\n<li>DMA_TO_DEVICE  </li>\n<li>DMA_NONE </li>\n</ul>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> dma_data_direction &#123;</span><br><span class=\"line\">\tDMA_BIDIRECTIONAL = <span class=\"number\">0</span>,</span><br><span class=\"line\">\tDMA_TO_DEVICE = <span class=\"number\">1</span>,</span><br><span class=\"line\">\tDMA_FROM_DEVICE = <span class=\"number\">2</span>,</span><br><span class=\"line\">\tDMA_NONE = <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dma_map_sg</span><span class=\"params\">(struct device *dev, struct scatterlist *sg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t   <span class=\"keyword\">int</span> nents, <span class=\"keyword\">enum</span> dma_data_direction dir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t   struct dma_attrs *attrs)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dma_unmap_sg</span><span class=\"params\">(struct device *dev, struct scatterlist *sg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t      <span class=\"keyword\">int</span> nents, <span class=\"keyword\">enum</span> dma_data_direction dir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t      struct dma_attrs *attrs)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：在dma_unmap_sg 之前，CPU 是不能操作page的， 原因在于这些addr 都是cached 地址，只有在保证地址被flush 到主存中才能让CPU 操作</strong></p>\n<p>Kernel 封装了如下函数，帮助我们显示的刷新cache 的数据，保证数据cache, memory 之间的一致性。</p>\n<p>使用dma_sync_sg_for_cpu（）函数，将使用权给CPU（之后Device 不能访问，否则数据不一致），<br>使用dma_sync_sg_for_device（）函数，将使用权给Device（CPU 不能访问）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span></span><br><span class=\"line\">dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,</span><br><span class=\"line\">\t\t    <span class=\"keyword\">int</span> nelems, <span class=\"keyword\">enum</span> dma_data_direction dir);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span></span><br><span class=\"line\">dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,</span><br><span class=\"line\">\t\t       <span class=\"keyword\">int</span> nelems, <span class=\"keyword\">enum</span> dma_data_direction dir)  ;</span><br></pre></td></tr></table></figure>\n<p>究其原因，是因为流式DMA缓冲区是cached，在map时刷了下cache，在设备DMA完成unmap时再刷cache（根据数据流向写回或者无效），来保证了cache数据一致性，在unmap之前CPU操作缓冲区是不能保证数据一致的。因此kernel需要严格保证操作时序。<br>当然kernel也提供函数dma_sync_sg_for_cpu与dma_sync_sg_for_device，可以在未释放时操作缓冲区，很明显这2个函数实现中肯定是再次进行刷新cache的操作保证数据一致性。</p>\n<h3 id=\"2-2-单个page-流式映射\"><a href=\"#2-2-单个page-流式映射\" class=\"headerlink\" title=\"2.2. 单个page 流式映射\"></a>2.2. 单个page 流式映射</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dma_map_single(dev, addr, size, dir);</span><br><span class=\"line\">dma_unmap_single(dev, hnd, size, dir);</span><br></pre></td></tr></table></figure>\n<p>与前面分散/聚集的多页映射一样， 我们不能在Device 访问期间，CPU 在访问，两者不能交互访问。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dma_sync_single_for_cpu</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">dma_addr_t</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t   <span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t   <span class=\"keyword\">enum</span> dma_data_direction dir)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dma_sync_single_for_device</span><span class=\"params\">(struct device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t      <span class=\"keyword\">dma_addr_t</span> addr, <span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t      <span class=\"keyword\">enum</span> dma_data_direction dir)</span></span>; </span><br><span class=\"line\">```                       </span><br><span class=\"line\"></span><br><span class=\"line\">dma_map_single ==&gt; __dma_map_page ==&gt; __dma_page_cpu_to_dev ==&gt; ___dma_page_cpu_to_dev </span><br><span class=\"line\">```c</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __dma_page_cpu_to_dev(struct page *page, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> off,</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> size, <span class=\"keyword\">enum</span> dma_data_direction dir)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">phys_addr_t</span> paddr;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdma_cache_maint_page(page, off, size, dir, dmac_map_area);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpaddr = page_to_phys(page) + off;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dir == DMA_FROM_DEVICE) &#123;</span><br><span class=\"line\">\t\touter_inv_range(paddr, paddr + size);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\touter_clean_range(paddr, paddr + size);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/* <span class=\"doctag\">FIXME:</span> non-speculating: flush on bidirectional mappings? */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>dmac_map_area 在我们配置的ARMV7 是指向的rch/arm/mm/cache-v7.S 文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRY(v7_dma_map_area)</span><br><span class=\"line\">\tadd\tr1, r1, r0</span><br><span class=\"line\">\tteq\tr2, #DMA_FROM_DEVICE</span><br><span class=\"line\">\tbeq\tv7_dma_inv_range</span><br><span class=\"line\">\tb\tv7_dma_clean_range</span><br><span class=\"line\">ENDPROC(v7_dma_map_area)</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRY(v7_dma_unmap_area)</span><br><span class=\"line\">\tadd\tr1, r1, r0</span><br><span class=\"line\">\tteq\tr2, #DMA_TO_DEVICE</span><br><span class=\"line\">\tbne\tv7_dma_inv_range</span><br><span class=\"line\">\tret\tlr</span><br><span class=\"line\">ENDPROC(v7_dma_unmap_area)</span><br></pre></td></tr></table></figure></p>\n<p>我们由此可以看出dma_map_sigle() 最终是使用汇编指令clean 或者invalidate cache 里面的数据，保证cache 与mem 之间的一致性。因此，在给Device 访问后，禁止CPU 访问，除非使用dma_sync_single_for_cpu（）函数，以此来将cache 数据invalidate。</p>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://blog.csdn.net/skyflying2012/article/\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/skyflying2012/article/</a><br><a href=\"https://my.oschina.net/yepanl/blog/3053881\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/yepanl/blog/3053881</a><br><a href=\"http://www.wowotech.net/memory_management/cma.html\" target=\"_blank\" rel=\"noopener\">http://www.wowotech.net/memory_management/cma.html</a></p>"},{"title":"kernel_mm_base","date":"2020-03-04T09:05:37.000Z","_content":"\n## 1. 术语\n__UMA（Uniform memory access）__  \n系统中的所有的processor共享一个统一的，一致的物理内存空间。无论从哪一个processor发起访问，对内存地址的访问时间都是一样的。\n\n__NUMA（Non-uniform memory access）__  \n对某个内存地址的访问是和该memory与processor之间的相对位置有关的。\n\n<!--more-->\n\n## 2. memory model\n### 2.1. Flat memory model\n如果cpu在访问物理内存的时候，其地址空间是连续的。PFN（page frame number）和mem_map数组index的关系是线性的（有一个固定偏移，如果内存对应的物理地址等于0，那么PFN就是数组index）. 映射与物理地址连续对应，两者可能差于固定偏移。\n\n### 2.2. Discontinuous Memory Mode\n如果cpu在访问物理内存的时候，其地址空间有一些空洞，是不连续的。\n\niscontiguous memory本质上是flat memory内存模型的扩展。在每一个成片的大块内存中node， 其内部模型是flat memory.\n\n![Discontinuous Memory Mode](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/Discontiguous%20Memory%20Model.gif)\n\n### 2.3. Sparse Memory Mode\n连续的地址空间按照SECTION（例如1G）被分成了一段一段的，其中每一section都是hotplug的。内存地址空间可以被切分的更细，支持更离散的Discontiguous memory。\n\nsparse memory多了一个section的概念，让转换变成了PFN<--->Section<--->page。 \n\n![Sparse Memory Mode](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/Sparse%20Memory%20Model.gif)\n\n在include/asm-generic/memory_model.h 可见\n```\n/*\n * supports 3 memory models.\n */\n#if defined(CONFIG_FLATMEM)\n\n#define __pfn_to_page(pfn)      (mem_map + ((pfn) - ARCH_PFN_OFFSET))\n#define __page_to_pfn(page)     ((unsigned long)((page) - mem_map) + \\\n                                 ARCH_PFN_OFFSET)\n\n#elif defined(CONFIG_DISCONTIGMEM)\n#define __pfn_to_page(pfn)                      \\\n({      unsigned long __pfn = (pfn);            \\\n        unsigned long __nid = arch_pfn_to_nid(__pfn);  \\\n        NODE_DATA(__nid)->node_mem_map + arch_local_page_offset(__pfn, __nid);\\\n})\n\n#define __page_to_pfn(pg)                                               \\\n({      const struct page *__pg = (pg);                                 \\\n        struct pglist_data *__pgdat = NODE_DATA(page_to_nid(__pg));     \\\n        (unsigned long)(__pg - __pgdat->node_mem_map) +                 \\\n         __pgdat->node_start_pfn;                                       \\\n})\n\n#elif defined(CONFIG_SPARSEMEM_VMEMMAP)\n/* memmap is virtually contiguous.  */\n#define __pfn_to_page(pfn)      (vmemmap + (pfn))\n#define __page_to_pfn(page)     (unsigned long)((page) - vmemmap)\n\n#elif defined(CONFIG_SPARSEMEM)\n/*\n * Note: section's mem_map is encoded to reflect its start_pfn.\n * section[i].section_mem_map == mem_map's address - start_pfn;\n */\n#define __page_to_pfn(pg)                                       \\\n({      const struct page *__pg = (pg);                         \\\n        int __sec = page_to_section(__pg);                      \\\n        (unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec))); \\\n})\n\n#define __pfn_to_page(pfn)                              \\\n({      unsigned long __pfn = (pfn);                    \\\n        struct mem_section *__sec = __pfn_to_section(__pfn);    \\\n        __section_mem_map_addr(__sec) + __pfn;          \\\n})\n#endif /* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */\n\n#define page_to_pfn __page_to_pfn\n#define pfn_to_page __pfn_to_page\n```\n\n## 3. 内存需求\n\n向内核线程/用户进程提供服务 \n- 应用程序访问远大于物理内存虚拟地址空间（Virtual Address Space） \n- 每个进程独立运行空间，可提供内存保护（memory protection） \n- 提供内存映射（Memory Mapping）机制，以便把物理内存、I/O空间、Kernel Image、文件等对象映射到相应进程的地址空间中，方便进程的访问 \n- 提供公平、高效的物理内存分配（Physical Memory Allocation）算法\n- 提供进程间内存共享的方法（以虚拟内存的形式），也称作Shared Virtual Memory \n\n更高级需求\n内存的热拔插（memory hotplug）\n- 内存的size超过了虚拟地址可寻址的空间怎么办（high memory）\n- 超大页（hugetlbpage）的支持\n- 利用磁盘作为交换页以扩大可用内存（各种swap机制和算法）\n- 在NUMA系统中通过移动物理页面位置的方法提升内存的访问效率（Page migration）\n- 内存泄漏的检查\n- 内存碎片的整理\n- 内存不足时的处理（oom kill机制） \n\nfixme\n![linux mem structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/mem_structure.gif)\n\n__cpu 访问内存方式__  \ncpu <---> MMU <---> Memory\n\n__Device 访问内存方式__  \nDevice <---> CPU <---> MEM  \nDevice <---> DMA <---> MEM  \nDevice <---> IOMMU <---> MEM  \n\n\n## Reference\n[Linux kernel内存管理的基本概念](http://www.wowotech.net/memory_management/concept.html)\n\n[Linux内存模型](http://www.wowotech.net/memory_management/memory_model.html)\n\n[ARM64架构下地址翻译相关的宏定义](http://www.wowotech.net/memory_management/arm64-memory-addressing.html)\n","source":"_posts/kernel-mm-base.md","raw":"---\ntitle: kernel_mm_base\ndate: 2020-03-04 17:05:37\ntags: mm\ncategories: memory\n---\n\n## 1. 术语\n__UMA（Uniform memory access）__  \n系统中的所有的processor共享一个统一的，一致的物理内存空间。无论从哪一个processor发起访问，对内存地址的访问时间都是一样的。\n\n__NUMA（Non-uniform memory access）__  \n对某个内存地址的访问是和该memory与processor之间的相对位置有关的。\n\n<!--more-->\n\n## 2. memory model\n### 2.1. Flat memory model\n如果cpu在访问物理内存的时候，其地址空间是连续的。PFN（page frame number）和mem_map数组index的关系是线性的（有一个固定偏移，如果内存对应的物理地址等于0，那么PFN就是数组index）. 映射与物理地址连续对应，两者可能差于固定偏移。\n\n### 2.2. Discontinuous Memory Mode\n如果cpu在访问物理内存的时候，其地址空间有一些空洞，是不连续的。\n\niscontiguous memory本质上是flat memory内存模型的扩展。在每一个成片的大块内存中node， 其内部模型是flat memory.\n\n![Discontinuous Memory Mode](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/Discontiguous%20Memory%20Model.gif)\n\n### 2.3. Sparse Memory Mode\n连续的地址空间按照SECTION（例如1G）被分成了一段一段的，其中每一section都是hotplug的。内存地址空间可以被切分的更细，支持更离散的Discontiguous memory。\n\nsparse memory多了一个section的概念，让转换变成了PFN<--->Section<--->page。 \n\n![Sparse Memory Mode](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/Sparse%20Memory%20Model.gif)\n\n在include/asm-generic/memory_model.h 可见\n```\n/*\n * supports 3 memory models.\n */\n#if defined(CONFIG_FLATMEM)\n\n#define __pfn_to_page(pfn)      (mem_map + ((pfn) - ARCH_PFN_OFFSET))\n#define __page_to_pfn(page)     ((unsigned long)((page) - mem_map) + \\\n                                 ARCH_PFN_OFFSET)\n\n#elif defined(CONFIG_DISCONTIGMEM)\n#define __pfn_to_page(pfn)                      \\\n({      unsigned long __pfn = (pfn);            \\\n        unsigned long __nid = arch_pfn_to_nid(__pfn);  \\\n        NODE_DATA(__nid)->node_mem_map + arch_local_page_offset(__pfn, __nid);\\\n})\n\n#define __page_to_pfn(pg)                                               \\\n({      const struct page *__pg = (pg);                                 \\\n        struct pglist_data *__pgdat = NODE_DATA(page_to_nid(__pg));     \\\n        (unsigned long)(__pg - __pgdat->node_mem_map) +                 \\\n         __pgdat->node_start_pfn;                                       \\\n})\n\n#elif defined(CONFIG_SPARSEMEM_VMEMMAP)\n/* memmap is virtually contiguous.  */\n#define __pfn_to_page(pfn)      (vmemmap + (pfn))\n#define __page_to_pfn(page)     (unsigned long)((page) - vmemmap)\n\n#elif defined(CONFIG_SPARSEMEM)\n/*\n * Note: section's mem_map is encoded to reflect its start_pfn.\n * section[i].section_mem_map == mem_map's address - start_pfn;\n */\n#define __page_to_pfn(pg)                                       \\\n({      const struct page *__pg = (pg);                         \\\n        int __sec = page_to_section(__pg);                      \\\n        (unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec))); \\\n})\n\n#define __pfn_to_page(pfn)                              \\\n({      unsigned long __pfn = (pfn);                    \\\n        struct mem_section *__sec = __pfn_to_section(__pfn);    \\\n        __section_mem_map_addr(__sec) + __pfn;          \\\n})\n#endif /* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */\n\n#define page_to_pfn __page_to_pfn\n#define pfn_to_page __pfn_to_page\n```\n\n## 3. 内存需求\n\n向内核线程/用户进程提供服务 \n- 应用程序访问远大于物理内存虚拟地址空间（Virtual Address Space） \n- 每个进程独立运行空间，可提供内存保护（memory protection） \n- 提供内存映射（Memory Mapping）机制，以便把物理内存、I/O空间、Kernel Image、文件等对象映射到相应进程的地址空间中，方便进程的访问 \n- 提供公平、高效的物理内存分配（Physical Memory Allocation）算法\n- 提供进程间内存共享的方法（以虚拟内存的形式），也称作Shared Virtual Memory \n\n更高级需求\n内存的热拔插（memory hotplug）\n- 内存的size超过了虚拟地址可寻址的空间怎么办（high memory）\n- 超大页（hugetlbpage）的支持\n- 利用磁盘作为交换页以扩大可用内存（各种swap机制和算法）\n- 在NUMA系统中通过移动物理页面位置的方法提升内存的访问效率（Page migration）\n- 内存泄漏的检查\n- 内存碎片的整理\n- 内存不足时的处理（oom kill机制） \n\nfixme\n![linux mem structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/mem_structure.gif)\n\n__cpu 访问内存方式__  \ncpu <---> MMU <---> Memory\n\n__Device 访问内存方式__  \nDevice <---> CPU <---> MEM  \nDevice <---> DMA <---> MEM  \nDevice <---> IOMMU <---> MEM  \n\n\n## Reference\n[Linux kernel内存管理的基本概念](http://www.wowotech.net/memory_management/concept.html)\n\n[Linux内存模型](http://www.wowotech.net/memory_management/memory_model.html)\n\n[ARM64架构下地址翻译相关的宏定义](http://www.wowotech.net/memory_management/arm64-memory-addressing.html)\n","slug":"kernel-mm-base","published":1,"updated":"2020-03-04T09:14:22.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0q40025zkgrszucj1t0","content":"<h2 id=\"1-术语\"><a href=\"#1-术语\" class=\"headerlink\" title=\"1. 术语\"></a>1. 术语</h2><p><strong>UMA（Uniform memory access）</strong><br>系统中的所有的processor共享一个统一的，一致的物理内存空间。无论从哪一个processor发起访问，对内存地址的访问时间都是一样的。</p>\n<p><strong>NUMA（Non-uniform memory access）</strong><br>对某个内存地址的访问是和该memory与processor之间的相对位置有关的。</p>\n<a id=\"more\"></a>\n<h2 id=\"2-memory-model\"><a href=\"#2-memory-model\" class=\"headerlink\" title=\"2. memory model\"></a>2. memory model</h2><h3 id=\"2-1-Flat-memory-model\"><a href=\"#2-1-Flat-memory-model\" class=\"headerlink\" title=\"2.1. Flat memory model\"></a>2.1. Flat memory model</h3><p>如果cpu在访问物理内存的时候，其地址空间是连续的。PFN（page frame number）和mem_map数组index的关系是线性的（有一个固定偏移，如果内存对应的物理地址等于0，那么PFN就是数组index）. 映射与物理地址连续对应，两者可能差于固定偏移。</p>\n<h3 id=\"2-2-Discontinuous-Memory-Mode\"><a href=\"#2-2-Discontinuous-Memory-Mode\" class=\"headerlink\" title=\"2.2. Discontinuous Memory Mode\"></a>2.2. Discontinuous Memory Mode</h3><p>如果cpu在访问物理内存的时候，其地址空间有一些空洞，是不连续的。</p>\n<p>iscontiguous memory本质上是flat memory内存模型的扩展。在每一个成片的大块内存中node， 其内部模型是flat memory.</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/Discontiguous%20Memory%20Model.gif\" alt=\"Discontinuous Memory Mode\"></p>\n<h3 id=\"2-3-Sparse-Memory-Mode\"><a href=\"#2-3-Sparse-Memory-Mode\" class=\"headerlink\" title=\"2.3. Sparse Memory Mode\"></a>2.3. Sparse Memory Mode</h3><p>连续的地址空间按照SECTION（例如1G）被分成了一段一段的，其中每一section都是hotplug的。内存地址空间可以被切分的更细，支持更离散的Discontiguous memory。</p>\n<p>sparse memory多了一个section的概念，让转换变成了PFN<--->Section<--->page。 </---></---></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/Sparse%20Memory%20Model.gif\" alt=\"Sparse Memory Mode\"></p>\n<p>在include/asm-generic/memory_model.h 可见<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * supports 3 memory models.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#if defined(CONFIG_FLATMEM)</span><br><span class=\"line\"></span><br><span class=\"line\">#define __pfn_to_page(pfn)      (mem_map + ((pfn) - ARCH_PFN_OFFSET))</span><br><span class=\"line\">#define __page_to_pfn(page)     ((unsigned long)((page) - mem_map) + \\</span><br><span class=\"line\">                                 ARCH_PFN_OFFSET)</span><br><span class=\"line\"></span><br><span class=\"line\">#elif defined(CONFIG_DISCONTIGMEM)</span><br><span class=\"line\">#define __pfn_to_page(pfn)                      \\</span><br><span class=\"line\">(&#123;      unsigned long __pfn = (pfn);            \\</span><br><span class=\"line\">        unsigned long __nid = arch_pfn_to_nid(__pfn);  \\</span><br><span class=\"line\">        NODE_DATA(__nid)-&gt;node_mem_map + arch_local_page_offset(__pfn, __nid);\\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">#define __page_to_pfn(pg)                                               \\</span><br><span class=\"line\">(&#123;      const struct page *__pg = (pg);                                 \\</span><br><span class=\"line\">        struct pglist_data *__pgdat = NODE_DATA(page_to_nid(__pg));     \\</span><br><span class=\"line\">        (unsigned long)(__pg - __pgdat-&gt;node_mem_map) +                 \\</span><br><span class=\"line\">         __pgdat-&gt;node_start_pfn;                                       \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">#elif defined(CONFIG_SPARSEMEM_VMEMMAP)</span><br><span class=\"line\">/* memmap is virtually contiguous.  */</span><br><span class=\"line\">#define __pfn_to_page(pfn)      (vmemmap + (pfn))</span><br><span class=\"line\">#define __page_to_pfn(page)     (unsigned long)((page) - vmemmap)</span><br><span class=\"line\"></span><br><span class=\"line\">#elif defined(CONFIG_SPARSEMEM)</span><br><span class=\"line\">/*</span><br><span class=\"line\"> * Note: section&apos;s mem_map is encoded to reflect its start_pfn.</span><br><span class=\"line\"> * section[i].section_mem_map == mem_map&apos;s address - start_pfn;</span><br><span class=\"line\"> */</span><br><span class=\"line\">#define __page_to_pfn(pg)                                       \\</span><br><span class=\"line\">(&#123;      const struct page *__pg = (pg);                         \\</span><br><span class=\"line\">        int __sec = page_to_section(__pg);                      \\</span><br><span class=\"line\">        (unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec))); \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">#define __pfn_to_page(pfn)                              \\</span><br><span class=\"line\">(&#123;      unsigned long __pfn = (pfn);                    \\</span><br><span class=\"line\">        struct mem_section *__sec = __pfn_to_section(__pfn);    \\</span><br><span class=\"line\">        __section_mem_map_addr(__sec) + __pfn;          \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">#endif /* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */</span><br><span class=\"line\"></span><br><span class=\"line\">#define page_to_pfn __page_to_pfn</span><br><span class=\"line\">#define pfn_to_page __pfn_to_page</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-内存需求\"><a href=\"#3-内存需求\" class=\"headerlink\" title=\"3. 内存需求\"></a>3. 内存需求</h2><p>向内核线程/用户进程提供服务 </p>\n<ul>\n<li>应用程序访问远大于物理内存虚拟地址空间（Virtual Address Space） </li>\n<li>每个进程独立运行空间，可提供内存保护（memory protection） </li>\n<li>提供内存映射（Memory Mapping）机制，以便把物理内存、I/O空间、Kernel Image、文件等对象映射到相应进程的地址空间中，方便进程的访问 </li>\n<li>提供公平、高效的物理内存分配（Physical Memory Allocation）算法</li>\n<li>提供进程间内存共享的方法（以虚拟内存的形式），也称作Shared Virtual Memory </li>\n</ul>\n<p>更高级需求<br>内存的热拔插（memory hotplug）</p>\n<ul>\n<li>内存的size超过了虚拟地址可寻址的空间怎么办（high memory）</li>\n<li>超大页（hugetlbpage）的支持</li>\n<li>利用磁盘作为交换页以扩大可用内存（各种swap机制和算法）</li>\n<li>在NUMA系统中通过移动物理页面位置的方法提升内存的访问效率（Page migration）</li>\n<li>内存泄漏的检查</li>\n<li>内存碎片的整理</li>\n<li>内存不足时的处理（oom kill机制） </li>\n</ul>\n<p>fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/mem_structure.gif\" alt=\"linux mem structure\"></p>\n<p><strong>cpu 访问内存方式</strong><br>cpu <---> MMU <---> Memory</---></---></p>\n<p><strong>Device 访问内存方式</strong><br>Device <---> CPU <---> MEM<br>Device <---> DMA <---> MEM<br>Device <---> IOMMU <---> MEM  </---></---></---></---></---></---></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/memory_management/concept.html\" target=\"_blank\" rel=\"noopener\">Linux kernel内存管理的基本概念</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/memory_model.html\" target=\"_blank\" rel=\"noopener\">Linux内存模型</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/arm64-memory-addressing.html\" target=\"_blank\" rel=\"noopener\">ARM64架构下地址翻译相关的宏定义</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-术语\"><a href=\"#1-术语\" class=\"headerlink\" title=\"1. 术语\"></a>1. 术语</h2><p><strong>UMA（Uniform memory access）</strong><br>系统中的所有的processor共享一个统一的，一致的物理内存空间。无论从哪一个processor发起访问，对内存地址的访问时间都是一样的。</p>\n<p><strong>NUMA（Non-uniform memory access）</strong><br>对某个内存地址的访问是和该memory与processor之间的相对位置有关的。</p>","more":"<h2 id=\"2-memory-model\"><a href=\"#2-memory-model\" class=\"headerlink\" title=\"2. memory model\"></a>2. memory model</h2><h3 id=\"2-1-Flat-memory-model\"><a href=\"#2-1-Flat-memory-model\" class=\"headerlink\" title=\"2.1. Flat memory model\"></a>2.1. Flat memory model</h3><p>如果cpu在访问物理内存的时候，其地址空间是连续的。PFN（page frame number）和mem_map数组index的关系是线性的（有一个固定偏移，如果内存对应的物理地址等于0，那么PFN就是数组index）. 映射与物理地址连续对应，两者可能差于固定偏移。</p>\n<h3 id=\"2-2-Discontinuous-Memory-Mode\"><a href=\"#2-2-Discontinuous-Memory-Mode\" class=\"headerlink\" title=\"2.2. Discontinuous Memory Mode\"></a>2.2. Discontinuous Memory Mode</h3><p>如果cpu在访问物理内存的时候，其地址空间有一些空洞，是不连续的。</p>\n<p>iscontiguous memory本质上是flat memory内存模型的扩展。在每一个成片的大块内存中node， 其内部模型是flat memory.</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/Discontiguous%20Memory%20Model.gif\" alt=\"Discontinuous Memory Mode\"></p>\n<h3 id=\"2-3-Sparse-Memory-Mode\"><a href=\"#2-3-Sparse-Memory-Mode\" class=\"headerlink\" title=\"2.3. Sparse Memory Mode\"></a>2.3. Sparse Memory Mode</h3><p>连续的地址空间按照SECTION（例如1G）被分成了一段一段的，其中每一section都是hotplug的。内存地址空间可以被切分的更细，支持更离散的Discontiguous memory。</p>\n<p>sparse memory多了一个section的概念，让转换变成了PFN<--->Section<--->page。 </---></---></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/Sparse%20Memory%20Model.gif\" alt=\"Sparse Memory Mode\"></p>\n<p>在include/asm-generic/memory_model.h 可见<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * supports 3 memory models.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#if defined(CONFIG_FLATMEM)</span><br><span class=\"line\"></span><br><span class=\"line\">#define __pfn_to_page(pfn)      (mem_map + ((pfn) - ARCH_PFN_OFFSET))</span><br><span class=\"line\">#define __page_to_pfn(page)     ((unsigned long)((page) - mem_map) + \\</span><br><span class=\"line\">                                 ARCH_PFN_OFFSET)</span><br><span class=\"line\"></span><br><span class=\"line\">#elif defined(CONFIG_DISCONTIGMEM)</span><br><span class=\"line\">#define __pfn_to_page(pfn)                      \\</span><br><span class=\"line\">(&#123;      unsigned long __pfn = (pfn);            \\</span><br><span class=\"line\">        unsigned long __nid = arch_pfn_to_nid(__pfn);  \\</span><br><span class=\"line\">        NODE_DATA(__nid)-&gt;node_mem_map + arch_local_page_offset(__pfn, __nid);\\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">#define __page_to_pfn(pg)                                               \\</span><br><span class=\"line\">(&#123;      const struct page *__pg = (pg);                                 \\</span><br><span class=\"line\">        struct pglist_data *__pgdat = NODE_DATA(page_to_nid(__pg));     \\</span><br><span class=\"line\">        (unsigned long)(__pg - __pgdat-&gt;node_mem_map) +                 \\</span><br><span class=\"line\">         __pgdat-&gt;node_start_pfn;                                       \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">#elif defined(CONFIG_SPARSEMEM_VMEMMAP)</span><br><span class=\"line\">/* memmap is virtually contiguous.  */</span><br><span class=\"line\">#define __pfn_to_page(pfn)      (vmemmap + (pfn))</span><br><span class=\"line\">#define __page_to_pfn(page)     (unsigned long)((page) - vmemmap)</span><br><span class=\"line\"></span><br><span class=\"line\">#elif defined(CONFIG_SPARSEMEM)</span><br><span class=\"line\">/*</span><br><span class=\"line\"> * Note: section&apos;s mem_map is encoded to reflect its start_pfn.</span><br><span class=\"line\"> * section[i].section_mem_map == mem_map&apos;s address - start_pfn;</span><br><span class=\"line\"> */</span><br><span class=\"line\">#define __page_to_pfn(pg)                                       \\</span><br><span class=\"line\">(&#123;      const struct page *__pg = (pg);                         \\</span><br><span class=\"line\">        int __sec = page_to_section(__pg);                      \\</span><br><span class=\"line\">        (unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec))); \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">#define __pfn_to_page(pfn)                              \\</span><br><span class=\"line\">(&#123;      unsigned long __pfn = (pfn);                    \\</span><br><span class=\"line\">        struct mem_section *__sec = __pfn_to_section(__pfn);    \\</span><br><span class=\"line\">        __section_mem_map_addr(__sec) + __pfn;          \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">#endif /* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */</span><br><span class=\"line\"></span><br><span class=\"line\">#define page_to_pfn __page_to_pfn</span><br><span class=\"line\">#define pfn_to_page __pfn_to_page</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-内存需求\"><a href=\"#3-内存需求\" class=\"headerlink\" title=\"3. 内存需求\"></a>3. 内存需求</h2><p>向内核线程/用户进程提供服务 </p>\n<ul>\n<li>应用程序访问远大于物理内存虚拟地址空间（Virtual Address Space） </li>\n<li>每个进程独立运行空间，可提供内存保护（memory protection） </li>\n<li>提供内存映射（Memory Mapping）机制，以便把物理内存、I/O空间、Kernel Image、文件等对象映射到相应进程的地址空间中，方便进程的访问 </li>\n<li>提供公平、高效的物理内存分配（Physical Memory Allocation）算法</li>\n<li>提供进程间内存共享的方法（以虚拟内存的形式），也称作Shared Virtual Memory </li>\n</ul>\n<p>更高级需求<br>内存的热拔插（memory hotplug）</p>\n<ul>\n<li>内存的size超过了虚拟地址可寻址的空间怎么办（high memory）</li>\n<li>超大页（hugetlbpage）的支持</li>\n<li>利用磁盘作为交换页以扩大可用内存（各种swap机制和算法）</li>\n<li>在NUMA系统中通过移动物理页面位置的方法提升内存的访问效率（Page migration）</li>\n<li>内存泄漏的检查</li>\n<li>内存碎片的整理</li>\n<li>内存不足时的处理（oom kill机制） </li>\n</ul>\n<p>fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/base/mem_structure.gif\" alt=\"linux mem structure\"></p>\n<p><strong>cpu 访问内存方式</strong><br>cpu <---> MMU <---> Memory</---></---></p>\n<p><strong>Device 访问内存方式</strong><br>Device <---> CPU <---> MEM<br>Device <---> DMA <---> MEM<br>Device <---> IOMMU <---> MEM  </---></---></---></---></---></---></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/memory_management/concept.html\" target=\"_blank\" rel=\"noopener\">Linux kernel内存管理的基本概念</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/memory_model.html\" target=\"_blank\" rel=\"noopener\">Linux内存模型</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/arm64-memory-addressing.html\" target=\"_blank\" rel=\"noopener\">ARM64架构下地址翻译相关的宏定义</a></p>"},{"title":"kernel_mm_cache","date":"2020-03-04T09:15:28.000Z","_content":"\n![arm_cortex-a7_mpcore_cpu_structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/arm_cortex-a7_mpcore_cpu_structure.png)\n\n\n从ARM Cortex-a7 mpcore（armv7）的架构图上可以看出, cortex-a7 每个核独享各自L1 cache， 共享L2 cache（使用snoop control unit， soc 保证per core 数据的一致性）。\n\ncache 分为:  \n- Data Cache\n- Instruction Cache\n\n<!--more-->\n\n## 1. Base\ncache 对应与main memory 最小的unit 为cache line. 一个有效的cache 由两部组成：__寻址 + 数据__\n\ncache = tag array + data array\n\nexample:\ncache size 64 byte, cache line 8 byte.\n\n![cache structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_structure.png)\n\noffset: 对应cache line 内中的偏移量\nindex: 指向which cache line\ntag: 这个位宽除index, offset bits剩余部分\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_structure_1.png)\n\n## 2. 映射方式\n映射方式常有：\n- 直接映射\n- 组相连映射\n- 全相连映射\n\n### 2.1. 直接映射缓存（Direct mapped cache） \n![direct mapped cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/direct_map_cache.png)\n如果依次访问0x00, 0x40, 0x80 三者index 都相同，访问0x40 时, tag match失败，cache miss 重新加载数据，这种现象称为**cache颠簸(cache thrashing)**。 访问0x80， tag不同cache miss，重新加载数据。这种情况，cache的引入并没有性能有所提升，因此，引入了组相连映射。\n\n### 2.2. 多路组相连缓存（multiple ways set associative cache） \n平均将cache 分成多份，每一份就是一路(way)。在每一路中index 相同的cache lines称为组(set)。直接映射也可以称之为单路组相连。\n\n多路组相连与直接映射对比：  \n\n| 优势                                                                                      | 劣势                                             |\n| :---------------------------------------------------------------------------------------- | :----------------------------------------------- |\n| 在相同的index 情况下， 如果一路(way) 中miss, 可以继续在另一路中寻找相同index 的cache line | 硬件成本更高，每次比较tag 需要比较多个cache line |\n\n![2-way set associative cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/2_way_set_associative_cache.png)\n\nexample： 32KB cache, 32 Bytes cache line, 4 ways, address bus 48-bit\n![4-way set associative cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/4_way_set_associative_cache.png)\n\n### 2.3. 全相连缓存（Full associative cache）\n所有cache line 都在一个组内，因此，不需要index。任意地址的数据都可以缓存在任意cache line。但伴随硬件的成本，设计复杂度也会增加。\n\n![full associative cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/full_associative_cache.png)\n\n## 3. 更新策略  \ncache 更新策略是在cache 命中，并且有写操作时，cache 如何更新。\nupdate policy 有两种： \n- write through  \n- write back\n\n### 3.1. 写直通(write through)  \ncache 更新的同时，main memory 也会一并更新。cache 与主存内容一致。\n\nFixme\n![write through](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/write_through.png)\n\n### 3.2. 写回(write back)  \n只更新cache， main memory 不更新。并且会置位 cache line中 “dirty bit”, 表明该cache line 修改过，并与主存不一致。在cache line 被替换时或flush 操作时更新到main memory。\n\nFixme\n![write back](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/write_back.png)\n\n## 4. coherent\ncache 的引入，Multiple Core, DMA 外设等因素，CPU Core访问的数据可能与另一个CPU Core或Device不一致。\n\n### 4.1. memory attribute\n比较直接的方式就是限制memory 的type 与attribute。例如设定成device type or strongly-ordered.\n\n|       type       | shareablility                                                          | cacheability                                                           |\n| :--------------: | :--------------------------------------------------------------------- | :--------------------------------------------------------------------- |\n| strongly-ordered | outer shareable                                                        | Non-cacheable                                                          |\n|      device      | outer shareable                                                        | Non-cacheable                                                          |\n|      normal      | one of:<br>- Non-shareable <br>- inner shareable <br>- outer shareable | one of:<br>- Non-cacheable <br>- inner cacheable <br>- outer cacheable |\n\n### 4.2. cache 一致性协议\n在cache line 增加状态位，表明当前cache line 的状态\n#### MESI\n\n| Status                                   | Remarks                                                     |\n| :--------------------------------------- | :---------------------------------------------------------- |\n| <font color=red>M</font> 修改(modified)  | cache line有效，数据被修改，与main memory 中不一致          |\n| <font color=red>E</font> 独享(Exclusive) | cache line 有效，数据与主存一致，并数据只存在于该cache line |\n| <font color=red>S</font> 共享(shared)    | cache line 有效，数据与主存一致，数据存在于多个cache line   |\n| <font color=red>I</font> 无效(invalide)  | cache line 无效                                             |\n\n状态图转换如下:\nFixme\n![MESI](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/MESI.png)\n\n#### MOESI\n相较于MESI，增加O(Owned), S也与MESI 定义不同，cache line 不一定与主存一致。M，E，I定义相同。\n\n| Status                                   | Remarks                                                                                    |\n| :--------------------------------------- | :----------------------------------------------------------------------------------------- |\n| <font color=red>M</font> 修改(modified)  | cache line有效，数据被修改，与main memory 中不一致                                         |\n| <font color=red>O</font> 拥有(Owned)     | O为1， 当前cache line是当前cpu 最新数据拷贝，且其他core 一定具有该cache line 的副本状态位S |\n| <font color=red>E</font> 独享(Exclusive) | cache line 有效，数据与主存一致，并数据只存在于该cache line                                |\n| <font color=red>S</font> 共享(shared)    | cache line 有效，数据与主存**不一定**一致，数据存在于多个cache line                        |\n| <font color=red>I</font> 无效(invalide)  | cache line 无效                                                                            |\n\nFixme\n![MOESI](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/MOESI.png)\n\n### 4.3. automic operating\nARM 提供了原子操作的指令,ldrex, strex, clrex系列指令。这能保证在多核之间对数据进行唯一性的访问。\n\n配对使用的指令：\n\n| load instruction | store instruction | remarks             |\n| :--------------- | :---------------- | :------------------ |\n| ldrexb           | strexb            | byte access         |\n| ldrexh           | strexh            | half world access   |\n| ldrexd           | strexd            | double world access |\n\n```c\n# load Ry 地址中的数据到Rx，并标记对该段内存独占访问\n# 如果已经标记过，不影响操作\nldrex Rx, [Ry]\n\n# 如果Rz 已经被标记为独占访问，store Ry 到Rz 地址内存，清除独占标记并set Rx->0\n# 如果Rz 没有设定为独占访问，不更新内存，并set Rx->1 表明失败\nstrex Rx, Ry, [Rz]\n```\n\n## 5. Cache Maintenance Operations\narmv7 下cache 可以依据MVA(modified virtual address)，set/way或全部内容进行维护更新,可参看如下图：\n![cache_maintenance_operations](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_maintenance_operations.png)\n\nPOU - to point of unification\nPOC - to point of coherence\n\nPOU 主要指Instruction, data, TLB 看到的为同一份mem\nPOC 主要指各个Core 之间看到的为同一份mem。\n\n![POU](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POU.png)\n\n![POC](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POC.png)\n\n![POU&POC](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POU%26POC.png)\n\n## Reference\n[浅谈Cache Memory](http://www.wowotech.net/memory_management/458.html)  \n[缓存一致性协议MESI和MOESI](https://blog.csdn.net/loongshawn/article/details/83083346)  \n[MESI & MOESI 协议](http://www.360doc.com/content/19/0410/14/496343_827699509.shtml)  \n[arm64 memory 属性 Device-nGnRnE](https://blog.csdn.net/shenhuxi_yu/article/details/90617675)  \n[ARM平台下独占访问指令LDREX和STREX的原理与使用详解](https://blog.csdn.net/roland_sun/article/details/47670099)  \n[什么是PoU和PoC？](https://community.arm.com/cn/f/discussions/3437/pou-poc/9674)","source":"_posts/kernel-mm-cache.md","raw":"---\ntitle: kernel_mm_cache\ndate: 2020-03-04 17:15:28\ntags: cache\ncategories: memory\n---\n\n![arm_cortex-a7_mpcore_cpu_structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/arm_cortex-a7_mpcore_cpu_structure.png)\n\n\n从ARM Cortex-a7 mpcore（armv7）的架构图上可以看出, cortex-a7 每个核独享各自L1 cache， 共享L2 cache（使用snoop control unit， soc 保证per core 数据的一致性）。\n\ncache 分为:  \n- Data Cache\n- Instruction Cache\n\n<!--more-->\n\n## 1. Base\ncache 对应与main memory 最小的unit 为cache line. 一个有效的cache 由两部组成：__寻址 + 数据__\n\ncache = tag array + data array\n\nexample:\ncache size 64 byte, cache line 8 byte.\n\n![cache structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_structure.png)\n\noffset: 对应cache line 内中的偏移量\nindex: 指向which cache line\ntag: 这个位宽除index, offset bits剩余部分\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_structure_1.png)\n\n## 2. 映射方式\n映射方式常有：\n- 直接映射\n- 组相连映射\n- 全相连映射\n\n### 2.1. 直接映射缓存（Direct mapped cache） \n![direct mapped cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/direct_map_cache.png)\n如果依次访问0x00, 0x40, 0x80 三者index 都相同，访问0x40 时, tag match失败，cache miss 重新加载数据，这种现象称为**cache颠簸(cache thrashing)**。 访问0x80， tag不同cache miss，重新加载数据。这种情况，cache的引入并没有性能有所提升，因此，引入了组相连映射。\n\n### 2.2. 多路组相连缓存（multiple ways set associative cache） \n平均将cache 分成多份，每一份就是一路(way)。在每一路中index 相同的cache lines称为组(set)。直接映射也可以称之为单路组相连。\n\n多路组相连与直接映射对比：  \n\n| 优势                                                                                      | 劣势                                             |\n| :---------------------------------------------------------------------------------------- | :----------------------------------------------- |\n| 在相同的index 情况下， 如果一路(way) 中miss, 可以继续在另一路中寻找相同index 的cache line | 硬件成本更高，每次比较tag 需要比较多个cache line |\n\n![2-way set associative cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/2_way_set_associative_cache.png)\n\nexample： 32KB cache, 32 Bytes cache line, 4 ways, address bus 48-bit\n![4-way set associative cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/4_way_set_associative_cache.png)\n\n### 2.3. 全相连缓存（Full associative cache）\n所有cache line 都在一个组内，因此，不需要index。任意地址的数据都可以缓存在任意cache line。但伴随硬件的成本，设计复杂度也会增加。\n\n![full associative cache](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/full_associative_cache.png)\n\n## 3. 更新策略  \ncache 更新策略是在cache 命中，并且有写操作时，cache 如何更新。\nupdate policy 有两种： \n- write through  \n- write back\n\n### 3.1. 写直通(write through)  \ncache 更新的同时，main memory 也会一并更新。cache 与主存内容一致。\n\nFixme\n![write through](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/write_through.png)\n\n### 3.2. 写回(write back)  \n只更新cache， main memory 不更新。并且会置位 cache line中 “dirty bit”, 表明该cache line 修改过，并与主存不一致。在cache line 被替换时或flush 操作时更新到main memory。\n\nFixme\n![write back](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/write_back.png)\n\n## 4. coherent\ncache 的引入，Multiple Core, DMA 外设等因素，CPU Core访问的数据可能与另一个CPU Core或Device不一致。\n\n### 4.1. memory attribute\n比较直接的方式就是限制memory 的type 与attribute。例如设定成device type or strongly-ordered.\n\n|       type       | shareablility                                                          | cacheability                                                           |\n| :--------------: | :--------------------------------------------------------------------- | :--------------------------------------------------------------------- |\n| strongly-ordered | outer shareable                                                        | Non-cacheable                                                          |\n|      device      | outer shareable                                                        | Non-cacheable                                                          |\n|      normal      | one of:<br>- Non-shareable <br>- inner shareable <br>- outer shareable | one of:<br>- Non-cacheable <br>- inner cacheable <br>- outer cacheable |\n\n### 4.2. cache 一致性协议\n在cache line 增加状态位，表明当前cache line 的状态\n#### MESI\n\n| Status                                   | Remarks                                                     |\n| :--------------------------------------- | :---------------------------------------------------------- |\n| <font color=red>M</font> 修改(modified)  | cache line有效，数据被修改，与main memory 中不一致          |\n| <font color=red>E</font> 独享(Exclusive) | cache line 有效，数据与主存一致，并数据只存在于该cache line |\n| <font color=red>S</font> 共享(shared)    | cache line 有效，数据与主存一致，数据存在于多个cache line   |\n| <font color=red>I</font> 无效(invalide)  | cache line 无效                                             |\n\n状态图转换如下:\nFixme\n![MESI](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/MESI.png)\n\n#### MOESI\n相较于MESI，增加O(Owned), S也与MESI 定义不同，cache line 不一定与主存一致。M，E，I定义相同。\n\n| Status                                   | Remarks                                                                                    |\n| :--------------------------------------- | :----------------------------------------------------------------------------------------- |\n| <font color=red>M</font> 修改(modified)  | cache line有效，数据被修改，与main memory 中不一致                                         |\n| <font color=red>O</font> 拥有(Owned)     | O为1， 当前cache line是当前cpu 最新数据拷贝，且其他core 一定具有该cache line 的副本状态位S |\n| <font color=red>E</font> 独享(Exclusive) | cache line 有效，数据与主存一致，并数据只存在于该cache line                                |\n| <font color=red>S</font> 共享(shared)    | cache line 有效，数据与主存**不一定**一致，数据存在于多个cache line                        |\n| <font color=red>I</font> 无效(invalide)  | cache line 无效                                                                            |\n\nFixme\n![MOESI](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/MOESI.png)\n\n### 4.3. automic operating\nARM 提供了原子操作的指令,ldrex, strex, clrex系列指令。这能保证在多核之间对数据进行唯一性的访问。\n\n配对使用的指令：\n\n| load instruction | store instruction | remarks             |\n| :--------------- | :---------------- | :------------------ |\n| ldrexb           | strexb            | byte access         |\n| ldrexh           | strexh            | half world access   |\n| ldrexd           | strexd            | double world access |\n\n```c\n# load Ry 地址中的数据到Rx，并标记对该段内存独占访问\n# 如果已经标记过，不影响操作\nldrex Rx, [Ry]\n\n# 如果Rz 已经被标记为独占访问，store Ry 到Rz 地址内存，清除独占标记并set Rx->0\n# 如果Rz 没有设定为独占访问，不更新内存，并set Rx->1 表明失败\nstrex Rx, Ry, [Rz]\n```\n\n## 5. Cache Maintenance Operations\narmv7 下cache 可以依据MVA(modified virtual address)，set/way或全部内容进行维护更新,可参看如下图：\n![cache_maintenance_operations](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_maintenance_operations.png)\n\nPOU - to point of unification\nPOC - to point of coherence\n\nPOU 主要指Instruction, data, TLB 看到的为同一份mem\nPOC 主要指各个Core 之间看到的为同一份mem。\n\n![POU](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POU.png)\n\n![POC](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POC.png)\n\n![POU&POC](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POU%26POC.png)\n\n## Reference\n[浅谈Cache Memory](http://www.wowotech.net/memory_management/458.html)  \n[缓存一致性协议MESI和MOESI](https://blog.csdn.net/loongshawn/article/details/83083346)  \n[MESI & MOESI 协议](http://www.360doc.com/content/19/0410/14/496343_827699509.shtml)  \n[arm64 memory 属性 Device-nGnRnE](https://blog.csdn.net/shenhuxi_yu/article/details/90617675)  \n[ARM平台下独占访问指令LDREX和STREX的原理与使用详解](https://blog.csdn.net/roland_sun/article/details/47670099)  \n[什么是PoU和PoC？](https://community.arm.com/cn/f/discussions/3437/pou-poc/9674)","slug":"kernel-mm-cache","published":1,"updated":"2020-03-12T08:44:38.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0q60029zkgry0n0fhlw","content":"<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/arm_cortex-a7_mpcore_cpu_structure.png\" alt=\"arm_cortex-a7_mpcore_cpu_structure\"></p>\n<p>从ARM Cortex-a7 mpcore（armv7）的架构图上可以看出, cortex-a7 每个核独享各自L1 cache， 共享L2 cache（使用snoop control unit， soc 保证per core 数据的一致性）。</p>\n<p>cache 分为:  </p>\n<ul>\n<li>Data Cache</li>\n<li>Instruction Cache</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"1-Base\"><a href=\"#1-Base\" class=\"headerlink\" title=\"1. Base\"></a>1. Base</h2><p>cache 对应与main memory 最小的unit 为cache line. 一个有效的cache 由两部组成：<strong>寻址 + 数据</strong></p>\n<p>cache = tag array + data array</p>\n<p>example:<br>cache size 64 byte, cache line 8 byte.</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_structure.png\" alt=\"cache structure\"></p>\n<p>offset: 对应cache line 内中的偏移量<br>index: 指向which cache line<br>tag: 这个位宽除index, offset bits剩余部分</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_structure_1.png\" alt=\"\"></p>\n<h2 id=\"2-映射方式\"><a href=\"#2-映射方式\" class=\"headerlink\" title=\"2. 映射方式\"></a>2. 映射方式</h2><p>映射方式常有：</p>\n<ul>\n<li>直接映射</li>\n<li>组相连映射</li>\n<li>全相连映射</li>\n</ul>\n<h3 id=\"2-1-直接映射缓存（Direct-mapped-cache）\"><a href=\"#2-1-直接映射缓存（Direct-mapped-cache）\" class=\"headerlink\" title=\"2.1. 直接映射缓存（Direct mapped cache）\"></a>2.1. 直接映射缓存（Direct mapped cache）</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/direct_map_cache.png\" alt=\"direct mapped cache\"><br>如果依次访问0x00, 0x40, 0x80 三者index 都相同，访问0x40 时, tag match失败，cache miss 重新加载数据，这种现象称为<strong>cache颠簸(cache thrashing)</strong>。 访问0x80， tag不同cache miss，重新加载数据。这种情况，cache的引入并没有性能有所提升，因此，引入了组相连映射。</p>\n<h3 id=\"2-2-多路组相连缓存（multiple-ways-set-associative-cache）\"><a href=\"#2-2-多路组相连缓存（multiple-ways-set-associative-cache）\" class=\"headerlink\" title=\"2.2. 多路组相连缓存（multiple ways set associative cache）\"></a>2.2. 多路组相连缓存（multiple ways set associative cache）</h3><p>平均将cache 分成多份，每一份就是一路(way)。在每一路中index 相同的cache lines称为组(set)。直接映射也可以称之为单路组相连。</p>\n<p>多路组相连与直接映射对比：  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">优势</th>\n<th style=\"text-align:left\">劣势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">在相同的index 情况下， 如果一路(way) 中miss, 可以继续在另一路中寻找相同index 的cache line</td>\n<td style=\"text-align:left\">硬件成本更高，每次比较tag 需要比较多个cache line</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/2_way_set_associative_cache.png\" alt=\"2-way set associative cache\"></p>\n<p>example： 32KB cache, 32 Bytes cache line, 4 ways, address bus 48-bit<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/4_way_set_associative_cache.png\" alt=\"4-way set associative cache\"></p>\n<h3 id=\"2-3-全相连缓存（Full-associative-cache）\"><a href=\"#2-3-全相连缓存（Full-associative-cache）\" class=\"headerlink\" title=\"2.3. 全相连缓存（Full associative cache）\"></a>2.3. 全相连缓存（Full associative cache）</h3><p>所有cache line 都在一个组内，因此，不需要index。任意地址的数据都可以缓存在任意cache line。但伴随硬件的成本，设计复杂度也会增加。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/full_associative_cache.png\" alt=\"full associative cache\"></p>\n<h2 id=\"3-更新策略\"><a href=\"#3-更新策略\" class=\"headerlink\" title=\"3. 更新策略\"></a>3. 更新策略</h2><p>cache 更新策略是在cache 命中，并且有写操作时，cache 如何更新。<br>update policy 有两种： </p>\n<ul>\n<li>write through  </li>\n<li>write back</li>\n</ul>\n<h3 id=\"3-1-写直通-write-through\"><a href=\"#3-1-写直通-write-through\" class=\"headerlink\" title=\"3.1. 写直通(write through)\"></a>3.1. 写直通(write through)</h3><p>cache 更新的同时，main memory 也会一并更新。cache 与主存内容一致。</p>\n<p>Fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/write_through.png\" alt=\"write through\"></p>\n<h3 id=\"3-2-写回-write-back\"><a href=\"#3-2-写回-write-back\" class=\"headerlink\" title=\"3.2. 写回(write back)\"></a>3.2. 写回(write back)</h3><p>只更新cache， main memory 不更新。并且会置位 cache line中 “dirty bit”, 表明该cache line 修改过，并与主存不一致。在cache line 被替换时或flush 操作时更新到main memory。</p>\n<p>Fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/write_back.png\" alt=\"write back\"></p>\n<h2 id=\"4-coherent\"><a href=\"#4-coherent\" class=\"headerlink\" title=\"4. coherent\"></a>4. coherent</h2><p>cache 的引入，Multiple Core, DMA 外设等因素，CPU Core访问的数据可能与另一个CPU Core或Device不一致。</p>\n<h3 id=\"4-1-memory-attribute\"><a href=\"#4-1-memory-attribute\" class=\"headerlink\" title=\"4.1. memory attribute\"></a>4.1. memory attribute</h3><p>比较直接的方式就是限制memory 的type 与attribute。例如设定成device type or strongly-ordered.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">type</th>\n<th style=\"text-align:left\">shareablility</th>\n<th style=\"text-align:left\">cacheability</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">strongly-ordered</td>\n<td style=\"text-align:left\">outer shareable</td>\n<td style=\"text-align:left\">Non-cacheable</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">device</td>\n<td style=\"text-align:left\">outer shareable</td>\n<td style=\"text-align:left\">Non-cacheable</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">normal</td>\n<td style=\"text-align:left\">one of:<br>- Non-shareable <br>- inner shareable <br>- outer shareable</td>\n<td style=\"text-align:left\">one of:<br>- Non-cacheable <br>- inner cacheable <br>- outer cacheable</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-2-cache-一致性协议\"><a href=\"#4-2-cache-一致性协议\" class=\"headerlink\" title=\"4.2. cache 一致性协议\"></a>4.2. cache 一致性协议</h3><p>在cache line 增加状态位，表明当前cache line 的状态</p>\n<h4 id=\"MESI\"><a href=\"#MESI\" class=\"headerlink\" title=\"MESI\"></a>MESI</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Status</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">M</font> 修改(modified)</td>\n<td style=\"text-align:left\">cache line有效，数据被修改，与main memory 中不一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">E</font> 独享(Exclusive)</td>\n<td style=\"text-align:left\">cache line 有效，数据与主存一致，并数据只存在于该cache line</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">S</font> 共享(shared)</td>\n<td style=\"text-align:left\">cache line 有效，数据与主存一致，数据存在于多个cache line</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">I</font> 无效(invalide)</td>\n<td style=\"text-align:left\">cache line 无效</td>\n</tr>\n</tbody>\n</table>\n<p>状态图转换如下:<br>Fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/MESI.png\" alt=\"MESI\"></p>\n<h4 id=\"MOESI\"><a href=\"#MOESI\" class=\"headerlink\" title=\"MOESI\"></a>MOESI</h4><p>相较于MESI，增加O(Owned), S也与MESI 定义不同，cache line 不一定与主存一致。M，E，I定义相同。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Status</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">M</font> 修改(modified)</td>\n<td style=\"text-align:left\">cache line有效，数据被修改，与main memory 中不一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">O</font> 拥有(Owned)</td>\n<td style=\"text-align:left\">O为1， 当前cache line是当前cpu 最新数据拷贝，且其他core 一定具有该cache line 的副本状态位S</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">E</font> 独享(Exclusive)</td>\n<td style=\"text-align:left\">cache line 有效，数据与主存一致，并数据只存在于该cache line</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">S</font> 共享(shared)</td>\n<td style=\"text-align:left\">cache line 有效，数据与主存<strong>不一定</strong>一致，数据存在于多个cache line</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">I</font> 无效(invalide)</td>\n<td style=\"text-align:left\">cache line 无效</td>\n</tr>\n</tbody>\n</table>\n<p>Fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/MOESI.png\" alt=\"MOESI\"></p>\n<h3 id=\"4-3-automic-operating\"><a href=\"#4-3-automic-operating\" class=\"headerlink\" title=\"4.3. automic operating\"></a>4.3. automic operating</h3><p>ARM 提供了原子操作的指令,ldrex, strex, clrex系列指令。这能保证在多核之间对数据进行唯一性的访问。</p>\n<p>配对使用的指令：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">load instruction</th>\n<th style=\"text-align:left\">store instruction</th>\n<th style=\"text-align:left\">remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ldrexb</td>\n<td style=\"text-align:left\">strexb</td>\n<td style=\"text-align:left\">byte access</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ldrexh</td>\n<td style=\"text-align:left\">strexh</td>\n<td style=\"text-align:left\">half world access</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ldrexd</td>\n<td style=\"text-align:left\">strexd</td>\n<td style=\"text-align:left\">double world access</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># load Ry 地址中的数据到Rx，并标记对该段内存独占访问</span></span><br><span class=\"line\"># 如果已经标记过，不影响操作</span><br><span class=\"line\">ldrex Rx, [Ry]</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果Rz 已经被标记为独占访问，store Ry 到Rz 地址内存，清除独占标记并<span class=\"built_in\">set</span> Rx-&gt;<span class=\"number\">0</span></span><br><span class=\"line\"># 如果Rz 没有设定为独占访问，不更新内存，并<span class=\"built_in\">set</span> Rx-&gt;<span class=\"number\">1</span> 表明失败</span><br><span class=\"line\">strex Rx, Ry, [Rz]</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-Cache-Maintenance-Operations\"><a href=\"#5-Cache-Maintenance-Operations\" class=\"headerlink\" title=\"5. Cache Maintenance Operations\"></a>5. Cache Maintenance Operations</h2><p>armv7 下cache 可以依据MVA(modified virtual address)，set/way或全部内容进行维护更新,可参看如下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_maintenance_operations.png\" alt=\"cache_maintenance_operations\"></p>\n<p>POU - to point of unification<br>POC - to point of coherence</p>\n<p>POU 主要指Instruction, data, TLB 看到的为同一份mem<br>POC 主要指各个Core 之间看到的为同一份mem。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POU.png\" alt=\"POU\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POC.png\" alt=\"POC\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POU%26POC.png\" alt=\"POU&amp;POC\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/memory_management/458.html\" target=\"_blank\" rel=\"noopener\">浅谈Cache Memory</a><br><a href=\"https://blog.csdn.net/loongshawn/article/details/83083346\" target=\"_blank\" rel=\"noopener\">缓存一致性协议MESI和MOESI</a><br><a href=\"http://www.360doc.com/content/19/0410/14/496343_827699509.shtml\" target=\"_blank\" rel=\"noopener\">MESI &amp; MOESI 协议</a><br><a href=\"https://blog.csdn.net/shenhuxi_yu/article/details/90617675\" target=\"_blank\" rel=\"noopener\">arm64 memory 属性 Device-nGnRnE</a><br><a href=\"https://blog.csdn.net/roland_sun/article/details/47670099\" target=\"_blank\" rel=\"noopener\">ARM平台下独占访问指令LDREX和STREX的原理与使用详解</a><br><a href=\"https://community.arm.com/cn/f/discussions/3437/pou-poc/9674\" target=\"_blank\" rel=\"noopener\">什么是PoU和PoC？</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/arm_cortex-a7_mpcore_cpu_structure.png\" alt=\"arm_cortex-a7_mpcore_cpu_structure\"></p>\n<p>从ARM Cortex-a7 mpcore（armv7）的架构图上可以看出, cortex-a7 每个核独享各自L1 cache， 共享L2 cache（使用snoop control unit， soc 保证per core 数据的一致性）。</p>\n<p>cache 分为:  </p>\n<ul>\n<li>Data Cache</li>\n<li>Instruction Cache</li>\n</ul>","more":"<h2 id=\"1-Base\"><a href=\"#1-Base\" class=\"headerlink\" title=\"1. Base\"></a>1. Base</h2><p>cache 对应与main memory 最小的unit 为cache line. 一个有效的cache 由两部组成：<strong>寻址 + 数据</strong></p>\n<p>cache = tag array + data array</p>\n<p>example:<br>cache size 64 byte, cache line 8 byte.</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_structure.png\" alt=\"cache structure\"></p>\n<p>offset: 对应cache line 内中的偏移量<br>index: 指向which cache line<br>tag: 这个位宽除index, offset bits剩余部分</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_structure_1.png\" alt=\"\"></p>\n<h2 id=\"2-映射方式\"><a href=\"#2-映射方式\" class=\"headerlink\" title=\"2. 映射方式\"></a>2. 映射方式</h2><p>映射方式常有：</p>\n<ul>\n<li>直接映射</li>\n<li>组相连映射</li>\n<li>全相连映射</li>\n</ul>\n<h3 id=\"2-1-直接映射缓存（Direct-mapped-cache）\"><a href=\"#2-1-直接映射缓存（Direct-mapped-cache）\" class=\"headerlink\" title=\"2.1. 直接映射缓存（Direct mapped cache）\"></a>2.1. 直接映射缓存（Direct mapped cache）</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/direct_map_cache.png\" alt=\"direct mapped cache\"><br>如果依次访问0x00, 0x40, 0x80 三者index 都相同，访问0x40 时, tag match失败，cache miss 重新加载数据，这种现象称为<strong>cache颠簸(cache thrashing)</strong>。 访问0x80， tag不同cache miss，重新加载数据。这种情况，cache的引入并没有性能有所提升，因此，引入了组相连映射。</p>\n<h3 id=\"2-2-多路组相连缓存（multiple-ways-set-associative-cache）\"><a href=\"#2-2-多路组相连缓存（multiple-ways-set-associative-cache）\" class=\"headerlink\" title=\"2.2. 多路组相连缓存（multiple ways set associative cache）\"></a>2.2. 多路组相连缓存（multiple ways set associative cache）</h3><p>平均将cache 分成多份，每一份就是一路(way)。在每一路中index 相同的cache lines称为组(set)。直接映射也可以称之为单路组相连。</p>\n<p>多路组相连与直接映射对比：  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">优势</th>\n<th style=\"text-align:left\">劣势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">在相同的index 情况下， 如果一路(way) 中miss, 可以继续在另一路中寻找相同index 的cache line</td>\n<td style=\"text-align:left\">硬件成本更高，每次比较tag 需要比较多个cache line</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/2_way_set_associative_cache.png\" alt=\"2-way set associative cache\"></p>\n<p>example： 32KB cache, 32 Bytes cache line, 4 ways, address bus 48-bit<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/4_way_set_associative_cache.png\" alt=\"4-way set associative cache\"></p>\n<h3 id=\"2-3-全相连缓存（Full-associative-cache）\"><a href=\"#2-3-全相连缓存（Full-associative-cache）\" class=\"headerlink\" title=\"2.3. 全相连缓存（Full associative cache）\"></a>2.3. 全相连缓存（Full associative cache）</h3><p>所有cache line 都在一个组内，因此，不需要index。任意地址的数据都可以缓存在任意cache line。但伴随硬件的成本，设计复杂度也会增加。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/full_associative_cache.png\" alt=\"full associative cache\"></p>\n<h2 id=\"3-更新策略\"><a href=\"#3-更新策略\" class=\"headerlink\" title=\"3. 更新策略\"></a>3. 更新策略</h2><p>cache 更新策略是在cache 命中，并且有写操作时，cache 如何更新。<br>update policy 有两种： </p>\n<ul>\n<li>write through  </li>\n<li>write back</li>\n</ul>\n<h3 id=\"3-1-写直通-write-through\"><a href=\"#3-1-写直通-write-through\" class=\"headerlink\" title=\"3.1. 写直通(write through)\"></a>3.1. 写直通(write through)</h3><p>cache 更新的同时，main memory 也会一并更新。cache 与主存内容一致。</p>\n<p>Fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/write_through.png\" alt=\"write through\"></p>\n<h3 id=\"3-2-写回-write-back\"><a href=\"#3-2-写回-write-back\" class=\"headerlink\" title=\"3.2. 写回(write back)\"></a>3.2. 写回(write back)</h3><p>只更新cache， main memory 不更新。并且会置位 cache line中 “dirty bit”, 表明该cache line 修改过，并与主存不一致。在cache line 被替换时或flush 操作时更新到main memory。</p>\n<p>Fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/write_back.png\" alt=\"write back\"></p>\n<h2 id=\"4-coherent\"><a href=\"#4-coherent\" class=\"headerlink\" title=\"4. coherent\"></a>4. coherent</h2><p>cache 的引入，Multiple Core, DMA 外设等因素，CPU Core访问的数据可能与另一个CPU Core或Device不一致。</p>\n<h3 id=\"4-1-memory-attribute\"><a href=\"#4-1-memory-attribute\" class=\"headerlink\" title=\"4.1. memory attribute\"></a>4.1. memory attribute</h3><p>比较直接的方式就是限制memory 的type 与attribute。例如设定成device type or strongly-ordered.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">type</th>\n<th style=\"text-align:left\">shareablility</th>\n<th style=\"text-align:left\">cacheability</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">strongly-ordered</td>\n<td style=\"text-align:left\">outer shareable</td>\n<td style=\"text-align:left\">Non-cacheable</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">device</td>\n<td style=\"text-align:left\">outer shareable</td>\n<td style=\"text-align:left\">Non-cacheable</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">normal</td>\n<td style=\"text-align:left\">one of:<br>- Non-shareable <br>- inner shareable <br>- outer shareable</td>\n<td style=\"text-align:left\">one of:<br>- Non-cacheable <br>- inner cacheable <br>- outer cacheable</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-2-cache-一致性协议\"><a href=\"#4-2-cache-一致性协议\" class=\"headerlink\" title=\"4.2. cache 一致性协议\"></a>4.2. cache 一致性协议</h3><p>在cache line 增加状态位，表明当前cache line 的状态</p>\n<h4 id=\"MESI\"><a href=\"#MESI\" class=\"headerlink\" title=\"MESI\"></a>MESI</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Status</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">M</font> 修改(modified)</td>\n<td style=\"text-align:left\">cache line有效，数据被修改，与main memory 中不一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">E</font> 独享(Exclusive)</td>\n<td style=\"text-align:left\">cache line 有效，数据与主存一致，并数据只存在于该cache line</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">S</font> 共享(shared)</td>\n<td style=\"text-align:left\">cache line 有效，数据与主存一致，数据存在于多个cache line</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">I</font> 无效(invalide)</td>\n<td style=\"text-align:left\">cache line 无效</td>\n</tr>\n</tbody>\n</table>\n<p>状态图转换如下:<br>Fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/MESI.png\" alt=\"MESI\"></p>\n<h4 id=\"MOESI\"><a href=\"#MOESI\" class=\"headerlink\" title=\"MOESI\"></a>MOESI</h4><p>相较于MESI，增加O(Owned), S也与MESI 定义不同，cache line 不一定与主存一致。M，E，I定义相同。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Status</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">M</font> 修改(modified)</td>\n<td style=\"text-align:left\">cache line有效，数据被修改，与main memory 中不一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">O</font> 拥有(Owned)</td>\n<td style=\"text-align:left\">O为1， 当前cache line是当前cpu 最新数据拷贝，且其他core 一定具有该cache line 的副本状态位S</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">E</font> 独享(Exclusive)</td>\n<td style=\"text-align:left\">cache line 有效，数据与主存一致，并数据只存在于该cache line</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">S</font> 共享(shared)</td>\n<td style=\"text-align:left\">cache line 有效，数据与主存<strong>不一定</strong>一致，数据存在于多个cache line</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"red\">I</font> 无效(invalide)</td>\n<td style=\"text-align:left\">cache line 无效</td>\n</tr>\n</tbody>\n</table>\n<p>Fixme<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/MOESI.png\" alt=\"MOESI\"></p>\n<h3 id=\"4-3-automic-operating\"><a href=\"#4-3-automic-operating\" class=\"headerlink\" title=\"4.3. automic operating\"></a>4.3. automic operating</h3><p>ARM 提供了原子操作的指令,ldrex, strex, clrex系列指令。这能保证在多核之间对数据进行唯一性的访问。</p>\n<p>配对使用的指令：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">load instruction</th>\n<th style=\"text-align:left\">store instruction</th>\n<th style=\"text-align:left\">remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ldrexb</td>\n<td style=\"text-align:left\">strexb</td>\n<td style=\"text-align:left\">byte access</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ldrexh</td>\n<td style=\"text-align:left\">strexh</td>\n<td style=\"text-align:left\">half world access</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ldrexd</td>\n<td style=\"text-align:left\">strexd</td>\n<td style=\"text-align:left\">double world access</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># load Ry 地址中的数据到Rx，并标记对该段内存独占访问</span></span><br><span class=\"line\"># 如果已经标记过，不影响操作</span><br><span class=\"line\">ldrex Rx, [Ry]</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果Rz 已经被标记为独占访问，store Ry 到Rz 地址内存，清除独占标记并<span class=\"built_in\">set</span> Rx-&gt;<span class=\"number\">0</span></span><br><span class=\"line\"># 如果Rz 没有设定为独占访问，不更新内存，并<span class=\"built_in\">set</span> Rx-&gt;<span class=\"number\">1</span> 表明失败</span><br><span class=\"line\">strex Rx, Ry, [Rz]</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-Cache-Maintenance-Operations\"><a href=\"#5-Cache-Maintenance-Operations\" class=\"headerlink\" title=\"5. Cache Maintenance Operations\"></a>5. Cache Maintenance Operations</h2><p>armv7 下cache 可以依据MVA(modified virtual address)，set/way或全部内容进行维护更新,可参看如下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/cache_maintenance_operations.png\" alt=\"cache_maintenance_operations\"></p>\n<p>POU - to point of unification<br>POC - to point of coherence</p>\n<p>POU 主要指Instruction, data, TLB 看到的为同一份mem<br>POC 主要指各个Core 之间看到的为同一份mem。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POU.png\" alt=\"POU\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POC.png\" alt=\"POC\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/cache/POU%26POC.png\" alt=\"POU&amp;POC\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/memory_management/458.html\" target=\"_blank\" rel=\"noopener\">浅谈Cache Memory</a><br><a href=\"https://blog.csdn.net/loongshawn/article/details/83083346\" target=\"_blank\" rel=\"noopener\">缓存一致性协议MESI和MOESI</a><br><a href=\"http://www.360doc.com/content/19/0410/14/496343_827699509.shtml\" target=\"_blank\" rel=\"noopener\">MESI &amp; MOESI 协议</a><br><a href=\"https://blog.csdn.net/shenhuxi_yu/article/details/90617675\" target=\"_blank\" rel=\"noopener\">arm64 memory 属性 Device-nGnRnE</a><br><a href=\"https://blog.csdn.net/roland_sun/article/details/47670099\" target=\"_blank\" rel=\"noopener\">ARM平台下独占访问指令LDREX和STREX的原理与使用详解</a><br><a href=\"https://community.arm.com/cn/f/discussions/3437/pou-poc/9674\" target=\"_blank\" rel=\"noopener\">什么是PoU和PoC？</a></p>"},{"title":"Hello World","date":"2017-06-14T15:55:39.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-06-14 23:55:39\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0q8002czkgrhy56du5f","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"kernel_crypto_I","date":"2019-08-06T11:37:35.000Z","_content":"\n### 1. 基础\nSE(Securty Engine) 提供encryption/decryption。\nSE 常见使用如下形式加解密：\n- cipher engine(密码引擎)  \n- short messages（short message 指front message 的长度小于block cipher length）  \n- residue（残余） technology (residue 指当我们最后的数据是小于cipher input block length 剩下的data)\n\n术语 | 解释\n:- | :-\n明文| 原始信息\n加密算法| 以密钥为参数，对明文进行多种置换和转换的规则和步骤，变换结果为密文。\n密钥| 加密与解密算法的参数，直接影响对明文进行变换的结果\n密文| 对明文进行变换的结果\n解密算法| 加密算法的逆变换，以密文为输入、密钥为参数，变换结果为明文\n\n<!--more-->\n\n#### 1.1. 常见cipher engine \n- AES 128/192/256  \n- DES  \n- TDES(EEE/DDD/EDE/DED)\n\n当然cipher 还有如下full chain(加密模式) 可以搭配, 例如AES_ECB, DES_CBC等。\n- ECB \n- CBC  \n- CTR  \n- OFB  \n- CFB   \n\n例如ECB 模式： \n![ecb](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/ecb.png)\n\nresidue ecb_clr：\n![residue](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/residue_ecb.png)\n\nshortmessage ecb_clr:\n![shortmessage](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/short_message_for%20ecb_with_clr.png)\n\ncipher chain | CLR (short message) | XOR(IV1)(short message) | XOR(IV2)(short message) | CLR(residue) | RBT(residue) | CTS(residue) \n:- | :- | :- | :- | :- | :- | :- \n<font color=blue>AES_ECB</font> | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=blue>AES_CBC</font> | <font color=red>O</font> | X | X | <font color=red>O</font> | <font color=red>O</font> | <font color=red>O</font>\n<font color=blue>AES_CTR</font> | X | <font color=red>O</font> | X | X | <font color=red>O</font> | <font color=red>O</font>\n<font color=blue>AES_OFB</font> | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=blue>AES_CFB</font> | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=green>DES_ECB | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=green>DES_CBC | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=green>DES_CBC | X | <font color=red>O</font> | <font color=red>O</font> | X | <font color=red>O</font> | X\n<font color=green>DES_CTR | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=green>DES_OFB | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=green>DES_CFB | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_ECB | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_CBC | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_CBC | X | <font color=red>O | <font color=red>O | X | <font color=red>O | X\n<font color=orange>TES_CTR | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_OFB | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_CFB | <font color=red>O | X | X | <font color=red>O | X | X\n__注__：\n<font color=red>O</font>: legal\n X: illegal\n\n#### 1.2. key(密钥)\n硬件模块支持set key。有些还提供了CPU cannot access 的internal key 进一步保证安全性。因此，我们在加密时需要选择何种key。\n\n![key selection](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/key_selection.png)\n\n当然，internal key 是可以重新生成的，重新产生流程如下：\n![internal key generate](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/internal_key_generate.png)\n\n![internal key generate flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/internal_key_generate_flow.png)\n\n#### 1.3. R/W 方式\ncryptographic 一般支持三种方式的encryption or decrytion:\n- pio  \n- dma\n- List + dma  \n\n__List Mode__\n每一entry 内容常见为：\n- attribute (algorithm)  \n- dma size  \n- dma r/w addr  \n  \n![list entry](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/link_list.png)\n\n__PIO Mode__\n![pio encrypto flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/pio_encrypttion_flow.png)\n\n\n### 2. Kernel Crypto\ncrypto 在kernel 中可以分为如下几类（）：\n1. cipher (AES, DES, TDES等)\n1.1. Symmetric cipher(ablkcipher, blkcipher, cipher)  \n1.2. aead cipher(Authenticated Encryption with Associated Data )  \n2. compress(zlib, lzo 等)  \n3. digest  (摘要算法例如crc32, sha1, md5等)\n4. random （软件层随机数）\n5. hash (CAC, HMAC, XCBC, VMAC 等)\n\n#### 2.1. kernel menuconfig\n![menuconfig_core](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menconfig_core.png)\n\n![menuconfig_associate_data](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menconfig_associated_data.png)\n\n![menuconfig_cipher](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menuconfig_cipher.png)\n\nkernel 的crypto 子系统采用了分层的思想。作者使用crypto_alg 代表算法例如（AES_CBC, DES_CBC等）， crypto_tfm 代表用户实例化的对象，它包含了算法与处理逻辑。\n\n>crt_u里面的回调函数和cra_u中的回调函数名称几乎一模一样，但是它们的层次不同，crt中的函数实现了一大类算法的运行逻辑，比如cipher中的des中的块应该怎么分割等等，虽然对于摘要算法，sha1或者别的什么的算法逻辑没有什么区别，但是对于cipher来讲就不是这样了，同一种算法可能拥有ecb，cbc，fcb等不同的模式，于是就来了个中间层，这个中间层就是上面的联合体crt_u。\n\n#### 2.2. data structure\n```c\nstruct crypto_alg {\n\tstruct list_head cra_list;\n\tstruct list_head cra_users;\n\n\tu32 cra_flags;\n\tunsigned int cra_blocksize;\n\tunsigned int cra_ctxsize;\n\tunsigned int cra_alignmask;\n\n\tint cra_priority;\n\tatomic_t cra_refcnt;\n\n\tchar cra_name[CRYPTO_MAX_ALG_NAME];\n\tchar cra_driver_name[CRYPTO_MAX_ALG_NAME];\n\n\tconst struct crypto_type *cra_type;\n\n\tunion {\n\t\tstruct ablkcipher_alg ablkcipher;\n\t\tstruct aead_alg aead;\n\t\tstruct blkcipher_alg blkcipher;\n\t\tstruct cipher_alg cipher;\n\t\tstruct compress_alg compress;\n\t\tstruct rng_alg rng;\n\t} cra_u;\n\n\tint (*cra_init)(struct crypto_tfm *tfm);\n\tvoid (*cra_exit)(struct crypto_tfm *tfm);\n\tvoid (*cra_destroy)(struct crypto_alg *alg);\n\t\n\tstruct module *cra_module;\n};\n\n/*\n * Transforms: user-instantiated objects which encapsulate algorithms\n * and core processing logic.  Managed via crypto_alloc_*() and\n * crypto_free_*(), as well as the various helpers below.\n */\nstruct crypto_tfm {\n\tu32 crt_flags;\n\tunion {\n\t\tstruct ablkcipher_tfm ablkcipher;\n\t\tstruct aead_tfm aead;\n\t\tstruct blkcipher_tfm blkcipher;\n\t\tstruct cipher_tfm cipher;\n\t\tstruct hash_tfm hash;\n\t\tstruct compress_tfm compress;\n\t\tstruct rng_tfm rng;\n\t} crt_u;\n\n\tvoid (*exit)(struct crypto_tfm *tfm);\n\tstruct crypto_alg *__crt_alg;\n\tvoid *__crt_ctx[] CRYPTO_MINALIGN_ATTR;\n};\n```\n#### 2.3. usage\nkernel中crypto 相关源码在两个位置：\n- ${kernel_src}/crypto （向Kernel或userspace提供的api） \n- ${kernel_src}/drivers/crypto （支持硬件加密的驱动）\n\ntfm 的管理通过如下函数：\n```c\ncrypto_alloc_tfm()\ncrypto_free_tfm()\n```\n\n在SE 驱动中，我们使用crypto_register_alg() 将他们添加到list中\n```c\nint crypto_register_algs(struct crypto_alg *algs, int count;\nlist_add(&alg->cra_list, &crypto_alg_list);\n\nint crypto_unregister_algs(struct crypto_alg *algs, int count);\n```\n他们的使用关系大致如下：\n>crypto API <—> crypto core <—> crypto_register_alg\n\n### 参看资料\n[常用加解密算法总结1-DES、TDES、3DES](https://blog.csdn.net/youyu_torch/article/details/78117530)\n\n[Linux加密框架设计与实现(转)](https://www.cnblogs.com/hoys/archive/2013/03/25/2981612.html)\n\n[linux内核cryto接口的实现以及与openssl的比较](https://blog.csdn.net/dog250/article/details/5561075)\n\n[Linux Kernel Crypto API](https://01.org/linuxgraphics/gfx-docs/drm/crypto/)\n\n[什么是AEAD加密](https://zhuanlan.zhihu.com/p/28566058)","source":"_posts/kernel-crypto-I.md","raw":"---\ntitle: kernel_crypto_I\ndate: 2019-08-06 19:37:35\ntags: cryptographic\ncategories: drivers\n---\n\n### 1. 基础\nSE(Securty Engine) 提供encryption/decryption。\nSE 常见使用如下形式加解密：\n- cipher engine(密码引擎)  \n- short messages（short message 指front message 的长度小于block cipher length）  \n- residue（残余） technology (residue 指当我们最后的数据是小于cipher input block length 剩下的data)\n\n术语 | 解释\n:- | :-\n明文| 原始信息\n加密算法| 以密钥为参数，对明文进行多种置换和转换的规则和步骤，变换结果为密文。\n密钥| 加密与解密算法的参数，直接影响对明文进行变换的结果\n密文| 对明文进行变换的结果\n解密算法| 加密算法的逆变换，以密文为输入、密钥为参数，变换结果为明文\n\n<!--more-->\n\n#### 1.1. 常见cipher engine \n- AES 128/192/256  \n- DES  \n- TDES(EEE/DDD/EDE/DED)\n\n当然cipher 还有如下full chain(加密模式) 可以搭配, 例如AES_ECB, DES_CBC等。\n- ECB \n- CBC  \n- CTR  \n- OFB  \n- CFB   \n\n例如ECB 模式： \n![ecb](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/ecb.png)\n\nresidue ecb_clr：\n![residue](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/residue_ecb.png)\n\nshortmessage ecb_clr:\n![shortmessage](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/short_message_for%20ecb_with_clr.png)\n\ncipher chain | CLR (short message) | XOR(IV1)(short message) | XOR(IV2)(short message) | CLR(residue) | RBT(residue) | CTS(residue) \n:- | :- | :- | :- | :- | :- | :- \n<font color=blue>AES_ECB</font> | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=blue>AES_CBC</font> | <font color=red>O</font> | X | X | <font color=red>O</font> | <font color=red>O</font> | <font color=red>O</font>\n<font color=blue>AES_CTR</font> | X | <font color=red>O</font> | X | X | <font color=red>O</font> | <font color=red>O</font>\n<font color=blue>AES_OFB</font> | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=blue>AES_CFB</font> | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=green>DES_ECB | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=green>DES_CBC | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=green>DES_CBC | X | <font color=red>O</font> | <font color=red>O</font> | X | <font color=red>O</font> | X\n<font color=green>DES_CTR | <font color=red>O</font> | X | X | <font color=red>O</font> | X | X\n<font color=green>DES_OFB | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=green>DES_CFB | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_ECB | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_CBC | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_CBC | X | <font color=red>O | <font color=red>O | X | <font color=red>O | X\n<font color=orange>TES_CTR | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_OFB | <font color=red>O | X | X | <font color=red>O | X | X\n<font color=orange>TES_CFB | <font color=red>O | X | X | <font color=red>O | X | X\n__注__：\n<font color=red>O</font>: legal\n X: illegal\n\n#### 1.2. key(密钥)\n硬件模块支持set key。有些还提供了CPU cannot access 的internal key 进一步保证安全性。因此，我们在加密时需要选择何种key。\n\n![key selection](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/key_selection.png)\n\n当然，internal key 是可以重新生成的，重新产生流程如下：\n![internal key generate](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/internal_key_generate.png)\n\n![internal key generate flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/internal_key_generate_flow.png)\n\n#### 1.3. R/W 方式\ncryptographic 一般支持三种方式的encryption or decrytion:\n- pio  \n- dma\n- List + dma  \n\n__List Mode__\n每一entry 内容常见为：\n- attribute (algorithm)  \n- dma size  \n- dma r/w addr  \n  \n![list entry](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/link_list.png)\n\n__PIO Mode__\n![pio encrypto flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/pio_encrypttion_flow.png)\n\n\n### 2. Kernel Crypto\ncrypto 在kernel 中可以分为如下几类（）：\n1. cipher (AES, DES, TDES等)\n1.1. Symmetric cipher(ablkcipher, blkcipher, cipher)  \n1.2. aead cipher(Authenticated Encryption with Associated Data )  \n2. compress(zlib, lzo 等)  \n3. digest  (摘要算法例如crc32, sha1, md5等)\n4. random （软件层随机数）\n5. hash (CAC, HMAC, XCBC, VMAC 等)\n\n#### 2.1. kernel menuconfig\n![menuconfig_core](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menconfig_core.png)\n\n![menuconfig_associate_data](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menconfig_associated_data.png)\n\n![menuconfig_cipher](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menuconfig_cipher.png)\n\nkernel 的crypto 子系统采用了分层的思想。作者使用crypto_alg 代表算法例如（AES_CBC, DES_CBC等）， crypto_tfm 代表用户实例化的对象，它包含了算法与处理逻辑。\n\n>crt_u里面的回调函数和cra_u中的回调函数名称几乎一模一样，但是它们的层次不同，crt中的函数实现了一大类算法的运行逻辑，比如cipher中的des中的块应该怎么分割等等，虽然对于摘要算法，sha1或者别的什么的算法逻辑没有什么区别，但是对于cipher来讲就不是这样了，同一种算法可能拥有ecb，cbc，fcb等不同的模式，于是就来了个中间层，这个中间层就是上面的联合体crt_u。\n\n#### 2.2. data structure\n```c\nstruct crypto_alg {\n\tstruct list_head cra_list;\n\tstruct list_head cra_users;\n\n\tu32 cra_flags;\n\tunsigned int cra_blocksize;\n\tunsigned int cra_ctxsize;\n\tunsigned int cra_alignmask;\n\n\tint cra_priority;\n\tatomic_t cra_refcnt;\n\n\tchar cra_name[CRYPTO_MAX_ALG_NAME];\n\tchar cra_driver_name[CRYPTO_MAX_ALG_NAME];\n\n\tconst struct crypto_type *cra_type;\n\n\tunion {\n\t\tstruct ablkcipher_alg ablkcipher;\n\t\tstruct aead_alg aead;\n\t\tstruct blkcipher_alg blkcipher;\n\t\tstruct cipher_alg cipher;\n\t\tstruct compress_alg compress;\n\t\tstruct rng_alg rng;\n\t} cra_u;\n\n\tint (*cra_init)(struct crypto_tfm *tfm);\n\tvoid (*cra_exit)(struct crypto_tfm *tfm);\n\tvoid (*cra_destroy)(struct crypto_alg *alg);\n\t\n\tstruct module *cra_module;\n};\n\n/*\n * Transforms: user-instantiated objects which encapsulate algorithms\n * and core processing logic.  Managed via crypto_alloc_*() and\n * crypto_free_*(), as well as the various helpers below.\n */\nstruct crypto_tfm {\n\tu32 crt_flags;\n\tunion {\n\t\tstruct ablkcipher_tfm ablkcipher;\n\t\tstruct aead_tfm aead;\n\t\tstruct blkcipher_tfm blkcipher;\n\t\tstruct cipher_tfm cipher;\n\t\tstruct hash_tfm hash;\n\t\tstruct compress_tfm compress;\n\t\tstruct rng_tfm rng;\n\t} crt_u;\n\n\tvoid (*exit)(struct crypto_tfm *tfm);\n\tstruct crypto_alg *__crt_alg;\n\tvoid *__crt_ctx[] CRYPTO_MINALIGN_ATTR;\n};\n```\n#### 2.3. usage\nkernel中crypto 相关源码在两个位置：\n- ${kernel_src}/crypto （向Kernel或userspace提供的api） \n- ${kernel_src}/drivers/crypto （支持硬件加密的驱动）\n\ntfm 的管理通过如下函数：\n```c\ncrypto_alloc_tfm()\ncrypto_free_tfm()\n```\n\n在SE 驱动中，我们使用crypto_register_alg() 将他们添加到list中\n```c\nint crypto_register_algs(struct crypto_alg *algs, int count;\nlist_add(&alg->cra_list, &crypto_alg_list);\n\nint crypto_unregister_algs(struct crypto_alg *algs, int count);\n```\n他们的使用关系大致如下：\n>crypto API <—> crypto core <—> crypto_register_alg\n\n### 参看资料\n[常用加解密算法总结1-DES、TDES、3DES](https://blog.csdn.net/youyu_torch/article/details/78117530)\n\n[Linux加密框架设计与实现(转)](https://www.cnblogs.com/hoys/archive/2013/03/25/2981612.html)\n\n[linux内核cryto接口的实现以及与openssl的比较](https://blog.csdn.net/dog250/article/details/5561075)\n\n[Linux Kernel Crypto API](https://01.org/linuxgraphics/gfx-docs/drm/crypto/)\n\n[什么是AEAD加密](https://zhuanlan.zhihu.com/p/28566058)","slug":"kernel-crypto-I","published":1,"updated":"2019-08-07T06:53:04.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qa002gzkgrja9eke6b","content":"<h3 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1. 基础\"></a>1. 基础</h3><p>SE(Securty Engine) 提供encryption/decryption。<br>SE 常见使用如下形式加解密：</p>\n<ul>\n<li>cipher engine(密码引擎)  </li>\n<li>short messages（short message 指front message 的长度小于block cipher length）  </li>\n<li>residue（残余） technology (residue 指当我们最后的数据是小于cipher input block length 剩下的data)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">术语</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">明文</td>\n<td style=\"text-align:left\">原始信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">加密算法</td>\n<td style=\"text-align:left\">以密钥为参数，对明文进行多种置换和转换的规则和步骤，变换结果为密文。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">密钥</td>\n<td style=\"text-align:left\">加密与解密算法的参数，直接影响对明文进行变换的结果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">密文</td>\n<td style=\"text-align:left\">对明文进行变换的结果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">解密算法</td>\n<td style=\"text-align:left\">加密算法的逆变换，以密文为输入、密钥为参数，变换结果为明文</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h4 id=\"1-1-常见cipher-engine\"><a href=\"#1-1-常见cipher-engine\" class=\"headerlink\" title=\"1.1. 常见cipher engine\"></a>1.1. 常见cipher engine</h4><ul>\n<li>AES 128/192/256  </li>\n<li>DES  </li>\n<li>TDES(EEE/DDD/EDE/DED)</li>\n</ul>\n<p>当然cipher 还有如下full chain(加密模式) 可以搭配, 例如AES_ECB, DES_CBC等。</p>\n<ul>\n<li>ECB </li>\n<li>CBC  </li>\n<li>CTR  </li>\n<li>OFB  </li>\n<li>CFB   </li>\n</ul>\n<p>例如ECB 模式：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/ecb.png\" alt=\"ecb\"></p>\n<p>residue ecb_clr：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/residue_ecb.png\" alt=\"residue\"></p>\n<p>shortmessage ecb_clr:<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/short_message_for%20ecb_with_clr.png\" alt=\"shortmessage\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">cipher chain</th>\n<th style=\"text-align:left\">CLR (short message)</th>\n<th style=\"text-align:left\">XOR(IV1)(short message)</th>\n<th style=\"text-align:left\">XOR(IV2)(short message)</th>\n<th style=\"text-align:left\">CLR(residue)</th>\n<th style=\"text-align:left\">RBT(residue)</th>\n<th style=\"text-align:left\">CTS(residue) </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_ECB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_CBC</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_CTR</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_OFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_CFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_ECB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_CBC</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_CBC</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_CTR</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_OFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_CFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_ECB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_CBC</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_CBC</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_CTR</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_OFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_CFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注</strong>：</p>\n<p><font color=\"red\">O</font>: legal<br> X: illegal</p>\n<h4 id=\"1-2-key-密钥\"><a href=\"#1-2-key-密钥\" class=\"headerlink\" title=\"1.2. key(密钥)\"></a>1.2. key(密钥)</h4><p>硬件模块支持set key。有些还提供了CPU cannot access 的internal key 进一步保证安全性。因此，我们在加密时需要选择何种key。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/key_selection.png\" alt=\"key selection\"></p>\n<p>当然，internal key 是可以重新生成的，重新产生流程如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/internal_key_generate.png\" alt=\"internal key generate\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/internal_key_generate_flow.png\" alt=\"internal key generate flow\"></p>\n<h4 id=\"1-3-R-W-方式\"><a href=\"#1-3-R-W-方式\" class=\"headerlink\" title=\"1.3. R/W 方式\"></a>1.3. R/W 方式</h4><p>cryptographic 一般支持三种方式的encryption or decrytion:</p>\n<ul>\n<li>pio  </li>\n<li>dma</li>\n<li>List + dma  </li>\n</ul>\n<p><strong>List Mode</strong><br>每一entry 内容常见为：</p>\n<ul>\n<li>attribute (algorithm)  </li>\n<li>dma size  </li>\n<li>dma r/w addr  </li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/link_list.png\" alt=\"list entry\"></p>\n<p><strong>PIO Mode</strong><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/pio_encrypttion_flow.png\" alt=\"pio encrypto flow\"></p>\n<h3 id=\"2-Kernel-Crypto\"><a href=\"#2-Kernel-Crypto\" class=\"headerlink\" title=\"2. Kernel Crypto\"></a>2. Kernel Crypto</h3><p>crypto 在kernel 中可以分为如下几类（）：</p>\n<ol>\n<li>cipher (AES, DES, TDES等)<br>1.1. Symmetric cipher(ablkcipher, blkcipher, cipher)<br>1.2. aead cipher(Authenticated Encryption with Associated Data )  </li>\n<li>compress(zlib, lzo 等)  </li>\n<li>digest  (摘要算法例如crc32, sha1, md5等)</li>\n<li>random （软件层随机数）</li>\n<li>hash (CAC, HMAC, XCBC, VMAC 等)</li>\n</ol>\n<h4 id=\"2-1-kernel-menuconfig\"><a href=\"#2-1-kernel-menuconfig\" class=\"headerlink\" title=\"2.1. kernel menuconfig\"></a>2.1. kernel menuconfig</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menconfig_core.png\" alt=\"menuconfig_core\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menconfig_associated_data.png\" alt=\"menuconfig_associate_data\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menuconfig_cipher.png\" alt=\"menuconfig_cipher\"></p>\n<p>kernel 的crypto 子系统采用了分层的思想。作者使用crypto_alg 代表算法例如（AES_CBC, DES_CBC等）， crypto_tfm 代表用户实例化的对象，它包含了算法与处理逻辑。</p>\n<blockquote>\n<p>crt_u里面的回调函数和cra_u中的回调函数名称几乎一模一样，但是它们的层次不同，crt中的函数实现了一大类算法的运行逻辑，比如cipher中的des中的块应该怎么分割等等，虽然对于摘要算法，sha1或者别的什么的算法逻辑没有什么区别，但是对于cipher来讲就不是这样了，同一种算法可能拥有ecb，cbc，fcb等不同的模式，于是就来了个中间层，这个中间层就是上面的联合体crt_u。</p>\n</blockquote>\n<h4 id=\"2-2-data-structure\"><a href=\"#2-2-data-structure\" class=\"headerlink\" title=\"2.2. data structure\"></a>2.2. data structure</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_alg</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">cra_list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">cra_users</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tu32 cra_flags;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cra_blocksize;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cra_ctxsize;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cra_alignmask;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cra_priority;</span><br><span class=\"line\">\t<span class=\"keyword\">atomic_t</span> cra_refcnt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cra_name[CRYPTO_MAX_ALG_NAME];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cra_driver_name[CRYPTO_MAX_ALG_NAME];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_type</span> *<span class=\"title\">cra_type</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_alg</span> <span class=\"title\">ablkcipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">aead_alg</span> <span class=\"title\">aead</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blkcipher_alg</span> <span class=\"title\">blkcipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cipher_alg</span> <span class=\"title\">cipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">compress_alg</span> <span class=\"title\">compress</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rng_alg</span> <span class=\"title\">rng</span>;</span></span><br><span class=\"line\">\t&#125; cra_u;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*cra_init)(struct crypto_tfm *tfm);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*cra_exit)(struct crypto_tfm *tfm);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*cra_destroy)(struct crypto_alg *alg);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">cra_module</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Transforms: user-instantiated objects which encapsulate algorithms</span></span><br><span class=\"line\"><span class=\"comment\"> * and core processing logic.  Managed via crypto_alloc_*() and</span></span><br><span class=\"line\"><span class=\"comment\"> * crypto_free_*(), as well as the various helpers below.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_tfm</span> &#123;</span></span><br><span class=\"line\">\tu32 crt_flags;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_tfm</span> <span class=\"title\">ablkcipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">aead_tfm</span> <span class=\"title\">aead</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blkcipher_tfm</span> <span class=\"title\">blkcipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cipher_tfm</span> <span class=\"title\">cipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_tfm</span> <span class=\"title\">hash</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">compress_tfm</span> <span class=\"title\">compress</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rng_tfm</span> <span class=\"title\">rng</span>;</span></span><br><span class=\"line\">\t&#125; crt_u;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*<span class=\"built_in\">exit</span>)(struct crypto_tfm *tfm);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_alg</span> *__<span class=\"title\">crt_alg</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *__crt_ctx[] CRYPTO_MINALIGN_ATTR;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-usage\"><a href=\"#2-3-usage\" class=\"headerlink\" title=\"2.3. usage\"></a>2.3. usage</h4><p>kernel中crypto 相关源码在两个位置：</p>\n<ul>\n<li>${kernel_src}/crypto （向Kernel或userspace提供的api） </li>\n<li>${kernel_src}/drivers/crypto （支持硬件加密的驱动）</li>\n</ul>\n<p>tfm 的管理通过如下函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crypto_alloc_tfm()</span><br><span class=\"line\">crypto_free_tfm()</span><br></pre></td></tr></table></figure></p>\n<p>在SE 驱动中，我们使用crypto_register_alg() 将他们添加到list中<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">crypto_register_algs</span><span class=\"params\">(struct crypto_alg *algs, <span class=\"keyword\">int</span> count;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">crypto_unregister_algs</span><span class=\"params\">(struct crypto_alg *algs, <span class=\"keyword\">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>他们的使用关系大致如下：</p>\n<blockquote>\n<p>crypto API &lt;—&gt; crypto core &lt;—&gt; crypto_register_alg</p>\n</blockquote>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://blog.csdn.net/youyu_torch/article/details/78117530\" target=\"_blank\" rel=\"noopener\">常用加解密算法总结1-DES、TDES、3DES</a></p>\n<p><a href=\"https://www.cnblogs.com/hoys/archive/2013/03/25/2981612.html\" target=\"_blank\" rel=\"noopener\">Linux加密框架设计与实现(转)</a></p>\n<p><a href=\"https://blog.csdn.net/dog250/article/details/5561075\" target=\"_blank\" rel=\"noopener\">linux内核cryto接口的实现以及与openssl的比较</a></p>\n<p><a href=\"https://01.org/linuxgraphics/gfx-docs/drm/crypto/\" target=\"_blank\" rel=\"noopener\">Linux Kernel Crypto API</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/28566058\" target=\"_blank\" rel=\"noopener\">什么是AEAD加密</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1. 基础\"></a>1. 基础</h3><p>SE(Securty Engine) 提供encryption/decryption。<br>SE 常见使用如下形式加解密：</p>\n<ul>\n<li>cipher engine(密码引擎)  </li>\n<li>short messages（short message 指front message 的长度小于block cipher length）  </li>\n<li>residue（残余） technology (residue 指当我们最后的数据是小于cipher input block length 剩下的data)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">术语</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">明文</td>\n<td style=\"text-align:left\">原始信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">加密算法</td>\n<td style=\"text-align:left\">以密钥为参数，对明文进行多种置换和转换的规则和步骤，变换结果为密文。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">密钥</td>\n<td style=\"text-align:left\">加密与解密算法的参数，直接影响对明文进行变换的结果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">密文</td>\n<td style=\"text-align:left\">对明文进行变换的结果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">解密算法</td>\n<td style=\"text-align:left\">加密算法的逆变换，以密文为输入、密钥为参数，变换结果为明文</td>\n</tr>\n</tbody>\n</table>","more":"<h4 id=\"1-1-常见cipher-engine\"><a href=\"#1-1-常见cipher-engine\" class=\"headerlink\" title=\"1.1. 常见cipher engine\"></a>1.1. 常见cipher engine</h4><ul>\n<li>AES 128/192/256  </li>\n<li>DES  </li>\n<li>TDES(EEE/DDD/EDE/DED)</li>\n</ul>\n<p>当然cipher 还有如下full chain(加密模式) 可以搭配, 例如AES_ECB, DES_CBC等。</p>\n<ul>\n<li>ECB </li>\n<li>CBC  </li>\n<li>CTR  </li>\n<li>OFB  </li>\n<li>CFB   </li>\n</ul>\n<p>例如ECB 模式：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/ecb.png\" alt=\"ecb\"></p>\n<p>residue ecb_clr：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/residue_ecb.png\" alt=\"residue\"></p>\n<p>shortmessage ecb_clr:<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/short_message_for%20ecb_with_clr.png\" alt=\"shortmessage\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">cipher chain</th>\n<th style=\"text-align:left\">CLR (short message)</th>\n<th style=\"text-align:left\">XOR(IV1)(short message)</th>\n<th style=\"text-align:left\">XOR(IV2)(short message)</th>\n<th style=\"text-align:left\">CLR(residue)</th>\n<th style=\"text-align:left\">RBT(residue)</th>\n<th style=\"text-align:left\">CTS(residue) </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_ECB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_CBC</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_CTR</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_OFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"blue\">AES_CFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_ECB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_CBC</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_CBC</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_CTR</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_OFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"green\">DES_CFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_ECB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_CBC</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_CBC</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_CTR</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_OFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><font color=\"orange\">TES_CFB</font></td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\"><font color=\"red\">O</font></td>\n<td style=\"text-align:left\">X</td>\n<td style=\"text-align:left\">X</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注</strong>：</p>\n<p><font color=\"red\">O</font>: legal<br> X: illegal</p>\n<h4 id=\"1-2-key-密钥\"><a href=\"#1-2-key-密钥\" class=\"headerlink\" title=\"1.2. key(密钥)\"></a>1.2. key(密钥)</h4><p>硬件模块支持set key。有些还提供了CPU cannot access 的internal key 进一步保证安全性。因此，我们在加密时需要选择何种key。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/key_selection.png\" alt=\"key selection\"></p>\n<p>当然，internal key 是可以重新生成的，重新产生流程如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/internal_key_generate.png\" alt=\"internal key generate\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/internal_key_generate_flow.png\" alt=\"internal key generate flow\"></p>\n<h4 id=\"1-3-R-W-方式\"><a href=\"#1-3-R-W-方式\" class=\"headerlink\" title=\"1.3. R/W 方式\"></a>1.3. R/W 方式</h4><p>cryptographic 一般支持三种方式的encryption or decrytion:</p>\n<ul>\n<li>pio  </li>\n<li>dma</li>\n<li>List + dma  </li>\n</ul>\n<p><strong>List Mode</strong><br>每一entry 内容常见为：</p>\n<ul>\n<li>attribute (algorithm)  </li>\n<li>dma size  </li>\n<li>dma r/w addr  </li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/link_list.png\" alt=\"list entry\"></p>\n<p><strong>PIO Mode</strong><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/pio_encrypttion_flow.png\" alt=\"pio encrypto flow\"></p>\n<h3 id=\"2-Kernel-Crypto\"><a href=\"#2-Kernel-Crypto\" class=\"headerlink\" title=\"2. Kernel Crypto\"></a>2. Kernel Crypto</h3><p>crypto 在kernel 中可以分为如下几类（）：</p>\n<ol>\n<li>cipher (AES, DES, TDES等)<br>1.1. Symmetric cipher(ablkcipher, blkcipher, cipher)<br>1.2. aead cipher(Authenticated Encryption with Associated Data )  </li>\n<li>compress(zlib, lzo 等)  </li>\n<li>digest  (摘要算法例如crc32, sha1, md5等)</li>\n<li>random （软件层随机数）</li>\n<li>hash (CAC, HMAC, XCBC, VMAC 等)</li>\n</ol>\n<h4 id=\"2-1-kernel-menuconfig\"><a href=\"#2-1-kernel-menuconfig\" class=\"headerlink\" title=\"2.1. kernel menuconfig\"></a>2.1. kernel menuconfig</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menconfig_core.png\" alt=\"menuconfig_core\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menconfig_associated_data.png\" alt=\"menuconfig_associate_data\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_crypto/menuconfig_cipher.png\" alt=\"menuconfig_cipher\"></p>\n<p>kernel 的crypto 子系统采用了分层的思想。作者使用crypto_alg 代表算法例如（AES_CBC, DES_CBC等）， crypto_tfm 代表用户实例化的对象，它包含了算法与处理逻辑。</p>\n<blockquote>\n<p>crt_u里面的回调函数和cra_u中的回调函数名称几乎一模一样，但是它们的层次不同，crt中的函数实现了一大类算法的运行逻辑，比如cipher中的des中的块应该怎么分割等等，虽然对于摘要算法，sha1或者别的什么的算法逻辑没有什么区别，但是对于cipher来讲就不是这样了，同一种算法可能拥有ecb，cbc，fcb等不同的模式，于是就来了个中间层，这个中间层就是上面的联合体crt_u。</p>\n</blockquote>\n<h4 id=\"2-2-data-structure\"><a href=\"#2-2-data-structure\" class=\"headerlink\" title=\"2.2. data structure\"></a>2.2. data structure</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_alg</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">cra_list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">cra_users</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tu32 cra_flags;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cra_blocksize;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cra_ctxsize;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cra_alignmask;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cra_priority;</span><br><span class=\"line\">\t<span class=\"keyword\">atomic_t</span> cra_refcnt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cra_name[CRYPTO_MAX_ALG_NAME];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cra_driver_name[CRYPTO_MAX_ALG_NAME];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_type</span> *<span class=\"title\">cra_type</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_alg</span> <span class=\"title\">ablkcipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">aead_alg</span> <span class=\"title\">aead</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blkcipher_alg</span> <span class=\"title\">blkcipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cipher_alg</span> <span class=\"title\">cipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">compress_alg</span> <span class=\"title\">compress</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rng_alg</span> <span class=\"title\">rng</span>;</span></span><br><span class=\"line\">\t&#125; cra_u;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*cra_init)(struct crypto_tfm *tfm);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*cra_exit)(struct crypto_tfm *tfm);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*cra_destroy)(struct crypto_alg *alg);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">cra_module</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Transforms: user-instantiated objects which encapsulate algorithms</span></span><br><span class=\"line\"><span class=\"comment\"> * and core processing logic.  Managed via crypto_alloc_*() and</span></span><br><span class=\"line\"><span class=\"comment\"> * crypto_free_*(), as well as the various helpers below.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_tfm</span> &#123;</span></span><br><span class=\"line\">\tu32 crt_flags;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ablkcipher_tfm</span> <span class=\"title\">ablkcipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">aead_tfm</span> <span class=\"title\">aead</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blkcipher_tfm</span> <span class=\"title\">blkcipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cipher_tfm</span> <span class=\"title\">cipher</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_tfm</span> <span class=\"title\">hash</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">compress_tfm</span> <span class=\"title\">compress</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rng_tfm</span> <span class=\"title\">rng</span>;</span></span><br><span class=\"line\">\t&#125; crt_u;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*<span class=\"built_in\">exit</span>)(struct crypto_tfm *tfm);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">crypto_alg</span> *__<span class=\"title\">crt_alg</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *__crt_ctx[] CRYPTO_MINALIGN_ATTR;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-usage\"><a href=\"#2-3-usage\" class=\"headerlink\" title=\"2.3. usage\"></a>2.3. usage</h4><p>kernel中crypto 相关源码在两个位置：</p>\n<ul>\n<li>${kernel_src}/crypto （向Kernel或userspace提供的api） </li>\n<li>${kernel_src}/drivers/crypto （支持硬件加密的驱动）</li>\n</ul>\n<p>tfm 的管理通过如下函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crypto_alloc_tfm()</span><br><span class=\"line\">crypto_free_tfm()</span><br></pre></td></tr></table></figure></p>\n<p>在SE 驱动中，我们使用crypto_register_alg() 将他们添加到list中<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">crypto_register_algs</span><span class=\"params\">(struct crypto_alg *algs, <span class=\"keyword\">int</span> count;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">crypto_unregister_algs</span><span class=\"params\">(struct crypto_alg *algs, <span class=\"keyword\">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>他们的使用关系大致如下：</p>\n<blockquote>\n<p>crypto API &lt;—&gt; crypto core &lt;—&gt; crypto_register_alg</p>\n</blockquote>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://blog.csdn.net/youyu_torch/article/details/78117530\" target=\"_blank\" rel=\"noopener\">常用加解密算法总结1-DES、TDES、3DES</a></p>\n<p><a href=\"https://www.cnblogs.com/hoys/archive/2013/03/25/2981612.html\" target=\"_blank\" rel=\"noopener\">Linux加密框架设计与实现(转)</a></p>\n<p><a href=\"https://blog.csdn.net/dog250/article/details/5561075\" target=\"_blank\" rel=\"noopener\">linux内核cryto接口的实现以及与openssl的比较</a></p>\n<p><a href=\"https://01.org/linuxgraphics/gfx-docs/drm/crypto/\" target=\"_blank\" rel=\"noopener\">Linux Kernel Crypto API</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/28566058\" target=\"_blank\" rel=\"noopener\">什么是AEAD加密</a></p>"},{"title":"kernel_source_code_online","date":"2019-08-23T02:52:29.000Z","_content":"\n今天看到有几个非常优秀的在线浏览kernel source code 的网站。\n- [kernel github](https://github.com/torvalds/linux/)\n- [kernel.org](https://www.kernel.org/)\n- [bootlin](https://elixir.bootlin.com/linux/latest/source)\n- [woboq](https://code.woboq.org/)\n  \n从功能上讲woboq 是最强的， bootlin 次之，但是胜在支持的kernel source 的版本比价多。\n\n<!--more-->\n\n### 1. woboq\n这是官方给出的亮点, [woboq benefit](https://woboq.com/codebrowser.html#benefits)\n\n我觉得比较有用的有：\n- 类型，定义处，引用处表明\n- 函数列表\n- 宏展开\n- 搜索功能\n- 预处理\n- 显示主题切换\n- 行号显示toggle\n\n![woboq image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_source_code_image.png)\n\n#### 1.1. functions list\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_functions_list.png)\n\n#### 1.2. defines and uses link\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_define_usage.png)\n\n#### 1.3. macro expansions\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_macro_expansons.png)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_macro_expansions_2.png)\n\n#### 1.4. search\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_search.png)\n\n#### 1.5. file in path and some code in which function\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_path_class_show.png)\n\n#### 1.6. themes switch\n![woboq themes image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_themes.png)\n\n#### 1.7. line number toggle\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_line_toggle.png)\n\n### 2. bootlin\n![bootlin url images](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin.png)\n\n![bootlin source code image]()\n\n![bootlin search image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin_search.png)\n\n![bootlin search result image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin_search_result.png)\n\n### 3. kernel.org\n![kernel org source code image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/kernel_org_source_code.png)\n\n### 4. github repository\n![kernel source code image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/github_source_code.png)\n   ","source":"_posts/kernel-source-code-online.md","raw":"---\ntitle: kernel_source_code_online\ndate: 2019-08-23 10:52:29\ntags: kernel\ncategories: kernel\n---\n\n今天看到有几个非常优秀的在线浏览kernel source code 的网站。\n- [kernel github](https://github.com/torvalds/linux/)\n- [kernel.org](https://www.kernel.org/)\n- [bootlin](https://elixir.bootlin.com/linux/latest/source)\n- [woboq](https://code.woboq.org/)\n  \n从功能上讲woboq 是最强的， bootlin 次之，但是胜在支持的kernel source 的版本比价多。\n\n<!--more-->\n\n### 1. woboq\n这是官方给出的亮点, [woboq benefit](https://woboq.com/codebrowser.html#benefits)\n\n我觉得比较有用的有：\n- 类型，定义处，引用处表明\n- 函数列表\n- 宏展开\n- 搜索功能\n- 预处理\n- 显示主题切换\n- 行号显示toggle\n\n![woboq image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_source_code_image.png)\n\n#### 1.1. functions list\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_functions_list.png)\n\n#### 1.2. defines and uses link\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_define_usage.png)\n\n#### 1.3. macro expansions\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_macro_expansons.png)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_macro_expansions_2.png)\n\n#### 1.4. search\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_search.png)\n\n#### 1.5. file in path and some code in which function\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_path_class_show.png)\n\n#### 1.6. themes switch\n![woboq themes image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_themes.png)\n\n#### 1.7. line number toggle\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_line_toggle.png)\n\n### 2. bootlin\n![bootlin url images](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin.png)\n\n![bootlin source code image]()\n\n![bootlin search image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin_search.png)\n\n![bootlin search result image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin_search_result.png)\n\n### 3. kernel.org\n![kernel org source code image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/kernel_org_source_code.png)\n\n### 4. github repository\n![kernel source code image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/github_source_code.png)\n   ","slug":"kernel-source-code-online","published":1,"updated":"2019-08-23T03:43:48.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qc002jzkgrg47azaf7","content":"<p>今天看到有几个非常优秀的在线浏览kernel source code 的网站。</p>\n<ul>\n<li><a href=\"https://github.com/torvalds/linux/\" target=\"_blank\" rel=\"noopener\">kernel github</a></li>\n<li><a href=\"https://www.kernel.org/\" target=\"_blank\" rel=\"noopener\">kernel.org</a></li>\n<li><a href=\"https://elixir.bootlin.com/linux/latest/source\" target=\"_blank\" rel=\"noopener\">bootlin</a></li>\n<li><a href=\"https://code.woboq.org/\" target=\"_blank\" rel=\"noopener\">woboq</a></li>\n</ul>\n<p>从功能上讲woboq 是最强的， bootlin 次之，但是胜在支持的kernel source 的版本比价多。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-woboq\"><a href=\"#1-woboq\" class=\"headerlink\" title=\"1. woboq\"></a>1. woboq</h3><p>这是官方给出的亮点, <a href=\"https://woboq.com/codebrowser.html#benefits\" target=\"_blank\" rel=\"noopener\">woboq benefit</a></p>\n<p>我觉得比较有用的有：</p>\n<ul>\n<li>类型，定义处，引用处表明</li>\n<li>函数列表</li>\n<li>宏展开</li>\n<li>搜索功能</li>\n<li>预处理</li>\n<li>显示主题切换</li>\n<li>行号显示toggle</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_source_code_image.png\" alt=\"woboq image\"></p>\n<h4 id=\"1-1-functions-list\"><a href=\"#1-1-functions-list\" class=\"headerlink\" title=\"1.1. functions list\"></a>1.1. functions list</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_functions_list.png\" alt=\"\"></p>\n<h4 id=\"1-2-defines-and-uses-link\"><a href=\"#1-2-defines-and-uses-link\" class=\"headerlink\" title=\"1.2. defines and uses link\"></a>1.2. defines and uses link</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_define_usage.png\" alt=\"\"></p>\n<h4 id=\"1-3-macro-expansions\"><a href=\"#1-3-macro-expansions\" class=\"headerlink\" title=\"1.3. macro expansions\"></a>1.3. macro expansions</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_macro_expansons.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_macro_expansions_2.png\" alt=\"\"></p>\n<h4 id=\"1-4-search\"><a href=\"#1-4-search\" class=\"headerlink\" title=\"1.4. search\"></a>1.4. search</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_search.png\" alt=\"\"></p>\n<h4 id=\"1-5-file-in-path-and-some-code-in-which-function\"><a href=\"#1-5-file-in-path-and-some-code-in-which-function\" class=\"headerlink\" title=\"1.5. file in path and some code in which function\"></a>1.5. file in path and some code in which function</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_path_class_show.png\" alt=\"\"></p>\n<h4 id=\"1-6-themes-switch\"><a href=\"#1-6-themes-switch\" class=\"headerlink\" title=\"1.6. themes switch\"></a>1.6. themes switch</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_themes.png\" alt=\"woboq themes image\"></p>\n<h4 id=\"1-7-line-number-toggle\"><a href=\"#1-7-line-number-toggle\" class=\"headerlink\" title=\"1.7. line number toggle\"></a>1.7. line number toggle</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_line_toggle.png\" alt=\"\"></p>\n<h3 id=\"2-bootlin\"><a href=\"#2-bootlin\" class=\"headerlink\" title=\"2. bootlin\"></a>2. bootlin</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin.png\" alt=\"bootlin url images\"></p>\n<p><img src=\"\" alt=\"bootlin source code image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin_search.png\" alt=\"bootlin search image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin_search_result.png\" alt=\"bootlin search result image\"></p>\n<h3 id=\"3-kernel-org\"><a href=\"#3-kernel-org\" class=\"headerlink\" title=\"3. kernel.org\"></a>3. kernel.org</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/kernel_org_source_code.png\" alt=\"kernel org source code image\"></p>\n<h3 id=\"4-github-repository\"><a href=\"#4-github-repository\" class=\"headerlink\" title=\"4. github repository\"></a>4. github repository</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/github_source_code.png\" alt=\"kernel source code image\"></p>\n","site":{"data":{}},"excerpt":"<p>今天看到有几个非常优秀的在线浏览kernel source code 的网站。</p>\n<ul>\n<li><a href=\"https://github.com/torvalds/linux/\" target=\"_blank\" rel=\"noopener\">kernel github</a></li>\n<li><a href=\"https://www.kernel.org/\" target=\"_blank\" rel=\"noopener\">kernel.org</a></li>\n<li><a href=\"https://elixir.bootlin.com/linux/latest/source\" target=\"_blank\" rel=\"noopener\">bootlin</a></li>\n<li><a href=\"https://code.woboq.org/\" target=\"_blank\" rel=\"noopener\">woboq</a></li>\n</ul>\n<p>从功能上讲woboq 是最强的， bootlin 次之，但是胜在支持的kernel source 的版本比价多。</p>","more":"<h3 id=\"1-woboq\"><a href=\"#1-woboq\" class=\"headerlink\" title=\"1. woboq\"></a>1. woboq</h3><p>这是官方给出的亮点, <a href=\"https://woboq.com/codebrowser.html#benefits\" target=\"_blank\" rel=\"noopener\">woboq benefit</a></p>\n<p>我觉得比较有用的有：</p>\n<ul>\n<li>类型，定义处，引用处表明</li>\n<li>函数列表</li>\n<li>宏展开</li>\n<li>搜索功能</li>\n<li>预处理</li>\n<li>显示主题切换</li>\n<li>行号显示toggle</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_source_code_image.png\" alt=\"woboq image\"></p>\n<h4 id=\"1-1-functions-list\"><a href=\"#1-1-functions-list\" class=\"headerlink\" title=\"1.1. functions list\"></a>1.1. functions list</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_functions_list.png\" alt=\"\"></p>\n<h4 id=\"1-2-defines-and-uses-link\"><a href=\"#1-2-defines-and-uses-link\" class=\"headerlink\" title=\"1.2. defines and uses link\"></a>1.2. defines and uses link</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_define_usage.png\" alt=\"\"></p>\n<h4 id=\"1-3-macro-expansions\"><a href=\"#1-3-macro-expansions\" class=\"headerlink\" title=\"1.3. macro expansions\"></a>1.3. macro expansions</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_macro_expansons.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_macro_expansions_2.png\" alt=\"\"></p>\n<h4 id=\"1-4-search\"><a href=\"#1-4-search\" class=\"headerlink\" title=\"1.4. search\"></a>1.4. search</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_search.png\" alt=\"\"></p>\n<h4 id=\"1-5-file-in-path-and-some-code-in-which-function\"><a href=\"#1-5-file-in-path-and-some-code-in-which-function\" class=\"headerlink\" title=\"1.5. file in path and some code in which function\"></a>1.5. file in path and some code in which function</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_path_class_show.png\" alt=\"\"></p>\n<h4 id=\"1-6-themes-switch\"><a href=\"#1-6-themes-switch\" class=\"headerlink\" title=\"1.6. themes switch\"></a>1.6. themes switch</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_themes.png\" alt=\"woboq themes image\"></p>\n<h4 id=\"1-7-line-number-toggle\"><a href=\"#1-7-line-number-toggle\" class=\"headerlink\" title=\"1.7. line number toggle\"></a>1.7. line number toggle</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/woboq_line_toggle.png\" alt=\"\"></p>\n<h3 id=\"2-bootlin\"><a href=\"#2-bootlin\" class=\"headerlink\" title=\"2. bootlin\"></a>2. bootlin</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin.png\" alt=\"bootlin url images\"></p>\n<p><img src=\"\" alt=\"bootlin source code image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin_search.png\" alt=\"bootlin search image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/bootlin_search_result.png\" alt=\"bootlin search result image\"></p>\n<h3 id=\"3-kernel-org\"><a href=\"#3-kernel-org\" class=\"headerlink\" title=\"3. kernel.org\"></a>3. kernel.org</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/kernel_org_source_code.png\" alt=\"kernel org source code image\"></p>\n<h3 id=\"4-github-repository\"><a href=\"#4-github-repository\" class=\"headerlink\" title=\"4. github repository\"></a>4. github repository</h3><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_source_code_online/github_source_code.png\" alt=\"kernel source code image\"></p>"},{"title":"kernel_tickless_idle","date":"2020-04-15T03:15:18.000Z","_content":"\n在嵌入式设备中对于高功耗都避之若浼。IOT 物联网，手机等更是看中设备的电池使用时间。省电节约功耗基本从考虑降低频率（手机CPU 的大小核），关闭暂未使用模块，睡眠等方向考虑。 在kernel 中就有tickless timer，通过在OS IDLE 时减少scheduling-clock ticks，节省功耗。下面主要分析kernel-4.9.198 Idle dynticks system(tickless idle)。\n\n<!--more-->\n## 1. Base\nkernel Timer system 中常见有如下方法管理：\n- 周期时钟 (schedule-clock interrupts, CONFIG_HZ_PERIODIC=y)  \n- idle 时忽略timer tick (tickless idle， CONFIG_NO_HZ_IDLE=y or CONFIG_NO_HZ=y, kernel default choose)\n- idle 时或者只有一个task run 时不需要调度，忽略CPU 的调度时钟滴答(CONFIG_NO_HZ_FULL=y)\n\n在kernel/time/Kconfig 可以看见其配置信息。\n```kconfig\nconfig NO_HZ_IDLE\n        bool \"Idle dynticks system (tickless idle)\"\n        select NO_HZ_COMMON\n        help\n          This option enables a tickless idle system: timer interrupts\n          will only trigger on an as-needed basis when the system is idle.\n          This is usually interesting for energy saving.\n\n          Most of the time you want to say Y here.\n\nconfig NO_HZ_FULL\n        bool \"Full dynticks system (tickless)\"\n        # We need at least one periodic CPU for timekeeping\n        select NO_HZ_COMMON\n        select RCU_NOCB_CPU\n        select VIRT_CPU_ACCOUNTING_GEN\n        select IRQ_WORK\n        help\n         Adaptively try to shutdown the tick whenever possible, even when\n         the CPU is running tasks. Typically this requires running a single\n         task on the CPU. Chances for running tickless are maximized when\n         the task mostly runs in userspace and has few kernel activity.\n```\n\n![config_tickless](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/tickless_idle/config_tickless_idle.png)\n\n![config_tickless_help](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/tickless_idle/config_tickless_idle_help.png)\n\nTick，即周期性产生的 timer 中断事件，可用于系统时间管理、进程信息统计、低精度 timer 处理等等。\n`低分辨率定时器`\n低分辨率定时器是<font color=red>基于 HZ 来实现</font>的，精度为 1/HZ。对定时器精度要求不高的内核模块还在大量使用低分辨率定时器，例如 CPU DVFS，CPU Hotplug 等。内核通过 time_list 结构体来描述低分辨率定时器。\n\n`高精度定时器`\n高精度定时器可以提供<font color=red>纳秒级别的定时精度</font>，以满足对时间精度要求严格的内核模块，例如音频模块，内核通过 hrtimer 结构体来描述高精度定时器。在系统启动的开始阶段，高精度定时器只能工作在低精度周期模式，在条件满足之后的某个阶段就会切换到高精度单触发模式。在系统切换为高精度timer 后，通过one_shot 模拟周期timer，为系统提供周期tick。\n\n`tickless`\n动态时钟，并不是真正没有tick， 只是在idle 时停掉tick 一段时间。\n\n## 2. tickless 何时启动？\n\n通过搜索tickless 关键函数`tick_nohz_stop_sched_tick()` 的调用， tickless 启动主要有两个时机点：\n- cpu idle 时\n- irq exit 时，尝试继续tickless\n\n```c\n/* sched tick emulation and no idle tick control/stats*/\nstruct tick_sched {\n\tstruct hrtimer\t\t\tsched_timer;\n\tunsigned long\t\t\tcheck_clocks;\n\tenum tick_nohz_mode\t\tnohz_mode;\n\tktime_t\t\t\t\tlast_tick;\n\tint\t\t\t\tinidle;\n\tint\t\t\t\ttick_stopped;\n\tunsigned long\t\t\tidle_jiffies;\n\tunsigned long\t\t\tidle_calls;\n\tunsigned long\t\t\tidle_sleeps;\n\tint\t\t\t\tidle_active;\n\tktime_t\t\t\t\tidle_entrytime;\n\tktime_t\t\t\t\tidle_waketime;\n\tktime_t\t\t\t\tidle_exittime;\n\tktime_t\t\t\t\tidle_sleeptime;\n\tktime_t\t\t\t\tiowait_sleeptime;\n\tktime_t\t\t\t\tsleep_length;\n\tunsigned long\t\t\tlast_jiffies;\n\tu64\t\t\t\tnext_timer;\n\tktime_t\t\t\t\tidle_expires;\n\tint\t\t\t\tdo_timer_last; /* CPU was the last one doing do_timer before going idle*/\n\tatomic_t\t\t\ttick_dep_mask;\n};\n```\n\n### 2.1. idle 时启动tickless\nkernel 总所周知有一个pid=1 的init 进程， 其实还有一个pid=0 的idle 进程。当CPU 进入此低优先级的idle 进程后，我们可以认定此时CPU 是处于idle 状态。 因此，在该进程中可以尝试停掉一段时间的tick。callstack 如下：\ncpu_idle_loop -> \ntick_nohz_idle_enter -> \n__tick_nohz_idle_enter -> \ntick_nohz_stop_sched_tick\n\n从`cpu_idle_loop()` 可以看出进入idle 进程 尝试开启tickless， 之后让CPU 进入低功耗`cpuidle_idle_call()`, 之后若有调度事件 则退出tickless, `tick_nohz_idle_exit()`\n```c\n/* kernel-4.9.198, remove some code */\nstatic void cpuidle_idle_call(void)\n{\n   /* default idle */\n   __asm__  volatile (\"wfi');\n}\n\nstatic void cpu_idle_loop(void)\n{\n\tint cpu = smp_processor_id();\n\n\twhile (1) {\n\t\ttick_nohz_idle_enter();\n\n\t\twhile (!need_resched()) {\n\t\t\tlocal_irq_disable();\n\t\t\tarch_cpu_idle_enter();\n\t\t\tcpuidle_idle_call();\n\t\t\tarch_cpu_idle_exit();\n\t\t}\n\t\ttick_nohz_idle_exit();\n\t}\n}\n```\n\n在`__tick_nohz_idle_enter()` 中设定idle_entrytime, idle_active 状态， 并且判断是否可以stop idle tick， 其依据为：\n- cpu online\n- no need re-schedule\n- no local softirq pending\n- disable nohz full, or do timer cpu is not current cpu\n\n```c\nstatic ktime_t tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tktime_t now = ktime_get();\n\tts->idle_entrytime = now;\n\tts->idle_active = 1;\n\treturn now;\n}\n\nstatic void __tick_nohz_idle_enter(struct tick_sched *ts)\n{\n\tktime_t now, expires;\n\tint cpu = smp_processor_id();\n\n\tnow = tick_nohz_start_idle(ts);\n\n\tif (can_stop_idle_tick(cpu, ts)) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\tts->idle_calls++;\n\n\t\texpires = tick_nohz_stop_sched_tick(ts, now, cpu);\n\t\tif (expires.tv64 > 0LL) {\n\t\t\tts->idle_sleeps++;\n\t\t\tts->idle_expires = expires;\n\t\t}\n\n\t\tif (!was_stopped && ts->tick_stopped)\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t}\n}\n```\ntickless 核心关键函数落在`tick_nohz_stop_sched_tick()`，其基本流程是是否能进入tickless。若可以，则计算出合适的ticks 并调用`h`rtimer_start()` 或`tick_program_event()`对timer 重新编程。在后面小节**tickless 停掉tick 数确定** 会较详细分析该函数。\n\n### 2.2. irq_exit 时尝试启动tickless\n当有one shot timer中断到来时，我们在 tick_nohz_handler() intr servive 中设定下一次tick唤醒，这样在没有其他中断，进程执行时，也要被唤醒，这样我们的timer 又变成了周期timer。最好的应该是kernel 进行检查是否需要继续进行tickless 操作，因此在irq_exit 中有如下操作：\nirq_exit -> \ntick_irq_exit -> \ntick_nohz_irq_exit->\ntick_nohz_stop_sched_tick\n\n补充：\nirq 在arm 处理流程大致为：\n```c\nvoid handle_IRQ(unsigned int irq, struct pt_regs *regs)\n{\n\t__handle_domain_irq(NULL, irq, false, regs);\n}\n\nint __handle_domain_irq(struct irq_domain *domain, unsigned int hwirq,\n\t\t\tbool lookup, struct pt_regs *regs)\n{\n\tirq_enter();\n    ...\n    /* call irq intr func */\n\tgeneric_handle_irq(irq);\n\t\n\tirq_exit();\n}\n```\nirq_enter(), irq_exit() 就会去做我们的软中断，generic_handle_irq() 实作HW 中断。\n\n## 3. tickless 停掉tick 数确定\ntickless 能停掉的ticks 怎样确认了？ \n\n在只有idle 进程运行时，cpu 需要处理的还有不定的HW 中断等，但是发生时间不能预测。<font color=red>但是第一个即将到期的中断时间是可以知道的，在这个时间到期之前都可以停掉 tick，由此得到需要停掉的tick 数</font>。\n\n另外，停掉 tick 的时间不能超过 clock_event_device 的 max_delta_ns，不然可能会造成 clocksource 的溢出。\n如果停掉的ticks 是在下一个tick_period 则不用stop tick。\n\n```c\nstatic ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,\n\t\t\t\t\t ktime_t now, int cpu)\n{\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\ttick.tv64 = 0;\n\t\ttimer_clear_idle();\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last. If this CPU\n\t * is the one which had the do_timer() duty last, we limit the\n\t * sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tdelta = KTIME_MAX;\n\t\tts->do_timer_last = 0;\n\t} else if (!ts->do_timer_last) {\n\t\tdelta = KTIME_MAX;\n\t}\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\texpires = min_t(u64, expires, next_tick);\n\ttick.tv64 = expires;\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tnohz_balance_enter_idle(cpu);\n\t\tcalc_load_enter_idle();\n\t\tcpu_load_update_nohz_start();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\thrtimer_start(&ts->sched_timer, tick, HRTIMER_MODE_ABS_PINNED);\n\telse\n\t\ttick_program_event(tick, 1);\nout:\n\t/* Update the estimated sleep length */\n\tts->sleep_length = ktime_sub(dev->next_event, now);\n\treturn tick;\n}\n```\n\n## 4. tickless 何时停止？\n在cpu_idle_loop 循环中判断有新的进程被唤醒时退出tickless 模式，可参见前面`cpu_idle_loop()`函数，恢复到tick_period。\ntick_nohz_idle_exit->\ntick_nohz_restart \n\n在函数中，会判断高低分辨 timer，若是high resolution timer 则设定one shot 下一次中断来的expires, 反之低分辨率timer 则使用`tick_program_event()` 重新设定clockevent 。\n```c\nstatic void tick_nohz_restart(struct tick_sched *ts, ktime_t now)\n{\n\thrtimer_cancel(&ts->sched_timer);\n\thrtimer_set_expires(&ts->sched_timer, ts->last_tick);\n\n\t/* Forward the time to expire in the future */\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED);\n\telse\n\t\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n}\n```\n\n## 5. tickless 对中断的影响\n由于动态时钟出现，jiffies 是滞后的，其一般是在恢复周期时钟时更新。如果进入中断时需要访问jiffies，那么数据是不准确的。因此，进入中断irq_enter, tick_check_idle() 被调用，以此来更新jiffies值。\n\n```c\nstatic void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event(0);\n}\n\nvoid tick_irq_enter(void)\n{\n\ttick_check_oneshot_broadcast_this_cpu();\n\ttick_nohz_irq_enter();\n}\n\nvoid irq_enter(void)\n{\n\trcu_irq_enter();\n\tif (is_idle_task(current) && !in_interrupt()) {\n\t\t/*\n\t\t * Prevent raise_softirq from needlessly waking up ksoftirqd\n\t\t * here, as softirq will be serviced on return from interrupt.\n\t\t */\n\t\tlocal_bh_disable();\n\t\ttick_irq_enter();\n\t\t_local_bh_enable();\n\t}\n\t__irq_enter();\n}\n```\n\n## Reference \n[Linux Tick 和 Tickless](http://kernel.meizu.com/linux-tick-and-tickless.html)\n\n[Linux时间子系统之八：动态时钟框架（CONFIG_NO_HZ、tickless）](https://blog.csdn.net/DroidPhone/article/details/8112948)\n\n[linux动态时钟探索](http://blog.chinaunix.net/uid-25942458-id-3412358.html)\n\n[动静结合学内核：linux idle进程和init进程浅析](https://www.cnblogs.com/mfrbuaa/p/5152800.html)\n\n[Linux时间子系统之（十三）：Tick Device layer综述](http://www.wowotech.net/timer_subsystem/tick-device-layer.html)\n\n[NO_HZ: 减少调度时钟的滴答](https://blog.csdn.net/zhoudawei/article/details/86427101)\n[kernel/Documentation/timers/NO_HZ.txt](https://lwn.net/Articles/549593/)","source":"_posts/kernel-tickless-idle.md","raw":"---\ntitle: kernel_tickless_idle\ndate: 2020-04-15 11:15:18\ntags:\n    - timer\ncategories:\n    - drivers\n---\n\n在嵌入式设备中对于高功耗都避之若浼。IOT 物联网，手机等更是看中设备的电池使用时间。省电节约功耗基本从考虑降低频率（手机CPU 的大小核），关闭暂未使用模块，睡眠等方向考虑。 在kernel 中就有tickless timer，通过在OS IDLE 时减少scheduling-clock ticks，节省功耗。下面主要分析kernel-4.9.198 Idle dynticks system(tickless idle)。\n\n<!--more-->\n## 1. Base\nkernel Timer system 中常见有如下方法管理：\n- 周期时钟 (schedule-clock interrupts, CONFIG_HZ_PERIODIC=y)  \n- idle 时忽略timer tick (tickless idle， CONFIG_NO_HZ_IDLE=y or CONFIG_NO_HZ=y, kernel default choose)\n- idle 时或者只有一个task run 时不需要调度，忽略CPU 的调度时钟滴答(CONFIG_NO_HZ_FULL=y)\n\n在kernel/time/Kconfig 可以看见其配置信息。\n```kconfig\nconfig NO_HZ_IDLE\n        bool \"Idle dynticks system (tickless idle)\"\n        select NO_HZ_COMMON\n        help\n          This option enables a tickless idle system: timer interrupts\n          will only trigger on an as-needed basis when the system is idle.\n          This is usually interesting for energy saving.\n\n          Most of the time you want to say Y here.\n\nconfig NO_HZ_FULL\n        bool \"Full dynticks system (tickless)\"\n        # We need at least one periodic CPU for timekeeping\n        select NO_HZ_COMMON\n        select RCU_NOCB_CPU\n        select VIRT_CPU_ACCOUNTING_GEN\n        select IRQ_WORK\n        help\n         Adaptively try to shutdown the tick whenever possible, even when\n         the CPU is running tasks. Typically this requires running a single\n         task on the CPU. Chances for running tickless are maximized when\n         the task mostly runs in userspace and has few kernel activity.\n```\n\n![config_tickless](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/tickless_idle/config_tickless_idle.png)\n\n![config_tickless_help](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/tickless_idle/config_tickless_idle_help.png)\n\nTick，即周期性产生的 timer 中断事件，可用于系统时间管理、进程信息统计、低精度 timer 处理等等。\n`低分辨率定时器`\n低分辨率定时器是<font color=red>基于 HZ 来实现</font>的，精度为 1/HZ。对定时器精度要求不高的内核模块还在大量使用低分辨率定时器，例如 CPU DVFS，CPU Hotplug 等。内核通过 time_list 结构体来描述低分辨率定时器。\n\n`高精度定时器`\n高精度定时器可以提供<font color=red>纳秒级别的定时精度</font>，以满足对时间精度要求严格的内核模块，例如音频模块，内核通过 hrtimer 结构体来描述高精度定时器。在系统启动的开始阶段，高精度定时器只能工作在低精度周期模式，在条件满足之后的某个阶段就会切换到高精度单触发模式。在系统切换为高精度timer 后，通过one_shot 模拟周期timer，为系统提供周期tick。\n\n`tickless`\n动态时钟，并不是真正没有tick， 只是在idle 时停掉tick 一段时间。\n\n## 2. tickless 何时启动？\n\n通过搜索tickless 关键函数`tick_nohz_stop_sched_tick()` 的调用， tickless 启动主要有两个时机点：\n- cpu idle 时\n- irq exit 时，尝试继续tickless\n\n```c\n/* sched tick emulation and no idle tick control/stats*/\nstruct tick_sched {\n\tstruct hrtimer\t\t\tsched_timer;\n\tunsigned long\t\t\tcheck_clocks;\n\tenum tick_nohz_mode\t\tnohz_mode;\n\tktime_t\t\t\t\tlast_tick;\n\tint\t\t\t\tinidle;\n\tint\t\t\t\ttick_stopped;\n\tunsigned long\t\t\tidle_jiffies;\n\tunsigned long\t\t\tidle_calls;\n\tunsigned long\t\t\tidle_sleeps;\n\tint\t\t\t\tidle_active;\n\tktime_t\t\t\t\tidle_entrytime;\n\tktime_t\t\t\t\tidle_waketime;\n\tktime_t\t\t\t\tidle_exittime;\n\tktime_t\t\t\t\tidle_sleeptime;\n\tktime_t\t\t\t\tiowait_sleeptime;\n\tktime_t\t\t\t\tsleep_length;\n\tunsigned long\t\t\tlast_jiffies;\n\tu64\t\t\t\tnext_timer;\n\tktime_t\t\t\t\tidle_expires;\n\tint\t\t\t\tdo_timer_last; /* CPU was the last one doing do_timer before going idle*/\n\tatomic_t\t\t\ttick_dep_mask;\n};\n```\n\n### 2.1. idle 时启动tickless\nkernel 总所周知有一个pid=1 的init 进程， 其实还有一个pid=0 的idle 进程。当CPU 进入此低优先级的idle 进程后，我们可以认定此时CPU 是处于idle 状态。 因此，在该进程中可以尝试停掉一段时间的tick。callstack 如下：\ncpu_idle_loop -> \ntick_nohz_idle_enter -> \n__tick_nohz_idle_enter -> \ntick_nohz_stop_sched_tick\n\n从`cpu_idle_loop()` 可以看出进入idle 进程 尝试开启tickless， 之后让CPU 进入低功耗`cpuidle_idle_call()`, 之后若有调度事件 则退出tickless, `tick_nohz_idle_exit()`\n```c\n/* kernel-4.9.198, remove some code */\nstatic void cpuidle_idle_call(void)\n{\n   /* default idle */\n   __asm__  volatile (\"wfi');\n}\n\nstatic void cpu_idle_loop(void)\n{\n\tint cpu = smp_processor_id();\n\n\twhile (1) {\n\t\ttick_nohz_idle_enter();\n\n\t\twhile (!need_resched()) {\n\t\t\tlocal_irq_disable();\n\t\t\tarch_cpu_idle_enter();\n\t\t\tcpuidle_idle_call();\n\t\t\tarch_cpu_idle_exit();\n\t\t}\n\t\ttick_nohz_idle_exit();\n\t}\n}\n```\n\n在`__tick_nohz_idle_enter()` 中设定idle_entrytime, idle_active 状态， 并且判断是否可以stop idle tick， 其依据为：\n- cpu online\n- no need re-schedule\n- no local softirq pending\n- disable nohz full, or do timer cpu is not current cpu\n\n```c\nstatic ktime_t tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tktime_t now = ktime_get();\n\tts->idle_entrytime = now;\n\tts->idle_active = 1;\n\treturn now;\n}\n\nstatic void __tick_nohz_idle_enter(struct tick_sched *ts)\n{\n\tktime_t now, expires;\n\tint cpu = smp_processor_id();\n\n\tnow = tick_nohz_start_idle(ts);\n\n\tif (can_stop_idle_tick(cpu, ts)) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\tts->idle_calls++;\n\n\t\texpires = tick_nohz_stop_sched_tick(ts, now, cpu);\n\t\tif (expires.tv64 > 0LL) {\n\t\t\tts->idle_sleeps++;\n\t\t\tts->idle_expires = expires;\n\t\t}\n\n\t\tif (!was_stopped && ts->tick_stopped)\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t}\n}\n```\ntickless 核心关键函数落在`tick_nohz_stop_sched_tick()`，其基本流程是是否能进入tickless。若可以，则计算出合适的ticks 并调用`h`rtimer_start()` 或`tick_program_event()`对timer 重新编程。在后面小节**tickless 停掉tick 数确定** 会较详细分析该函数。\n\n### 2.2. irq_exit 时尝试启动tickless\n当有one shot timer中断到来时，我们在 tick_nohz_handler() intr servive 中设定下一次tick唤醒，这样在没有其他中断，进程执行时，也要被唤醒，这样我们的timer 又变成了周期timer。最好的应该是kernel 进行检查是否需要继续进行tickless 操作，因此在irq_exit 中有如下操作：\nirq_exit -> \ntick_irq_exit -> \ntick_nohz_irq_exit->\ntick_nohz_stop_sched_tick\n\n补充：\nirq 在arm 处理流程大致为：\n```c\nvoid handle_IRQ(unsigned int irq, struct pt_regs *regs)\n{\n\t__handle_domain_irq(NULL, irq, false, regs);\n}\n\nint __handle_domain_irq(struct irq_domain *domain, unsigned int hwirq,\n\t\t\tbool lookup, struct pt_regs *regs)\n{\n\tirq_enter();\n    ...\n    /* call irq intr func */\n\tgeneric_handle_irq(irq);\n\t\n\tirq_exit();\n}\n```\nirq_enter(), irq_exit() 就会去做我们的软中断，generic_handle_irq() 实作HW 中断。\n\n## 3. tickless 停掉tick 数确定\ntickless 能停掉的ticks 怎样确认了？ \n\n在只有idle 进程运行时，cpu 需要处理的还有不定的HW 中断等，但是发生时间不能预测。<font color=red>但是第一个即将到期的中断时间是可以知道的，在这个时间到期之前都可以停掉 tick，由此得到需要停掉的tick 数</font>。\n\n另外，停掉 tick 的时间不能超过 clock_event_device 的 max_delta_ns，不然可能会造成 clocksource 的溢出。\n如果停掉的ticks 是在下一个tick_period 则不用stop tick。\n\n```c\nstatic ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,\n\t\t\t\t\t ktime_t now, int cpu)\n{\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\ttick.tv64 = 0;\n\t\ttimer_clear_idle();\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last. If this CPU\n\t * is the one which had the do_timer() duty last, we limit the\n\t * sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tdelta = KTIME_MAX;\n\t\tts->do_timer_last = 0;\n\t} else if (!ts->do_timer_last) {\n\t\tdelta = KTIME_MAX;\n\t}\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\texpires = min_t(u64, expires, next_tick);\n\ttick.tv64 = expires;\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tnohz_balance_enter_idle(cpu);\n\t\tcalc_load_enter_idle();\n\t\tcpu_load_update_nohz_start();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\thrtimer_start(&ts->sched_timer, tick, HRTIMER_MODE_ABS_PINNED);\n\telse\n\t\ttick_program_event(tick, 1);\nout:\n\t/* Update the estimated sleep length */\n\tts->sleep_length = ktime_sub(dev->next_event, now);\n\treturn tick;\n}\n```\n\n## 4. tickless 何时停止？\n在cpu_idle_loop 循环中判断有新的进程被唤醒时退出tickless 模式，可参见前面`cpu_idle_loop()`函数，恢复到tick_period。\ntick_nohz_idle_exit->\ntick_nohz_restart \n\n在函数中，会判断高低分辨 timer，若是high resolution timer 则设定one shot 下一次中断来的expires, 反之低分辨率timer 则使用`tick_program_event()` 重新设定clockevent 。\n```c\nstatic void tick_nohz_restart(struct tick_sched *ts, ktime_t now)\n{\n\thrtimer_cancel(&ts->sched_timer);\n\thrtimer_set_expires(&ts->sched_timer, ts->last_tick);\n\n\t/* Forward the time to expire in the future */\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED);\n\telse\n\t\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n}\n```\n\n## 5. tickless 对中断的影响\n由于动态时钟出现，jiffies 是滞后的，其一般是在恢复周期时钟时更新。如果进入中断时需要访问jiffies，那么数据是不准确的。因此，进入中断irq_enter, tick_check_idle() 被调用，以此来更新jiffies值。\n\n```c\nstatic void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event(0);\n}\n\nvoid tick_irq_enter(void)\n{\n\ttick_check_oneshot_broadcast_this_cpu();\n\ttick_nohz_irq_enter();\n}\n\nvoid irq_enter(void)\n{\n\trcu_irq_enter();\n\tif (is_idle_task(current) && !in_interrupt()) {\n\t\t/*\n\t\t * Prevent raise_softirq from needlessly waking up ksoftirqd\n\t\t * here, as softirq will be serviced on return from interrupt.\n\t\t */\n\t\tlocal_bh_disable();\n\t\ttick_irq_enter();\n\t\t_local_bh_enable();\n\t}\n\t__irq_enter();\n}\n```\n\n## Reference \n[Linux Tick 和 Tickless](http://kernel.meizu.com/linux-tick-and-tickless.html)\n\n[Linux时间子系统之八：动态时钟框架（CONFIG_NO_HZ、tickless）](https://blog.csdn.net/DroidPhone/article/details/8112948)\n\n[linux动态时钟探索](http://blog.chinaunix.net/uid-25942458-id-3412358.html)\n\n[动静结合学内核：linux idle进程和init进程浅析](https://www.cnblogs.com/mfrbuaa/p/5152800.html)\n\n[Linux时间子系统之（十三）：Tick Device layer综述](http://www.wowotech.net/timer_subsystem/tick-device-layer.html)\n\n[NO_HZ: 减少调度时钟的滴答](https://blog.csdn.net/zhoudawei/article/details/86427101)\n[kernel/Documentation/timers/NO_HZ.txt](https://lwn.net/Articles/549593/)","slug":"kernel-tickless-idle","published":1,"updated":"2020-04-15T09:51:27.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qe002mzkgr6ohvnje1","content":"<p>在嵌入式设备中对于高功耗都避之若浼。IOT 物联网，手机等更是看中设备的电池使用时间。省电节约功耗基本从考虑降低频率（手机CPU 的大小核），关闭暂未使用模块，睡眠等方向考虑。 在kernel 中就有tickless timer，通过在OS IDLE 时减少scheduling-clock ticks，节省功耗。下面主要分析kernel-4.9.198 Idle dynticks system(tickless idle)。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-Base\"><a href=\"#1-Base\" class=\"headerlink\" title=\"1. Base\"></a>1. Base</h2><p>kernel Timer system 中常见有如下方法管理：</p>\n<ul>\n<li>周期时钟 (schedule-clock interrupts, CONFIG_HZ_PERIODIC=y)  </li>\n<li>idle 时忽略timer tick (tickless idle， CONFIG_NO_HZ_IDLE=y or CONFIG_NO_HZ=y, kernel default choose)</li>\n<li>idle 时或者只有一个task run 时不需要调度，忽略CPU 的调度时钟滴答(CONFIG_NO_HZ_FULL=y)</li>\n</ul>\n<p>在kernel/time/Kconfig 可以看见其配置信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config NO_HZ_IDLE</span><br><span class=\"line\">        bool &quot;Idle dynticks system (tickless idle)&quot;</span><br><span class=\"line\">        select NO_HZ_COMMON</span><br><span class=\"line\">        help</span><br><span class=\"line\">          This option enables a tickless idle system: timer interrupts</span><br><span class=\"line\">          will only trigger on an as-needed basis when the system is idle.</span><br><span class=\"line\">          This is usually interesting for energy saving.</span><br><span class=\"line\"></span><br><span class=\"line\">          Most of the time you want to say Y here.</span><br><span class=\"line\"></span><br><span class=\"line\">config NO_HZ_FULL</span><br><span class=\"line\">        bool &quot;Full dynticks system (tickless)&quot;</span><br><span class=\"line\">        # We need at least one periodic CPU for timekeeping</span><br><span class=\"line\">        select NO_HZ_COMMON</span><br><span class=\"line\">        select RCU_NOCB_CPU</span><br><span class=\"line\">        select VIRT_CPU_ACCOUNTING_GEN</span><br><span class=\"line\">        select IRQ_WORK</span><br><span class=\"line\">        help</span><br><span class=\"line\">         Adaptively try to shutdown the tick whenever possible, even when</span><br><span class=\"line\">         the CPU is running tasks. Typically this requires running a single</span><br><span class=\"line\">         task on the CPU. Chances for running tickless are maximized when</span><br><span class=\"line\">         the task mostly runs in userspace and has few kernel activity.</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/tickless_idle/config_tickless_idle.png\" alt=\"config_tickless\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/tickless_idle/config_tickless_idle_help.png\" alt=\"config_tickless_help\"></p>\n<p>Tick，即周期性产生的 timer 中断事件，可用于系统时间管理、进程信息统计、低精度 timer 处理等等。<br><code>低分辨率定时器</code><br>低分辨率定时器是<font color=\"red\">基于 HZ 来实现</font>的，精度为 1/HZ。对定时器精度要求不高的内核模块还在大量使用低分辨率定时器，例如 CPU DVFS，CPU Hotplug 等。内核通过 time_list 结构体来描述低分辨率定时器。</p>\n<p><code>高精度定时器</code><br>高精度定时器可以提供<font color=\"red\">纳秒级别的定时精度</font>，以满足对时间精度要求严格的内核模块，例如音频模块，内核通过 hrtimer 结构体来描述高精度定时器。在系统启动的开始阶段，高精度定时器只能工作在低精度周期模式，在条件满足之后的某个阶段就会切换到高精度单触发模式。在系统切换为高精度timer 后，通过one_shot 模拟周期timer，为系统提供周期tick。</p>\n<p><code>tickless</code><br>动态时钟，并不是真正没有tick， 只是在idle 时停掉tick 一段时间。</p>\n<h2 id=\"2-tickless-何时启动？\"><a href=\"#2-tickless-何时启动？\" class=\"headerlink\" title=\"2. tickless 何时启动？\"></a>2. tickless 何时启动？</h2><p>通过搜索tickless 关键函数<code>tick_nohz_stop_sched_tick()</code> 的调用， tickless 启动主要有两个时机点：</p>\n<ul>\n<li>cpu idle 时</li>\n<li>irq exit 时，尝试继续tickless</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* sched tick emulation and no idle tick control/stats*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tick_sched</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hrtimer</span>\t\t\t<span class=\"title\">sched_timer</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tcheck_clocks;</span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> tick_nohz_mode\t\tnohz_mode;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tlast_tick;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t\tinidle;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t\ttick_stopped;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tidle_jiffies;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tidle_calls;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tidle_sleeps;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t\tidle_active;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_entrytime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_waketime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_exittime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_sleeptime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tiowait_sleeptime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tsleep_length;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tlast_jiffies;</span><br><span class=\"line\">\tu64\t\t\t\tnext_timer;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_expires;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t\tdo_timer_last; <span class=\"comment\">/* CPU was the last one doing do_timer before going idle*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">atomic_t</span>\t\t\ttick_dep_mask;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-idle-时启动tickless\"><a href=\"#2-1-idle-时启动tickless\" class=\"headerlink\" title=\"2.1. idle 时启动tickless\"></a>2.1. idle 时启动tickless</h3><p>kernel 总所周知有一个pid=1 的init 进程， 其实还有一个pid=0 的idle 进程。当CPU 进入此低优先级的idle 进程后，我们可以认定此时CPU 是处于idle 状态。 因此，在该进程中可以尝试停掉一段时间的tick。callstack 如下：<br>cpu_idle_loop -&gt;<br>tick_nohz_idle_enter -&gt;<br>__tick_nohz_idle_enter -&gt;<br>tick_nohz_stop_sched_tick</p>\n<p>从<code>cpu_idle_loop()</code> 可以看出进入idle 进程 尝试开启tickless， 之后让CPU 进入低功耗<code>cpuidle_idle_call()</code>, 之后若有调度事件 则退出tickless, <code>tick_nohz_idle_exit()</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* kernel-4.9.198, remove some code */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">cpuidle_idle_call</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* default idle */</span></span><br><span class=\"line\">   __<span class=\"function\">asm__  <span class=\"title\">volatile</span> <span class=\"params\">(<span class=\"string\">\"wfi');</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">static void cpu_idle_loop(void)</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">&#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\tint cpu = smp_processor_id();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\twhile (1) &#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\ttick_nohz_idle_enter();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\twhile (!need_resched()) &#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tlocal_irq_disable();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tarch_cpu_idle_enter();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tcpuidle_idle_call();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tarch_cpu_idle_exit();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\ttick_nohz_idle_exit();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure></p>\n<p>在<code>__tick_nohz_idle_enter()</code> 中设定idle_entrytime, idle_active 状态， 并且判断是否可以stop idle tick， 其依据为：</p>\n<ul>\n<li>cpu online</li>\n<li>no need re-schedule</li>\n<li>no local softirq pending</li>\n<li>disable nohz full, or do timer cpu is not current cpu</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ktime_t <span class=\"title\">tick_nohz_start_idle</span><span class=\"params\">(struct tick_sched *ts)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span> now = ktime_get();</span><br><span class=\"line\">\tts-&gt;idle_entrytime = now;</span><br><span class=\"line\">\tts-&gt;idle_active = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __tick_nohz_idle_enter(struct tick_sched *ts)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span> now, expires;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cpu = smp_processor_id();</span><br><span class=\"line\"></span><br><span class=\"line\">\tnow = tick_nohz_start_idle(ts);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (can_stop_idle_tick(cpu, ts)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> was_stopped = ts-&gt;tick_stopped;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tts-&gt;idle_calls++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\texpires = tick_nohz_stop_sched_tick(ts, now, cpu);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (expires.tv64 &gt; <span class=\"number\">0L</span>L) &#123;</span><br><span class=\"line\">\t\t\tts-&gt;idle_sleeps++;</span><br><span class=\"line\">\t\t\tts-&gt;idle_expires = expires;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!was_stopped &amp;&amp; ts-&gt;tick_stopped)</span><br><span class=\"line\">\t\t\tts-&gt;idle_jiffies = ts-&gt;last_jiffies;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>tickless 核心关键函数落在<code>tick_nohz_stop_sched_tick()</code>，其基本流程是是否能进入tickless。若可以，则计算出合适的ticks 并调用<code>h</code>rtimer_start()<code>或</code>tick_program_event()`对timer 重新编程。在后面小节<strong>tickless 停掉tick 数确定</strong> 会较详细分析该函数。</p>\n<h3 id=\"2-2-irq-exit-时尝试启动tickless\"><a href=\"#2-2-irq-exit-时尝试启动tickless\" class=\"headerlink\" title=\"2.2. irq_exit 时尝试启动tickless\"></a>2.2. irq_exit 时尝试启动tickless</h3><p>当有one shot timer中断到来时，我们在 tick_nohz_handler() intr servive 中设定下一次tick唤醒，这样在没有其他中断，进程执行时，也要被唤醒，这样我们的timer 又变成了周期timer。最好的应该是kernel 进行检查是否需要继续进行tickless 操作，因此在irq_exit 中有如下操作：<br>irq_exit -&gt;<br>tick_irq_exit -&gt;<br>tick_nohz_irq_exit-&gt;<br>tick_nohz_stop_sched_tick</p>\n<p>补充：<br>irq 在arm 处理流程大致为：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handle_IRQ</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq, struct pt_regs *regs)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t__handle_domain_irq(<span class=\"literal\">NULL</span>, irq, <span class=\"literal\">false</span>, regs);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> __handle_domain_irq(struct irq_domain *domain, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hwirq,</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">bool</span> lookup, struct pt_regs *regs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tirq_enter();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/* call irq intr func */</span></span><br><span class=\"line\">\tgeneric_handle_irq(irq);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tirq_exit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>irq_enter(), irq_exit() 就会去做我们的软中断，generic_handle_irq() 实作HW 中断。</p>\n<h2 id=\"3-tickless-停掉tick-数确定\"><a href=\"#3-tickless-停掉tick-数确定\" class=\"headerlink\" title=\"3. tickless 停掉tick 数确定\"></a>3. tickless 停掉tick 数确定</h2><p>tickless 能停掉的ticks 怎样确认了？ </p>\n<p>在只有idle 进程运行时，cpu 需要处理的还有不定的HW 中断等，但是发生时间不能预测。<font color=\"red\">但是第一个即将到期的中断时间是可以知道的，在这个时间到期之前都可以停掉 tick，由此得到需要停掉的tick 数</font>。</p>\n<p>另外，停掉 tick 的时间不能超过 clock_event_device 的 max_delta_ns，不然可能会造成 clocksource 的溢出。<br>如果停掉的ticks 是在下一个tick_period 则不用stop tick。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ktime_t <span class=\"title\">tick_nohz_stop_sched_tick</span><span class=\"params\">(struct tick_sched *ts,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t <span class=\"keyword\">ktime_t</span> now, <span class=\"keyword\">int</span> cpu)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Keep the periodic tick, when RCU, architecture or irq_work</span></span><br><span class=\"line\"><span class=\"comment\">\t * requests it.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Aside of that check whether the local timer softirq is</span></span><br><span class=\"line\"><span class=\"comment\">\t * pending. If so its a bad idea to call get_next_timer_interrupt()</span></span><br><span class=\"line\"><span class=\"comment\">\t * because there is an already expired timer, so it will request</span></span><br><span class=\"line\"><span class=\"comment\">\t * immeditate expiry, which rearms the hardware timer with a</span></span><br><span class=\"line\"><span class=\"comment\">\t * minimal delta which brings us back to this place</span></span><br><span class=\"line\"><span class=\"comment\">\t * immediately. Lather, rinse and repeat...</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (rcu_needs_cpu(basemono, &amp;next_rcu) || arch_needs_cpu() ||</span><br><span class=\"line\">\t    irq_work_needs_cpu() || local_timer_softirq_pending()) &#123;</span><br><span class=\"line\">\t\tnext_tick = basemono + TICK_NSEC;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);</span><br><span class=\"line\">\t\tts-&gt;next_timer = next_tmr;</span><br><span class=\"line\">\t\tnext_tick = next_rcu &lt; next_tmr ? next_rcu : next_tmr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * If the tick is due in the next period, keep it ticking or</span></span><br><span class=\"line\"><span class=\"comment\">\t * force prod the timer.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tdelta = next_tick - basemono;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (delta &lt;= (u64)TICK_NSEC) &#123;</span><br><span class=\"line\">\t\ttick.tv64 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttimer_clear_idle();</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * If this CPU is the one which updates jiffies, then give up</span></span><br><span class=\"line\"><span class=\"comment\">\t * the assignment and let it be taken by the CPU which runs</span></span><br><span class=\"line\"><span class=\"comment\">\t * the tick timer next, which might be this CPU as well. If we</span></span><br><span class=\"line\"><span class=\"comment\">\t * don't drop this here the jiffies might be stale and</span></span><br><span class=\"line\"><span class=\"comment\">\t * do_timer() never invoked. Keep track of the fact that it</span></span><br><span class=\"line\"><span class=\"comment\">\t * was the one which had the do_timer() duty last. If this CPU</span></span><br><span class=\"line\"><span class=\"comment\">\t * is the one which had the do_timer() duty last, we limit the</span></span><br><span class=\"line\"><span class=\"comment\">\t * sleep time to the timekeeping max_deferment value.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Otherwise we can sleep as long as we want.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tdelta = timekeeping_max_deferment();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cpu == tick_do_timer_cpu) &#123;</span><br><span class=\"line\">\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;</span><br><span class=\"line\">\t\tts-&gt;do_timer_last = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tick_do_timer_cpu != TICK_DO_TIMER_NONE) &#123;</span><br><span class=\"line\">\t\tdelta = KTIME_MAX;</span><br><span class=\"line\">\t\tts-&gt;do_timer_last = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!ts-&gt;do_timer_last) &#123;</span><br><span class=\"line\">\t\tdelta = KTIME_MAX;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Calculate the next expiry time */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (delta &lt; (KTIME_MAX - basemono))</span><br><span class=\"line\">\t\texpires = basemono + delta;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\texpires = KTIME_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">\texpires = <span class=\"keyword\">min_t</span>(u64, expires, next_tick);</span><br><span class=\"line\">\ttick.tv64 = expires;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * nohz_stop_sched_tick can be called several times before</span></span><br><span class=\"line\"><span class=\"comment\">\t * the nohz_restart_sched_tick is called. This happens when</span></span><br><span class=\"line\"><span class=\"comment\">\t * interrupts arrive which do not cause a reschedule. In the</span></span><br><span class=\"line\"><span class=\"comment\">\t * first call we save the current tick time, so we can restart</span></span><br><span class=\"line\"><span class=\"comment\">\t * the scheduler tick in nohz_restart_sched_tick.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ts-&gt;tick_stopped) &#123;</span><br><span class=\"line\">\t\tnohz_balance_enter_idle(cpu);</span><br><span class=\"line\">\t\tcalc_load_enter_idle();</span><br><span class=\"line\">\t\tcpu_load_update_nohz_start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tts-&gt;last_tick = hrtimer_get_expires(&amp;ts-&gt;sched_timer);</span><br><span class=\"line\">\t\tts-&gt;tick_stopped = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ttrace_tick_stop(<span class=\"number\">1</span>, TICK_DEP_MASK_NONE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ts-&gt;nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class=\"line\">\t\thrtimer_start(&amp;ts-&gt;sched_timer, tick, HRTIMER_MODE_ABS_PINNED);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\ttick_program_event(tick, <span class=\"number\">1</span>);</span><br><span class=\"line\">out:</span><br><span class=\"line\">\t<span class=\"comment\">/* Update the estimated sleep length */</span></span><br><span class=\"line\">\tts-&gt;sleep_length = ktime_sub(dev-&gt;next_event, now);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> tick;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-tickless-何时停止？\"><a href=\"#4-tickless-何时停止？\" class=\"headerlink\" title=\"4. tickless 何时停止？\"></a>4. tickless 何时停止？</h2><p>在cpu_idle_loop 循环中判断有新的进程被唤醒时退出tickless 模式，可参见前面<code>cpu_idle_loop()</code>函数，恢复到tick_period。<br>tick_nohz_idle_exit-&gt;<br>tick_nohz_restart </p>\n<p>在函数中，会判断高低分辨 timer，若是high resolution timer 则设定one shot 下一次中断来的expires, 反之低分辨率timer 则使用<code>tick_program_event()</code> 重新设定clockevent 。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick_nohz_restart</span><span class=\"params\">(struct tick_sched *ts, <span class=\"keyword\">ktime_t</span> now)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\thrtimer_cancel(&amp;ts-&gt;sched_timer);</span><br><span class=\"line\">\thrtimer_set_expires(&amp;ts-&gt;sched_timer, ts-&gt;last_tick);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Forward the time to expire in the future */</span></span><br><span class=\"line\">\thrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ts-&gt;nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class=\"line\">\t\thrtimer_start_expires(&amp;ts-&gt;sched_timer, HRTIMER_MODE_ABS_PINNED);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\ttick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-tickless-对中断的影响\"><a href=\"#5-tickless-对中断的影响\" class=\"headerlink\" title=\"5. tickless 对中断的影响\"></a>5. tickless 对中断的影响</h2><p>由于动态时钟出现，jiffies 是滞后的，其一般是在恢复周期时钟时更新。如果进入中断时需要访问jiffies，那么数据是不准确的。因此，进入中断irq_enter, tick_check_idle() 被调用，以此来更新jiffies值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick_nohz_stop_idle</span><span class=\"params\">(struct tick_sched *ts, <span class=\"keyword\">ktime_t</span> now)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tupdate_ts_time_stats(smp_processor_id(), ts, now, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\tts-&gt;idle_active = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsched_clock_idle_wakeup_event(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tick_irq_enter</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\ttick_check_oneshot_broadcast_this_cpu();</span><br><span class=\"line\">\ttick_nohz_irq_enter();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">irq_enter</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\trcu_irq_enter();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_idle_task(current) &amp;&amp; !in_interrupt()) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Prevent raise_softirq from needlessly waking up ksoftirqd</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * here, as softirq will be serviced on return from interrupt.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tlocal_bh_disable();</span><br><span class=\"line\">\t\ttick_irq_enter();</span><br><span class=\"line\">\t\t_local_bh_enable();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t__irq_enter();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://kernel.meizu.com/linux-tick-and-tickless.html\" target=\"_blank\" rel=\"noopener\">Linux Tick 和 Tickless</a></p>\n<p><a href=\"https://blog.csdn.net/DroidPhone/article/details/8112948\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之八：动态时钟框架（CONFIG_NO_HZ、tickless）</a></p>\n<p><a href=\"http://blog.chinaunix.net/uid-25942458-id-3412358.html\" target=\"_blank\" rel=\"noopener\">linux动态时钟探索</a></p>\n<p><a href=\"https://www.cnblogs.com/mfrbuaa/p/5152800.html\" target=\"_blank\" rel=\"noopener\">动静结合学内核：linux idle进程和init进程浅析</a></p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/tick-device-layer.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十三）：Tick Device layer综述</a></p>\n<p><a href=\"https://blog.csdn.net/zhoudawei/article/details/86427101\" target=\"_blank\" rel=\"noopener\">NO_HZ: 减少调度时钟的滴答</a><br><a href=\"https://lwn.net/Articles/549593/\" target=\"_blank\" rel=\"noopener\">kernel/Documentation/timers/NO_HZ.txt</a></p>\n","site":{"data":{}},"excerpt":"<p>在嵌入式设备中对于高功耗都避之若浼。IOT 物联网，手机等更是看中设备的电池使用时间。省电节约功耗基本从考虑降低频率（手机CPU 的大小核），关闭暂未使用模块，睡眠等方向考虑。 在kernel 中就有tickless timer，通过在OS IDLE 时减少scheduling-clock ticks，节省功耗。下面主要分析kernel-4.9.198 Idle dynticks system(tickless idle)。</p>","more":"<h2 id=\"1-Base\"><a href=\"#1-Base\" class=\"headerlink\" title=\"1. Base\"></a>1. Base</h2><p>kernel Timer system 中常见有如下方法管理：</p>\n<ul>\n<li>周期时钟 (schedule-clock interrupts, CONFIG_HZ_PERIODIC=y)  </li>\n<li>idle 时忽略timer tick (tickless idle， CONFIG_NO_HZ_IDLE=y or CONFIG_NO_HZ=y, kernel default choose)</li>\n<li>idle 时或者只有一个task run 时不需要调度，忽略CPU 的调度时钟滴答(CONFIG_NO_HZ_FULL=y)</li>\n</ul>\n<p>在kernel/time/Kconfig 可以看见其配置信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config NO_HZ_IDLE</span><br><span class=\"line\">        bool &quot;Idle dynticks system (tickless idle)&quot;</span><br><span class=\"line\">        select NO_HZ_COMMON</span><br><span class=\"line\">        help</span><br><span class=\"line\">          This option enables a tickless idle system: timer interrupts</span><br><span class=\"line\">          will only trigger on an as-needed basis when the system is idle.</span><br><span class=\"line\">          This is usually interesting for energy saving.</span><br><span class=\"line\"></span><br><span class=\"line\">          Most of the time you want to say Y here.</span><br><span class=\"line\"></span><br><span class=\"line\">config NO_HZ_FULL</span><br><span class=\"line\">        bool &quot;Full dynticks system (tickless)&quot;</span><br><span class=\"line\">        # We need at least one periodic CPU for timekeeping</span><br><span class=\"line\">        select NO_HZ_COMMON</span><br><span class=\"line\">        select RCU_NOCB_CPU</span><br><span class=\"line\">        select VIRT_CPU_ACCOUNTING_GEN</span><br><span class=\"line\">        select IRQ_WORK</span><br><span class=\"line\">        help</span><br><span class=\"line\">         Adaptively try to shutdown the tick whenever possible, even when</span><br><span class=\"line\">         the CPU is running tasks. Typically this requires running a single</span><br><span class=\"line\">         task on the CPU. Chances for running tickless are maximized when</span><br><span class=\"line\">         the task mostly runs in userspace and has few kernel activity.</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/tickless_idle/config_tickless_idle.png\" alt=\"config_tickless\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/tickless_idle/config_tickless_idle_help.png\" alt=\"config_tickless_help\"></p>\n<p>Tick，即周期性产生的 timer 中断事件，可用于系统时间管理、进程信息统计、低精度 timer 处理等等。<br><code>低分辨率定时器</code><br>低分辨率定时器是<font color=\"red\">基于 HZ 来实现</font>的，精度为 1/HZ。对定时器精度要求不高的内核模块还在大量使用低分辨率定时器，例如 CPU DVFS，CPU Hotplug 等。内核通过 time_list 结构体来描述低分辨率定时器。</p>\n<p><code>高精度定时器</code><br>高精度定时器可以提供<font color=\"red\">纳秒级别的定时精度</font>，以满足对时间精度要求严格的内核模块，例如音频模块，内核通过 hrtimer 结构体来描述高精度定时器。在系统启动的开始阶段，高精度定时器只能工作在低精度周期模式，在条件满足之后的某个阶段就会切换到高精度单触发模式。在系统切换为高精度timer 后，通过one_shot 模拟周期timer，为系统提供周期tick。</p>\n<p><code>tickless</code><br>动态时钟，并不是真正没有tick， 只是在idle 时停掉tick 一段时间。</p>\n<h2 id=\"2-tickless-何时启动？\"><a href=\"#2-tickless-何时启动？\" class=\"headerlink\" title=\"2. tickless 何时启动？\"></a>2. tickless 何时启动？</h2><p>通过搜索tickless 关键函数<code>tick_nohz_stop_sched_tick()</code> 的调用， tickless 启动主要有两个时机点：</p>\n<ul>\n<li>cpu idle 时</li>\n<li>irq exit 时，尝试继续tickless</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* sched tick emulation and no idle tick control/stats*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tick_sched</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hrtimer</span>\t\t\t<span class=\"title\">sched_timer</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tcheck_clocks;</span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> tick_nohz_mode\t\tnohz_mode;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tlast_tick;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t\tinidle;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t\ttick_stopped;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tidle_jiffies;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tidle_calls;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tidle_sleeps;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t\tidle_active;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_entrytime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_waketime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_exittime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_sleeptime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tiowait_sleeptime;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tsleep_length;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\t\tlast_jiffies;</span><br><span class=\"line\">\tu64\t\t\t\tnext_timer;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\t\tidle_expires;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t\tdo_timer_last; <span class=\"comment\">/* CPU was the last one doing do_timer before going idle*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">atomic_t</span>\t\t\ttick_dep_mask;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-idle-时启动tickless\"><a href=\"#2-1-idle-时启动tickless\" class=\"headerlink\" title=\"2.1. idle 时启动tickless\"></a>2.1. idle 时启动tickless</h3><p>kernel 总所周知有一个pid=1 的init 进程， 其实还有一个pid=0 的idle 进程。当CPU 进入此低优先级的idle 进程后，我们可以认定此时CPU 是处于idle 状态。 因此，在该进程中可以尝试停掉一段时间的tick。callstack 如下：<br>cpu_idle_loop -&gt;<br>tick_nohz_idle_enter -&gt;<br>__tick_nohz_idle_enter -&gt;<br>tick_nohz_stop_sched_tick</p>\n<p>从<code>cpu_idle_loop()</code> 可以看出进入idle 进程 尝试开启tickless， 之后让CPU 进入低功耗<code>cpuidle_idle_call()</code>, 之后若有调度事件 则退出tickless, <code>tick_nohz_idle_exit()</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* kernel-4.9.198, remove some code */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">cpuidle_idle_call</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* default idle */</span></span><br><span class=\"line\">   __<span class=\"function\">asm__  <span class=\"title\">volatile</span> <span class=\"params\">(<span class=\"string\">\"wfi');</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">static void cpu_idle_loop(void)</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">&#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\tint cpu = smp_processor_id();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\twhile (1) &#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\ttick_nohz_idle_enter();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\twhile (!need_resched()) &#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tlocal_irq_disable();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tarch_cpu_idle_enter();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tcpuidle_idle_call();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tarch_cpu_idle_exit();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\ttick_nohz_idle_exit();</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure></p>\n<p>在<code>__tick_nohz_idle_enter()</code> 中设定idle_entrytime, idle_active 状态， 并且判断是否可以stop idle tick， 其依据为：</p>\n<ul>\n<li>cpu online</li>\n<li>no need re-schedule</li>\n<li>no local softirq pending</li>\n<li>disable nohz full, or do timer cpu is not current cpu</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ktime_t <span class=\"title\">tick_nohz_start_idle</span><span class=\"params\">(struct tick_sched *ts)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span> now = ktime_get();</span><br><span class=\"line\">\tts-&gt;idle_entrytime = now;</span><br><span class=\"line\">\tts-&gt;idle_active = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __tick_nohz_idle_enter(struct tick_sched *ts)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span> now, expires;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cpu = smp_processor_id();</span><br><span class=\"line\"></span><br><span class=\"line\">\tnow = tick_nohz_start_idle(ts);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (can_stop_idle_tick(cpu, ts)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> was_stopped = ts-&gt;tick_stopped;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tts-&gt;idle_calls++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\texpires = tick_nohz_stop_sched_tick(ts, now, cpu);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (expires.tv64 &gt; <span class=\"number\">0L</span>L) &#123;</span><br><span class=\"line\">\t\t\tts-&gt;idle_sleeps++;</span><br><span class=\"line\">\t\t\tts-&gt;idle_expires = expires;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!was_stopped &amp;&amp; ts-&gt;tick_stopped)</span><br><span class=\"line\">\t\t\tts-&gt;idle_jiffies = ts-&gt;last_jiffies;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>tickless 核心关键函数落在<code>tick_nohz_stop_sched_tick()</code>，其基本流程是是否能进入tickless。若可以，则计算出合适的ticks 并调用<code>h</code>rtimer_start()<code>或</code>tick_program_event()`对timer 重新编程。在后面小节<strong>tickless 停掉tick 数确定</strong> 会较详细分析该函数。</p>\n<h3 id=\"2-2-irq-exit-时尝试启动tickless\"><a href=\"#2-2-irq-exit-时尝试启动tickless\" class=\"headerlink\" title=\"2.2. irq_exit 时尝试启动tickless\"></a>2.2. irq_exit 时尝试启动tickless</h3><p>当有one shot timer中断到来时，我们在 tick_nohz_handler() intr servive 中设定下一次tick唤醒，这样在没有其他中断，进程执行时，也要被唤醒，这样我们的timer 又变成了周期timer。最好的应该是kernel 进行检查是否需要继续进行tickless 操作，因此在irq_exit 中有如下操作：<br>irq_exit -&gt;<br>tick_irq_exit -&gt;<br>tick_nohz_irq_exit-&gt;<br>tick_nohz_stop_sched_tick</p>\n<p>补充：<br>irq 在arm 处理流程大致为：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handle_IRQ</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq, struct pt_regs *regs)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t__handle_domain_irq(<span class=\"literal\">NULL</span>, irq, <span class=\"literal\">false</span>, regs);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> __handle_domain_irq(struct irq_domain *domain, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hwirq,</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">bool</span> lookup, struct pt_regs *regs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tirq_enter();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/* call irq intr func */</span></span><br><span class=\"line\">\tgeneric_handle_irq(irq);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tirq_exit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>irq_enter(), irq_exit() 就会去做我们的软中断，generic_handle_irq() 实作HW 中断。</p>\n<h2 id=\"3-tickless-停掉tick-数确定\"><a href=\"#3-tickless-停掉tick-数确定\" class=\"headerlink\" title=\"3. tickless 停掉tick 数确定\"></a>3. tickless 停掉tick 数确定</h2><p>tickless 能停掉的ticks 怎样确认了？ </p>\n<p>在只有idle 进程运行时，cpu 需要处理的还有不定的HW 中断等，但是发生时间不能预测。<font color=\"red\">但是第一个即将到期的中断时间是可以知道的，在这个时间到期之前都可以停掉 tick，由此得到需要停掉的tick 数</font>。</p>\n<p>另外，停掉 tick 的时间不能超过 clock_event_device 的 max_delta_ns，不然可能会造成 clocksource 的溢出。<br>如果停掉的ticks 是在下一个tick_period 则不用stop tick。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ktime_t <span class=\"title\">tick_nohz_stop_sched_tick</span><span class=\"params\">(struct tick_sched *ts,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t <span class=\"keyword\">ktime_t</span> now, <span class=\"keyword\">int</span> cpu)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Keep the periodic tick, when RCU, architecture or irq_work</span></span><br><span class=\"line\"><span class=\"comment\">\t * requests it.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Aside of that check whether the local timer softirq is</span></span><br><span class=\"line\"><span class=\"comment\">\t * pending. If so its a bad idea to call get_next_timer_interrupt()</span></span><br><span class=\"line\"><span class=\"comment\">\t * because there is an already expired timer, so it will request</span></span><br><span class=\"line\"><span class=\"comment\">\t * immeditate expiry, which rearms the hardware timer with a</span></span><br><span class=\"line\"><span class=\"comment\">\t * minimal delta which brings us back to this place</span></span><br><span class=\"line\"><span class=\"comment\">\t * immediately. Lather, rinse and repeat...</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (rcu_needs_cpu(basemono, &amp;next_rcu) || arch_needs_cpu() ||</span><br><span class=\"line\">\t    irq_work_needs_cpu() || local_timer_softirq_pending()) &#123;</span><br><span class=\"line\">\t\tnext_tick = basemono + TICK_NSEC;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);</span><br><span class=\"line\">\t\tts-&gt;next_timer = next_tmr;</span><br><span class=\"line\">\t\tnext_tick = next_rcu &lt; next_tmr ? next_rcu : next_tmr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * If the tick is due in the next period, keep it ticking or</span></span><br><span class=\"line\"><span class=\"comment\">\t * force prod the timer.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tdelta = next_tick - basemono;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (delta &lt;= (u64)TICK_NSEC) &#123;</span><br><span class=\"line\">\t\ttick.tv64 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttimer_clear_idle();</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * If this CPU is the one which updates jiffies, then give up</span></span><br><span class=\"line\"><span class=\"comment\">\t * the assignment and let it be taken by the CPU which runs</span></span><br><span class=\"line\"><span class=\"comment\">\t * the tick timer next, which might be this CPU as well. If we</span></span><br><span class=\"line\"><span class=\"comment\">\t * don't drop this here the jiffies might be stale and</span></span><br><span class=\"line\"><span class=\"comment\">\t * do_timer() never invoked. Keep track of the fact that it</span></span><br><span class=\"line\"><span class=\"comment\">\t * was the one which had the do_timer() duty last. If this CPU</span></span><br><span class=\"line\"><span class=\"comment\">\t * is the one which had the do_timer() duty last, we limit the</span></span><br><span class=\"line\"><span class=\"comment\">\t * sleep time to the timekeeping max_deferment value.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Otherwise we can sleep as long as we want.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tdelta = timekeeping_max_deferment();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cpu == tick_do_timer_cpu) &#123;</span><br><span class=\"line\">\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;</span><br><span class=\"line\">\t\tts-&gt;do_timer_last = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tick_do_timer_cpu != TICK_DO_TIMER_NONE) &#123;</span><br><span class=\"line\">\t\tdelta = KTIME_MAX;</span><br><span class=\"line\">\t\tts-&gt;do_timer_last = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!ts-&gt;do_timer_last) &#123;</span><br><span class=\"line\">\t\tdelta = KTIME_MAX;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Calculate the next expiry time */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (delta &lt; (KTIME_MAX - basemono))</span><br><span class=\"line\">\t\texpires = basemono + delta;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\texpires = KTIME_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">\texpires = <span class=\"keyword\">min_t</span>(u64, expires, next_tick);</span><br><span class=\"line\">\ttick.tv64 = expires;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * nohz_stop_sched_tick can be called several times before</span></span><br><span class=\"line\"><span class=\"comment\">\t * the nohz_restart_sched_tick is called. This happens when</span></span><br><span class=\"line\"><span class=\"comment\">\t * interrupts arrive which do not cause a reschedule. In the</span></span><br><span class=\"line\"><span class=\"comment\">\t * first call we save the current tick time, so we can restart</span></span><br><span class=\"line\"><span class=\"comment\">\t * the scheduler tick in nohz_restart_sched_tick.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ts-&gt;tick_stopped) &#123;</span><br><span class=\"line\">\t\tnohz_balance_enter_idle(cpu);</span><br><span class=\"line\">\t\tcalc_load_enter_idle();</span><br><span class=\"line\">\t\tcpu_load_update_nohz_start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tts-&gt;last_tick = hrtimer_get_expires(&amp;ts-&gt;sched_timer);</span><br><span class=\"line\">\t\tts-&gt;tick_stopped = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ttrace_tick_stop(<span class=\"number\">1</span>, TICK_DEP_MASK_NONE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ts-&gt;nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class=\"line\">\t\thrtimer_start(&amp;ts-&gt;sched_timer, tick, HRTIMER_MODE_ABS_PINNED);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\ttick_program_event(tick, <span class=\"number\">1</span>);</span><br><span class=\"line\">out:</span><br><span class=\"line\">\t<span class=\"comment\">/* Update the estimated sleep length */</span></span><br><span class=\"line\">\tts-&gt;sleep_length = ktime_sub(dev-&gt;next_event, now);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> tick;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-tickless-何时停止？\"><a href=\"#4-tickless-何时停止？\" class=\"headerlink\" title=\"4. tickless 何时停止？\"></a>4. tickless 何时停止？</h2><p>在cpu_idle_loop 循环中判断有新的进程被唤醒时退出tickless 模式，可参见前面<code>cpu_idle_loop()</code>函数，恢复到tick_period。<br>tick_nohz_idle_exit-&gt;<br>tick_nohz_restart </p>\n<p>在函数中，会判断高低分辨 timer，若是high resolution timer 则设定one shot 下一次中断来的expires, 反之低分辨率timer 则使用<code>tick_program_event()</code> 重新设定clockevent 。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick_nohz_restart</span><span class=\"params\">(struct tick_sched *ts, <span class=\"keyword\">ktime_t</span> now)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\thrtimer_cancel(&amp;ts-&gt;sched_timer);</span><br><span class=\"line\">\thrtimer_set_expires(&amp;ts-&gt;sched_timer, ts-&gt;last_tick);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Forward the time to expire in the future */</span></span><br><span class=\"line\">\thrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ts-&gt;nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class=\"line\">\t\thrtimer_start_expires(&amp;ts-&gt;sched_timer, HRTIMER_MODE_ABS_PINNED);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\ttick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-tickless-对中断的影响\"><a href=\"#5-tickless-对中断的影响\" class=\"headerlink\" title=\"5. tickless 对中断的影响\"></a>5. tickless 对中断的影响</h2><p>由于动态时钟出现，jiffies 是滞后的，其一般是在恢复周期时钟时更新。如果进入中断时需要访问jiffies，那么数据是不准确的。因此，进入中断irq_enter, tick_check_idle() 被调用，以此来更新jiffies值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick_nohz_stop_idle</span><span class=\"params\">(struct tick_sched *ts, <span class=\"keyword\">ktime_t</span> now)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tupdate_ts_time_stats(smp_processor_id(), ts, now, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\tts-&gt;idle_active = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsched_clock_idle_wakeup_event(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tick_irq_enter</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\ttick_check_oneshot_broadcast_this_cpu();</span><br><span class=\"line\">\ttick_nohz_irq_enter();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">irq_enter</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\trcu_irq_enter();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_idle_task(current) &amp;&amp; !in_interrupt()) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Prevent raise_softirq from needlessly waking up ksoftirqd</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * here, as softirq will be serviced on return from interrupt.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tlocal_bh_disable();</span><br><span class=\"line\">\t\ttick_irq_enter();</span><br><span class=\"line\">\t\t_local_bh_enable();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t__irq_enter();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://kernel.meizu.com/linux-tick-and-tickless.html\" target=\"_blank\" rel=\"noopener\">Linux Tick 和 Tickless</a></p>\n<p><a href=\"https://blog.csdn.net/DroidPhone/article/details/8112948\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之八：动态时钟框架（CONFIG_NO_HZ、tickless）</a></p>\n<p><a href=\"http://blog.chinaunix.net/uid-25942458-id-3412358.html\" target=\"_blank\" rel=\"noopener\">linux动态时钟探索</a></p>\n<p><a href=\"https://www.cnblogs.com/mfrbuaa/p/5152800.html\" target=\"_blank\" rel=\"noopener\">动静结合学内核：linux idle进程和init进程浅析</a></p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/tick-device-layer.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十三）：Tick Device layer综述</a></p>\n<p><a href=\"https://blog.csdn.net/zhoudawei/article/details/86427101\" target=\"_blank\" rel=\"noopener\">NO_HZ: 减少调度时钟的滴答</a><br><a href=\"https://lwn.net/Articles/549593/\" target=\"_blank\" rel=\"noopener\">kernel/Documentation/timers/NO_HZ.txt</a></p>"},{"title":"kernel-timer-system","date":"2019-11-28T06:54:31.000Z","_content":"## 1. Kernel Timer 软件架构\n\n![Kernel timer structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/kernel_timer_structure.png)\n\n<!--more-->\n\n|      术语       | 说明                                                                                                                                                                                         |\n| :-------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Global Counter  | free running system counter, 可以参看arm_arm 手册里的Generic Timer->system counter。Rollover 时间至少40年。他提供了一个基础的timeline, 无线延伸                                              |\n| CPU local Timer | CPU local timer 可以是Peripheral HW Timer, 或者是CPU 如ARM 含有的Generic Timer -> timer.                                                                                                     |\n|   clock event   | 通过timer硬件的 __中断处理函数__ 完成的，在此基础上可以构建tick模块。clock event 是在timeline 上指定点产生event。                                                                            |\n|    tick 模块    | 维护了系统的tick，各个 __进程的时间统计__ 也是基于tick的，内核的 __调度器__ 根据这些信息进行调度。__System Load和Kernel Profiling模块__ 也是基于tick的，用于计算系统负荷和进行内核性能剖析。 |\n| timekeeping模块 | 系统时间， 每tick 的发生，其值增加。高进度的值，可以来源于clocksource                                                                                                                        |\n|    timer lib    | 用户空间需求：1.获取系统时间，time, stime, gettimeofday, 2.定时器功能，settimer, alarm等                                                                                                     |\n\n一个CPU 可以有多个local Clock Event， 但是会选择一个适合的作为tick device。\n\ntick device 工作模式：\n- one shot mode(提供高精度的clock event)\n- periodic mode\n\n一般有多少个cpu，就会有多少个tick device - local tick device, 在所有device 中会选取一个做global tick device, 负责维护整个系统的jiffies，更新wall clock，计算全局负荷等。\n\n当系统处于高精度timer的时候（tick device处于one shot mode），系统会setup一个特别的高精度timer（可以称之sched timer），该高精度timer会周期性的触发，从而模拟的传统的periodic tick，从而推动了传统低精度timer的运转。因此，一些传统的内核模块仍然可以调用经典的低精度timer模块的接口。 \n\n![Tick Device Layer structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/kernel_tick_device_structure.png)\n\n## 2. file structure\n\n|                         文件                         | 说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| :--------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|                 time.c<br>timeconv.c                 | 用户空间函数,time, stime, gettimeofday，alarm等，以及转换函数                                                                                                                                                                                                                                                                                                                                                                                                           |\n|             time_list.c<br>time_status.c             | 向用户空间提供的调试接口。在用户空间，可以通过/proc/timer_list接口可以获得内核中的时间子系统的相关信息。                                                                                                                                                                                                                                                                                                                                                                |\n| posix-timer.c<br>posix-cpu-timers.c<br>posix-clock.c | POSIX timer， clock模块                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n|                     alrmtimer.c                      | alarmtimer 模块                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|                        ntp.c                         | NTP 模块                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n|        timerkeeping.c<br>timerkeeping_debug.c        | timerkeeping.c模块                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n|    ick-common.c<br>tick-oneshot.c<br>tick-sched.c    | tick device layer模块。<br>tick-common.c文件是periodic tick模块，用于管理周期性tick事件。<br>tick-oneshot.c文件是for高精度timer的，用于管理高精度tick时间。<br> tick-sched.c是用于dynamic tick的。                                                                                                                                                                                                                                                                      |\n|     tick-broadcast.c<br>tick-broadcast-hrtimer.c     | broadcast tick模块。                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n|                    sched_clock.c                     | 通用sched clock模块。这个模块主要是提供一个sched_clock的接口函数，可以获取当前时间点到系统启动之间的纳秒值。底层的HW counter其实是千差万别的，有些平台可以提供64-bit的HW counter，我们可以不使用这个通用sched clock模块（不配置CONFIG_GENERIC_SCHED_CLOCK这个内核选项），而在自己的clock source chip driver中直接提供sched_clock接口。使用通用sched clock模块的好处是：该模块扩展了64-bit的counter，即使底层的HW counter比特数目不足（有些平台HW counter只有32个bit）。 |\n|              clocksource.c<br>jiffies.c              | clocksource.c是通用clocksource driver。其实也可以把system tick也看成一个特定的clocksource，其代码在jiffies.c文件中                                                                                                                                                                                                                                                                                                                                                      |\n|                     clockevnet.c                     | clockevent 模块                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|                       timer.c                        | 传统的低精度timer 模块， 基本tick                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n|                       htimer.c                       | 高精度timer                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n\n## 3. clocksource\n时间其实可以抽象成一条直线, timeline. clock source就是用来抽象一个在指定输入频率的clock下工作的一个counter。输入频率可以确定以什么样的精度来划分timeline(假设输入counter的频率是1GHz，那么一个cycle就是1ns)\n\nclocksource 数据结构如下：\n```c\n/* linux-4.9.198 code */\n/**\n * struct clocksource - hardware abstraction for a free running counter\n *\tProvides mostly state-free accessors to the underlying hardware.\n *\tThis is the structure used for system time.\n *\n * @name:\t\tptr to clocksource name\n * @list:\t\tlist head for registration\n * @rating:\t\trating value for selection (higher is better)\n *\t\t\tTo avoid rating inflation the following\n *\t\t\tlist should give you a guide as to how\n *\t\t\tto assign your clocksource a rating\n *\t\t\t1-99: Unfit for real use\n *\t\t\t\tOnly available for bootup and testing purposes.\n *\t\t\t100-199: Base level usability.\n *\t\t\t\tFunctional for real use, but not desired.\n *\t\t\t200-299: Good.\n *\t\t\t\tA correct and usable clocksource.\n *\t\t\t300-399: Desired.\n *\t\t\t\tA reasonably fast and accurate clocksource.\n *\t\t\t400-499: Perfect\n *\t\t\t\tThe ideal clocksource. A must-use where\n *\t\t\t\tavailable.\n * @read:\t\treturns a cycle value, passes clocksource as argument\n * @enable:\t\toptional function to enable the clocksource\n * @disable:\t\toptional function to disable the clocksource\n * @mask:\t\tbitmask for two's complement\n *\t\t\tsubtraction of non 64 bit counters\n * @mult:\t\tcycle to nanosecond multiplier\n * @shift:\t\tcycle to nanosecond divisor (power of two)\n * @max_idle_ns:\tmax idle time permitted by the clocksource (nsecs)\n * @maxadj:\t\tmaximum adjustment value to mult (~11%)\n * @max_cycles:\t\tmaximum safe cycle value which won't overflow on multiplication\n * @flags:\t\tflags describing special properties\n * @archdata:\t\tarch-specific data\n * @suspend:\t\tsuspend function for the clocksource, if necessary\n * @resume:\t\tresume function for the clocksource, if necessary\n * @owner:\t\tmodule reference, must be set by clocksource in modules\n *\n * Note: This struct is not used in hotpathes of the timekeeping code\n * because the timekeeper caches the hot path fields in its own data\n * structure, so no line cache alignment is required,\n *\n * The pointer to the clocksource itself is handed to the read\n * callback. If you need extra information there you can wrap struct\n * clocksource into your own struct. Depending on the amount of\n * information you need you should consider to cache line align that\n * structure.\n */\nstruct clocksource {\n\tcycle_t (*read)(struct clocksource *cs);\n\tcycle_t mask;\n\tu32 mult;\n\tu32 shift;\n\tu64 max_idle_ns;\n\tu32 maxadj;\n#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA\n\tstruct arch_clocksource_data archdata;\n#endif\n\tu64 max_cycles;\n\tconst char *name;\n\tstruct list_head list;\n\tint rating;\n\tint (*enable)(struct clocksource *cs);\n\tvoid (*disable)(struct clocksource *cs);\n\tunsigned long flags;\n\tvoid (*suspend)(struct clocksource *cs);\n\tvoid (*resume)(struct clocksource *cs);\n\n\t/* private: */\n#ifdef CONFIG_CLOCKSOURCE_WATCHDOG\n\t/* Watchdog related data, used by the framework */\n\tstruct list_head wd_list;\n\tcycle_t cs_last;\n\tcycle_t wd_last;\n#endif\n\tstruct module *owner;\n};\n```\n### 3.1. register/unregister clocksource\n\n系统中使用cycle_t cycles 进行计数， 为了人们的方便会转换成年月日方式，所以就会用mult, shift（乘法，除法系数）进行转换。\n\n```c\nstatic inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)\n{\n    return ((u64) cycles * mult) >> shift;\n} \n```\n\n```c\n/* need to calculate mult, shift by caller */\nint clocksource_register(struct clocksource *cs);\n\n/* os will calculate mult, shift */\nstatic inline int clocksource_register_hz(struct clocksource *cs,  u32 hz) ;\nstatic inline int clocksource_register_khz(struct clocksource *cs,  u32 khz);\n\nstatic int clocksource_unbind(struct clocksource *cs);\n```\n\n### 3.2. OS选择clock source\n主要参看的因素有两个：\n- best rate （分辨率越高的）\n- 用户空间的选择\n```c\nstatic void __clocksource_select(bool skipcur)\n```\n\n### 3.3. timecounter 与 cyclecounter\n具体来讲， cyclecounter 表示free running system counter 绝对的时间点, 而timecounter 表示counter， 但是表达的是ns 时间单位。\n\n```c\n/**\n * struct cyclecounter - hardware abstraction for a free running counter\n *\tProvides completely state-free accessors to the underlying hardware.\n *\tDepending on which hardware it reads, the cycle counter may wrap\n *\taround quickly. Locking rules (if necessary) have to be defined\n *\tby the implementor and user of specific instances of this API.\n *\n * @read:\t\treturns the current cycle value\n * @mask:\t\tbitmask for two's complement\n *\t\t\tsubtraction of non 64 bit counters,\n *\t\t\tsee CYCLECOUNTER_MASK() helper macro\n * @mult:\t\tcycle to nanosecond multiplier\n * @shift:\t\tcycle to nanosecond divisor (power of two)\n */\nstruct cyclecounter {\n\tcycle_t (*read)(const struct cyclecounter *cc);\n\tcycle_t mask;\n\tu32 mult;\n\tu32 shift;\n};\n\n/**\n * struct timecounter - layer above a %struct cyclecounter which counts nanoseconds\n *\tContains the state needed by timecounter_read() to detect\n *\tcycle counter wrap around. Initialize with\n *\ttimecounter_init(). Also used to convert cycle counts into the\n *\tcorresponding nanosecond counts with timecounter_cyc2time(). Users\n *\tof this code are responsible for initializing the underlying\n *\tcycle counter hardware, locking issues and reading the time\n *\tmore often than the cycle counter wraps around. The nanosecond\n *\tcounter will only wrap around after ~585 years.\n *\n * @cc:\t\t\tthe cycle counter used by this instance\n * @cycle_last:\t\tmost recent cycle counter value seen by\n *\t\t\ttimecounter_read()\n * @nsec:\t\tcontinuously increasing count\n * @mask:\t\tbit mask for maintaining the 'frac' field\n * @frac:\t\taccumulated fractional nanoseconds\n */\nstruct timecounter {\n\tconst struct cyclecounter *cc;\n\tcycle_t cycle_last;\n\tu64 nsec;\n\tu64 mask;\n\tu64 frac;\n};\n```\n\n## 4. clockevent\nclockevent 数据结构如下\n\n```c\n/**\n * struct clock_event_device - clock event device descriptor\n * @event_handler:\tAssigned by the framework to be called by the low\n *\t\t\tlevel handler of the event source\n * @set_next_event:\tset next event function using a clocksource delta\n * @set_next_ktime:\tset next event function using a direct ktime value\n * @next_event:\t\tlocal storage for the next event in oneshot mode\n * @max_delta_ns:\tmaximum delta value in ns\n * @min_delta_ns:\tminimum delta value in ns\n * @mult:\t\tnanosecond to cycles multiplier\n * @shift:\t\tnanoseconds to cycles divisor (power of two)\n * @state_use_accessors:current state of the device, assigned by the core code\n * @features:\t\tfeatures\n * @retries:\t\tnumber of forced programming retries\n * @set_state_periodic:\tswitch state to periodic\n * @set_state_oneshot:\tswitch state to oneshot\n * @set_state_oneshot_stopped: switch state to oneshot_stopped\n * @set_state_shutdown:\tswitch state to shutdown\n * @tick_resume:\tresume clkevt device\n * @broadcast:\t\tfunction to broadcast events\n * @min_delta_ticks:\tminimum delta value in ticks stored for reconfiguration\n * @max_delta_ticks:\tmaximum delta value in ticks stored for reconfiguration\n * @name:\t\tptr to clock event name\n * @rating:\t\tvariable to rate clock event devices\n * @irq:\t\tIRQ number (only for non CPU local devices)\n * @bound_on:\t\tBound on CPU\n * @cpumask:\t\tcpumask to indicate for which CPUs this device works\n * @list:\t\tlist head for the management code\n * @owner:\t\tmodule reference\n */\nstruct clock_event_device {\n\tvoid\t\t\t(*event_handler)(struct clock_event_device *);\n\tint\t\t\t(*set_next_event)(unsigned long evt, struct clock_event_device *);\n\tint\t\t\t(*set_next_ktime)(ktime_t expires, struct clock_event_device *);\n\tktime_t\t\t\tnext_event;\n\tu64\t\t\tmax_delta_ns;\n\tu64\t\t\tmin_delta_ns;\n\tu32\t\t\tmult;\n\tu32\t\t\tshift;\n\tenum clock_event_state\tstate_use_accessors;\n\tunsigned int\t\tfeatures;\n\tunsigned long\t\tretries;\n\n\tint\t\t\t(*set_state_periodic)(struct clock_event_device *);\n\tint\t\t\t(*set_state_oneshot)(struct clock_event_device *);\n\tint\t\t\t(*set_state_oneshot_stopped)(struct clock_event_device *);\n\tint\t\t\t(*set_state_shutdown)(struct clock_event_device *);\n\tint\t\t\t(*tick_resume)(struct clock_event_device *);\n\n\tvoid\t\t\t(*broadcast)(const struct cpumask *mask);\n\tvoid\t\t\t(*suspend)(struct clock_event_device *);\n\tvoid\t\t\t(*resume)(struct clock_event_device *);\n\tunsigned long\t\tmin_delta_ticks;\n\tunsigned long\t\tmax_delta_ticks;\n\n\tconst char\t\t*name;\n\tint\t\t\trating;\n\tint\t\t\tirq;\n\tint\t\t\tbound_on;\n\tconst struct cpumask\t*cpumask;\n\tstruct list_head\tlist;\n\tstruct module\t\t*owner;\n} ____cacheline_aligned;\n```\n\n上面重要的有\n```c\n    /* set next event interrupt by cyclecounter or ktime */\n    int\t\t\t(*set_next_event)(unsigned long evt, struct clock_event_device *);\n\tint\t\t\t(*set_next_ktime)(ktime_t expires, struct clock_event_device *);\n\n    /* switch event mode: periodic or oneshot */\n\tint\t\t\t(*set_state_periodic)(struct clock_event_device *);\n\tint\t\t\t(*set_state_oneshot)(struct clock_event_device *);    \n```\n\n### 4.1. 常用函数\n\n```c\nextern void clockevents_config_and_register(struct clock_event_device *dev,\n\t\t\t\t\t    u32 freq, unsigned long min_delta,\n\t\t\t\t\t    unsigned long max_delta);\n\nextern void clockevents_config(struct clock_event_device *dev, u32 freq);\nextern void clockevents_register_device(struct clock_event_device *dev);\n\nextern int clockevents_unbind_device(struct clock_event_device *ced, int cpu);\n```\n\n在我们register clockevnet 后， 上层的tick layer 可能会考虑替换当前的clockevent device.\n替换参考的依据是：\n- 首先是CPU local device\n- 具备更好的rate\n\n如果current clockevent device 是broadcast device(broadcost clockevent device 主要用于在CPU sleep 时，其他CPU local timer 已经睡眠，在resume时我们可以通过broadcast device 唤醒其他CPU)，需要先close.\n\n```c\n/* linux-4.9.198 code */\n/*\n * Check, if the new registered device should be used. Called with\n * clockevents_lock held and interrupts disabled.\n */\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t/* cpu local device ? */\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t/* Preference decision */\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev);\n}\n```\n## Reference\n[Linux时间子系统之（二）：软件架构](http://www.wowotech.net/timer_subsystem/time-subsyste-architecture.html)\n\n[Linux时间子系统之（十三）：Tick Device layer 综述](http://www.wowotech.net/timer_subsystem/tick-device-layer.html)\n\n[Linux时间子系统之（十五）：clocksource](http://www.wowotech.net/timer_subsystem/clocksource.html)\n\n[Linux时间子系统之（十六）：clockevent](http://www.wowotech.net/timer_subsystem/clock-event.html)","source":"_posts/kernel-timer-system.md","raw":"---\ntitle: kernel-timer-system\ndate: 2019-11-28 14:54:31\ntags:\n    - timer\ncategories:\n    - drivers\n---\n## 1. Kernel Timer 软件架构\n\n![Kernel timer structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/kernel_timer_structure.png)\n\n<!--more-->\n\n|      术语       | 说明                                                                                                                                                                                         |\n| :-------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Global Counter  | free running system counter, 可以参看arm_arm 手册里的Generic Timer->system counter。Rollover 时间至少40年。他提供了一个基础的timeline, 无线延伸                                              |\n| CPU local Timer | CPU local timer 可以是Peripheral HW Timer, 或者是CPU 如ARM 含有的Generic Timer -> timer.                                                                                                     |\n|   clock event   | 通过timer硬件的 __中断处理函数__ 完成的，在此基础上可以构建tick模块。clock event 是在timeline 上指定点产生event。                                                                            |\n|    tick 模块    | 维护了系统的tick，各个 __进程的时间统计__ 也是基于tick的，内核的 __调度器__ 根据这些信息进行调度。__System Load和Kernel Profiling模块__ 也是基于tick的，用于计算系统负荷和进行内核性能剖析。 |\n| timekeeping模块 | 系统时间， 每tick 的发生，其值增加。高进度的值，可以来源于clocksource                                                                                                                        |\n|    timer lib    | 用户空间需求：1.获取系统时间，time, stime, gettimeofday, 2.定时器功能，settimer, alarm等                                                                                                     |\n\n一个CPU 可以有多个local Clock Event， 但是会选择一个适合的作为tick device。\n\ntick device 工作模式：\n- one shot mode(提供高精度的clock event)\n- periodic mode\n\n一般有多少个cpu，就会有多少个tick device - local tick device, 在所有device 中会选取一个做global tick device, 负责维护整个系统的jiffies，更新wall clock，计算全局负荷等。\n\n当系统处于高精度timer的时候（tick device处于one shot mode），系统会setup一个特别的高精度timer（可以称之sched timer），该高精度timer会周期性的触发，从而模拟的传统的periodic tick，从而推动了传统低精度timer的运转。因此，一些传统的内核模块仍然可以调用经典的低精度timer模块的接口。 \n\n![Tick Device Layer structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/kernel_tick_device_structure.png)\n\n## 2. file structure\n\n|                         文件                         | 说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| :--------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|                 time.c<br>timeconv.c                 | 用户空间函数,time, stime, gettimeofday，alarm等，以及转换函数                                                                                                                                                                                                                                                                                                                                                                                                           |\n|             time_list.c<br>time_status.c             | 向用户空间提供的调试接口。在用户空间，可以通过/proc/timer_list接口可以获得内核中的时间子系统的相关信息。                                                                                                                                                                                                                                                                                                                                                                |\n| posix-timer.c<br>posix-cpu-timers.c<br>posix-clock.c | POSIX timer， clock模块                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n|                     alrmtimer.c                      | alarmtimer 模块                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|                        ntp.c                         | NTP 模块                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n|        timerkeeping.c<br>timerkeeping_debug.c        | timerkeeping.c模块                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n|    ick-common.c<br>tick-oneshot.c<br>tick-sched.c    | tick device layer模块。<br>tick-common.c文件是periodic tick模块，用于管理周期性tick事件。<br>tick-oneshot.c文件是for高精度timer的，用于管理高精度tick时间。<br> tick-sched.c是用于dynamic tick的。                                                                                                                                                                                                                                                                      |\n|     tick-broadcast.c<br>tick-broadcast-hrtimer.c     | broadcast tick模块。                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n|                    sched_clock.c                     | 通用sched clock模块。这个模块主要是提供一个sched_clock的接口函数，可以获取当前时间点到系统启动之间的纳秒值。底层的HW counter其实是千差万别的，有些平台可以提供64-bit的HW counter，我们可以不使用这个通用sched clock模块（不配置CONFIG_GENERIC_SCHED_CLOCK这个内核选项），而在自己的clock source chip driver中直接提供sched_clock接口。使用通用sched clock模块的好处是：该模块扩展了64-bit的counter，即使底层的HW counter比特数目不足（有些平台HW counter只有32个bit）。 |\n|              clocksource.c<br>jiffies.c              | clocksource.c是通用clocksource driver。其实也可以把system tick也看成一个特定的clocksource，其代码在jiffies.c文件中                                                                                                                                                                                                                                                                                                                                                      |\n|                     clockevnet.c                     | clockevent 模块                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|                       timer.c                        | 传统的低精度timer 模块， 基本tick                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n|                       htimer.c                       | 高精度timer                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n\n## 3. clocksource\n时间其实可以抽象成一条直线, timeline. clock source就是用来抽象一个在指定输入频率的clock下工作的一个counter。输入频率可以确定以什么样的精度来划分timeline(假设输入counter的频率是1GHz，那么一个cycle就是1ns)\n\nclocksource 数据结构如下：\n```c\n/* linux-4.9.198 code */\n/**\n * struct clocksource - hardware abstraction for a free running counter\n *\tProvides mostly state-free accessors to the underlying hardware.\n *\tThis is the structure used for system time.\n *\n * @name:\t\tptr to clocksource name\n * @list:\t\tlist head for registration\n * @rating:\t\trating value for selection (higher is better)\n *\t\t\tTo avoid rating inflation the following\n *\t\t\tlist should give you a guide as to how\n *\t\t\tto assign your clocksource a rating\n *\t\t\t1-99: Unfit for real use\n *\t\t\t\tOnly available for bootup and testing purposes.\n *\t\t\t100-199: Base level usability.\n *\t\t\t\tFunctional for real use, but not desired.\n *\t\t\t200-299: Good.\n *\t\t\t\tA correct and usable clocksource.\n *\t\t\t300-399: Desired.\n *\t\t\t\tA reasonably fast and accurate clocksource.\n *\t\t\t400-499: Perfect\n *\t\t\t\tThe ideal clocksource. A must-use where\n *\t\t\t\tavailable.\n * @read:\t\treturns a cycle value, passes clocksource as argument\n * @enable:\t\toptional function to enable the clocksource\n * @disable:\t\toptional function to disable the clocksource\n * @mask:\t\tbitmask for two's complement\n *\t\t\tsubtraction of non 64 bit counters\n * @mult:\t\tcycle to nanosecond multiplier\n * @shift:\t\tcycle to nanosecond divisor (power of two)\n * @max_idle_ns:\tmax idle time permitted by the clocksource (nsecs)\n * @maxadj:\t\tmaximum adjustment value to mult (~11%)\n * @max_cycles:\t\tmaximum safe cycle value which won't overflow on multiplication\n * @flags:\t\tflags describing special properties\n * @archdata:\t\tarch-specific data\n * @suspend:\t\tsuspend function for the clocksource, if necessary\n * @resume:\t\tresume function for the clocksource, if necessary\n * @owner:\t\tmodule reference, must be set by clocksource in modules\n *\n * Note: This struct is not used in hotpathes of the timekeeping code\n * because the timekeeper caches the hot path fields in its own data\n * structure, so no line cache alignment is required,\n *\n * The pointer to the clocksource itself is handed to the read\n * callback. If you need extra information there you can wrap struct\n * clocksource into your own struct. Depending on the amount of\n * information you need you should consider to cache line align that\n * structure.\n */\nstruct clocksource {\n\tcycle_t (*read)(struct clocksource *cs);\n\tcycle_t mask;\n\tu32 mult;\n\tu32 shift;\n\tu64 max_idle_ns;\n\tu32 maxadj;\n#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA\n\tstruct arch_clocksource_data archdata;\n#endif\n\tu64 max_cycles;\n\tconst char *name;\n\tstruct list_head list;\n\tint rating;\n\tint (*enable)(struct clocksource *cs);\n\tvoid (*disable)(struct clocksource *cs);\n\tunsigned long flags;\n\tvoid (*suspend)(struct clocksource *cs);\n\tvoid (*resume)(struct clocksource *cs);\n\n\t/* private: */\n#ifdef CONFIG_CLOCKSOURCE_WATCHDOG\n\t/* Watchdog related data, used by the framework */\n\tstruct list_head wd_list;\n\tcycle_t cs_last;\n\tcycle_t wd_last;\n#endif\n\tstruct module *owner;\n};\n```\n### 3.1. register/unregister clocksource\n\n系统中使用cycle_t cycles 进行计数， 为了人们的方便会转换成年月日方式，所以就会用mult, shift（乘法，除法系数）进行转换。\n\n```c\nstatic inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)\n{\n    return ((u64) cycles * mult) >> shift;\n} \n```\n\n```c\n/* need to calculate mult, shift by caller */\nint clocksource_register(struct clocksource *cs);\n\n/* os will calculate mult, shift */\nstatic inline int clocksource_register_hz(struct clocksource *cs,  u32 hz) ;\nstatic inline int clocksource_register_khz(struct clocksource *cs,  u32 khz);\n\nstatic int clocksource_unbind(struct clocksource *cs);\n```\n\n### 3.2. OS选择clock source\n主要参看的因素有两个：\n- best rate （分辨率越高的）\n- 用户空间的选择\n```c\nstatic void __clocksource_select(bool skipcur)\n```\n\n### 3.3. timecounter 与 cyclecounter\n具体来讲， cyclecounter 表示free running system counter 绝对的时间点, 而timecounter 表示counter， 但是表达的是ns 时间单位。\n\n```c\n/**\n * struct cyclecounter - hardware abstraction for a free running counter\n *\tProvides completely state-free accessors to the underlying hardware.\n *\tDepending on which hardware it reads, the cycle counter may wrap\n *\taround quickly. Locking rules (if necessary) have to be defined\n *\tby the implementor and user of specific instances of this API.\n *\n * @read:\t\treturns the current cycle value\n * @mask:\t\tbitmask for two's complement\n *\t\t\tsubtraction of non 64 bit counters,\n *\t\t\tsee CYCLECOUNTER_MASK() helper macro\n * @mult:\t\tcycle to nanosecond multiplier\n * @shift:\t\tcycle to nanosecond divisor (power of two)\n */\nstruct cyclecounter {\n\tcycle_t (*read)(const struct cyclecounter *cc);\n\tcycle_t mask;\n\tu32 mult;\n\tu32 shift;\n};\n\n/**\n * struct timecounter - layer above a %struct cyclecounter which counts nanoseconds\n *\tContains the state needed by timecounter_read() to detect\n *\tcycle counter wrap around. Initialize with\n *\ttimecounter_init(). Also used to convert cycle counts into the\n *\tcorresponding nanosecond counts with timecounter_cyc2time(). Users\n *\tof this code are responsible for initializing the underlying\n *\tcycle counter hardware, locking issues and reading the time\n *\tmore often than the cycle counter wraps around. The nanosecond\n *\tcounter will only wrap around after ~585 years.\n *\n * @cc:\t\t\tthe cycle counter used by this instance\n * @cycle_last:\t\tmost recent cycle counter value seen by\n *\t\t\ttimecounter_read()\n * @nsec:\t\tcontinuously increasing count\n * @mask:\t\tbit mask for maintaining the 'frac' field\n * @frac:\t\taccumulated fractional nanoseconds\n */\nstruct timecounter {\n\tconst struct cyclecounter *cc;\n\tcycle_t cycle_last;\n\tu64 nsec;\n\tu64 mask;\n\tu64 frac;\n};\n```\n\n## 4. clockevent\nclockevent 数据结构如下\n\n```c\n/**\n * struct clock_event_device - clock event device descriptor\n * @event_handler:\tAssigned by the framework to be called by the low\n *\t\t\tlevel handler of the event source\n * @set_next_event:\tset next event function using a clocksource delta\n * @set_next_ktime:\tset next event function using a direct ktime value\n * @next_event:\t\tlocal storage for the next event in oneshot mode\n * @max_delta_ns:\tmaximum delta value in ns\n * @min_delta_ns:\tminimum delta value in ns\n * @mult:\t\tnanosecond to cycles multiplier\n * @shift:\t\tnanoseconds to cycles divisor (power of two)\n * @state_use_accessors:current state of the device, assigned by the core code\n * @features:\t\tfeatures\n * @retries:\t\tnumber of forced programming retries\n * @set_state_periodic:\tswitch state to periodic\n * @set_state_oneshot:\tswitch state to oneshot\n * @set_state_oneshot_stopped: switch state to oneshot_stopped\n * @set_state_shutdown:\tswitch state to shutdown\n * @tick_resume:\tresume clkevt device\n * @broadcast:\t\tfunction to broadcast events\n * @min_delta_ticks:\tminimum delta value in ticks stored for reconfiguration\n * @max_delta_ticks:\tmaximum delta value in ticks stored for reconfiguration\n * @name:\t\tptr to clock event name\n * @rating:\t\tvariable to rate clock event devices\n * @irq:\t\tIRQ number (only for non CPU local devices)\n * @bound_on:\t\tBound on CPU\n * @cpumask:\t\tcpumask to indicate for which CPUs this device works\n * @list:\t\tlist head for the management code\n * @owner:\t\tmodule reference\n */\nstruct clock_event_device {\n\tvoid\t\t\t(*event_handler)(struct clock_event_device *);\n\tint\t\t\t(*set_next_event)(unsigned long evt, struct clock_event_device *);\n\tint\t\t\t(*set_next_ktime)(ktime_t expires, struct clock_event_device *);\n\tktime_t\t\t\tnext_event;\n\tu64\t\t\tmax_delta_ns;\n\tu64\t\t\tmin_delta_ns;\n\tu32\t\t\tmult;\n\tu32\t\t\tshift;\n\tenum clock_event_state\tstate_use_accessors;\n\tunsigned int\t\tfeatures;\n\tunsigned long\t\tretries;\n\n\tint\t\t\t(*set_state_periodic)(struct clock_event_device *);\n\tint\t\t\t(*set_state_oneshot)(struct clock_event_device *);\n\tint\t\t\t(*set_state_oneshot_stopped)(struct clock_event_device *);\n\tint\t\t\t(*set_state_shutdown)(struct clock_event_device *);\n\tint\t\t\t(*tick_resume)(struct clock_event_device *);\n\n\tvoid\t\t\t(*broadcast)(const struct cpumask *mask);\n\tvoid\t\t\t(*suspend)(struct clock_event_device *);\n\tvoid\t\t\t(*resume)(struct clock_event_device *);\n\tunsigned long\t\tmin_delta_ticks;\n\tunsigned long\t\tmax_delta_ticks;\n\n\tconst char\t\t*name;\n\tint\t\t\trating;\n\tint\t\t\tirq;\n\tint\t\t\tbound_on;\n\tconst struct cpumask\t*cpumask;\n\tstruct list_head\tlist;\n\tstruct module\t\t*owner;\n} ____cacheline_aligned;\n```\n\n上面重要的有\n```c\n    /* set next event interrupt by cyclecounter or ktime */\n    int\t\t\t(*set_next_event)(unsigned long evt, struct clock_event_device *);\n\tint\t\t\t(*set_next_ktime)(ktime_t expires, struct clock_event_device *);\n\n    /* switch event mode: periodic or oneshot */\n\tint\t\t\t(*set_state_periodic)(struct clock_event_device *);\n\tint\t\t\t(*set_state_oneshot)(struct clock_event_device *);    \n```\n\n### 4.1. 常用函数\n\n```c\nextern void clockevents_config_and_register(struct clock_event_device *dev,\n\t\t\t\t\t    u32 freq, unsigned long min_delta,\n\t\t\t\t\t    unsigned long max_delta);\n\nextern void clockevents_config(struct clock_event_device *dev, u32 freq);\nextern void clockevents_register_device(struct clock_event_device *dev);\n\nextern int clockevents_unbind_device(struct clock_event_device *ced, int cpu);\n```\n\n在我们register clockevnet 后， 上层的tick layer 可能会考虑替换当前的clockevent device.\n替换参考的依据是：\n- 首先是CPU local device\n- 具备更好的rate\n\n如果current clockevent device 是broadcast device(broadcost clockevent device 主要用于在CPU sleep 时，其他CPU local timer 已经睡眠，在resume时我们可以通过broadcast device 唤醒其他CPU)，需要先close.\n\n```c\n/* linux-4.9.198 code */\n/*\n * Check, if the new registered device should be used. Called with\n * clockevents_lock held and interrupts disabled.\n */\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t/* cpu local device ? */\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t/* Preference decision */\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev);\n}\n```\n## Reference\n[Linux时间子系统之（二）：软件架构](http://www.wowotech.net/timer_subsystem/time-subsyste-architecture.html)\n\n[Linux时间子系统之（十三）：Tick Device layer 综述](http://www.wowotech.net/timer_subsystem/tick-device-layer.html)\n\n[Linux时间子系统之（十五）：clocksource](http://www.wowotech.net/timer_subsystem/clocksource.html)\n\n[Linux时间子系统之（十六）：clockevent](http://www.wowotech.net/timer_subsystem/clock-event.html)","slug":"kernel-timer-system","published":1,"updated":"2020-03-11T06:32:20.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qg002ozkgrr4moj0eu","content":"<h2 id=\"1-Kernel-Timer-软件架构\"><a href=\"#1-Kernel-Timer-软件架构\" class=\"headerlink\" title=\"1. Kernel Timer 软件架构\"></a>1. Kernel Timer 软件架构</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/kernel_timer_structure.png\" alt=\"Kernel timer structure\"></p>\n<a id=\"more\"></a>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">术语</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Global Counter</td>\n<td style=\"text-align:left\">free running system counter, 可以参看arm_arm 手册里的Generic Timer-&gt;system counter。Rollover 时间至少40年。他提供了一个基础的timeline, 无线延伸</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CPU local Timer</td>\n<td style=\"text-align:left\">CPU local timer 可以是Peripheral HW Timer, 或者是CPU 如ARM 含有的Generic Timer -&gt; timer.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">clock event</td>\n<td style=\"text-align:left\">通过timer硬件的 <strong>中断处理函数</strong> 完成的，在此基础上可以构建tick模块。clock event 是在timeline 上指定点产生event。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tick 模块</td>\n<td style=\"text-align:left\">维护了系统的tick，各个 <strong>进程的时间统计</strong> 也是基于tick的，内核的 <strong>调度器</strong> 根据这些信息进行调度。<strong>System Load和Kernel Profiling模块</strong> 也是基于tick的，用于计算系统负荷和进行内核性能剖析。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timekeeping模块</td>\n<td style=\"text-align:left\">系统时间， 每tick 的发生，其值增加。高进度的值，可以来源于clocksource</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timer lib</td>\n<td style=\"text-align:left\">用户空间需求：1.获取系统时间，time, stime, gettimeofday, 2.定时器功能，settimer, alarm等</td>\n</tr>\n</tbody>\n</table>\n<p>一个CPU 可以有多个local Clock Event， 但是会选择一个适合的作为tick device。</p>\n<p>tick device 工作模式：</p>\n<ul>\n<li>one shot mode(提供高精度的clock event)</li>\n<li>periodic mode</li>\n</ul>\n<p>一般有多少个cpu，就会有多少个tick device - local tick device, 在所有device 中会选取一个做global tick device, 负责维护整个系统的jiffies，更新wall clock，计算全局负荷等。</p>\n<p>当系统处于高精度timer的时候（tick device处于one shot mode），系统会setup一个特别的高精度timer（可以称之sched timer），该高精度timer会周期性的触发，从而模拟的传统的periodic tick，从而推动了传统低精度timer的运转。因此，一些传统的内核模块仍然可以调用经典的低精度timer模块的接口。 </p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/kernel_tick_device_structure.png\" alt=\"Tick Device Layer structure\"></p>\n<h2 id=\"2-file-structure\"><a href=\"#2-file-structure\" class=\"headerlink\" title=\"2. file structure\"></a>2. file structure</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文件</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">time.c<br>timeconv.c</td>\n<td style=\"text-align:left\">用户空间函数,time, stime, gettimeofday，alarm等，以及转换函数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">time_list.c<br>time_status.c</td>\n<td style=\"text-align:left\">向用户空间提供的调试接口。在用户空间，可以通过/proc/timer_list接口可以获得内核中的时间子系统的相关信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">posix-timer.c<br>posix-cpu-timers.c<br>posix-clock.c</td>\n<td style=\"text-align:left\">POSIX timer， clock模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">alrmtimer.c</td>\n<td style=\"text-align:left\">alarmtimer 模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ntp.c</td>\n<td style=\"text-align:left\">NTP 模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timerkeeping.c<br>timerkeeping_debug.c</td>\n<td style=\"text-align:left\">timerkeeping.c模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ick-common.c<br>tick-oneshot.c<br>tick-sched.c</td>\n<td style=\"text-align:left\">tick device layer模块。<br>tick-common.c文件是periodic tick模块，用于管理周期性tick事件。<br>tick-oneshot.c文件是for高精度timer的，用于管理高精度tick时间。<br> tick-sched.c是用于dynamic tick的。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tick-broadcast.c<br>tick-broadcast-hrtimer.c</td>\n<td style=\"text-align:left\">broadcast tick模块。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sched_clock.c</td>\n<td style=\"text-align:left\">通用sched clock模块。这个模块主要是提供一个sched_clock的接口函数，可以获取当前时间点到系统启动之间的纳秒值。底层的HW counter其实是千差万别的，有些平台可以提供64-bit的HW counter，我们可以不使用这个通用sched clock模块（不配置CONFIG_GENERIC_SCHED_CLOCK这个内核选项），而在自己的clock source chip driver中直接提供sched_clock接口。使用通用sched clock模块的好处是：该模块扩展了64-bit的counter，即使底层的HW counter比特数目不足（有些平台HW counter只有32个bit）。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">clocksource.c<br>jiffies.c</td>\n<td style=\"text-align:left\">clocksource.c是通用clocksource driver。其实也可以把system tick也看成一个特定的clocksource，其代码在jiffies.c文件中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">clockevnet.c</td>\n<td style=\"text-align:left\">clockevent 模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timer.c</td>\n<td style=\"text-align:left\">传统的低精度timer 模块， 基本tick</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">htimer.c</td>\n<td style=\"text-align:left\">高精度timer</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-clocksource\"><a href=\"#3-clocksource\" class=\"headerlink\" title=\"3. clocksource\"></a>3. clocksource</h2><p>时间其实可以抽象成一条直线, timeline. clock source就是用来抽象一个在指定输入频率的clock下工作的一个counter。输入频率可以确定以什么样的精度来划分timeline(假设输入counter的频率是1GHz，那么一个cycle就是1ns)</p>\n<p>clocksource 数据结构如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* linux-4.9.198 code */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * struct clocksource - hardware abstraction for a free running counter</span></span><br><span class=\"line\"><span class=\"comment\"> *\tProvides mostly state-free accessors to the underlying hardware.</span></span><br><span class=\"line\"><span class=\"comment\"> *\tThis is the structure used for system time.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @name:\t\tptr to clocksource name</span></span><br><span class=\"line\"><span class=\"comment\"> * @list:\t\tlist head for registration</span></span><br><span class=\"line\"><span class=\"comment\"> * @rating:\t\trating value for selection (higher is better)</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tTo avoid rating inflation the following</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tlist should give you a guide as to how</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tto assign your clocksource a rating</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t1-99: Unfit for real use</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tOnly available for bootup and testing purposes.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t100-199: Base level usability.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tFunctional for real use, but not desired.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t200-299: Good.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tA correct and usable clocksource.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t300-399: Desired.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tA reasonably fast and accurate clocksource.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t400-499: Perfect</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tThe ideal clocksource. A must-use where</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tavailable.</span></span><br><span class=\"line\"><span class=\"comment\"> * @read:\t\treturns a cycle value, passes clocksource as argument</span></span><br><span class=\"line\"><span class=\"comment\"> * @enable:\t\toptional function to enable the clocksource</span></span><br><span class=\"line\"><span class=\"comment\"> * @disable:\t\toptional function to disable the clocksource</span></span><br><span class=\"line\"><span class=\"comment\"> * @mask:\t\tbitmask for two's complement</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tsubtraction of non 64 bit counters</span></span><br><span class=\"line\"><span class=\"comment\"> * @mult:\t\tcycle to nanosecond multiplier</span></span><br><span class=\"line\"><span class=\"comment\"> * @shift:\t\tcycle to nanosecond divisor (power of two)</span></span><br><span class=\"line\"><span class=\"comment\"> * @max_idle_ns:\tmax idle time permitted by the clocksource (nsecs)</span></span><br><span class=\"line\"><span class=\"comment\"> * @maxadj:\t\tmaximum adjustment value to mult (~11%)</span></span><br><span class=\"line\"><span class=\"comment\"> * @max_cycles:\t\tmaximum safe cycle value which won't overflow on multiplication</span></span><br><span class=\"line\"><span class=\"comment\"> * @flags:\t\tflags describing special properties</span></span><br><span class=\"line\"><span class=\"comment\"> * @archdata:\t\tarch-specific data</span></span><br><span class=\"line\"><span class=\"comment\"> * @suspend:\t\tsuspend function for the clocksource, if necessary</span></span><br><span class=\"line\"><span class=\"comment\"> * @resume:\t\tresume function for the clocksource, if necessary</span></span><br><span class=\"line\"><span class=\"comment\"> * @owner:\t\tmodule reference, must be set by clocksource in modules</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: This struct is not used in hotpathes of the timekeeping code</span></span><br><span class=\"line\"><span class=\"comment\"> * because the timekeeper caches the hot path fields in its own data</span></span><br><span class=\"line\"><span class=\"comment\"> * structure, so no line cache alignment is required,</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The pointer to the clocksource itself is handed to the read</span></span><br><span class=\"line\"><span class=\"comment\"> * callback. If you need extra information there you can wrap struct</span></span><br><span class=\"line\"><span class=\"comment\"> * clocksource into your own struct. Depending on the amount of</span></span><br><span class=\"line\"><span class=\"comment\"> * information you need you should consider to cache line align that</span></span><br><span class=\"line\"><span class=\"comment\"> * structure.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">clocksource</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> (*read)(struct clocksource *cs);</span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> mask;</span><br><span class=\"line\">\tu32 mult;</span><br><span class=\"line\">\tu32 shift;</span><br><span class=\"line\">\tu64 max_idle_ns;</span><br><span class=\"line\">\tu32 maxadj;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_ARCH_CLOCKSOURCE_DATA</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">arch_clocksource_data</span> <span class=\"title\">archdata</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\tu64 max_cycles;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rating;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*enable)(struct clocksource *cs);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*disable)(struct clocksource *cs);</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*suspend)(struct clocksource *cs);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*resume)(struct clocksource *cs);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* private: */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_CLOCKSOURCE_WATCHDOG</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Watchdog related data, used by the framework */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">wd_list</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> cs_last;</span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> wd_last;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-register-unregister-clocksource\"><a href=\"#3-1-register-unregister-clocksource\" class=\"headerlink\" title=\"3.1. register/unregister clocksource\"></a>3.1. register/unregister clocksource</h3><p>系统中使用cycle_t cycles 进行计数， 为了人们的方便会转换成年月日方式，所以就会用mult, shift（乘法，除法系数）进行转换。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> s64 <span class=\"title\">clocksource_cyc2ns</span><span class=\"params\">(<span class=\"keyword\">cycle_t</span> cycles, u32 mult, u32 shift)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((u64) cycles * mult) &gt;&gt; shift;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* need to calculate mult, shift by caller */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">clocksource_register</span><span class=\"params\">(struct clocksource *cs)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* os will calculate mult, shift */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">clocksource_register_hz</span><span class=\"params\">(struct clocksource *cs,  u32 hz)</span> </span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">clocksource_register_khz</span><span class=\"params\">(struct clocksource *cs,  u32 khz)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">clocksource_unbind</span><span class=\"params\">(struct clocksource *cs)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-OS选择clock-source\"><a href=\"#3-2-OS选择clock-source\" class=\"headerlink\" title=\"3.2. OS选择clock source\"></a>3.2. OS选择clock source</h3><p>主要参看的因素有两个：</p>\n<ul>\n<li>best rate （分辨率越高的）</li>\n<li>用户空间的选择<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __clocksource_select(<span class=\"keyword\">bool</span> skipcur)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-3-timecounter-与-cyclecounter\"><a href=\"#3-3-timecounter-与-cyclecounter\" class=\"headerlink\" title=\"3.3. timecounter 与 cyclecounter\"></a>3.3. timecounter 与 cyclecounter</h3><p>具体来讲， cyclecounter 表示free running system counter 绝对的时间点, 而timecounter 表示counter， 但是表达的是ns 时间单位。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * struct cyclecounter - hardware abstraction for a free running counter</span></span><br><span class=\"line\"><span class=\"comment\"> *\tProvides completely state-free accessors to the underlying hardware.</span></span><br><span class=\"line\"><span class=\"comment\"> *\tDepending on which hardware it reads, the cycle counter may wrap</span></span><br><span class=\"line\"><span class=\"comment\"> *\taround quickly. Locking rules (if necessary) have to be defined</span></span><br><span class=\"line\"><span class=\"comment\"> *\tby the implementor and user of specific instances of this API.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @read:\t\treturns the current cycle value</span></span><br><span class=\"line\"><span class=\"comment\"> * @mask:\t\tbitmask for two's complement</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tsubtraction of non 64 bit counters,</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tsee CYCLECOUNTER_MASK() helper macro</span></span><br><span class=\"line\"><span class=\"comment\"> * @mult:\t\tcycle to nanosecond multiplier</span></span><br><span class=\"line\"><span class=\"comment\"> * @shift:\t\tcycle to nanosecond divisor (power of two)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cyclecounter</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> (*read)(<span class=\"keyword\">const</span> struct cyclecounter *cc);</span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> mask;</span><br><span class=\"line\">\tu32 mult;</span><br><span class=\"line\">\tu32 shift;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * struct timecounter - layer above a %struct cyclecounter which counts nanoseconds</span></span><br><span class=\"line\"><span class=\"comment\"> *\tContains the state needed by timecounter_read() to detect</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcycle counter wrap around. Initialize with</span></span><br><span class=\"line\"><span class=\"comment\"> *\ttimecounter_init(). Also used to convert cycle counts into the</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcorresponding nanosecond counts with timecounter_cyc2time(). Users</span></span><br><span class=\"line\"><span class=\"comment\"> *\tof this code are responsible for initializing the underlying</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcycle counter hardware, locking issues and reading the time</span></span><br><span class=\"line\"><span class=\"comment\"> *\tmore often than the cycle counter wraps around. The nanosecond</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcounter will only wrap around after ~585 years.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @cc:\t\t\tthe cycle counter used by this instance</span></span><br><span class=\"line\"><span class=\"comment\"> * @cycle_last:\t\tmost recent cycle counter value seen by</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\ttimecounter_read()</span></span><br><span class=\"line\"><span class=\"comment\"> * @nsec:\t\tcontinuously increasing count</span></span><br><span class=\"line\"><span class=\"comment\"> * @mask:\t\tbit mask for maintaining the 'frac' field</span></span><br><span class=\"line\"><span class=\"comment\"> * @frac:\t\taccumulated fractional nanoseconds</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timecounter</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cyclecounter</span> *<span class=\"title\">cc</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> cycle_last;</span><br><span class=\"line\">\tu64 nsec;</span><br><span class=\"line\">\tu64 mask;</span><br><span class=\"line\">\tu64 frac;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-clockevent\"><a href=\"#4-clockevent\" class=\"headerlink\" title=\"4. clockevent\"></a>4. clockevent</h2><p>clockevent 数据结构如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * struct clock_event_device - clock event device descriptor</span></span><br><span class=\"line\"><span class=\"comment\"> * @event_handler:\tAssigned by the framework to be called by the low</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tlevel handler of the event source</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_next_event:\tset next event function using a clocksource delta</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_next_ktime:\tset next event function using a direct ktime value</span></span><br><span class=\"line\"><span class=\"comment\"> * @next_event:\t\tlocal storage for the next event in oneshot mode</span></span><br><span class=\"line\"><span class=\"comment\"> * @max_delta_ns:\tmaximum delta value in ns</span></span><br><span class=\"line\"><span class=\"comment\"> * @min_delta_ns:\tminimum delta value in ns</span></span><br><span class=\"line\"><span class=\"comment\"> * @mult:\t\tnanosecond to cycles multiplier</span></span><br><span class=\"line\"><span class=\"comment\"> * @shift:\t\tnanoseconds to cycles divisor (power of two)</span></span><br><span class=\"line\"><span class=\"comment\"> * @state_use_accessors:current state of the device, assigned by the core code</span></span><br><span class=\"line\"><span class=\"comment\"> * @features:\t\tfeatures</span></span><br><span class=\"line\"><span class=\"comment\"> * @retries:\t\tnumber of forced programming retries</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_state_periodic:\tswitch state to periodic</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_state_oneshot:\tswitch state to oneshot</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_state_oneshot_stopped: switch state to oneshot_stopped</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_state_shutdown:\tswitch state to shutdown</span></span><br><span class=\"line\"><span class=\"comment\"> * @tick_resume:\tresume clkevt device</span></span><br><span class=\"line\"><span class=\"comment\"> * @broadcast:\t\tfunction to broadcast events</span></span><br><span class=\"line\"><span class=\"comment\"> * @min_delta_ticks:\tminimum delta value in ticks stored for reconfiguration</span></span><br><span class=\"line\"><span class=\"comment\"> * @max_delta_ticks:\tmaximum delta value in ticks stored for reconfiguration</span></span><br><span class=\"line\"><span class=\"comment\"> * @name:\t\tptr to clock event name</span></span><br><span class=\"line\"><span class=\"comment\"> * @rating:\t\tvariable to rate clock event devices</span></span><br><span class=\"line\"><span class=\"comment\"> * @irq:\t\tIRQ number (only for non CPU local devices)</span></span><br><span class=\"line\"><span class=\"comment\"> * @bound_on:\t\tBound on CPU</span></span><br><span class=\"line\"><span class=\"comment\"> * @cpumask:\t\tcpumask to indicate for which CPUs this device works</span></span><br><span class=\"line\"><span class=\"comment\"> * @list:\t\tlist head for the management code</span></span><br><span class=\"line\"><span class=\"comment\"> * @owner:\t\tmodule reference</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">clock_event_device</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*event_handler)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_next_event)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> evt, struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_next_ktime)(<span class=\"keyword\">ktime_t</span> expires, struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\tnext_event;</span><br><span class=\"line\">\tu64\t\t\tmax_delta_ns;</span><br><span class=\"line\">\tu64\t\t\tmin_delta_ns;</span><br><span class=\"line\">\tu32\t\t\tmult;</span><br><span class=\"line\">\tu32\t\t\tshift;</span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> clock_event_state\tstate_use_accessors;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\t\tfeatures;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\tretries;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_state_periodic)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_state_oneshot)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_state_oneshot_stopped)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_state_shutdown)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*tick_resume)(struct clock_event_device *);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*broadcast)(<span class=\"keyword\">const</span> struct cpumask *mask);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*suspend)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*resume)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\tmin_delta_ticks;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\tmax_delta_ticks;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t\t*name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\trating;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\tirq;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\tbound_on;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cpumask</span>\t*<span class=\"title\">cpumask</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>\t<span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span>\t\t*<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>\n<p>上面重要的有<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">/* set next event interrupt by cyclecounter or ktime */</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span>\t\t\t(*set_next_event)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> evt, struct clock_event_device *);</span><br><span class=\"line\"><span class=\"keyword\">int</span>\t\t\t(*set_next_ktime)(<span class=\"keyword\">ktime_t</span> expires, struct clock_event_device *);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* switch event mode: periodic or oneshot */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>\t\t\t(*set_state_periodic)(struct clock_event_device *);</span><br><span class=\"line\"><span class=\"keyword\">int</span>\t\t\t(*set_state_oneshot)(struct clock_event_device *);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-1-常用函数\"><a href=\"#4-1-常用函数\" class=\"headerlink\" title=\"4.1. 常用函数\"></a>4.1. 常用函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">clockevents_config_and_register</span><span class=\"params\">(struct clock_event_device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t    u32 freq, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> min_delta,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> max_delta)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">clockevents_config</span><span class=\"params\">(struct clock_event_device *dev, u32 freq)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">clockevents_register_device</span><span class=\"params\">(struct clock_event_device *dev)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">clockevents_unbind_device</span><span class=\"params\">(struct clock_event_device *ced, <span class=\"keyword\">int</span> cpu)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在我们register clockevnet 后， 上层的tick layer 可能会考虑替换当前的clockevent device.<br>替换参考的依据是：</p>\n<ul>\n<li>首先是CPU local device</li>\n<li>具备更好的rate</li>\n</ul>\n<p>如果current clockevent device 是broadcast device(broadcost clockevent device 主要用于在CPU sleep 时，其他CPU local timer 已经睡眠，在resume时我们可以通过broadcast device 唤醒其他CPU)，需要先close.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* linux-4.9.198 code */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Check, if the new registered device should be used. Called with</span></span><br><span class=\"line\"><span class=\"comment\"> * clockevents_lock held and interrupts disabled.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tick_check_new_device</span><span class=\"params\">(struct clock_event_device *newdev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">clock_event_device</span> *<span class=\"title\">curdev</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tick_device</span> *<span class=\"title\">td</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cpu;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcpu = smp_processor_id();</span><br><span class=\"line\">\ttd = &amp;per_cpu(tick_cpu_device, cpu);</span><br><span class=\"line\">\tcurdev = td-&gt;evtdev;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* cpu local device ? */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!tick_check_percpu(curdev, newdev, cpu))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out_bc;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Preference decision */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!tick_check_preferred(curdev, newdev))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out_bc;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!try_module_get(newdev-&gt;owner))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Replace the eventually existing device by the new</span></span><br><span class=\"line\"><span class=\"comment\">\t * device. If the current device is the broadcast device, do</span></span><br><span class=\"line\"><span class=\"comment\">\t * not give it back to the clockevents layer !</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tick_is_broadcast_device(curdev)) &#123;</span><br><span class=\"line\">\t\tclockevents_shutdown(curdev);</span><br><span class=\"line\">\t\tcurdev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclockevents_exchange_device(curdev, newdev);</span><br><span class=\"line\">\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)</span><br><span class=\"line\">\t\ttick_oneshot_notify();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">out_bc:</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Can the new device be used as a broadcast device ?</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\ttick_install_broadcast_device(newdev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/timer_subsystem/time-subsyste-architecture.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（二）：软件架构</a></p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/tick-device-layer.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十三）：Tick Device layer 综述</a></p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/clocksource.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十五）：clocksource</a></p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/clock-event.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十六）：clockevent</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-Kernel-Timer-软件架构\"><a href=\"#1-Kernel-Timer-软件架构\" class=\"headerlink\" title=\"1. Kernel Timer 软件架构\"></a>1. Kernel Timer 软件架构</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/kernel_timer_structure.png\" alt=\"Kernel timer structure\"></p>","more":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">术语</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Global Counter</td>\n<td style=\"text-align:left\">free running system counter, 可以参看arm_arm 手册里的Generic Timer-&gt;system counter。Rollover 时间至少40年。他提供了一个基础的timeline, 无线延伸</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CPU local Timer</td>\n<td style=\"text-align:left\">CPU local timer 可以是Peripheral HW Timer, 或者是CPU 如ARM 含有的Generic Timer -&gt; timer.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">clock event</td>\n<td style=\"text-align:left\">通过timer硬件的 <strong>中断处理函数</strong> 完成的，在此基础上可以构建tick模块。clock event 是在timeline 上指定点产生event。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tick 模块</td>\n<td style=\"text-align:left\">维护了系统的tick，各个 <strong>进程的时间统计</strong> 也是基于tick的，内核的 <strong>调度器</strong> 根据这些信息进行调度。<strong>System Load和Kernel Profiling模块</strong> 也是基于tick的，用于计算系统负荷和进行内核性能剖析。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timekeeping模块</td>\n<td style=\"text-align:left\">系统时间， 每tick 的发生，其值增加。高进度的值，可以来源于clocksource</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timer lib</td>\n<td style=\"text-align:left\">用户空间需求：1.获取系统时间，time, stime, gettimeofday, 2.定时器功能，settimer, alarm等</td>\n</tr>\n</tbody>\n</table>\n<p>一个CPU 可以有多个local Clock Event， 但是会选择一个适合的作为tick device。</p>\n<p>tick device 工作模式：</p>\n<ul>\n<li>one shot mode(提供高精度的clock event)</li>\n<li>periodic mode</li>\n</ul>\n<p>一般有多少个cpu，就会有多少个tick device - local tick device, 在所有device 中会选取一个做global tick device, 负责维护整个系统的jiffies，更新wall clock，计算全局负荷等。</p>\n<p>当系统处于高精度timer的时候（tick device处于one shot mode），系统会setup一个特别的高精度timer（可以称之sched timer），该高精度timer会周期性的触发，从而模拟的传统的periodic tick，从而推动了传统低精度timer的运转。因此，一些传统的内核模块仍然可以调用经典的低精度timer模块的接口。 </p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_timer_system/kernel_tick_device_structure.png\" alt=\"Tick Device Layer structure\"></p>\n<h2 id=\"2-file-structure\"><a href=\"#2-file-structure\" class=\"headerlink\" title=\"2. file structure\"></a>2. file structure</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文件</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">time.c<br>timeconv.c</td>\n<td style=\"text-align:left\">用户空间函数,time, stime, gettimeofday，alarm等，以及转换函数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">time_list.c<br>time_status.c</td>\n<td style=\"text-align:left\">向用户空间提供的调试接口。在用户空间，可以通过/proc/timer_list接口可以获得内核中的时间子系统的相关信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">posix-timer.c<br>posix-cpu-timers.c<br>posix-clock.c</td>\n<td style=\"text-align:left\">POSIX timer， clock模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">alrmtimer.c</td>\n<td style=\"text-align:left\">alarmtimer 模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ntp.c</td>\n<td style=\"text-align:left\">NTP 模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timerkeeping.c<br>timerkeeping_debug.c</td>\n<td style=\"text-align:left\">timerkeeping.c模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ick-common.c<br>tick-oneshot.c<br>tick-sched.c</td>\n<td style=\"text-align:left\">tick device layer模块。<br>tick-common.c文件是periodic tick模块，用于管理周期性tick事件。<br>tick-oneshot.c文件是for高精度timer的，用于管理高精度tick时间。<br> tick-sched.c是用于dynamic tick的。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tick-broadcast.c<br>tick-broadcast-hrtimer.c</td>\n<td style=\"text-align:left\">broadcast tick模块。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sched_clock.c</td>\n<td style=\"text-align:left\">通用sched clock模块。这个模块主要是提供一个sched_clock的接口函数，可以获取当前时间点到系统启动之间的纳秒值。底层的HW counter其实是千差万别的，有些平台可以提供64-bit的HW counter，我们可以不使用这个通用sched clock模块（不配置CONFIG_GENERIC_SCHED_CLOCK这个内核选项），而在自己的clock source chip driver中直接提供sched_clock接口。使用通用sched clock模块的好处是：该模块扩展了64-bit的counter，即使底层的HW counter比特数目不足（有些平台HW counter只有32个bit）。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">clocksource.c<br>jiffies.c</td>\n<td style=\"text-align:left\">clocksource.c是通用clocksource driver。其实也可以把system tick也看成一个特定的clocksource，其代码在jiffies.c文件中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">clockevnet.c</td>\n<td style=\"text-align:left\">clockevent 模块</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timer.c</td>\n<td style=\"text-align:left\">传统的低精度timer 模块， 基本tick</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">htimer.c</td>\n<td style=\"text-align:left\">高精度timer</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-clocksource\"><a href=\"#3-clocksource\" class=\"headerlink\" title=\"3. clocksource\"></a>3. clocksource</h2><p>时间其实可以抽象成一条直线, timeline. clock source就是用来抽象一个在指定输入频率的clock下工作的一个counter。输入频率可以确定以什么样的精度来划分timeline(假设输入counter的频率是1GHz，那么一个cycle就是1ns)</p>\n<p>clocksource 数据结构如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* linux-4.9.198 code */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * struct clocksource - hardware abstraction for a free running counter</span></span><br><span class=\"line\"><span class=\"comment\"> *\tProvides mostly state-free accessors to the underlying hardware.</span></span><br><span class=\"line\"><span class=\"comment\"> *\tThis is the structure used for system time.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @name:\t\tptr to clocksource name</span></span><br><span class=\"line\"><span class=\"comment\"> * @list:\t\tlist head for registration</span></span><br><span class=\"line\"><span class=\"comment\"> * @rating:\t\trating value for selection (higher is better)</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tTo avoid rating inflation the following</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tlist should give you a guide as to how</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tto assign your clocksource a rating</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t1-99: Unfit for real use</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tOnly available for bootup and testing purposes.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t100-199: Base level usability.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tFunctional for real use, but not desired.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t200-299: Good.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tA correct and usable clocksource.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t300-399: Desired.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tA reasonably fast and accurate clocksource.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t400-499: Perfect</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tThe ideal clocksource. A must-use where</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tavailable.</span></span><br><span class=\"line\"><span class=\"comment\"> * @read:\t\treturns a cycle value, passes clocksource as argument</span></span><br><span class=\"line\"><span class=\"comment\"> * @enable:\t\toptional function to enable the clocksource</span></span><br><span class=\"line\"><span class=\"comment\"> * @disable:\t\toptional function to disable the clocksource</span></span><br><span class=\"line\"><span class=\"comment\"> * @mask:\t\tbitmask for two's complement</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tsubtraction of non 64 bit counters</span></span><br><span class=\"line\"><span class=\"comment\"> * @mult:\t\tcycle to nanosecond multiplier</span></span><br><span class=\"line\"><span class=\"comment\"> * @shift:\t\tcycle to nanosecond divisor (power of two)</span></span><br><span class=\"line\"><span class=\"comment\"> * @max_idle_ns:\tmax idle time permitted by the clocksource (nsecs)</span></span><br><span class=\"line\"><span class=\"comment\"> * @maxadj:\t\tmaximum adjustment value to mult (~11%)</span></span><br><span class=\"line\"><span class=\"comment\"> * @max_cycles:\t\tmaximum safe cycle value which won't overflow on multiplication</span></span><br><span class=\"line\"><span class=\"comment\"> * @flags:\t\tflags describing special properties</span></span><br><span class=\"line\"><span class=\"comment\"> * @archdata:\t\tarch-specific data</span></span><br><span class=\"line\"><span class=\"comment\"> * @suspend:\t\tsuspend function for the clocksource, if necessary</span></span><br><span class=\"line\"><span class=\"comment\"> * @resume:\t\tresume function for the clocksource, if necessary</span></span><br><span class=\"line\"><span class=\"comment\"> * @owner:\t\tmodule reference, must be set by clocksource in modules</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: This struct is not used in hotpathes of the timekeeping code</span></span><br><span class=\"line\"><span class=\"comment\"> * because the timekeeper caches the hot path fields in its own data</span></span><br><span class=\"line\"><span class=\"comment\"> * structure, so no line cache alignment is required,</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The pointer to the clocksource itself is handed to the read</span></span><br><span class=\"line\"><span class=\"comment\"> * callback. If you need extra information there you can wrap struct</span></span><br><span class=\"line\"><span class=\"comment\"> * clocksource into your own struct. Depending on the amount of</span></span><br><span class=\"line\"><span class=\"comment\"> * information you need you should consider to cache line align that</span></span><br><span class=\"line\"><span class=\"comment\"> * structure.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">clocksource</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> (*read)(struct clocksource *cs);</span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> mask;</span><br><span class=\"line\">\tu32 mult;</span><br><span class=\"line\">\tu32 shift;</span><br><span class=\"line\">\tu64 max_idle_ns;</span><br><span class=\"line\">\tu32 maxadj;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_ARCH_CLOCKSOURCE_DATA</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">arch_clocksource_data</span> <span class=\"title\">archdata</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\tu64 max_cycles;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rating;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*enable)(struct clocksource *cs);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*disable)(struct clocksource *cs);</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*suspend)(struct clocksource *cs);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*resume)(struct clocksource *cs);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* private: */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_CLOCKSOURCE_WATCHDOG</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Watchdog related data, used by the framework */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">wd_list</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> cs_last;</span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> wd_last;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-register-unregister-clocksource\"><a href=\"#3-1-register-unregister-clocksource\" class=\"headerlink\" title=\"3.1. register/unregister clocksource\"></a>3.1. register/unregister clocksource</h3><p>系统中使用cycle_t cycles 进行计数， 为了人们的方便会转换成年月日方式，所以就会用mult, shift（乘法，除法系数）进行转换。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> s64 <span class=\"title\">clocksource_cyc2ns</span><span class=\"params\">(<span class=\"keyword\">cycle_t</span> cycles, u32 mult, u32 shift)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((u64) cycles * mult) &gt;&gt; shift;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* need to calculate mult, shift by caller */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">clocksource_register</span><span class=\"params\">(struct clocksource *cs)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* os will calculate mult, shift */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">clocksource_register_hz</span><span class=\"params\">(struct clocksource *cs,  u32 hz)</span> </span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">clocksource_register_khz</span><span class=\"params\">(struct clocksource *cs,  u32 khz)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">clocksource_unbind</span><span class=\"params\">(struct clocksource *cs)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-OS选择clock-source\"><a href=\"#3-2-OS选择clock-source\" class=\"headerlink\" title=\"3.2. OS选择clock source\"></a>3.2. OS选择clock source</h3><p>主要参看的因素有两个：</p>\n<ul>\n<li>best rate （分辨率越高的）</li>\n<li>用户空间的选择<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __clocksource_select(<span class=\"keyword\">bool</span> skipcur)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-3-timecounter-与-cyclecounter\"><a href=\"#3-3-timecounter-与-cyclecounter\" class=\"headerlink\" title=\"3.3. timecounter 与 cyclecounter\"></a>3.3. timecounter 与 cyclecounter</h3><p>具体来讲， cyclecounter 表示free running system counter 绝对的时间点, 而timecounter 表示counter， 但是表达的是ns 时间单位。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * struct cyclecounter - hardware abstraction for a free running counter</span></span><br><span class=\"line\"><span class=\"comment\"> *\tProvides completely state-free accessors to the underlying hardware.</span></span><br><span class=\"line\"><span class=\"comment\"> *\tDepending on which hardware it reads, the cycle counter may wrap</span></span><br><span class=\"line\"><span class=\"comment\"> *\taround quickly. Locking rules (if necessary) have to be defined</span></span><br><span class=\"line\"><span class=\"comment\"> *\tby the implementor and user of specific instances of this API.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @read:\t\treturns the current cycle value</span></span><br><span class=\"line\"><span class=\"comment\"> * @mask:\t\tbitmask for two's complement</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tsubtraction of non 64 bit counters,</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tsee CYCLECOUNTER_MASK() helper macro</span></span><br><span class=\"line\"><span class=\"comment\"> * @mult:\t\tcycle to nanosecond multiplier</span></span><br><span class=\"line\"><span class=\"comment\"> * @shift:\t\tcycle to nanosecond divisor (power of two)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cyclecounter</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> (*read)(<span class=\"keyword\">const</span> struct cyclecounter *cc);</span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> mask;</span><br><span class=\"line\">\tu32 mult;</span><br><span class=\"line\">\tu32 shift;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * struct timecounter - layer above a %struct cyclecounter which counts nanoseconds</span></span><br><span class=\"line\"><span class=\"comment\"> *\tContains the state needed by timecounter_read() to detect</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcycle counter wrap around. Initialize with</span></span><br><span class=\"line\"><span class=\"comment\"> *\ttimecounter_init(). Also used to convert cycle counts into the</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcorresponding nanosecond counts with timecounter_cyc2time(). Users</span></span><br><span class=\"line\"><span class=\"comment\"> *\tof this code are responsible for initializing the underlying</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcycle counter hardware, locking issues and reading the time</span></span><br><span class=\"line\"><span class=\"comment\"> *\tmore often than the cycle counter wraps around. The nanosecond</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcounter will only wrap around after ~585 years.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @cc:\t\t\tthe cycle counter used by this instance</span></span><br><span class=\"line\"><span class=\"comment\"> * @cycle_last:\t\tmost recent cycle counter value seen by</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\ttimecounter_read()</span></span><br><span class=\"line\"><span class=\"comment\"> * @nsec:\t\tcontinuously increasing count</span></span><br><span class=\"line\"><span class=\"comment\"> * @mask:\t\tbit mask for maintaining the 'frac' field</span></span><br><span class=\"line\"><span class=\"comment\"> * @frac:\t\taccumulated fractional nanoseconds</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timecounter</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cyclecounter</span> *<span class=\"title\">cc</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">cycle_t</span> cycle_last;</span><br><span class=\"line\">\tu64 nsec;</span><br><span class=\"line\">\tu64 mask;</span><br><span class=\"line\">\tu64 frac;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-clockevent\"><a href=\"#4-clockevent\" class=\"headerlink\" title=\"4. clockevent\"></a>4. clockevent</h2><p>clockevent 数据结构如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * struct clock_event_device - clock event device descriptor</span></span><br><span class=\"line\"><span class=\"comment\"> * @event_handler:\tAssigned by the framework to be called by the low</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\tlevel handler of the event source</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_next_event:\tset next event function using a clocksource delta</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_next_ktime:\tset next event function using a direct ktime value</span></span><br><span class=\"line\"><span class=\"comment\"> * @next_event:\t\tlocal storage for the next event in oneshot mode</span></span><br><span class=\"line\"><span class=\"comment\"> * @max_delta_ns:\tmaximum delta value in ns</span></span><br><span class=\"line\"><span class=\"comment\"> * @min_delta_ns:\tminimum delta value in ns</span></span><br><span class=\"line\"><span class=\"comment\"> * @mult:\t\tnanosecond to cycles multiplier</span></span><br><span class=\"line\"><span class=\"comment\"> * @shift:\t\tnanoseconds to cycles divisor (power of two)</span></span><br><span class=\"line\"><span class=\"comment\"> * @state_use_accessors:current state of the device, assigned by the core code</span></span><br><span class=\"line\"><span class=\"comment\"> * @features:\t\tfeatures</span></span><br><span class=\"line\"><span class=\"comment\"> * @retries:\t\tnumber of forced programming retries</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_state_periodic:\tswitch state to periodic</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_state_oneshot:\tswitch state to oneshot</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_state_oneshot_stopped: switch state to oneshot_stopped</span></span><br><span class=\"line\"><span class=\"comment\"> * @set_state_shutdown:\tswitch state to shutdown</span></span><br><span class=\"line\"><span class=\"comment\"> * @tick_resume:\tresume clkevt device</span></span><br><span class=\"line\"><span class=\"comment\"> * @broadcast:\t\tfunction to broadcast events</span></span><br><span class=\"line\"><span class=\"comment\"> * @min_delta_ticks:\tminimum delta value in ticks stored for reconfiguration</span></span><br><span class=\"line\"><span class=\"comment\"> * @max_delta_ticks:\tmaximum delta value in ticks stored for reconfiguration</span></span><br><span class=\"line\"><span class=\"comment\"> * @name:\t\tptr to clock event name</span></span><br><span class=\"line\"><span class=\"comment\"> * @rating:\t\tvariable to rate clock event devices</span></span><br><span class=\"line\"><span class=\"comment\"> * @irq:\t\tIRQ number (only for non CPU local devices)</span></span><br><span class=\"line\"><span class=\"comment\"> * @bound_on:\t\tBound on CPU</span></span><br><span class=\"line\"><span class=\"comment\"> * @cpumask:\t\tcpumask to indicate for which CPUs this device works</span></span><br><span class=\"line\"><span class=\"comment\"> * @list:\t\tlist head for the management code</span></span><br><span class=\"line\"><span class=\"comment\"> * @owner:\t\tmodule reference</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">clock_event_device</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*event_handler)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_next_event)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> evt, struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_next_ktime)(<span class=\"keyword\">ktime_t</span> expires, struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">ktime_t</span>\t\t\tnext_event;</span><br><span class=\"line\">\tu64\t\t\tmax_delta_ns;</span><br><span class=\"line\">\tu64\t\t\tmin_delta_ns;</span><br><span class=\"line\">\tu32\t\t\tmult;</span><br><span class=\"line\">\tu32\t\t\tshift;</span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> clock_event_state\tstate_use_accessors;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\t\tfeatures;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\tretries;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_state_periodic)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_state_oneshot)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_state_oneshot_stopped)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*set_state_shutdown)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\t(*tick_resume)(struct clock_event_device *);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*broadcast)(<span class=\"keyword\">const</span> struct cpumask *mask);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*suspend)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*resume)(struct clock_event_device *);</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\tmin_delta_ticks;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\t\tmax_delta_ticks;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t\t*name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\trating;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\tirq;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\tbound_on;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cpumask</span>\t*<span class=\"title\">cpumask</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>\t<span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span>\t\t*<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>\n<p>上面重要的有<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">/* set next event interrupt by cyclecounter or ktime */</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span>\t\t\t(*set_next_event)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> evt, struct clock_event_device *);</span><br><span class=\"line\"><span class=\"keyword\">int</span>\t\t\t(*set_next_ktime)(<span class=\"keyword\">ktime_t</span> expires, struct clock_event_device *);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* switch event mode: periodic or oneshot */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>\t\t\t(*set_state_periodic)(struct clock_event_device *);</span><br><span class=\"line\"><span class=\"keyword\">int</span>\t\t\t(*set_state_oneshot)(struct clock_event_device *);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-1-常用函数\"><a href=\"#4-1-常用函数\" class=\"headerlink\" title=\"4.1. 常用函数\"></a>4.1. 常用函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">clockevents_config_and_register</span><span class=\"params\">(struct clock_event_device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t    u32 freq, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> min_delta,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> max_delta)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">clockevents_config</span><span class=\"params\">(struct clock_event_device *dev, u32 freq)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">clockevents_register_device</span><span class=\"params\">(struct clock_event_device *dev)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">clockevents_unbind_device</span><span class=\"params\">(struct clock_event_device *ced, <span class=\"keyword\">int</span> cpu)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在我们register clockevnet 后， 上层的tick layer 可能会考虑替换当前的clockevent device.<br>替换参考的依据是：</p>\n<ul>\n<li>首先是CPU local device</li>\n<li>具备更好的rate</li>\n</ul>\n<p>如果current clockevent device 是broadcast device(broadcost clockevent device 主要用于在CPU sleep 时，其他CPU local timer 已经睡眠，在resume时我们可以通过broadcast device 唤醒其他CPU)，需要先close.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* linux-4.9.198 code */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Check, if the new registered device should be used. Called with</span></span><br><span class=\"line\"><span class=\"comment\"> * clockevents_lock held and interrupts disabled.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tick_check_new_device</span><span class=\"params\">(struct clock_event_device *newdev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">clock_event_device</span> *<span class=\"title\">curdev</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tick_device</span> *<span class=\"title\">td</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cpu;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcpu = smp_processor_id();</span><br><span class=\"line\">\ttd = &amp;per_cpu(tick_cpu_device, cpu);</span><br><span class=\"line\">\tcurdev = td-&gt;evtdev;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* cpu local device ? */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!tick_check_percpu(curdev, newdev, cpu))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out_bc;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Preference decision */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!tick_check_preferred(curdev, newdev))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out_bc;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!try_module_get(newdev-&gt;owner))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Replace the eventually existing device by the new</span></span><br><span class=\"line\"><span class=\"comment\">\t * device. If the current device is the broadcast device, do</span></span><br><span class=\"line\"><span class=\"comment\">\t * not give it back to the clockevents layer !</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tick_is_broadcast_device(curdev)) &#123;</span><br><span class=\"line\">\t\tclockevents_shutdown(curdev);</span><br><span class=\"line\">\t\tcurdev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclockevents_exchange_device(curdev, newdev);</span><br><span class=\"line\">\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)</span><br><span class=\"line\">\t\ttick_oneshot_notify();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">out_bc:</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Can the new device be used as a broadcast device ?</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\ttick_install_broadcast_device(newdev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/timer_subsystem/time-subsyste-architecture.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（二）：软件架构</a></p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/tick-device-layer.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十三）：Tick Device layer 综述</a></p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/clocksource.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十五）：clocksource</a></p>\n<p><a href=\"http://www.wowotech.net/timer_subsystem/clock-event.html\" target=\"_blank\" rel=\"noopener\">Linux时间子系统之（十六）：clockevent</a></p>"},{"title":"kernel_tlb","date":"2020-03-12T02:48:52.000Z","_content":"\nTLB(Translation lookaside buffer) 本质上也是一种cache， 物理特性与D/I Cache 类似（SDRAM）。D/I Cache 中cache 的是数据或者指令，而TLB帮助cpu 取指或执行访问mem指令时将VA（Virtual Address）转换成PA（Physical Address）, 减少HW translation table walk 访问main mem 中的page tables，他在armv7 架构中的位置可以参看：\n\n<!--more-->\n\n![arm cortex-a7 structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/arm_cortex-a7_mpcore_cpu_structure.png)\n\nTLB 一般还分为两大类：\n- main tlb (常规的tlb)\n- micro tlb (用于加速Data, Instructions的快速访问)\n\n## 1. work flow\nArmv7 ARM(architecture reference manual)中并没有规定TLB 具体的数据结构， 不过他主要包括：\n- 物理地址（更准确的说是physical page number）。这是地址翻译的结果\n- 虚拟地址（更准确的说是virtual page number）。用cache的术语来描述的话应该叫做Tag，进行匹配的时候就是对比Tag\n- Memory attribute（例如：memory type，cache policies，access permissions）\n- status bits（例如：Valid、dirty和reference bits\n- 其他相关信息。例如ASID、VMID\n\n当需要转换VA到PA的时候，首先在TLB中找是否有匹配的条目，如果有，那么TLB hit，这时候不需要再去访问页表来完成地址翻译。不过TLB始终是全部页表的一个子集，因此也有可能在TLB中找不到。如果没有在TLB中找到对应的item，那么称之TLB miss，那么就需要去访问memory中的page table来完成地址翻译，同时将翻译结果放入TLB。\n\n![tlb work flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/tlb_work_flow.gif)\n\n## 2. TLB Match\n整个地址翻译过程并非简单的VA到PA的映射那么简单，系统中虚拟地址空间很多，每个地址空间都是独立的。可以考虑如下情况：\n1. userspace 的进程都是独立虚拟空间，各个进程不同的虚拟地址空间中，相同的VA需翻译成不同的PA\n2. 若支持virtual extension。guest os 之间相同的VA 也要通过过VA->IPA->PA 形式转换成不同的PA\n3. secure, non-secure 虚拟的地址空间\n4. Global 地址如OS TEXT段与Non Global 地址\n   \n因此，只有在满足一定的条件才能说TLB match：\n1. 请求VA page number 与TLB TAG 中VA page number相等；\n2. 请求VA 的memory space identifiler 与TLB entry中memory space identifiler 相同。space ID区分PL1,2 或secure, non-secure level；\n3. 请求entry 为Non Global时，请求翻译的地址的ASID 与TLB 中相等。\n4. 请求地址翻译的VMID 等于TLB entry 中VMID 相等。 \n\n### 2.1. ASID(Address Space Identifier)\n在进程切换的时候，将TLB中的所有内容全部flush掉（全部置为无效），这样的设计当然很清爽，但是性能会大打折扣。\n一个比较好的方案是区分Global pages （内核地址空间）和Process-specific pages（参考页表描述符的nG的定义）。对于Global pages，地址翻译对所有操作系统中的进程都是一样的，因此，进程切换的时候，下一个进程仍然需要这些TLB entry，因而不需要flush掉。对于那些Process-specific pages对应的TLB entry，一旦发生切换，而TLB又不能识别的话，那么必须要flush掉上一个进程虚拟地址空间的TLB entry。如果支持了ASID，那么情况就不一样了：对于那些nG的地址映射，它会有一个ASID，对于TLB的entry而言，即便是保存多个相同虚拟地址到不同物理地址的映射也是OK的，只要他们有不同的ASID。 \n\n### 2.2. VMID(Vitural Machine Identifier)\n与ASID 存在意义类似， 在切换虚拟机的时候具有加速作用。\n\n## 3.translation table\nVMSAv7 支持两种格式translation table\n`Short-descriptor format`\nThis is the original format defined in issue A of this Architecture Reference Manual, and is the only\nformat supported on implementations that do not include the Large Physical Address Extension. \n- Up to two levels of address lookup.\n- 32-bit input addresses.Output addresses of up to 40 bits.\n- Support for PAs of more than 32 bits by use of supersections, with 16MB granularity.\n- 32-bit table entries.\n  \n`Long-descriptor format`\n- Up to three levels of address lookup.\n- Input addresses of up to 40 bits, when used for stage 2 translations.\n- Output addresses of up to 40 bits.\n- 4KB assignment granularity across the entire PA range.\n- 64-bit table entries.\n  \nTTBCR.EAE 的配置决定采用何种格式转换表。\n\n`Translation table base config`\n\n|                    Config Register                    | Control Register | Remarks                                                                                                                 |\n| :---------------------------------------------------: | :--------------: | :---------------------------------------------------------------------------------------------------------------------- |\n|   HTTBR(Hypervisor Translation Tabel Base Register)   |       HTCR       | Non-secure PL2 stage 1 translation                                                                                      |\n| VTTBR(Virtualization Translation Table Base Register) |       VTCR       | Non-secure PL1&0 stage 2 translation                                                                                    |\n|                        TTBR0/1                        |      TTBCR       | secure/non-secure PL1&0 stage 1 translation,  TTBR0, TTBR1, and TTBCR are Banked between Secure and Non-secure versions |\n\n### 3.1. short-descriptor translation table\n支持四种section or pages：\n- supersections, consist of 16MB blocks\n- sections, consist of 1MB blocks\n- large pages, consist of 64KB blocks\n- small pages, consist of 4KB blocks\n\n`First-level table`\nHolds first-level descriptors that contain the base address and\n• translation properties for a Section and Supersection\n• translation properties and pointers to a second-level table for a Large page or a Small page.\n\n`Second-level tables`\nHold second-level descriptors that contain the base address and translation properties for a Small\npage or a Large page. With the Short-descriptor format, second-level tables can be referred to as\nPage tables.\nA second-level table requires 1KByte of memory.\n\n#### 3.1.1. general view of address translation using short-descriptor\n![general view of address translation using short-descriptor](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_using_short_descriptor.png)\n\n#### 3.1.2. short descriptor 1st level format\n![short descriptor 1st level format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/short_descriptor_first_level.png)\n\n#### 3.1.3. short descriptor 2nd level format\n![short descriptor 2nd level format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/short_descriptor_2nd_level.png)\n\n\n|   Attribute    | Remarks                                                                     |\n| :------------: | :-------------------------------------------------------------------------- |\n| TEX[2:0]，C, B | mem 属性，cache, share等， These bits are not present in a Page table entry |\n|       XN       | execute-never bit，CPU 是否能执行此地址指令                                 |\n|       NS       | Non-secure bit                                                              |\n|       AP       | Access permission， read/write 权限                                         |\n|       S        | shareable bit                                                               |\n|       nG       | not Global bit                                                              |\n\n#### 3.1.4. TTBR0,1 之间的选择\n当TTBCR.EAE=0 选择short-descriptor format，TTBCR.N 决定了TTBR0, TTBR1 的选择情况。\n- N=0, only using TTBR0\n- N>0, 若VA[31:32-N] bit 为0， 使用TTBR0, 其他使用TTBR1\n\nTTBCR format when using short descriptor with security extension- \n![TTBCR format when using short descriptor with security extension](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR%20format%20when%20using%20short%20descriptor%20with%20security%20extension.png)\n\nTTBCR.N effect on address translation, short descriptor format\n![TTBCR.N effect on address translation, short descriptor format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR.N%20effect%20on%20address%20translation%2C%20short%20descriptor%20format.png)\n\nExample TTBCR.N effect on address translation, short descriptor format\n![Example TTBCR.N effect on address translation, short descriptor format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/example%20TTBCR.N%20effect%20on%20address%20translation%2C%20short%20descriptor%20format.png)\n\n### 3.2. long-descriptor translation table\nlong-descriptor 在有virtualization extension的ARM 时，支持：\n1. the Non-secure PL2 stage 1 translation\n2. the Non-secure PL1&0 stage 2 translation\n3. can be used for the Secure and Non-secure PL1&0 stage 1 translations\n\n#### 3.2.1. general view of stage 1 address translation using long-descriptor\n![general view of stage 1 address translation using long-descriptor](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_stage1_using_long_descriptor.png)\n\n#### 3.2.2. general view of stage 2 address translation using long-descriptor\n![general view of stage 2 address translation using long-descriptor](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_stage2_using_long_descriptor.png)\n\n#### 3.2.3. long descriptor 1st, 2nd level format\n![long descriptor 1st level format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/long_descriptor_1st_2nd_level.png)\n\n#### 3.2.4. long descriptor 3rd level format\n![long descriptor 3rd level format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/long_descriptor_3nd_level.png)\n\n\n#### 3.2.5. TTBR0,1 之间的选择\n与short descriptor 相似，但是查看TTBCR.T0SZ\nTTBCR format when using long descriptor\n![TTBCR format when using long descriptor](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR%20format%20when%20using%20long%20descriptor.png)\n\n## 4. TLB Maintenance\nTLB 相关的操作可以参看如下图， 可以依照MVA(modified virtual address) 也可以依照ASID(Application space identifiler) 去维护TLB。\ntlb maintenance operations\n![tlb maintenance operations](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/tlb_maintenance_operations.png)\n\n注：  \n- MVA(modified virtual address)\n- ASID (application space identifiler)\n\n## Reference\n[TLB flush操作](http://www.wowotech.net/memory_management/tlb-flush.html)\nARMv7 ARM - DDI0406C_C_arm_architecture_reference_manual","source":"_posts/kernel-tlb.md","raw":"---\ntitle: kernel_tlb\ndate: 2020-03-12 10:48:52\ntags: tlb\ncategories: memory\n---\n\nTLB(Translation lookaside buffer) 本质上也是一种cache， 物理特性与D/I Cache 类似（SDRAM）。D/I Cache 中cache 的是数据或者指令，而TLB帮助cpu 取指或执行访问mem指令时将VA（Virtual Address）转换成PA（Physical Address）, 减少HW translation table walk 访问main mem 中的page tables，他在armv7 架构中的位置可以参看：\n\n<!--more-->\n\n![arm cortex-a7 structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/arm_cortex-a7_mpcore_cpu_structure.png)\n\nTLB 一般还分为两大类：\n- main tlb (常规的tlb)\n- micro tlb (用于加速Data, Instructions的快速访问)\n\n## 1. work flow\nArmv7 ARM(architecture reference manual)中并没有规定TLB 具体的数据结构， 不过他主要包括：\n- 物理地址（更准确的说是physical page number）。这是地址翻译的结果\n- 虚拟地址（更准确的说是virtual page number）。用cache的术语来描述的话应该叫做Tag，进行匹配的时候就是对比Tag\n- Memory attribute（例如：memory type，cache policies，access permissions）\n- status bits（例如：Valid、dirty和reference bits\n- 其他相关信息。例如ASID、VMID\n\n当需要转换VA到PA的时候，首先在TLB中找是否有匹配的条目，如果有，那么TLB hit，这时候不需要再去访问页表来完成地址翻译。不过TLB始终是全部页表的一个子集，因此也有可能在TLB中找不到。如果没有在TLB中找到对应的item，那么称之TLB miss，那么就需要去访问memory中的page table来完成地址翻译，同时将翻译结果放入TLB。\n\n![tlb work flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/tlb_work_flow.gif)\n\n## 2. TLB Match\n整个地址翻译过程并非简单的VA到PA的映射那么简单，系统中虚拟地址空间很多，每个地址空间都是独立的。可以考虑如下情况：\n1. userspace 的进程都是独立虚拟空间，各个进程不同的虚拟地址空间中，相同的VA需翻译成不同的PA\n2. 若支持virtual extension。guest os 之间相同的VA 也要通过过VA->IPA->PA 形式转换成不同的PA\n3. secure, non-secure 虚拟的地址空间\n4. Global 地址如OS TEXT段与Non Global 地址\n   \n因此，只有在满足一定的条件才能说TLB match：\n1. 请求VA page number 与TLB TAG 中VA page number相等；\n2. 请求VA 的memory space identifiler 与TLB entry中memory space identifiler 相同。space ID区分PL1,2 或secure, non-secure level；\n3. 请求entry 为Non Global时，请求翻译的地址的ASID 与TLB 中相等。\n4. 请求地址翻译的VMID 等于TLB entry 中VMID 相等。 \n\n### 2.1. ASID(Address Space Identifier)\n在进程切换的时候，将TLB中的所有内容全部flush掉（全部置为无效），这样的设计当然很清爽，但是性能会大打折扣。\n一个比较好的方案是区分Global pages （内核地址空间）和Process-specific pages（参考页表描述符的nG的定义）。对于Global pages，地址翻译对所有操作系统中的进程都是一样的，因此，进程切换的时候，下一个进程仍然需要这些TLB entry，因而不需要flush掉。对于那些Process-specific pages对应的TLB entry，一旦发生切换，而TLB又不能识别的话，那么必须要flush掉上一个进程虚拟地址空间的TLB entry。如果支持了ASID，那么情况就不一样了：对于那些nG的地址映射，它会有一个ASID，对于TLB的entry而言，即便是保存多个相同虚拟地址到不同物理地址的映射也是OK的，只要他们有不同的ASID。 \n\n### 2.2. VMID(Vitural Machine Identifier)\n与ASID 存在意义类似， 在切换虚拟机的时候具有加速作用。\n\n## 3.translation table\nVMSAv7 支持两种格式translation table\n`Short-descriptor format`\nThis is the original format defined in issue A of this Architecture Reference Manual, and is the only\nformat supported on implementations that do not include the Large Physical Address Extension. \n- Up to two levels of address lookup.\n- 32-bit input addresses.Output addresses of up to 40 bits.\n- Support for PAs of more than 32 bits by use of supersections, with 16MB granularity.\n- 32-bit table entries.\n  \n`Long-descriptor format`\n- Up to three levels of address lookup.\n- Input addresses of up to 40 bits, when used for stage 2 translations.\n- Output addresses of up to 40 bits.\n- 4KB assignment granularity across the entire PA range.\n- 64-bit table entries.\n  \nTTBCR.EAE 的配置决定采用何种格式转换表。\n\n`Translation table base config`\n\n|                    Config Register                    | Control Register | Remarks                                                                                                                 |\n| :---------------------------------------------------: | :--------------: | :---------------------------------------------------------------------------------------------------------------------- |\n|   HTTBR(Hypervisor Translation Tabel Base Register)   |       HTCR       | Non-secure PL2 stage 1 translation                                                                                      |\n| VTTBR(Virtualization Translation Table Base Register) |       VTCR       | Non-secure PL1&0 stage 2 translation                                                                                    |\n|                        TTBR0/1                        |      TTBCR       | secure/non-secure PL1&0 stage 1 translation,  TTBR0, TTBR1, and TTBCR are Banked between Secure and Non-secure versions |\n\n### 3.1. short-descriptor translation table\n支持四种section or pages：\n- supersections, consist of 16MB blocks\n- sections, consist of 1MB blocks\n- large pages, consist of 64KB blocks\n- small pages, consist of 4KB blocks\n\n`First-level table`\nHolds first-level descriptors that contain the base address and\n• translation properties for a Section and Supersection\n• translation properties and pointers to a second-level table for a Large page or a Small page.\n\n`Second-level tables`\nHold second-level descriptors that contain the base address and translation properties for a Small\npage or a Large page. With the Short-descriptor format, second-level tables can be referred to as\nPage tables.\nA second-level table requires 1KByte of memory.\n\n#### 3.1.1. general view of address translation using short-descriptor\n![general view of address translation using short-descriptor](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_using_short_descriptor.png)\n\n#### 3.1.2. short descriptor 1st level format\n![short descriptor 1st level format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/short_descriptor_first_level.png)\n\n#### 3.1.3. short descriptor 2nd level format\n![short descriptor 2nd level format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/short_descriptor_2nd_level.png)\n\n\n|   Attribute    | Remarks                                                                     |\n| :------------: | :-------------------------------------------------------------------------- |\n| TEX[2:0]，C, B | mem 属性，cache, share等， These bits are not present in a Page table entry |\n|       XN       | execute-never bit，CPU 是否能执行此地址指令                                 |\n|       NS       | Non-secure bit                                                              |\n|       AP       | Access permission， read/write 权限                                         |\n|       S        | shareable bit                                                               |\n|       nG       | not Global bit                                                              |\n\n#### 3.1.4. TTBR0,1 之间的选择\n当TTBCR.EAE=0 选择short-descriptor format，TTBCR.N 决定了TTBR0, TTBR1 的选择情况。\n- N=0, only using TTBR0\n- N>0, 若VA[31:32-N] bit 为0， 使用TTBR0, 其他使用TTBR1\n\nTTBCR format when using short descriptor with security extension- \n![TTBCR format when using short descriptor with security extension](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR%20format%20when%20using%20short%20descriptor%20with%20security%20extension.png)\n\nTTBCR.N effect on address translation, short descriptor format\n![TTBCR.N effect on address translation, short descriptor format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR.N%20effect%20on%20address%20translation%2C%20short%20descriptor%20format.png)\n\nExample TTBCR.N effect on address translation, short descriptor format\n![Example TTBCR.N effect on address translation, short descriptor format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/example%20TTBCR.N%20effect%20on%20address%20translation%2C%20short%20descriptor%20format.png)\n\n### 3.2. long-descriptor translation table\nlong-descriptor 在有virtualization extension的ARM 时，支持：\n1. the Non-secure PL2 stage 1 translation\n2. the Non-secure PL1&0 stage 2 translation\n3. can be used for the Secure and Non-secure PL1&0 stage 1 translations\n\n#### 3.2.1. general view of stage 1 address translation using long-descriptor\n![general view of stage 1 address translation using long-descriptor](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_stage1_using_long_descriptor.png)\n\n#### 3.2.2. general view of stage 2 address translation using long-descriptor\n![general view of stage 2 address translation using long-descriptor](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_stage2_using_long_descriptor.png)\n\n#### 3.2.3. long descriptor 1st, 2nd level format\n![long descriptor 1st level format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/long_descriptor_1st_2nd_level.png)\n\n#### 3.2.4. long descriptor 3rd level format\n![long descriptor 3rd level format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/long_descriptor_3nd_level.png)\n\n\n#### 3.2.5. TTBR0,1 之间的选择\n与short descriptor 相似，但是查看TTBCR.T0SZ\nTTBCR format when using long descriptor\n![TTBCR format when using long descriptor](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR%20format%20when%20using%20long%20descriptor.png)\n\n## 4. TLB Maintenance\nTLB 相关的操作可以参看如下图， 可以依照MVA(modified virtual address) 也可以依照ASID(Application space identifiler) 去维护TLB。\ntlb maintenance operations\n![tlb maintenance operations](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/tlb_maintenance_operations.png)\n\n注：  \n- MVA(modified virtual address)\n- ASID (application space identifiler)\n\n## Reference\n[TLB flush操作](http://www.wowotech.net/memory_management/tlb-flush.html)\nARMv7 ARM - DDI0406C_C_arm_architecture_reference_manual","slug":"kernel-tlb","published":1,"updated":"2020-03-12T08:56:22.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qh002qzkgryws7yhoh","content":"<p>TLB(Translation lookaside buffer) 本质上也是一种cache， 物理特性与D/I Cache 类似（SDRAM）。D/I Cache 中cache 的是数据或者指令，而TLB帮助cpu 取指或执行访问mem指令时将VA（Virtual Address）转换成PA（Physical Address）, 减少HW translation table walk 访问main mem 中的page tables，他在armv7 架构中的位置可以参看：</p>\n<a id=\"more\"></a>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/arm_cortex-a7_mpcore_cpu_structure.png\" alt=\"arm cortex-a7 structure\"></p>\n<p>TLB 一般还分为两大类：</p>\n<ul>\n<li>main tlb (常规的tlb)</li>\n<li>micro tlb (用于加速Data, Instructions的快速访问)</li>\n</ul>\n<h2 id=\"1-work-flow\"><a href=\"#1-work-flow\" class=\"headerlink\" title=\"1. work flow\"></a>1. work flow</h2><p>Armv7 ARM(architecture reference manual)中并没有规定TLB 具体的数据结构， 不过他主要包括：</p>\n<ul>\n<li>物理地址（更准确的说是physical page number）。这是地址翻译的结果</li>\n<li>虚拟地址（更准确的说是virtual page number）。用cache的术语来描述的话应该叫做Tag，进行匹配的时候就是对比Tag</li>\n<li>Memory attribute（例如：memory type，cache policies，access permissions）</li>\n<li>status bits（例如：Valid、dirty和reference bits</li>\n<li>其他相关信息。例如ASID、VMID</li>\n</ul>\n<p>当需要转换VA到PA的时候，首先在TLB中找是否有匹配的条目，如果有，那么TLB hit，这时候不需要再去访问页表来完成地址翻译。不过TLB始终是全部页表的一个子集，因此也有可能在TLB中找不到。如果没有在TLB中找到对应的item，那么称之TLB miss，那么就需要去访问memory中的page table来完成地址翻译，同时将翻译结果放入TLB。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/tlb_work_flow.gif\" alt=\"tlb work flow\"></p>\n<h2 id=\"2-TLB-Match\"><a href=\"#2-TLB-Match\" class=\"headerlink\" title=\"2. TLB Match\"></a>2. TLB Match</h2><p>整个地址翻译过程并非简单的VA到PA的映射那么简单，系统中虚拟地址空间很多，每个地址空间都是独立的。可以考虑如下情况：</p>\n<ol>\n<li>userspace 的进程都是独立虚拟空间，各个进程不同的虚拟地址空间中，相同的VA需翻译成不同的PA</li>\n<li>若支持virtual extension。guest os 之间相同的VA 也要通过过VA-&gt;IPA-&gt;PA 形式转换成不同的PA</li>\n<li>secure, non-secure 虚拟的地址空间</li>\n<li>Global 地址如OS TEXT段与Non Global 地址</li>\n</ol>\n<p>因此，只有在满足一定的条件才能说TLB match：</p>\n<ol>\n<li>请求VA page number 与TLB TAG 中VA page number相等；</li>\n<li>请求VA 的memory space identifiler 与TLB entry中memory space identifiler 相同。space ID区分PL1,2 或secure, non-secure level；</li>\n<li>请求entry 为Non Global时，请求翻译的地址的ASID 与TLB 中相等。</li>\n<li>请求地址翻译的VMID 等于TLB entry 中VMID 相等。 </li>\n</ol>\n<h3 id=\"2-1-ASID-Address-Space-Identifier\"><a href=\"#2-1-ASID-Address-Space-Identifier\" class=\"headerlink\" title=\"2.1. ASID(Address Space Identifier)\"></a>2.1. ASID(Address Space Identifier)</h3><p>在进程切换的时候，将TLB中的所有内容全部flush掉（全部置为无效），这样的设计当然很清爽，但是性能会大打折扣。<br>一个比较好的方案是区分Global pages （内核地址空间）和Process-specific pages（参考页表描述符的nG的定义）。对于Global pages，地址翻译对所有操作系统中的进程都是一样的，因此，进程切换的时候，下一个进程仍然需要这些TLB entry，因而不需要flush掉。对于那些Process-specific pages对应的TLB entry，一旦发生切换，而TLB又不能识别的话，那么必须要flush掉上一个进程虚拟地址空间的TLB entry。如果支持了ASID，那么情况就不一样了：对于那些nG的地址映射，它会有一个ASID，对于TLB的entry而言，即便是保存多个相同虚拟地址到不同物理地址的映射也是OK的，只要他们有不同的ASID。 </p>\n<h3 id=\"2-2-VMID-Vitural-Machine-Identifier\"><a href=\"#2-2-VMID-Vitural-Machine-Identifier\" class=\"headerlink\" title=\"2.2. VMID(Vitural Machine Identifier)\"></a>2.2. VMID(Vitural Machine Identifier)</h3><p>与ASID 存在意义类似， 在切换虚拟机的时候具有加速作用。</p>\n<h2 id=\"3-translation-table\"><a href=\"#3-translation-table\" class=\"headerlink\" title=\"3.translation table\"></a>3.translation table</h2><p>VMSAv7 支持两种格式translation table<br><code>Short-descriptor format</code><br>This is the original format defined in issue A of this Architecture Reference Manual, and is the only<br>format supported on implementations that do not include the Large Physical Address Extension. </p>\n<ul>\n<li>Up to two levels of address lookup.</li>\n<li>32-bit input addresses.Output addresses of up to 40 bits.</li>\n<li>Support for PAs of more than 32 bits by use of supersections, with 16MB granularity.</li>\n<li>32-bit table entries.</li>\n</ul>\n<p><code>Long-descriptor format</code></p>\n<ul>\n<li>Up to three levels of address lookup.</li>\n<li>Input addresses of up to 40 bits, when used for stage 2 translations.</li>\n<li>Output addresses of up to 40 bits.</li>\n<li>4KB assignment granularity across the entire PA range.</li>\n<li>64-bit table entries.</li>\n</ul>\n<p>TTBCR.EAE 的配置决定采用何种格式转换表。</p>\n<p><code>Translation table base config</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Config Register</th>\n<th style=\"text-align:center\">Control Register</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HTTBR(Hypervisor Translation Tabel Base Register)</td>\n<td style=\"text-align:center\">HTCR</td>\n<td style=\"text-align:left\">Non-secure PL2 stage 1 translation</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">VTTBR(Virtualization Translation Table Base Register)</td>\n<td style=\"text-align:center\">VTCR</td>\n<td style=\"text-align:left\">Non-secure PL1&amp;0 stage 2 translation</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TTBR0/1</td>\n<td style=\"text-align:center\">TTBCR</td>\n<td style=\"text-align:left\">secure/non-secure PL1&amp;0 stage 1 translation,  TTBR0, TTBR1, and TTBCR are Banked between Secure and Non-secure versions</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-1-short-descriptor-translation-table\"><a href=\"#3-1-short-descriptor-translation-table\" class=\"headerlink\" title=\"3.1. short-descriptor translation table\"></a>3.1. short-descriptor translation table</h3><p>支持四种section or pages：</p>\n<ul>\n<li>supersections, consist of 16MB blocks</li>\n<li>sections, consist of 1MB blocks</li>\n<li>large pages, consist of 64KB blocks</li>\n<li>small pages, consist of 4KB blocks</li>\n</ul>\n<p><code>First-level table</code><br>Holds first-level descriptors that contain the base address and<br>• translation properties for a Section and Supersection<br>• translation properties and pointers to a second-level table for a Large page or a Small page.</p>\n<p><code>Second-level tables</code><br>Hold second-level descriptors that contain the base address and translation properties for a Small<br>page or a Large page. With the Short-descriptor format, second-level tables can be referred to as<br>Page tables.<br>A second-level table requires 1KByte of memory.</p>\n<h4 id=\"3-1-1-general-view-of-address-translation-using-short-descriptor\"><a href=\"#3-1-1-general-view-of-address-translation-using-short-descriptor\" class=\"headerlink\" title=\"3.1.1. general view of address translation using short-descriptor\"></a>3.1.1. general view of address translation using short-descriptor</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_using_short_descriptor.png\" alt=\"general view of address translation using short-descriptor\"></p>\n<h4 id=\"3-1-2-short-descriptor-1st-level-format\"><a href=\"#3-1-2-short-descriptor-1st-level-format\" class=\"headerlink\" title=\"3.1.2. short descriptor 1st level format\"></a>3.1.2. short descriptor 1st level format</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/short_descriptor_first_level.png\" alt=\"short descriptor 1st level format\"></p>\n<h4 id=\"3-1-3-short-descriptor-2nd-level-format\"><a href=\"#3-1-3-short-descriptor-2nd-level-format\" class=\"headerlink\" title=\"3.1.3. short descriptor 2nd level format\"></a>3.1.3. short descriptor 2nd level format</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/short_descriptor_2nd_level.png\" alt=\"short descriptor 2nd level format\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Attribute</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">TEX[2:0]，C, B</td>\n<td style=\"text-align:left\">mem 属性，cache, share等， These bits are not present in a Page table entry</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">XN</td>\n<td style=\"text-align:left\">execute-never bit，CPU 是否能执行此地址指令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NS</td>\n<td style=\"text-align:left\">Non-secure bit</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AP</td>\n<td style=\"text-align:left\">Access permission， read/write 权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">S</td>\n<td style=\"text-align:left\">shareable bit</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nG</td>\n<td style=\"text-align:left\">not Global bit</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-1-4-TTBR0-1-之间的选择\"><a href=\"#3-1-4-TTBR0-1-之间的选择\" class=\"headerlink\" title=\"3.1.4. TTBR0,1 之间的选择\"></a>3.1.4. TTBR0,1 之间的选择</h4><p>当TTBCR.EAE=0 选择short-descriptor format，TTBCR.N 决定了TTBR0, TTBR1 的选择情况。</p>\n<ul>\n<li>N=0, only using TTBR0</li>\n<li>N&gt;0, 若VA[31:32-N] bit 为0， 使用TTBR0, 其他使用TTBR1</li>\n</ul>\n<p>TTBCR format when using short descriptor with security extension-<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR%20format%20when%20using%20short%20descriptor%20with%20security%20extension.png\" alt=\"TTBCR format when using short descriptor with security extension\"></p>\n<p>TTBCR.N effect on address translation, short descriptor format<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR.N%20effect%20on%20address%20translation%2C%20short%20descriptor%20format.png\" alt=\"TTBCR.N effect on address translation, short descriptor format\"></p>\n<p>Example TTBCR.N effect on address translation, short descriptor format<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/example%20TTBCR.N%20effect%20on%20address%20translation%2C%20short%20descriptor%20format.png\" alt=\"Example TTBCR.N effect on address translation, short descriptor format\"></p>\n<h3 id=\"3-2-long-descriptor-translation-table\"><a href=\"#3-2-long-descriptor-translation-table\" class=\"headerlink\" title=\"3.2. long-descriptor translation table\"></a>3.2. long-descriptor translation table</h3><p>long-descriptor 在有virtualization extension的ARM 时，支持：</p>\n<ol>\n<li>the Non-secure PL2 stage 1 translation</li>\n<li>the Non-secure PL1&amp;0 stage 2 translation</li>\n<li>can be used for the Secure and Non-secure PL1&amp;0 stage 1 translations</li>\n</ol>\n<h4 id=\"3-2-1-general-view-of-stage-1-address-translation-using-long-descriptor\"><a href=\"#3-2-1-general-view-of-stage-1-address-translation-using-long-descriptor\" class=\"headerlink\" title=\"3.2.1. general view of stage 1 address translation using long-descriptor\"></a>3.2.1. general view of stage 1 address translation using long-descriptor</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_stage1_using_long_descriptor.png\" alt=\"general view of stage 1 address translation using long-descriptor\"></p>\n<h4 id=\"3-2-2-general-view-of-stage-2-address-translation-using-long-descriptor\"><a href=\"#3-2-2-general-view-of-stage-2-address-translation-using-long-descriptor\" class=\"headerlink\" title=\"3.2.2. general view of stage 2 address translation using long-descriptor\"></a>3.2.2. general view of stage 2 address translation using long-descriptor</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_stage2_using_long_descriptor.png\" alt=\"general view of stage 2 address translation using long-descriptor\"></p>\n<h4 id=\"3-2-3-long-descriptor-1st-2nd-level-format\"><a href=\"#3-2-3-long-descriptor-1st-2nd-level-format\" class=\"headerlink\" title=\"3.2.3. long descriptor 1st, 2nd level format\"></a>3.2.3. long descriptor 1st, 2nd level format</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/long_descriptor_1st_2nd_level.png\" alt=\"long descriptor 1st level format\"></p>\n<h4 id=\"3-2-4-long-descriptor-3rd-level-format\"><a href=\"#3-2-4-long-descriptor-3rd-level-format\" class=\"headerlink\" title=\"3.2.4. long descriptor 3rd level format\"></a>3.2.4. long descriptor 3rd level format</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/long_descriptor_3nd_level.png\" alt=\"long descriptor 3rd level format\"></p>\n<h4 id=\"3-2-5-TTBR0-1-之间的选择\"><a href=\"#3-2-5-TTBR0-1-之间的选择\" class=\"headerlink\" title=\"3.2.5. TTBR0,1 之间的选择\"></a>3.2.5. TTBR0,1 之间的选择</h4><p>与short descriptor 相似，但是查看TTBCR.T0SZ<br>TTBCR format when using long descriptor<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR%20format%20when%20using%20long%20descriptor.png\" alt=\"TTBCR format when using long descriptor\"></p>\n<h2 id=\"4-TLB-Maintenance\"><a href=\"#4-TLB-Maintenance\" class=\"headerlink\" title=\"4. TLB Maintenance\"></a>4. TLB Maintenance</h2><p>TLB 相关的操作可以参看如下图， 可以依照MVA(modified virtual address) 也可以依照ASID(Application space identifiler) 去维护TLB。<br>tlb maintenance operations<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/tlb_maintenance_operations.png\" alt=\"tlb maintenance operations\"></p>\n<p>注：  </p>\n<ul>\n<li>MVA(modified virtual address)</li>\n<li>ASID (application space identifiler)</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/memory_management/tlb-flush.html\" target=\"_blank\" rel=\"noopener\">TLB flush操作</a><br>ARMv7 ARM - DDI0406C_C_arm_architecture_reference_manual</p>\n","site":{"data":{}},"excerpt":"<p>TLB(Translation lookaside buffer) 本质上也是一种cache， 物理特性与D/I Cache 类似（SDRAM）。D/I Cache 中cache 的是数据或者指令，而TLB帮助cpu 取指或执行访问mem指令时将VA（Virtual Address）转换成PA（Physical Address）, 减少HW translation table walk 访问main mem 中的page tables，他在armv7 架构中的位置可以参看：</p>","more":"<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/arm_cortex-a7_mpcore_cpu_structure.png\" alt=\"arm cortex-a7 structure\"></p>\n<p>TLB 一般还分为两大类：</p>\n<ul>\n<li>main tlb (常规的tlb)</li>\n<li>micro tlb (用于加速Data, Instructions的快速访问)</li>\n</ul>\n<h2 id=\"1-work-flow\"><a href=\"#1-work-flow\" class=\"headerlink\" title=\"1. work flow\"></a>1. work flow</h2><p>Armv7 ARM(architecture reference manual)中并没有规定TLB 具体的数据结构， 不过他主要包括：</p>\n<ul>\n<li>物理地址（更准确的说是physical page number）。这是地址翻译的结果</li>\n<li>虚拟地址（更准确的说是virtual page number）。用cache的术语来描述的话应该叫做Tag，进行匹配的时候就是对比Tag</li>\n<li>Memory attribute（例如：memory type，cache policies，access permissions）</li>\n<li>status bits（例如：Valid、dirty和reference bits</li>\n<li>其他相关信息。例如ASID、VMID</li>\n</ul>\n<p>当需要转换VA到PA的时候，首先在TLB中找是否有匹配的条目，如果有，那么TLB hit，这时候不需要再去访问页表来完成地址翻译。不过TLB始终是全部页表的一个子集，因此也有可能在TLB中找不到。如果没有在TLB中找到对应的item，那么称之TLB miss，那么就需要去访问memory中的page table来完成地址翻译，同时将翻译结果放入TLB。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/tlb_work_flow.gif\" alt=\"tlb work flow\"></p>\n<h2 id=\"2-TLB-Match\"><a href=\"#2-TLB-Match\" class=\"headerlink\" title=\"2. TLB Match\"></a>2. TLB Match</h2><p>整个地址翻译过程并非简单的VA到PA的映射那么简单，系统中虚拟地址空间很多，每个地址空间都是独立的。可以考虑如下情况：</p>\n<ol>\n<li>userspace 的进程都是独立虚拟空间，各个进程不同的虚拟地址空间中，相同的VA需翻译成不同的PA</li>\n<li>若支持virtual extension。guest os 之间相同的VA 也要通过过VA-&gt;IPA-&gt;PA 形式转换成不同的PA</li>\n<li>secure, non-secure 虚拟的地址空间</li>\n<li>Global 地址如OS TEXT段与Non Global 地址</li>\n</ol>\n<p>因此，只有在满足一定的条件才能说TLB match：</p>\n<ol>\n<li>请求VA page number 与TLB TAG 中VA page number相等；</li>\n<li>请求VA 的memory space identifiler 与TLB entry中memory space identifiler 相同。space ID区分PL1,2 或secure, non-secure level；</li>\n<li>请求entry 为Non Global时，请求翻译的地址的ASID 与TLB 中相等。</li>\n<li>请求地址翻译的VMID 等于TLB entry 中VMID 相等。 </li>\n</ol>\n<h3 id=\"2-1-ASID-Address-Space-Identifier\"><a href=\"#2-1-ASID-Address-Space-Identifier\" class=\"headerlink\" title=\"2.1. ASID(Address Space Identifier)\"></a>2.1. ASID(Address Space Identifier)</h3><p>在进程切换的时候，将TLB中的所有内容全部flush掉（全部置为无效），这样的设计当然很清爽，但是性能会大打折扣。<br>一个比较好的方案是区分Global pages （内核地址空间）和Process-specific pages（参考页表描述符的nG的定义）。对于Global pages，地址翻译对所有操作系统中的进程都是一样的，因此，进程切换的时候，下一个进程仍然需要这些TLB entry，因而不需要flush掉。对于那些Process-specific pages对应的TLB entry，一旦发生切换，而TLB又不能识别的话，那么必须要flush掉上一个进程虚拟地址空间的TLB entry。如果支持了ASID，那么情况就不一样了：对于那些nG的地址映射，它会有一个ASID，对于TLB的entry而言，即便是保存多个相同虚拟地址到不同物理地址的映射也是OK的，只要他们有不同的ASID。 </p>\n<h3 id=\"2-2-VMID-Vitural-Machine-Identifier\"><a href=\"#2-2-VMID-Vitural-Machine-Identifier\" class=\"headerlink\" title=\"2.2. VMID(Vitural Machine Identifier)\"></a>2.2. VMID(Vitural Machine Identifier)</h3><p>与ASID 存在意义类似， 在切换虚拟机的时候具有加速作用。</p>\n<h2 id=\"3-translation-table\"><a href=\"#3-translation-table\" class=\"headerlink\" title=\"3.translation table\"></a>3.translation table</h2><p>VMSAv7 支持两种格式translation table<br><code>Short-descriptor format</code><br>This is the original format defined in issue A of this Architecture Reference Manual, and is the only<br>format supported on implementations that do not include the Large Physical Address Extension. </p>\n<ul>\n<li>Up to two levels of address lookup.</li>\n<li>32-bit input addresses.Output addresses of up to 40 bits.</li>\n<li>Support for PAs of more than 32 bits by use of supersections, with 16MB granularity.</li>\n<li>32-bit table entries.</li>\n</ul>\n<p><code>Long-descriptor format</code></p>\n<ul>\n<li>Up to three levels of address lookup.</li>\n<li>Input addresses of up to 40 bits, when used for stage 2 translations.</li>\n<li>Output addresses of up to 40 bits.</li>\n<li>4KB assignment granularity across the entire PA range.</li>\n<li>64-bit table entries.</li>\n</ul>\n<p>TTBCR.EAE 的配置决定采用何种格式转换表。</p>\n<p><code>Translation table base config</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Config Register</th>\n<th style=\"text-align:center\">Control Register</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HTTBR(Hypervisor Translation Tabel Base Register)</td>\n<td style=\"text-align:center\">HTCR</td>\n<td style=\"text-align:left\">Non-secure PL2 stage 1 translation</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">VTTBR(Virtualization Translation Table Base Register)</td>\n<td style=\"text-align:center\">VTCR</td>\n<td style=\"text-align:left\">Non-secure PL1&amp;0 stage 2 translation</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TTBR0/1</td>\n<td style=\"text-align:center\">TTBCR</td>\n<td style=\"text-align:left\">secure/non-secure PL1&amp;0 stage 1 translation,  TTBR0, TTBR1, and TTBCR are Banked between Secure and Non-secure versions</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-1-short-descriptor-translation-table\"><a href=\"#3-1-short-descriptor-translation-table\" class=\"headerlink\" title=\"3.1. short-descriptor translation table\"></a>3.1. short-descriptor translation table</h3><p>支持四种section or pages：</p>\n<ul>\n<li>supersections, consist of 16MB blocks</li>\n<li>sections, consist of 1MB blocks</li>\n<li>large pages, consist of 64KB blocks</li>\n<li>small pages, consist of 4KB blocks</li>\n</ul>\n<p><code>First-level table</code><br>Holds first-level descriptors that contain the base address and<br>• translation properties for a Section and Supersection<br>• translation properties and pointers to a second-level table for a Large page or a Small page.</p>\n<p><code>Second-level tables</code><br>Hold second-level descriptors that contain the base address and translation properties for a Small<br>page or a Large page. With the Short-descriptor format, second-level tables can be referred to as<br>Page tables.<br>A second-level table requires 1KByte of memory.</p>\n<h4 id=\"3-1-1-general-view-of-address-translation-using-short-descriptor\"><a href=\"#3-1-1-general-view-of-address-translation-using-short-descriptor\" class=\"headerlink\" title=\"3.1.1. general view of address translation using short-descriptor\"></a>3.1.1. general view of address translation using short-descriptor</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_using_short_descriptor.png\" alt=\"general view of address translation using short-descriptor\"></p>\n<h4 id=\"3-1-2-short-descriptor-1st-level-format\"><a href=\"#3-1-2-short-descriptor-1st-level-format\" class=\"headerlink\" title=\"3.1.2. short descriptor 1st level format\"></a>3.1.2. short descriptor 1st level format</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/short_descriptor_first_level.png\" alt=\"short descriptor 1st level format\"></p>\n<h4 id=\"3-1-3-short-descriptor-2nd-level-format\"><a href=\"#3-1-3-short-descriptor-2nd-level-format\" class=\"headerlink\" title=\"3.1.3. short descriptor 2nd level format\"></a>3.1.3. short descriptor 2nd level format</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/short_descriptor_2nd_level.png\" alt=\"short descriptor 2nd level format\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Attribute</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">TEX[2:0]，C, B</td>\n<td style=\"text-align:left\">mem 属性，cache, share等， These bits are not present in a Page table entry</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">XN</td>\n<td style=\"text-align:left\">execute-never bit，CPU 是否能执行此地址指令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NS</td>\n<td style=\"text-align:left\">Non-secure bit</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AP</td>\n<td style=\"text-align:left\">Access permission， read/write 权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">S</td>\n<td style=\"text-align:left\">shareable bit</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nG</td>\n<td style=\"text-align:left\">not Global bit</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-1-4-TTBR0-1-之间的选择\"><a href=\"#3-1-4-TTBR0-1-之间的选择\" class=\"headerlink\" title=\"3.1.4. TTBR0,1 之间的选择\"></a>3.1.4. TTBR0,1 之间的选择</h4><p>当TTBCR.EAE=0 选择short-descriptor format，TTBCR.N 决定了TTBR0, TTBR1 的选择情况。</p>\n<ul>\n<li>N=0, only using TTBR0</li>\n<li>N&gt;0, 若VA[31:32-N] bit 为0， 使用TTBR0, 其他使用TTBR1</li>\n</ul>\n<p>TTBCR format when using short descriptor with security extension-<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR%20format%20when%20using%20short%20descriptor%20with%20security%20extension.png\" alt=\"TTBCR format when using short descriptor with security extension\"></p>\n<p>TTBCR.N effect on address translation, short descriptor format<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR.N%20effect%20on%20address%20translation%2C%20short%20descriptor%20format.png\" alt=\"TTBCR.N effect on address translation, short descriptor format\"></p>\n<p>Example TTBCR.N effect on address translation, short descriptor format<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/example%20TTBCR.N%20effect%20on%20address%20translation%2C%20short%20descriptor%20format.png\" alt=\"Example TTBCR.N effect on address translation, short descriptor format\"></p>\n<h3 id=\"3-2-long-descriptor-translation-table\"><a href=\"#3-2-long-descriptor-translation-table\" class=\"headerlink\" title=\"3.2. long-descriptor translation table\"></a>3.2. long-descriptor translation table</h3><p>long-descriptor 在有virtualization extension的ARM 时，支持：</p>\n<ol>\n<li>the Non-secure PL2 stage 1 translation</li>\n<li>the Non-secure PL1&amp;0 stage 2 translation</li>\n<li>can be used for the Secure and Non-secure PL1&amp;0 stage 1 translations</li>\n</ol>\n<h4 id=\"3-2-1-general-view-of-stage-1-address-translation-using-long-descriptor\"><a href=\"#3-2-1-general-view-of-stage-1-address-translation-using-long-descriptor\" class=\"headerlink\" title=\"3.2.1. general view of stage 1 address translation using long-descriptor\"></a>3.2.1. general view of stage 1 address translation using long-descriptor</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_stage1_using_long_descriptor.png\" alt=\"general view of stage 1 address translation using long-descriptor\"></p>\n<h4 id=\"3-2-2-general-view-of-stage-2-address-translation-using-long-descriptor\"><a href=\"#3-2-2-general-view-of-stage-2-address-translation-using-long-descriptor\" class=\"headerlink\" title=\"3.2.2. general view of stage 2 address translation using long-descriptor\"></a>3.2.2. general view of stage 2 address translation using long-descriptor</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/general_view_stage2_using_long_descriptor.png\" alt=\"general view of stage 2 address translation using long-descriptor\"></p>\n<h4 id=\"3-2-3-long-descriptor-1st-2nd-level-format\"><a href=\"#3-2-3-long-descriptor-1st-2nd-level-format\" class=\"headerlink\" title=\"3.2.3. long descriptor 1st, 2nd level format\"></a>3.2.3. long descriptor 1st, 2nd level format</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/long_descriptor_1st_2nd_level.png\" alt=\"long descriptor 1st level format\"></p>\n<h4 id=\"3-2-4-long-descriptor-3rd-level-format\"><a href=\"#3-2-4-long-descriptor-3rd-level-format\" class=\"headerlink\" title=\"3.2.4. long descriptor 3rd level format\"></a>3.2.4. long descriptor 3rd level format</h4><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/long_descriptor_3nd_level.png\" alt=\"long descriptor 3rd level format\"></p>\n<h4 id=\"3-2-5-TTBR0-1-之间的选择\"><a href=\"#3-2-5-TTBR0-1-之间的选择\" class=\"headerlink\" title=\"3.2.5. TTBR0,1 之间的选择\"></a>3.2.5. TTBR0,1 之间的选择</h4><p>与short descriptor 相似，但是查看TTBCR.T0SZ<br>TTBCR format when using long descriptor<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/TTBCR%20format%20when%20using%20long%20descriptor.png\" alt=\"TTBCR format when using long descriptor\"></p>\n<h2 id=\"4-TLB-Maintenance\"><a href=\"#4-TLB-Maintenance\" class=\"headerlink\" title=\"4. TLB Maintenance\"></a>4. TLB Maintenance</h2><p>TLB 相关的操作可以参看如下图， 可以依照MVA(modified virtual address) 也可以依照ASID(Application space identifiler) 去维护TLB。<br>tlb maintenance operations<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/tlb/tlb_maintenance_operations.png\" alt=\"tlb maintenance operations\"></p>\n<p>注：  </p>\n<ul>\n<li>MVA(modified virtual address)</li>\n<li>ASID (application space identifiler)</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/memory_management/tlb-flush.html\" target=\"_blank\" rel=\"noopener\">TLB flush操作</a><br>ARMv7 ARM - DDI0406C_C_arm_architecture_reference_manual</p>"},{"title":"kernel_tty","date":"2020-02-17T10:12:19.000Z","_content":"\n## 1. Base\n### 1.1. 常见术语\n|      术语       | 解释                                                                                             |\n| :-------------: | :----------------------------------------------------------------------------------------------- |\n|    Terminal     | 终端，是一个电子（或电气）人机交互设备                                                           |\n| serial Terminal | TTY 设备的一种，通过串口线连接                                                                   |\n|     console     | 控制台，早期PC的键盘显示器，比TTY 终端拥有更多的权限，系统的运行日志、错误信息通常会输出到控制台 |\n\n>第一个Unix终端是一个名字为ASR33的电传打字机，而电传打字机的英文单词为Teletype（或Teletypewritter），缩写为TTY。\n\n<!--more-->\n\n### 1.2. TTY 分类\ntty 设备有几个分类：  \n- console(通常指键盘，显示器)  \n- serial tty(传统意义的HW，输入输出都在一个独立的硬件上，如peripheral uart)\n- VT(virtual tty，传统控制台同一时刻，只能有一个终端使用，为满足多用户、应用，Unix/linux又虚拟出6个终端，可以通过键盘的组合键（CTRL+ALT+ F1~F6）将某一个虚拟终端调出来在屏幕上显示)\n- PTY(Pseudo TTY) 伪终端由pts(pseudo terminal slave)和ptm(pseudo terminal master)组成。\n\n>PTS: 模拟终端完成与shell等应用的TTY 输入、输出需求\n>PTM: 将数据通过socket 等形式与真实设备之间进行通行\n>\n>shell <->  PTS <-> PTM <-> SSHD,XTERM\n\n如果从应用上讲还有如下：\n- 软件终端（PUTTY, SecureCRT, mobalxterm, xshell等， 由软件模拟终端） \n- USB, Ethernet终端（通过其他通信协议模拟终端，例如USB CDC的uart）   \n- 图形终端（GUI图形也可以说成终端的一种，只是不再是TTY框架中了，TTY主要在字符设备范围）\n\n```\n设备号(主, 次)        字符设备                            备注\n(5, 0)               /dev/tty                            控制终端（Controlling Terminal）\n(5, 1)               /dev/console                        控制台终端（Console Terminal）\n(4, 0)               /dev/vc/0 or /dev/tty0              虚拟终端（Virtual Terminal）\n(4, 1)               /dev/vc/1 or /dev/tty1              同上\n…                    …                                   …\n(x, x)               /dev/ttyS0                          串口终端（名称和设备号由驱动自行决定）\n…                    …                                   …\n(x, x)               /dev/ttyUSB0                        USB转串口终端 \n```\n\n## 2. 软件架构\n\n![tty framework structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/linux_tty_framework_structure.png)\n\n### TTY Line Disciplines\nline disciplines(线路规程), 可以把它看成设备驱动和应用接口之间的一个适配层, 按照一些定义的标准进行某些字符的转换。例如\"\\n\", \"\\r\" 之间的转换。在Linux 4.9.x中有这些：\n```c\n/* include/linux/tty.h, line disciplines */\n#define N_TTY\t\t0\n#define N_SLIP\t\t1\n#define N_MOUSE\t\t2\n#define N_PPP\t\t3\n#define N_STRIP\t\t4\n#define N_AX25\t\t5\n#define N_X25\t\t6\t/* X.25 async */\n#define N_6PACK\t\t7\n#define N_MASC\t\t8\t/* Reserved for Mobitex module <kaz@cafe.net> */\n#define N_R3964\t\t9\t/* Reserved for Simatic R3964 module */\n#define N_PROFIBUS_FDL\t10\t/* Reserved for Profibus */\n#define N_IRDA\t\t11\t/* Linux IrDa - http://irda.sourceforge.net/ */\n#define N_SMSBLOCK\t12\t/* SMS block mode - for talking to GSM data */\n\t\t\t\t/* cards about SMS messages */\n#define N_HDLC\t\t13\t/* synchronous HDLC */\n#define N_SYNC_PPP\t14\t/* synchronous PPP */\n#define N_HCI\t\t15\t/* Bluetooth HCI UART */\n#define N_GIGASET_M101\t16\t/* Siemens Gigaset M101 serial DECT adapter */\n#define N_SLCAN\t\t17\t/* Serial / USB serial CAN Adaptors */\n#define N_PPS\t\t18\t/* Pulse per Second */\n#define N_V253\t\t19\t/* Codec control over voice modem */\n#define N_CAIF\t\t20      /* CAIF protocol for talking to modems */\n#define N_GSM0710\t21\t/* GSM 0710 Mux */\n#define N_TI_WL\t\t22\t/* for TI's WL BT, FM, GPS combo chips */\n#define N_TRACESINK\t23\t/* Trace data routing for MIPI P1149.7 */\n#define N_TRACEROUTER\t24\t/* Trace data routing for MIPI P1149.7 */\n#define N_NCI\t\t25\t/* NFC NCI UART */\n```\n## 3. Data Structure\n\n### 3.1. TTY Core Data Structure\n![tty data structure](https://github.com/JShell07/jshell07.github.io/blob/master/images/kernel_tty/tty_data_structure.png?raw=true)\n\n```c\nstruct tty_struct {\n\tstruct device *dev;\n\tstruct tty_driver *driver;\n\tconst struct tty_operations *ops;\n    struct tty_ldisc *ldisc;\n\tunsigned char *write_buf;\n    ...\n\tstruct tty_port *port;\n}\n\nstruct ktermios {\n\ttcflag_t c_iflag;\t\t/* input mode flags */\n\ttcflag_t c_oflag;\t\t/* output mode flags */\n\ttcflag_t c_cflag;\t\t/* control mode flags */\n\ttcflag_t c_lflag;\t\t/* local mode flags */\n\tcc_t c_line;\t\t\t/* line discipline */\n\tcc_t c_cc[NCCS];\t\t/* control characters */\n\tspeed_t c_ispeed;\t\t/* input speed */\n\tspeed_t c_ospeed;\t\t/* output speed */\n};\n\nstruct tty_ldisc {\n\tstruct tty_ldisc_ops *ops;\n\tstruct tty_struct *tty;\n};\n\nstruct tty_port {\n\tstruct tty_bufhead\tbuf;\t\t/* Locked internally */\n\tstruct tty_struct\t*tty;\t\t/* Back pointer */\n\tstruct tty_struct\t*itty;\t\t/* internal back ptr */\n\tconst struct tty_port_operations *ops;\t/* Port operations */\n\tint\t\t\tcount;\t\t/* Usage count */\n    ...\n\tunsigned char\t\t*xmit_buf;\t/* Optional buffer */\n};\n\nstruct tty_driver {\n\tstruct cdev **cdevs;\n\tconst char\t*driver_name;\n\tconst char\t*name;\n\tint\tmajor;\t\t/* major device number */\n\tint\tminor_start;\t/* start of minor device number */\n\tunsigned int\tnum;\t/* number of devices allocated */\n\tshort\ttype;\t\t/* type of tty driver */\n\tshort\tsubtype;\t/* subtype of tty driver */\n\tstruct ktermios init_termios; /* Initial termios */\n\tunsigned long\tflags;\t\t/* tty driver flags */\n\tstruct proc_dir_entry *proc_entry; /* /proc fs entry */\n\n\t/* Pointer to the tty data structures */\n\tstruct tty_struct **ttys;\n\tstruct tty_port **ports;\n\tstruct ktermios **termios;\n    ...\n\tconst struct tty_operations *ops;\n};\n\n```\n\n### 3.2. Serial Driver Data Structure\n相关数据结构， `struct uart_driver` 用来联系`struct tty_driver`, `uart_port` 则包含了uart 的一些callback(其中大部分参数都是使用struct uart_port) 和固有属性例如:irq, baudrate, fifosize等。 \n\n![serial data structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/serial_data_structure.png)\n\n```c\nstruct uart_state {\n\tstruct tty_port\t\tport;\n\tstruct circ_buf\t\txmit;\n    ...\n\tstruct uart_port\t*uart_port;\n};\n\nstruct uart_port {\n\tunsigned long\tiobase;\t/* in/out[bwl] */\n\tunsigned char __iomem\t*membase; /* read/write[bwl] */\n\t\n\tunsigned int\tirq;\t/* irq number */\n\tunsigned long\tirqflags;\t/* irq flags  */\n\tunsigned int\tuartclk; /* base uart clock */\n\tunsigned int\tfifosize; /* tx fifo size */\n\tunsigned char\tx_char;\t/* xon/xoff char */\n\tunsigned char\tregshift; /* reg offset shift */\n\tunsigned char\tiotype;\t/* io access style */\n\n\tstruct uart_state\t*state;\t/* pointer to parent state */\n\tstruct uart_icount\ticount;\t/* statistics */\n\n\tstruct console\t*cons;\t/* struct console, if any */\n\tunsigned int\ttype;\t/* port type */\n\tconst struct uart ops\t*ops;\n\tunsigned int line;\t/* port index */\n\tstruct device\t*dev;\t/* parent device */\n};\n\nstruct uart_driver {\n\tstruct module\t*owner;\n\tconst char\t*driver_name;\n\tconst char\t*dev_name;\n\tint\tmajor;\n\tint\tminor;\n\tint nr;\n\tstruct console *cons;\n\n\tstruct uart_state *state;\n\tstruct tty_driver *tty_driver;\n};\n```\n\n## 4. Flow\n### 4.1. serial 驱动初始化\n串口驱动初始化，主要涉及两个函数:\n```c\nint uart_register_driver(struct uart_driver *drv);\nint uart_add_one_port(struct uart_driver *drv, struct uart_port *uport);\n```\n`uart_register_driver()`将uart_driver 透过`serial_core`中调用`tty_register_driver()`函数注册`tty_driver`结构体，同时根据Major, Minor 注册char设备。 \n\n之后调用`uart_add_one_port()` 将uart_port 绑定到uart_state上，并注册device_attribute,并最终调用`device_register()`,完成设备模型的注册，最终才会产生\"/dev/ttyS0\"等设备。\n\n![serial initial flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/serial_initial_flow.png)\n\n### 4.1. serial Open Flow\n\n在`uart_add_one_port()`->`tty_port_register_device_attr()`->`tty_cdev_add()`中注册了cdev设备的R/W/Open。\n```c\nstatic const struct file_operations tty_fops = {\n\t.read\t\t= tty_read,\n\t.write\t\t= tty_write,\n\t.unlocked_ioctl\t= tty_ioctl,\n\t.open\t\t= tty_open,\n\t.release\t= tty_release,\n};\n```\n\n因此，从数据结构上观察`struct file_operation`-> `struct tty_operation` -> `struct tty_port_operation` -> `struct uart_ops`，如下图：\n\n![linux_tty_open](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_open_flow.png)\n\n### 4.2. serial Read Flow\nRead 流程可以分为两个部分， 用户空间与硬件的RX 中断函数。可以理解成消费者与生产者的关系。\n\n#### 4.2.1. Consumer\n用户空间调用下来的read， 可以看作是消费者。\n\n![read flow consumer](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_read_flow_consumer.png)\n\n#### 4.2.2. Provider\n在中断服务程序中将收到的ch，扮演生产者的角色，放置到tty_port.tty_buffer, 如果空间不够则调用`__tty_buffer_request_room()` 最小分配256 Bytes.\n\n```c\nint __tty_insert_flip_char(struct tty_port *port, unsigned char ch, char flag)\n{\n\tstruct tty_buffer *tb;\n\tint flags = (flag == TTY_NORMAL) ? TTYB_NORMAL : 0;\n\n\tif (!__tty_buffer_request_room(port, 1, flags))\n\t\treturn 0;\n\n\ttb = port->buf.tail;\n\tif (~tb->flags & TTYB_NORMAL)\n\t\t*flag_buf_ptr(tb, tb->used) = flag;\n\t*char_buf_ptr(tb, tb->used++) = ch;\n\n\treturn 1;\n}\n\nvoid tty_flip_buffer_push(struct tty_port *port)\n{\n\ttty_schedule_flip(port);\n}\n```\n之后调用，`tty_flip_buffer_push()`唤醒work 即`tty_flip_buffer_push()`, 调用到`flush_to_ldisc()`工作队列函数，将tty_buf的数据拷贝到`struct n_tty_data.read_buf`，\n`kill_fasync()`负责唤醒用户空间的异步进程，`wake_up_interruptible_poll()`唤醒在discipline read 时的读等待队列。\n\n![read flow provider](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_read_flow_provider.png)\n\n### 4.3. serial Write Flow\n数据流向是userspace data -> `tty_struct.write_buf`-> `uart_state.xmit`。并且在n_tty.c 中的line routine（discipline）中做了回显的操作。\n\n在Write 的流程中涉及到了如下缓冲区域：\n- tty_struct.write_buf (char *)\n- uart_state.xmit (circ_buf)\n- HW 的TX-FIFO\n\n![tty write flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_write_flow.png)\n\n## Reference\n[Linux TTY framework(1)_基本概念](http://www.wowotech.net/tty_framework/tty_concept.html)\n\n[Linux TTY framework(2)_软件架构](http://www.wowotech.net/tty_framework/tty_architecture.html)\n\n[Linux TTY framework(3)_从应用的角度看TTY设备](http://www.wowotech.net/tty_framework/application_view.html)\n\n[tty驱动分析](http://www.wowotech.net/tty_framework/435.html)","source":"_posts/kernel-tty.md","raw":"---\ntitle: kernel_tty\ndate: 2020-02-17 18:12:19\ntags: tty\ncategories: drivers\n---\n\n## 1. Base\n### 1.1. 常见术语\n|      术语       | 解释                                                                                             |\n| :-------------: | :----------------------------------------------------------------------------------------------- |\n|    Terminal     | 终端，是一个电子（或电气）人机交互设备                                                           |\n| serial Terminal | TTY 设备的一种，通过串口线连接                                                                   |\n|     console     | 控制台，早期PC的键盘显示器，比TTY 终端拥有更多的权限，系统的运行日志、错误信息通常会输出到控制台 |\n\n>第一个Unix终端是一个名字为ASR33的电传打字机，而电传打字机的英文单词为Teletype（或Teletypewritter），缩写为TTY。\n\n<!--more-->\n\n### 1.2. TTY 分类\ntty 设备有几个分类：  \n- console(通常指键盘，显示器)  \n- serial tty(传统意义的HW，输入输出都在一个独立的硬件上，如peripheral uart)\n- VT(virtual tty，传统控制台同一时刻，只能有一个终端使用，为满足多用户、应用，Unix/linux又虚拟出6个终端，可以通过键盘的组合键（CTRL+ALT+ F1~F6）将某一个虚拟终端调出来在屏幕上显示)\n- PTY(Pseudo TTY) 伪终端由pts(pseudo terminal slave)和ptm(pseudo terminal master)组成。\n\n>PTS: 模拟终端完成与shell等应用的TTY 输入、输出需求\n>PTM: 将数据通过socket 等形式与真实设备之间进行通行\n>\n>shell <->  PTS <-> PTM <-> SSHD,XTERM\n\n如果从应用上讲还有如下：\n- 软件终端（PUTTY, SecureCRT, mobalxterm, xshell等， 由软件模拟终端） \n- USB, Ethernet终端（通过其他通信协议模拟终端，例如USB CDC的uart）   \n- 图形终端（GUI图形也可以说成终端的一种，只是不再是TTY框架中了，TTY主要在字符设备范围）\n\n```\n设备号(主, 次)        字符设备                            备注\n(5, 0)               /dev/tty                            控制终端（Controlling Terminal）\n(5, 1)               /dev/console                        控制台终端（Console Terminal）\n(4, 0)               /dev/vc/0 or /dev/tty0              虚拟终端（Virtual Terminal）\n(4, 1)               /dev/vc/1 or /dev/tty1              同上\n…                    …                                   …\n(x, x)               /dev/ttyS0                          串口终端（名称和设备号由驱动自行决定）\n…                    …                                   …\n(x, x)               /dev/ttyUSB0                        USB转串口终端 \n```\n\n## 2. 软件架构\n\n![tty framework structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/linux_tty_framework_structure.png)\n\n### TTY Line Disciplines\nline disciplines(线路规程), 可以把它看成设备驱动和应用接口之间的一个适配层, 按照一些定义的标准进行某些字符的转换。例如\"\\n\", \"\\r\" 之间的转换。在Linux 4.9.x中有这些：\n```c\n/* include/linux/tty.h, line disciplines */\n#define N_TTY\t\t0\n#define N_SLIP\t\t1\n#define N_MOUSE\t\t2\n#define N_PPP\t\t3\n#define N_STRIP\t\t4\n#define N_AX25\t\t5\n#define N_X25\t\t6\t/* X.25 async */\n#define N_6PACK\t\t7\n#define N_MASC\t\t8\t/* Reserved for Mobitex module <kaz@cafe.net> */\n#define N_R3964\t\t9\t/* Reserved for Simatic R3964 module */\n#define N_PROFIBUS_FDL\t10\t/* Reserved for Profibus */\n#define N_IRDA\t\t11\t/* Linux IrDa - http://irda.sourceforge.net/ */\n#define N_SMSBLOCK\t12\t/* SMS block mode - for talking to GSM data */\n\t\t\t\t/* cards about SMS messages */\n#define N_HDLC\t\t13\t/* synchronous HDLC */\n#define N_SYNC_PPP\t14\t/* synchronous PPP */\n#define N_HCI\t\t15\t/* Bluetooth HCI UART */\n#define N_GIGASET_M101\t16\t/* Siemens Gigaset M101 serial DECT adapter */\n#define N_SLCAN\t\t17\t/* Serial / USB serial CAN Adaptors */\n#define N_PPS\t\t18\t/* Pulse per Second */\n#define N_V253\t\t19\t/* Codec control over voice modem */\n#define N_CAIF\t\t20      /* CAIF protocol for talking to modems */\n#define N_GSM0710\t21\t/* GSM 0710 Mux */\n#define N_TI_WL\t\t22\t/* for TI's WL BT, FM, GPS combo chips */\n#define N_TRACESINK\t23\t/* Trace data routing for MIPI P1149.7 */\n#define N_TRACEROUTER\t24\t/* Trace data routing for MIPI P1149.7 */\n#define N_NCI\t\t25\t/* NFC NCI UART */\n```\n## 3. Data Structure\n\n### 3.1. TTY Core Data Structure\n![tty data structure](https://github.com/JShell07/jshell07.github.io/blob/master/images/kernel_tty/tty_data_structure.png?raw=true)\n\n```c\nstruct tty_struct {\n\tstruct device *dev;\n\tstruct tty_driver *driver;\n\tconst struct tty_operations *ops;\n    struct tty_ldisc *ldisc;\n\tunsigned char *write_buf;\n    ...\n\tstruct tty_port *port;\n}\n\nstruct ktermios {\n\ttcflag_t c_iflag;\t\t/* input mode flags */\n\ttcflag_t c_oflag;\t\t/* output mode flags */\n\ttcflag_t c_cflag;\t\t/* control mode flags */\n\ttcflag_t c_lflag;\t\t/* local mode flags */\n\tcc_t c_line;\t\t\t/* line discipline */\n\tcc_t c_cc[NCCS];\t\t/* control characters */\n\tspeed_t c_ispeed;\t\t/* input speed */\n\tspeed_t c_ospeed;\t\t/* output speed */\n};\n\nstruct tty_ldisc {\n\tstruct tty_ldisc_ops *ops;\n\tstruct tty_struct *tty;\n};\n\nstruct tty_port {\n\tstruct tty_bufhead\tbuf;\t\t/* Locked internally */\n\tstruct tty_struct\t*tty;\t\t/* Back pointer */\n\tstruct tty_struct\t*itty;\t\t/* internal back ptr */\n\tconst struct tty_port_operations *ops;\t/* Port operations */\n\tint\t\t\tcount;\t\t/* Usage count */\n    ...\n\tunsigned char\t\t*xmit_buf;\t/* Optional buffer */\n};\n\nstruct tty_driver {\n\tstruct cdev **cdevs;\n\tconst char\t*driver_name;\n\tconst char\t*name;\n\tint\tmajor;\t\t/* major device number */\n\tint\tminor_start;\t/* start of minor device number */\n\tunsigned int\tnum;\t/* number of devices allocated */\n\tshort\ttype;\t\t/* type of tty driver */\n\tshort\tsubtype;\t/* subtype of tty driver */\n\tstruct ktermios init_termios; /* Initial termios */\n\tunsigned long\tflags;\t\t/* tty driver flags */\n\tstruct proc_dir_entry *proc_entry; /* /proc fs entry */\n\n\t/* Pointer to the tty data structures */\n\tstruct tty_struct **ttys;\n\tstruct tty_port **ports;\n\tstruct ktermios **termios;\n    ...\n\tconst struct tty_operations *ops;\n};\n\n```\n\n### 3.2. Serial Driver Data Structure\n相关数据结构， `struct uart_driver` 用来联系`struct tty_driver`, `uart_port` 则包含了uart 的一些callback(其中大部分参数都是使用struct uart_port) 和固有属性例如:irq, baudrate, fifosize等。 \n\n![serial data structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/serial_data_structure.png)\n\n```c\nstruct uart_state {\n\tstruct tty_port\t\tport;\n\tstruct circ_buf\t\txmit;\n    ...\n\tstruct uart_port\t*uart_port;\n};\n\nstruct uart_port {\n\tunsigned long\tiobase;\t/* in/out[bwl] */\n\tunsigned char __iomem\t*membase; /* read/write[bwl] */\n\t\n\tunsigned int\tirq;\t/* irq number */\n\tunsigned long\tirqflags;\t/* irq flags  */\n\tunsigned int\tuartclk; /* base uart clock */\n\tunsigned int\tfifosize; /* tx fifo size */\n\tunsigned char\tx_char;\t/* xon/xoff char */\n\tunsigned char\tregshift; /* reg offset shift */\n\tunsigned char\tiotype;\t/* io access style */\n\n\tstruct uart_state\t*state;\t/* pointer to parent state */\n\tstruct uart_icount\ticount;\t/* statistics */\n\n\tstruct console\t*cons;\t/* struct console, if any */\n\tunsigned int\ttype;\t/* port type */\n\tconst struct uart ops\t*ops;\n\tunsigned int line;\t/* port index */\n\tstruct device\t*dev;\t/* parent device */\n};\n\nstruct uart_driver {\n\tstruct module\t*owner;\n\tconst char\t*driver_name;\n\tconst char\t*dev_name;\n\tint\tmajor;\n\tint\tminor;\n\tint nr;\n\tstruct console *cons;\n\n\tstruct uart_state *state;\n\tstruct tty_driver *tty_driver;\n};\n```\n\n## 4. Flow\n### 4.1. serial 驱动初始化\n串口驱动初始化，主要涉及两个函数:\n```c\nint uart_register_driver(struct uart_driver *drv);\nint uart_add_one_port(struct uart_driver *drv, struct uart_port *uport);\n```\n`uart_register_driver()`将uart_driver 透过`serial_core`中调用`tty_register_driver()`函数注册`tty_driver`结构体，同时根据Major, Minor 注册char设备。 \n\n之后调用`uart_add_one_port()` 将uart_port 绑定到uart_state上，并注册device_attribute,并最终调用`device_register()`,完成设备模型的注册，最终才会产生\"/dev/ttyS0\"等设备。\n\n![serial initial flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/serial_initial_flow.png)\n\n### 4.1. serial Open Flow\n\n在`uart_add_one_port()`->`tty_port_register_device_attr()`->`tty_cdev_add()`中注册了cdev设备的R/W/Open。\n```c\nstatic const struct file_operations tty_fops = {\n\t.read\t\t= tty_read,\n\t.write\t\t= tty_write,\n\t.unlocked_ioctl\t= tty_ioctl,\n\t.open\t\t= tty_open,\n\t.release\t= tty_release,\n};\n```\n\n因此，从数据结构上观察`struct file_operation`-> `struct tty_operation` -> `struct tty_port_operation` -> `struct uart_ops`，如下图：\n\n![linux_tty_open](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_open_flow.png)\n\n### 4.2. serial Read Flow\nRead 流程可以分为两个部分， 用户空间与硬件的RX 中断函数。可以理解成消费者与生产者的关系。\n\n#### 4.2.1. Consumer\n用户空间调用下来的read， 可以看作是消费者。\n\n![read flow consumer](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_read_flow_consumer.png)\n\n#### 4.2.2. Provider\n在中断服务程序中将收到的ch，扮演生产者的角色，放置到tty_port.tty_buffer, 如果空间不够则调用`__tty_buffer_request_room()` 最小分配256 Bytes.\n\n```c\nint __tty_insert_flip_char(struct tty_port *port, unsigned char ch, char flag)\n{\n\tstruct tty_buffer *tb;\n\tint flags = (flag == TTY_NORMAL) ? TTYB_NORMAL : 0;\n\n\tif (!__tty_buffer_request_room(port, 1, flags))\n\t\treturn 0;\n\n\ttb = port->buf.tail;\n\tif (~tb->flags & TTYB_NORMAL)\n\t\t*flag_buf_ptr(tb, tb->used) = flag;\n\t*char_buf_ptr(tb, tb->used++) = ch;\n\n\treturn 1;\n}\n\nvoid tty_flip_buffer_push(struct tty_port *port)\n{\n\ttty_schedule_flip(port);\n}\n```\n之后调用，`tty_flip_buffer_push()`唤醒work 即`tty_flip_buffer_push()`, 调用到`flush_to_ldisc()`工作队列函数，将tty_buf的数据拷贝到`struct n_tty_data.read_buf`，\n`kill_fasync()`负责唤醒用户空间的异步进程，`wake_up_interruptible_poll()`唤醒在discipline read 时的读等待队列。\n\n![read flow provider](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_read_flow_provider.png)\n\n### 4.3. serial Write Flow\n数据流向是userspace data -> `tty_struct.write_buf`-> `uart_state.xmit`。并且在n_tty.c 中的line routine（discipline）中做了回显的操作。\n\n在Write 的流程中涉及到了如下缓冲区域：\n- tty_struct.write_buf (char *)\n- uart_state.xmit (circ_buf)\n- HW 的TX-FIFO\n\n![tty write flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_write_flow.png)\n\n## Reference\n[Linux TTY framework(1)_基本概念](http://www.wowotech.net/tty_framework/tty_concept.html)\n\n[Linux TTY framework(2)_软件架构](http://www.wowotech.net/tty_framework/tty_architecture.html)\n\n[Linux TTY framework(3)_从应用的角度看TTY设备](http://www.wowotech.net/tty_framework/application_view.html)\n\n[tty驱动分析](http://www.wowotech.net/tty_framework/435.html)","slug":"kernel-tty","published":1,"updated":"2020-02-17T14:25:16.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qk002vzkgr7xgt5gtz","content":"<h2 id=\"1-Base\"><a href=\"#1-Base\" class=\"headerlink\" title=\"1. Base\"></a>1. Base</h2><h3 id=\"1-1-常见术语\"><a href=\"#1-1-常见术语\" class=\"headerlink\" title=\"1.1. 常见术语\"></a>1.1. 常见术语</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">术语</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Terminal</td>\n<td style=\"text-align:left\">终端，是一个电子（或电气）人机交互设备</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">serial Terminal</td>\n<td style=\"text-align:left\">TTY 设备的一种，通过串口线连接</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">console</td>\n<td style=\"text-align:left\">控制台，早期PC的键盘显示器，比TTY 终端拥有更多的权限，系统的运行日志、错误信息通常会输出到控制台</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>第一个Unix终端是一个名字为ASR33的电传打字机，而电传打字机的英文单词为Teletype（或Teletypewritter），缩写为TTY。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"1-2-TTY-分类\"><a href=\"#1-2-TTY-分类\" class=\"headerlink\" title=\"1.2. TTY 分类\"></a>1.2. TTY 分类</h3><p>tty 设备有几个分类：  </p>\n<ul>\n<li>console(通常指键盘，显示器)  </li>\n<li>serial tty(传统意义的HW，输入输出都在一个独立的硬件上，如peripheral uart)</li>\n<li>VT(virtual tty，传统控制台同一时刻，只能有一个终端使用，为满足多用户、应用，Unix/linux又虚拟出6个终端，可以通过键盘的组合键（CTRL+ALT+ F1~F6）将某一个虚拟终端调出来在屏幕上显示)</li>\n<li>PTY(Pseudo TTY) 伪终端由pts(pseudo terminal slave)和ptm(pseudo terminal master)组成。</li>\n</ul>\n<blockquote>\n<p>PTS: 模拟终端完成与shell等应用的TTY 输入、输出需求<br>PTM: 将数据通过socket 等形式与真实设备之间进行通行</p>\n<p>shell <->  PTS <-> PTM <-> SSHD,XTERM</-></-></-></p>\n</blockquote>\n<p>如果从应用上讲还有如下：</p>\n<ul>\n<li>软件终端（PUTTY, SecureCRT, mobalxterm, xshell等， 由软件模拟终端） </li>\n<li>USB, Ethernet终端（通过其他通信协议模拟终端，例如USB CDC的uart）   </li>\n<li>图形终端（GUI图形也可以说成终端的一种，只是不再是TTY框架中了，TTY主要在字符设备范围）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设备号(主, 次)        字符设备                            备注</span><br><span class=\"line\">(5, 0)               /dev/tty                            控制终端（Controlling Terminal）</span><br><span class=\"line\">(5, 1)               /dev/console                        控制台终端（Console Terminal）</span><br><span class=\"line\">(4, 0)               /dev/vc/0 or /dev/tty0              虚拟终端（Virtual Terminal）</span><br><span class=\"line\">(4, 1)               /dev/vc/1 or /dev/tty1              同上</span><br><span class=\"line\">…                    …                                   …</span><br><span class=\"line\">(x, x)               /dev/ttyS0                          串口终端（名称和设备号由驱动自行决定）</span><br><span class=\"line\">…                    …                                   …</span><br><span class=\"line\">(x, x)               /dev/ttyUSB0                        USB转串口终端</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-软件架构\"><a href=\"#2-软件架构\" class=\"headerlink\" title=\"2. 软件架构\"></a>2. 软件架构</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/linux_tty_framework_structure.png\" alt=\"tty framework structure\"></p>\n<h3 id=\"TTY-Line-Disciplines\"><a href=\"#TTY-Line-Disciplines\" class=\"headerlink\" title=\"TTY Line Disciplines\"></a>TTY Line Disciplines</h3><p>line disciplines(线路规程), 可以把它看成设备驱动和应用接口之间的一个适配层, 按照一些定义的标准进行某些字符的转换。例如”\\n”, “\\r” 之间的转换。在Linux 4.9.x中有这些：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* include/linux/tty.h, line disciplines */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TTY\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_SLIP\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_MOUSE\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_PPP\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_STRIP\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_AX25\t\t5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_X25\t\t6\t<span class=\"comment\">/* X.25 async */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_6PACK\t\t7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_MASC\t\t8\t<span class=\"comment\">/* Reserved for Mobitex module &lt;kaz@cafe.net&gt; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_R3964\t\t9\t<span class=\"comment\">/* Reserved for Simatic R3964 module */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_PROFIBUS_FDL\t10\t<span class=\"comment\">/* Reserved for Profibus */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_IRDA\t\t11\t<span class=\"comment\">/* Linux IrDa - http://irda.sourceforge.net/ */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_SMSBLOCK\t12\t<span class=\"comment\">/* SMS block mode - for talking to GSM data */</span></span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">/* cards about SMS messages */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_HDLC\t\t13\t<span class=\"comment\">/* synchronous HDLC */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_SYNC_PPP\t14\t<span class=\"comment\">/* synchronous PPP */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_HCI\t\t15\t<span class=\"comment\">/* Bluetooth HCI UART */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_GIGASET_M101\t16\t<span class=\"comment\">/* Siemens Gigaset M101 serial DECT adapter */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_SLCAN\t\t17\t<span class=\"comment\">/* Serial / USB serial CAN Adaptors */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_PPS\t\t18\t<span class=\"comment\">/* Pulse per Second */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_V253\t\t19\t<span class=\"comment\">/* Codec control over voice modem */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_CAIF\t\t20      <span class=\"comment\">/* CAIF protocol for talking to modems */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_GSM0710\t21\t<span class=\"comment\">/* GSM 0710 Mux */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TI_WL\t\t22\t<span class=\"comment\">/* for TI's WL BT, FM, GPS combo chips */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TRACESINK\t23\t<span class=\"comment\">/* Trace data routing for MIPI P1149.7 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TRACEROUTER\t24\t<span class=\"comment\">/* Trace data routing for MIPI P1149.7 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_NCI\t\t25\t<span class=\"comment\">/* NFC NCI UART */</span></span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-Data-Structure\"><a href=\"#3-Data-Structure\" class=\"headerlink\" title=\"3. Data Structure\"></a>3. Data Structure</h2><h3 id=\"3-1-TTY-Core-Data-Structure\"><a href=\"#3-1-TTY-Core-Data-Structure\" class=\"headerlink\" title=\"3.1. TTY Core Data Structure\"></a>3.1. TTY Core Data Structure</h3><p><img src=\"https://github.com/JShell07/jshell07.github.io/blob/master/images/kernel_tty/tty_data_structure.png?raw=true\" alt=\"tty data structure\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ldisc</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *write_buf;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> *<span class=\"title\">port</span>;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">tcflag_t</span> c_iflag;\t\t<span class=\"comment\">/* input mode flags */</span></span><br><span class=\"line\">\t<span class=\"keyword\">tcflag_t</span> c_oflag;\t\t<span class=\"comment\">/* output mode flags */</span></span><br><span class=\"line\">\t<span class=\"keyword\">tcflag_t</span> c_cflag;\t\t<span class=\"comment\">/* control mode flags */</span></span><br><span class=\"line\">\t<span class=\"keyword\">tcflag_t</span> c_lflag;\t\t<span class=\"comment\">/* local mode flags */</span></span><br><span class=\"line\">\t<span class=\"keyword\">cc_t</span> c_line;\t\t\t<span class=\"comment\">/* line discipline */</span></span><br><span class=\"line\">\t<span class=\"keyword\">cc_t</span> c_cc[NCCS];\t\t<span class=\"comment\">/* control characters */</span></span><br><span class=\"line\">\t<span class=\"keyword\">speed_t</span> c_ispeed;\t\t<span class=\"comment\">/* input speed */</span></span><br><span class=\"line\">\t<span class=\"keyword\">speed_t</span> c_ospeed;\t\t<span class=\"comment\">/* output speed */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_bufhead</span>\t<span class=\"title\">buf</span>;</span>\t\t<span class=\"comment\">/* Locked internally */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span>\t*<span class=\"title\">tty</span>;</span>\t\t<span class=\"comment\">/* Back pointer */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span>\t*<span class=\"title\">itty</span>;</span>\t\t<span class=\"comment\">/* internal back ptr */</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port_operations</span> *<span class=\"title\">ops</span>;</span>\t<span class=\"comment\">/* Port operations */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\tcount;\t\t<span class=\"comment\">/* Usage count */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\t\t*xmit_buf;\t<span class=\"comment\">/* Optional buffer */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> **<span class=\"title\">cdevs</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t*driver_name;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t*name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\tmajor;\t\t<span class=\"comment\">/* major device number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\tminor_start;\t<span class=\"comment\">/* start of minor device number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tnum;\t<span class=\"comment\">/* number of devices allocated */</span></span><br><span class=\"line\">\t<span class=\"keyword\">short</span>\ttype;\t\t<span class=\"comment\">/* type of tty driver */</span></span><br><span class=\"line\">\t<span class=\"keyword\">short</span>\tsubtype;\t<span class=\"comment\">/* subtype of tty driver */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> <span class=\"title\">init_termios</span>;</span> <span class=\"comment\">/* Initial termios */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tflags;\t\t<span class=\"comment\">/* tty driver flags */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc_dir_entry</span> *<span class=\"title\">proc_entry</span>;</span> <span class=\"comment\">/* /proc fs entry */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Pointer to the tty data structures */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> **<span class=\"title\">ttys</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> **<span class=\"title\">ports</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> **<span class=\"title\">termios</span>;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-Serial-Driver-Data-Structure\"><a href=\"#3-2-Serial-Driver-Data-Structure\" class=\"headerlink\" title=\"3.2. Serial Driver Data Structure\"></a>3.2. Serial Driver Data Structure</h3><p>相关数据结构， <code>struct uart_driver</code> 用来联系<code>struct tty_driver</code>, <code>uart_port</code> 则包含了uart 的一些callback(其中大部分参数都是使用struct uart_port) 和固有属性例如:irq, baudrate, fifosize等。 </p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/serial_data_structure.png\" alt=\"serial data structure\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_state</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span>\t\t<span class=\"title\">port</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">circ_buf</span>\t\t<span class=\"title\">xmit</span>;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_port</span>\t*<span class=\"title\">uart_port</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_port</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tiobase;\t<span class=\"comment\">/* in/out[bwl] */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __iomem\t*membase; <span class=\"comment\">/* read/write[bwl] */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tirq;\t<span class=\"comment\">/* irq number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tirqflags;\t<span class=\"comment\">/* irq flags  */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tuartclk; <span class=\"comment\">/* base uart clock */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tfifosize; <span class=\"comment\">/* tx fifo size */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\tx_char;\t<span class=\"comment\">/* xon/xoff char */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\tregshift; <span class=\"comment\">/* reg offset shift */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\tiotype;\t<span class=\"comment\">/* io access style */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_state</span>\t*<span class=\"title\">state</span>;</span>\t<span class=\"comment\">/* pointer to parent state */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_icount</span>\t<span class=\"title\">icount</span>;</span>\t<span class=\"comment\">/* statistics */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">console</span>\t*<span class=\"title\">cons</span>;</span>\t<span class=\"comment\">/* struct console, if any */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\ttype;\t<span class=\"comment\">/* port type */</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart</span> <span class=\"title\">ops</span>\t*<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> line;\t<span class=\"comment\">/* port index */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span>\t*<span class=\"title\">dev</span>;</span>\t<span class=\"comment\">/* parent device */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_driver</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span>\t*<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t*driver_name;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t*dev_name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\tmajor;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\tminor;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nr;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">console</span> *<span class=\"title\">cons</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_state</span> *<span class=\"title\">state</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">tty_driver</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-Flow\"><a href=\"#4-Flow\" class=\"headerlink\" title=\"4. Flow\"></a>4. Flow</h2><h3 id=\"4-1-serial-驱动初始化\"><a href=\"#4-1-serial-驱动初始化\" class=\"headerlink\" title=\"4.1. serial 驱动初始化\"></a>4.1. serial 驱动初始化</h3><p>串口驱动初始化，主要涉及两个函数:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uart_register_driver</span><span class=\"params\">(struct uart_driver *drv)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uart_add_one_port</span><span class=\"params\">(struct uart_driver *drv, struct uart_port *uport)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>uart_register_driver()</code>将uart_driver 透过<code>serial_core</code>中调用<code>tty_register_driver()</code>函数注册<code>tty_driver</code>结构体，同时根据Major, Minor 注册char设备。 </p>\n<p>之后调用<code>uart_add_one_port()</code> 将uart_port 绑定到uart_state上，并注册device_attribute,并最终调用<code>device_register()</code>,完成设备模型的注册，最终才会产生”/dev/ttyS0”等设备。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/serial_initial_flow.png\" alt=\"serial initial flow\"></p>\n<h3 id=\"4-1-serial-Open-Flow\"><a href=\"#4-1-serial-Open-Flow\" class=\"headerlink\" title=\"4.1. serial Open Flow\"></a>4.1. serial Open Flow</h3><p>在<code>uart_add_one_port()</code>-&gt;<code>tty_port_register_device_attr()</code>-&gt;<code>tty_cdev_add()</code>中注册了cdev设备的R/W/Open。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">tty_fops</span> = &#123;</span></span><br><span class=\"line\">\t.read\t\t= tty_read,</span><br><span class=\"line\">\t.write\t\t= tty_write,</span><br><span class=\"line\">\t.unlocked_ioctl\t= tty_ioctl,</span><br><span class=\"line\">\t.open\t\t= tty_open,</span><br><span class=\"line\">\t.release\t= tty_release,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>因此，从数据结构上观察<code>struct file_operation</code>-&gt; <code>struct tty_operation</code> -&gt; <code>struct tty_port_operation</code> -&gt; <code>struct uart_ops</code>，如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_open_flow.png\" alt=\"linux_tty_open\"></p>\n<h3 id=\"4-2-serial-Read-Flow\"><a href=\"#4-2-serial-Read-Flow\" class=\"headerlink\" title=\"4.2. serial Read Flow\"></a>4.2. serial Read Flow</h3><p>Read 流程可以分为两个部分， 用户空间与硬件的RX 中断函数。可以理解成消费者与生产者的关系。</p>\n<h4 id=\"4-2-1-Consumer\"><a href=\"#4-2-1-Consumer\" class=\"headerlink\" title=\"4.2.1. Consumer\"></a>4.2.1. Consumer</h4><p>用户空间调用下来的read， 可以看作是消费者。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_read_flow_consumer.png\" alt=\"read flow consumer\"></p>\n<h4 id=\"4-2-2-Provider\"><a href=\"#4-2-2-Provider\" class=\"headerlink\" title=\"4.2.2. Provider\"></a>4.2.2. Provider</h4><p>在中断服务程序中将收到的ch，扮演生产者的角色，放置到tty_port.tty_buffer, 如果空间不够则调用<code>__tty_buffer_request_room()</code> 最小分配256 Bytes.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> __tty_insert_flip_char(struct tty_port *port, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> ch, <span class=\"keyword\">char</span> flag)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_buffer</span> *<span class=\"title\">tb</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> flags = (flag == TTY_NORMAL) ? TTYB_NORMAL : <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!__tty_buffer_request_room(port, <span class=\"number\">1</span>, flags))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttb = port-&gt;buf.tail;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (~tb-&gt;flags &amp; TTYB_NORMAL)</span><br><span class=\"line\">\t\t*flag_buf_ptr(tb, tb-&gt;used) = flag;</span><br><span class=\"line\">\t*char_buf_ptr(tb, tb-&gt;used++) = ch;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tty_flip_buffer_push</span><span class=\"params\">(struct tty_port *port)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\ttty_schedule_flip(port);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后调用，<code>tty_flip_buffer_push()</code>唤醒work 即<code>tty_flip_buffer_push()</code>, 调用到<code>flush_to_ldisc()</code>工作队列函数，将tty_buf的数据拷贝到<code>struct n_tty_data.read_buf</code>，<br><code>kill_fasync()</code>负责唤醒用户空间的异步进程，<code>wake_up_interruptible_poll()</code>唤醒在discipline read 时的读等待队列。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_read_flow_provider.png\" alt=\"read flow provider\"></p>\n<h3 id=\"4-3-serial-Write-Flow\"><a href=\"#4-3-serial-Write-Flow\" class=\"headerlink\" title=\"4.3. serial Write Flow\"></a>4.3. serial Write Flow</h3><p>数据流向是userspace data -&gt; <code>tty_struct.write_buf</code>-&gt; <code>uart_state.xmit</code>。并且在n_tty.c 中的line routine（discipline）中做了回显的操作。</p>\n<p>在Write 的流程中涉及到了如下缓冲区域：</p>\n<ul>\n<li>tty_struct.write_buf (char *)</li>\n<li>uart_state.xmit (circ_buf)</li>\n<li>HW 的TX-FIFO</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_write_flow.png\" alt=\"tty write flow\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/tty_framework/tty_concept.html\" target=\"_blank\" rel=\"noopener\">Linux TTY framework(1)_基本概念</a></p>\n<p><a href=\"http://www.wowotech.net/tty_framework/tty_architecture.html\" target=\"_blank\" rel=\"noopener\">Linux TTY framework(2)_软件架构</a></p>\n<p><a href=\"http://www.wowotech.net/tty_framework/application_view.html\" target=\"_blank\" rel=\"noopener\">Linux TTY framework(3)_从应用的角度看TTY设备</a></p>\n<p><a href=\"http://www.wowotech.net/tty_framework/435.html\" target=\"_blank\" rel=\"noopener\">tty驱动分析</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-Base\"><a href=\"#1-Base\" class=\"headerlink\" title=\"1. Base\"></a>1. Base</h2><h3 id=\"1-1-常见术语\"><a href=\"#1-1-常见术语\" class=\"headerlink\" title=\"1.1. 常见术语\"></a>1.1. 常见术语</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">术语</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Terminal</td>\n<td style=\"text-align:left\">终端，是一个电子（或电气）人机交互设备</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">serial Terminal</td>\n<td style=\"text-align:left\">TTY 设备的一种，通过串口线连接</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">console</td>\n<td style=\"text-align:left\">控制台，早期PC的键盘显示器，比TTY 终端拥有更多的权限，系统的运行日志、错误信息通常会输出到控制台</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>第一个Unix终端是一个名字为ASR33的电传打字机，而电传打字机的英文单词为Teletype（或Teletypewritter），缩写为TTY。</p>\n</blockquote>","more":"<h3 id=\"1-2-TTY-分类\"><a href=\"#1-2-TTY-分类\" class=\"headerlink\" title=\"1.2. TTY 分类\"></a>1.2. TTY 分类</h3><p>tty 设备有几个分类：  </p>\n<ul>\n<li>console(通常指键盘，显示器)  </li>\n<li>serial tty(传统意义的HW，输入输出都在一个独立的硬件上，如peripheral uart)</li>\n<li>VT(virtual tty，传统控制台同一时刻，只能有一个终端使用，为满足多用户、应用，Unix/linux又虚拟出6个终端，可以通过键盘的组合键（CTRL+ALT+ F1~F6）将某一个虚拟终端调出来在屏幕上显示)</li>\n<li>PTY(Pseudo TTY) 伪终端由pts(pseudo terminal slave)和ptm(pseudo terminal master)组成。</li>\n</ul>\n<blockquote>\n<p>PTS: 模拟终端完成与shell等应用的TTY 输入、输出需求<br>PTM: 将数据通过socket 等形式与真实设备之间进行通行</p>\n<p>shell <->  PTS <-> PTM <-> SSHD,XTERM</-></-></-></p>\n</blockquote>\n<p>如果从应用上讲还有如下：</p>\n<ul>\n<li>软件终端（PUTTY, SecureCRT, mobalxterm, xshell等， 由软件模拟终端） </li>\n<li>USB, Ethernet终端（通过其他通信协议模拟终端，例如USB CDC的uart）   </li>\n<li>图形终端（GUI图形也可以说成终端的一种，只是不再是TTY框架中了，TTY主要在字符设备范围）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设备号(主, 次)        字符设备                            备注</span><br><span class=\"line\">(5, 0)               /dev/tty                            控制终端（Controlling Terminal）</span><br><span class=\"line\">(5, 1)               /dev/console                        控制台终端（Console Terminal）</span><br><span class=\"line\">(4, 0)               /dev/vc/0 or /dev/tty0              虚拟终端（Virtual Terminal）</span><br><span class=\"line\">(4, 1)               /dev/vc/1 or /dev/tty1              同上</span><br><span class=\"line\">…                    …                                   …</span><br><span class=\"line\">(x, x)               /dev/ttyS0                          串口终端（名称和设备号由驱动自行决定）</span><br><span class=\"line\">…                    …                                   …</span><br><span class=\"line\">(x, x)               /dev/ttyUSB0                        USB转串口终端</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-软件架构\"><a href=\"#2-软件架构\" class=\"headerlink\" title=\"2. 软件架构\"></a>2. 软件架构</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/linux_tty_framework_structure.png\" alt=\"tty framework structure\"></p>\n<h3 id=\"TTY-Line-Disciplines\"><a href=\"#TTY-Line-Disciplines\" class=\"headerlink\" title=\"TTY Line Disciplines\"></a>TTY Line Disciplines</h3><p>line disciplines(线路规程), 可以把它看成设备驱动和应用接口之间的一个适配层, 按照一些定义的标准进行某些字符的转换。例如”\\n”, “\\r” 之间的转换。在Linux 4.9.x中有这些：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* include/linux/tty.h, line disciplines */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TTY\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_SLIP\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_MOUSE\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_PPP\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_STRIP\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_AX25\t\t5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_X25\t\t6\t<span class=\"comment\">/* X.25 async */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_6PACK\t\t7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_MASC\t\t8\t<span class=\"comment\">/* Reserved for Mobitex module &lt;kaz@cafe.net&gt; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_R3964\t\t9\t<span class=\"comment\">/* Reserved for Simatic R3964 module */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_PROFIBUS_FDL\t10\t<span class=\"comment\">/* Reserved for Profibus */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_IRDA\t\t11\t<span class=\"comment\">/* Linux IrDa - http://irda.sourceforge.net/ */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_SMSBLOCK\t12\t<span class=\"comment\">/* SMS block mode - for talking to GSM data */</span></span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">/* cards about SMS messages */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_HDLC\t\t13\t<span class=\"comment\">/* synchronous HDLC */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_SYNC_PPP\t14\t<span class=\"comment\">/* synchronous PPP */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_HCI\t\t15\t<span class=\"comment\">/* Bluetooth HCI UART */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_GIGASET_M101\t16\t<span class=\"comment\">/* Siemens Gigaset M101 serial DECT adapter */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_SLCAN\t\t17\t<span class=\"comment\">/* Serial / USB serial CAN Adaptors */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_PPS\t\t18\t<span class=\"comment\">/* Pulse per Second */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_V253\t\t19\t<span class=\"comment\">/* Codec control over voice modem */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_CAIF\t\t20      <span class=\"comment\">/* CAIF protocol for talking to modems */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_GSM0710\t21\t<span class=\"comment\">/* GSM 0710 Mux */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TI_WL\t\t22\t<span class=\"comment\">/* for TI's WL BT, FM, GPS combo chips */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TRACESINK\t23\t<span class=\"comment\">/* Trace data routing for MIPI P1149.7 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TRACEROUTER\t24\t<span class=\"comment\">/* Trace data routing for MIPI P1149.7 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_NCI\t\t25\t<span class=\"comment\">/* NFC NCI UART */</span></span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-Data-Structure\"><a href=\"#3-Data-Structure\" class=\"headerlink\" title=\"3. Data Structure\"></a>3. Data Structure</h2><h3 id=\"3-1-TTY-Core-Data-Structure\"><a href=\"#3-1-TTY-Core-Data-Structure\" class=\"headerlink\" title=\"3.1. TTY Core Data Structure\"></a>3.1. TTY Core Data Structure</h3><p><img src=\"https://github.com/JShell07/jshell07.github.io/blob/master/images/kernel_tty/tty_data_structure.png?raw=true\" alt=\"tty data structure\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ldisc</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *write_buf;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> *<span class=\"title\">port</span>;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">tcflag_t</span> c_iflag;\t\t<span class=\"comment\">/* input mode flags */</span></span><br><span class=\"line\">\t<span class=\"keyword\">tcflag_t</span> c_oflag;\t\t<span class=\"comment\">/* output mode flags */</span></span><br><span class=\"line\">\t<span class=\"keyword\">tcflag_t</span> c_cflag;\t\t<span class=\"comment\">/* control mode flags */</span></span><br><span class=\"line\">\t<span class=\"keyword\">tcflag_t</span> c_lflag;\t\t<span class=\"comment\">/* local mode flags */</span></span><br><span class=\"line\">\t<span class=\"keyword\">cc_t</span> c_line;\t\t\t<span class=\"comment\">/* line discipline */</span></span><br><span class=\"line\">\t<span class=\"keyword\">cc_t</span> c_cc[NCCS];\t\t<span class=\"comment\">/* control characters */</span></span><br><span class=\"line\">\t<span class=\"keyword\">speed_t</span> c_ispeed;\t\t<span class=\"comment\">/* input speed */</span></span><br><span class=\"line\">\t<span class=\"keyword\">speed_t</span> c_ospeed;\t\t<span class=\"comment\">/* output speed */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_bufhead</span>\t<span class=\"title\">buf</span>;</span>\t\t<span class=\"comment\">/* Locked internally */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span>\t*<span class=\"title\">tty</span>;</span>\t\t<span class=\"comment\">/* Back pointer */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span>\t*<span class=\"title\">itty</span>;</span>\t\t<span class=\"comment\">/* internal back ptr */</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port_operations</span> *<span class=\"title\">ops</span>;</span>\t<span class=\"comment\">/* Port operations */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t\t\tcount;\t\t<span class=\"comment\">/* Usage count */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\t\t*xmit_buf;\t<span class=\"comment\">/* Optional buffer */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> **<span class=\"title\">cdevs</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t*driver_name;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t*name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\tmajor;\t\t<span class=\"comment\">/* major device number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\tminor_start;\t<span class=\"comment\">/* start of minor device number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tnum;\t<span class=\"comment\">/* number of devices allocated */</span></span><br><span class=\"line\">\t<span class=\"keyword\">short</span>\ttype;\t\t<span class=\"comment\">/* type of tty driver */</span></span><br><span class=\"line\">\t<span class=\"keyword\">short</span>\tsubtype;\t<span class=\"comment\">/* subtype of tty driver */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> <span class=\"title\">init_termios</span>;</span> <span class=\"comment\">/* Initial termios */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tflags;\t\t<span class=\"comment\">/* tty driver flags */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc_dir_entry</span> *<span class=\"title\">proc_entry</span>;</span> <span class=\"comment\">/* /proc fs entry */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Pointer to the tty data structures */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> **<span class=\"title\">ttys</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> **<span class=\"title\">ports</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> **<span class=\"title\">termios</span>;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-Serial-Driver-Data-Structure\"><a href=\"#3-2-Serial-Driver-Data-Structure\" class=\"headerlink\" title=\"3.2. Serial Driver Data Structure\"></a>3.2. Serial Driver Data Structure</h3><p>相关数据结构， <code>struct uart_driver</code> 用来联系<code>struct tty_driver</code>, <code>uart_port</code> 则包含了uart 的一些callback(其中大部分参数都是使用struct uart_port) 和固有属性例如:irq, baudrate, fifosize等。 </p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/serial_data_structure.png\" alt=\"serial data structure\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_state</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span>\t\t<span class=\"title\">port</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">circ_buf</span>\t\t<span class=\"title\">xmit</span>;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_port</span>\t*<span class=\"title\">uart_port</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_port</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tiobase;\t<span class=\"comment\">/* in/out[bwl] */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __iomem\t*membase; <span class=\"comment\">/* read/write[bwl] */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tirq;\t<span class=\"comment\">/* irq number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>\tirqflags;\t<span class=\"comment\">/* irq flags  */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tuartclk; <span class=\"comment\">/* base uart clock */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tfifosize; <span class=\"comment\">/* tx fifo size */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\tx_char;\t<span class=\"comment\">/* xon/xoff char */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\tregshift; <span class=\"comment\">/* reg offset shift */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>\tiotype;\t<span class=\"comment\">/* io access style */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_state</span>\t*<span class=\"title\">state</span>;</span>\t<span class=\"comment\">/* pointer to parent state */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_icount</span>\t<span class=\"title\">icount</span>;</span>\t<span class=\"comment\">/* statistics */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">console</span>\t*<span class=\"title\">cons</span>;</span>\t<span class=\"comment\">/* struct console, if any */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\ttype;\t<span class=\"comment\">/* port type */</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart</span> <span class=\"title\">ops</span>\t*<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> line;\t<span class=\"comment\">/* port index */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span>\t*<span class=\"title\">dev</span>;</span>\t<span class=\"comment\">/* parent device */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_driver</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span>\t*<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t*driver_name;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t*dev_name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\tmajor;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\tminor;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nr;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">console</span> *<span class=\"title\">cons</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_state</span> *<span class=\"title\">state</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">tty_driver</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-Flow\"><a href=\"#4-Flow\" class=\"headerlink\" title=\"4. Flow\"></a>4. Flow</h2><h3 id=\"4-1-serial-驱动初始化\"><a href=\"#4-1-serial-驱动初始化\" class=\"headerlink\" title=\"4.1. serial 驱动初始化\"></a>4.1. serial 驱动初始化</h3><p>串口驱动初始化，主要涉及两个函数:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uart_register_driver</span><span class=\"params\">(struct uart_driver *drv)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uart_add_one_port</span><span class=\"params\">(struct uart_driver *drv, struct uart_port *uport)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>uart_register_driver()</code>将uart_driver 透过<code>serial_core</code>中调用<code>tty_register_driver()</code>函数注册<code>tty_driver</code>结构体，同时根据Major, Minor 注册char设备。 </p>\n<p>之后调用<code>uart_add_one_port()</code> 将uart_port 绑定到uart_state上，并注册device_attribute,并最终调用<code>device_register()</code>,完成设备模型的注册，最终才会产生”/dev/ttyS0”等设备。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/serial_initial_flow.png\" alt=\"serial initial flow\"></p>\n<h3 id=\"4-1-serial-Open-Flow\"><a href=\"#4-1-serial-Open-Flow\" class=\"headerlink\" title=\"4.1. serial Open Flow\"></a>4.1. serial Open Flow</h3><p>在<code>uart_add_one_port()</code>-&gt;<code>tty_port_register_device_attr()</code>-&gt;<code>tty_cdev_add()</code>中注册了cdev设备的R/W/Open。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">tty_fops</span> = &#123;</span></span><br><span class=\"line\">\t.read\t\t= tty_read,</span><br><span class=\"line\">\t.write\t\t= tty_write,</span><br><span class=\"line\">\t.unlocked_ioctl\t= tty_ioctl,</span><br><span class=\"line\">\t.open\t\t= tty_open,</span><br><span class=\"line\">\t.release\t= tty_release,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>因此，从数据结构上观察<code>struct file_operation</code>-&gt; <code>struct tty_operation</code> -&gt; <code>struct tty_port_operation</code> -&gt; <code>struct uart_ops</code>，如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_open_flow.png\" alt=\"linux_tty_open\"></p>\n<h3 id=\"4-2-serial-Read-Flow\"><a href=\"#4-2-serial-Read-Flow\" class=\"headerlink\" title=\"4.2. serial Read Flow\"></a>4.2. serial Read Flow</h3><p>Read 流程可以分为两个部分， 用户空间与硬件的RX 中断函数。可以理解成消费者与生产者的关系。</p>\n<h4 id=\"4-2-1-Consumer\"><a href=\"#4-2-1-Consumer\" class=\"headerlink\" title=\"4.2.1. Consumer\"></a>4.2.1. Consumer</h4><p>用户空间调用下来的read， 可以看作是消费者。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_read_flow_consumer.png\" alt=\"read flow consumer\"></p>\n<h4 id=\"4-2-2-Provider\"><a href=\"#4-2-2-Provider\" class=\"headerlink\" title=\"4.2.2. Provider\"></a>4.2.2. Provider</h4><p>在中断服务程序中将收到的ch，扮演生产者的角色，放置到tty_port.tty_buffer, 如果空间不够则调用<code>__tty_buffer_request_room()</code> 最小分配256 Bytes.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> __tty_insert_flip_char(struct tty_port *port, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> ch, <span class=\"keyword\">char</span> flag)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_buffer</span> *<span class=\"title\">tb</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> flags = (flag == TTY_NORMAL) ? TTYB_NORMAL : <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!__tty_buffer_request_room(port, <span class=\"number\">1</span>, flags))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttb = port-&gt;buf.tail;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (~tb-&gt;flags &amp; TTYB_NORMAL)</span><br><span class=\"line\">\t\t*flag_buf_ptr(tb, tb-&gt;used) = flag;</span><br><span class=\"line\">\t*char_buf_ptr(tb, tb-&gt;used++) = ch;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tty_flip_buffer_push</span><span class=\"params\">(struct tty_port *port)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\ttty_schedule_flip(port);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后调用，<code>tty_flip_buffer_push()</code>唤醒work 即<code>tty_flip_buffer_push()</code>, 调用到<code>flush_to_ldisc()</code>工作队列函数，将tty_buf的数据拷贝到<code>struct n_tty_data.read_buf</code>，<br><code>kill_fasync()</code>负责唤醒用户空间的异步进程，<code>wake_up_interruptible_poll()</code>唤醒在discipline read 时的读等待队列。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_read_flow_provider.png\" alt=\"read flow provider\"></p>\n<h3 id=\"4-3-serial-Write-Flow\"><a href=\"#4-3-serial-Write-Flow\" class=\"headerlink\" title=\"4.3. serial Write Flow\"></a>4.3. serial Write Flow</h3><p>数据流向是userspace data -&gt; <code>tty_struct.write_buf</code>-&gt; <code>uart_state.xmit</code>。并且在n_tty.c 中的line routine（discipline）中做了回显的操作。</p>\n<p>在Write 的流程中涉及到了如下缓冲区域：</p>\n<ul>\n<li>tty_struct.write_buf (char *)</li>\n<li>uart_state.xmit (circ_buf)</li>\n<li>HW 的TX-FIFO</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_tty/tty_write_flow.png\" alt=\"tty write flow\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.wowotech.net/tty_framework/tty_concept.html\" target=\"_blank\" rel=\"noopener\">Linux TTY framework(1)_基本概念</a></p>\n<p><a href=\"http://www.wowotech.net/tty_framework/tty_architecture.html\" target=\"_blank\" rel=\"noopener\">Linux TTY framework(2)_软件架构</a></p>\n<p><a href=\"http://www.wowotech.net/tty_framework/application_view.html\" target=\"_blank\" rel=\"noopener\">Linux TTY framework(3)_从应用的角度看TTY设备</a></p>\n<p><a href=\"http://www.wowotech.net/tty_framework/435.html\" target=\"_blank\" rel=\"noopener\">tty驱动分析</a></p>"},{"title":"kernel_ubi","date":"2019-07-05T08:55:03.000Z","_content":"\n## 1. 背景\n\nFlash 设备存在如下缺点\n- 存在坏块  \n- 使用寿命较短  \n- 存储介质不稳定(bitflip)  \n- 读写速度慢  \n- 只能通过擦除将0改成1  \n- 最小读写单位为page or sub-page  \n\n<!--more-->\n\nKernel 引入UBI (Unsorted Block Images)来解决这些问题。<font color=red>UBI 本身就是针对RAW Flash的一个卷管理系统，并且提供基于磨损均衡的逻辑到物理的映射</font>。它类似于LVM（Logical Volume Manager)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/mtd%20partition%20vs%20ubi%20volume.png)\n\n因此UBI 具有如下特点：\n- UBI provides volumes which may be dynamically created, removed, or re-sized\n- UBI implements wear-leveling across whole flash device \n- UBI transparently handles bad physical eraseblocks;\n- UBI minimizes chances to lose data by means of scrubbing. （针对Nand Flash 的bit flip现象，将有bit-flips的数据块移动到好的数据块上）\n\n<!--more-->\n\n## 2. 框架\n在kernel MTD 模块看来， UBI 子系统的框架如下图：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi%20structure.png)\n\nUBI 子模块的文件组织结构如下图：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi%20software%20structure.png)\n\n文件名 | 说明\n:-: | :-\ncdev.c | 字符设备节点访问操作, attach/detach MTD, volume add/remove/rename/resize\nbuild.c | /dev/ubictrl, /sys 等节点注册\nattach.c | attach MTD sub-system\nvmt.c | volume 逻辑操作，增删， 重命名， 重新设定size \nvtbl.c | vmt.c 的下层，实际操作读写\nfastmap.c | 支持快速扫描MTD 设备\nupd.c | update volume, 考虑到突然掉电等引起的更新错误\neba.c | Erase Block Association sub-system 子系统， 逻辑映射\nwl.c | wear-leveling sub-system 磨损均衡子系统\nio.c | <font color=red>与MTD 设备I/O 交互, R/W data, VID(volume ID)/EC(Erase Counter) header </font>  \nkapi.c | 向UBIFS 提供的api 接口\n\n\n## 3. 代码分析\n### 3.1. 数据结构\n#### 3.1.1. UBI Headers\nUBI 包含两个被CRC32 保护的64 bytes header在每一个非坏块的开始：\n- erase counter(EC) header\n- volume identifier(VID) header\n\n因此，LEB < PEB 就是因为存储了UBI headers.\n\n参见 drivers/mtd/ubi/ubi-media.h\n```c\nstruct ubi_ec_hdr {\n\t__be32  magic;\n\t__u8    version;\n\t__u8    padding1[3];\n\t__be64  ec; /* Warning: the current limit is 31-bit anyway! */\n\t__be32  vid_hdr_offset;\n\t__be32  data_offset;\n\t__be32  image_seq;\n\t__u8    padding2[32];\n\t__be32  hdr_crc;\n} __packed;\n```\n每一次Erase 都会将EC 值增加。在unclean reboot 发生或者数据被corrupted， EC 将会被写入attach MTD 设备扫描的EC average。\n\n```c\nstruct ubi_vid_hdr {\n\t__be32  magic;\n\t__u8    version;\n\t__u8    vol_type;\n\t__u8    copy_flag;\n\t__u8    compat;\n\t__be32  vol_id;\n\t__be32  lnum;\n\t__u8    padding1[4];\n\t__be32  data_size;\n\t__be32  used_ebs;\n\t__be32  data_pad;\n\t__be32  data_crc;\n\t__u8    padding2[4];\n\t__be64  sqnum;\n\t__u8    padding3[12];\n\t__be32  hdr_crc;\n} __packed;\n```\nEC header 存储offset 为0， 而VID header 存储offset 为next min I/O Unit, sub-page or page.\n- NOR Flash, min I/O 为 1 byte, VID header offset 为64\n- Nand Flash, sub-page or page\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/UBI%20headers.png)\n\n#### 3.1.2. volume table \n数据是存储在flash 设备上， volume table 是ubit_vtbl_record 的数组，每一个记录它包含了如下meta-data:  \n- 卷名  \n- 保留物理擦除快的数量  \n- 类型(static or dynamica) \n- crc 校验  \n- update marker（用于标记更新volume name or size）  \n\n```c\nstruct ubi_vtbl_record {\n\t__be32  reserved_pebs;\n\t__be32  alignment;\n\t__be32  data_pad;\n\t__u8    vol_type;\n\t__u8    upd_marker;\n\t__be16  name_len;\n\t__u8    name[UBI_VOL_NAME_MAX+1];\n\t__u8    flags;\n\t__u8    padding[23];\n\t__be32  crc;\n} __packed;\n```\n\nUBI 使用了两个逻辑擦除快(Logical EraseBlock)保存record 数据，LEB0 and LEB1. 他们两者相互拷贝，以此来保证突发事件例如掉电等异常情形。当attach MTD 设备时，UBI确保这两个volume table是相同的，否则上次可能是unclean boot导致，使用新的，无corrupted data 拷贝到另一块。\n\nUBI 需要维护三种table:\n- volume table  \n- eraseblock association(EBA) table  \n- erase counter(EC) table  \n\nvolume table 是存储在Flash 上，它的修改只会发生在create, delete, re-size 时。\n\nEBA table 是用于logical to phsical 映射关系。\nEC table 包含每个PEB 的erase conter 值， UBI wear-leveling 将会使用此表格。\n\nEBA, EC table 可以做到存储在flash 上，但是它需要journaling, journal replay, journal commit 等，在boot-loader 时保证简单，代码的size 是不太容易的。\n\n因此， __EBA, EC table 默认在attach MTD 时，根据扫描的EC,VID header 信息在RAM 中构建.__ \n\n在vid_hdr 中包含的vol_id, lnum, squm 指定了他们的volume_id， squm 序列号， lnum 逻辑num 号， UBI attach 子系统在attach 时，根据这些信息创建red-block tree， 就能顺序读取data。\n\n### 3.2. UBI Sub-system\n#### 3.2.1. attach mtd\n本质是扫描(scan_all or scan_fast(fastmap))MTD 设备上的EC、VID header 信息生成volume 等结构体。\n\n相关的数据接口如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_data_structure.png)\n\nubi_ainf_peb -> ubi_ainf_volume.rb -> ubi_attach_info.volume。\n```c\nstruct ubi_attach_info {\n\tstruct rb_root volumes;\n\tstruct list_head corr;\n\tstruct list_head free;\n\tstruct list_head erase;\n\tstruct list_head alien;\n\tint corr_peb_count;\n\tint empty_peb_count;\n\tint alien_peb_count;\n\tint bad_peb_count;\n\tint maybe_bad_peb_count;\n\tint vols_found;\n\tint highest_vol_id;\n\tint is_empty;\n\tint min_ec;\n\tint max_ec;\n\tunsigned long long max_sqnum;\n\tint mean_ec;\n\tuint64_t ec_sum;\n\tint ec_count;\n\tstruct kmem_cache *aeb_slab_cache;\n};\n\nstruct ubi_ainf_volume {\n\tint vol_id;\n\tint highest_lnum;\n\tint leb_count;\n\tint vol_type;\n\tint used_ebs;\n\tint last_data_size;\n\tint data_pad;\n\tint compat;\n\tstruct rb_node rb; /* link in the volume RB-tree */\n\tstruct rb_root root;\n};\n\nstruct ubi_ainf_peb {\n\tint ec;\n\tint pnum;\t/* physical eraseblock number */\n\tint vol_id; /* ID of the volume this LEB belongs to */\n\tint lnum;\t/* logical eraseblock number */\n\tunsigned int scrub:1;\n\tunsigned int copy_flag:1;\n\tunsigned long long sqnum;\n\tunion {\n\t\tstruct rb_node rb;\t/* link in the per-volume RB-tree of &struct ubi_ainf_peb objects */\n\t\tstruct list_head list;\n\t} u;\n};\n```\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_attach.png)\nscan_all() 扫描每一个peb 并读取其中的ec_hdr, vid_hdr。 这里分层了三层结构体：\n- ubi_attach_info  \n- ubi_ainf_volume  \n- ubi_ainf_peb  \n管理volume， 以及属于该volume 的全部pebs 分类清晰，便于管理。\n\nubi_read_volume_table() 会在RAM 中生成volume table record. 他们是存放在具体的vol_id 的前两个LEB[0,1]中， 在process_lvol() 读取数据，并检查是否数据污染。\n\n#### 3.2.2. eba, eraseblock association\n在attach 时候， 调用ubi_eba_init（）, UBI EBA 子系统会根据数据结构 ubi_attach_info -> ubi_ainf_volume -> ubi_ainf_peb, 在ubi_ainf_peb 里面记录了pnum, lnum，这就是物理逻辑映射关系。\n\n```c\nint ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)\n{\n\tfor (i = 0; i < num_volumes; i++) {\n\t\tvol = ubi->volumes[i];\n\t\tif (!vol)\n\t\t\tcontinue;\n\t\tvol->eba_tbl = kmalloc(vol->reserved_pebs * sizeof(int),\n\t\t\t\t       GFP_KERNEL);\n\t\tfor (j = 0; j < vol->reserved_pebs; j++)\n\t\t\tvol->eba_tbl[j] = UBI_LEB_UNMAPPED;\n\n\t\tav = ubi_find_av(ai, idx2vol_id(ubi, i));\n\t\tif (!av)\n\t\t\tcontinue;\n\n\t\tubi_rb_for_each_entry(rb, aeb, &av->root, u.rb) {\n\t\t\tif (aeb->lnum >= vol->reserved_pebs)\n\t\t\t\t/*\n\t\t\t\t * This may happen in case of an unclean reboot\n\t\t\t\t * during re-size.\n\t\t\t\t */\n\t\t\t\tubi_move_aeb_to_list(av, aeb, &ai->erase);\n\t\t\tvol->eba_tbl[aeb->lnum] = aeb->pnum;\n\t\t}\n\t}\n}\t\t\t   \n```\n\n后续的write, read 都是通过在RAM 中的eba_tlb 进行逻辑查询后，再调用到io -> mtd.read/write\n假如EBA 没有映射， 调用Wear-leveling 子系统获取PEB。\n\n至于lnum 的值在UBIFS 中体现，是从上层下来。UBI wear-leveling 会考虑磨损均衡的情况下选择合适的PEBs 映射到某一个lnum 上。\n\n__marking eraseblocks as bad__\n判断依据：\n- 写操作时失败，UBI 将数据搬移，并准备对该eraseblock 进行torturing(拷问，审查)。\n- erase 操作失败EIO error， 直接将它标记为bad\n\ntorturing 主要是两方面\n1. eraseblock, and read check all is 0xFF\n2. write data, and read check\n\n#### 3.2.3. wear-leveling\n磨损均衡是UBI的核心功能之一，负责管理PEB的分配、回收、擦除、scrub、磨损均衡等, 在这些操作时都会触发磨损均衡检查。其中scrub、擦除, 磨损均衡功能由UBI后台线程进行异步调度管理。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_wl.png)\n```c\nstruct ubi_wl_entry {\n\tunion {\n\t\tstruct rb_node rb;  /* link in the corresponding (free/used) RB-tree*/\n\t\tstruct list_head list;\n\t} u;\n\tint ec;\n\tint pnum;\n};\n```\n\n如果used peb 的EC 与free peb 的EC 差大于 <font color=red>UBI_WL_THRESHOLD</font> 则会考虑使用wear-leveling 子系统进行磨损均衡搬移，避免过多的搬移数据造成本身的反复擦除。\n```c\nstatic int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,\n\t\t\t\tint shutdown)\n{\n\tint err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;\n\tint vol_id = -1, uninitialized_var(lnum);\n\n\tstruct ubi_wl_entry *e1, *e2;\n\tstruct ubi_vid_hdr *vid_hdr;\n\n\tvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);\n\n\tmutex_lock(&ubi->move_mutex);\n\tspin_lock(&ubi->wl_lock);\n\n\tif (!ubi->scrub.rb_node) {\n\t\t/*\n\t\t * Now pick the least worn-out used physical eraseblock and a\n\t\t * highly worn-out free physical eraseblock. If the erase\n\t\t * counters differ much enough, start wear-leveling.\n\t\t */\n\t\te1 = rb_entry(rb_first(&ubi->used), struct ubi_wl_entry, u.rb);\n\t\te2 = get_peb_for_wl(ubi);\n\n\t\tif (!(e2->ec - e1->ec >= UBI_WL_THRESHOLD)) {\n\t\t\tdbg_wl(\"no WL needed: min used EC %d, max free EC %d\",\n\t\t\t       e1->ec, e2->ec);\n\n\t\t\t/* Give the unused PEB back */\n\t\t\twl_tree_add(e2, &ubi->free);\n\t\t\tubi->free_count++;\n\t\t\tgoto out_cancel;\n\t\t}\n\t\trb_erase(&e1->u.rb, &ubi->used);\n\t\tdbg_wl(\"move PEB %d EC %d to PEB %d EC %d\",\n\t\t       e1->pnum, e1->ec, e2->pnum, e2->ec);\n\t} else {\n\t\t/* Perform scrubbing */\n\t\tscrubbing = 1;\n\t\te1 = rb_entry(rb_first(&ubi->scrub), struct ubi_wl_entry, u.rb);\n\t\te2 = get_peb_for_wl(ubi);\n\t\t\n\t\trb_erase(&e1->u.rb, &ubi->scrub);\n\t\tdbg_wl(\"scrub PEB %d to PEB %d\", e1->pnum, e2->pnum);\n\t}\n\n\tubi->move_from = e1;\n\tubi->move_to = e2;\n\tspin_unlock(&ubi->wl_lock);\n\n\t/*\n\t * Now we are going to copy physical eraseblock @e1->pnum to @e2->pnum.\n\t * We so far do not know which logical eraseblock our physical\n\t * eraseblock (@e1) belongs to. We have to read the volume identifier\n\t * header first.\n\t *\n\t * Note, we are protected from this PEB being unmapped and erased. The\n\t * 'ubi_wl_put_peb()' would wait for moving to be finished if the PEB\n\t * which is being moved was unmapped.\n\t */\n\terr = ubi_io_read_vid_hdr(ubi, e1->pnum, vid_hdr, 0);\n\n\tvol_id = be32_to_cpu(vid_hdr->vol_id);\n\tlnum = be32_to_cpu(vid_hdr->lnum);\n\n\terr = ubi_eba_copy_leb(ubi, e1->pnum, e2->pnum, vid_hdr);\n\n\t/* The PEB has been successfully moved */\n\tif (scrubbing)\n\t\tubi_msg(\"scrubbed PEB %d (LEB %d:%d), data moved to PEB %d\",\n\t\t\te1->pnum, vol_id, lnum, e2->pnum);\n\tubi_free_vid_hdr(ubi, vid_hdr);\n\n\tspin_lock(&ubi->wl_lock);\n\tif (!ubi->move_to_put) {\n\t\twl_tree_add(e2, &ubi->used);\n\t\te2 = NULL;\n\t}\n\tubi->move_from = ubi->move_to = NULL;\n\tubi->move_to_put = ubi->wl_scheduled = 0;\n\tspin_unlock(&ubi->wl_lock);\n\n\terr = do_sync_erase(ubi, e1, vol_id, lnum, 0);\n\n\tif (e2) {\n\t\t/*\n\t\t * Well, the target PEB was put meanwhile, schedule it for\n\t\t * erasure.\n\t\t */\n\t\tdbg_wl(\"PEB %d (LEB %d:%d) was put meanwhile, erase\",\n\t\t       e2->pnum, vol_id, lnum);\n\t\terr = do_sync_erase(ubi, e2, vol_id, lnum, 0);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\tmutex_unlock(&ubi->move_mutex);\n\treturn 0;\n}\n```\n\n在EBA write 时，如果没有映射，我们就会调用ubi_wl_get_peb() 获取free PEB。 \n* drivers/mtd/ubi/wl.c *\nubi_wl_get_peb() ->  \n&nbsp;&nbsp;__wl_get_peb() ->  \n\n```c\nint ubi_eba_write_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\n\t\t      const void *buf, int offset, int len)\n{\n\tint err, pnum, tries = 0, vol_id = vol->vol_id;\n\tstruct ubi_vid_hdr *vid_hdr;\n\n\terr = leb_write_lock(ubi, vol_id, lnum);\n\n\tpnum = vol->eba_tbl[lnum];\n\tif (pnum >= 0) {\n\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);\n\t\tleb_write_unlock(ubi, vol_id, lnum);\n\t\treturn err;\n\t}\n\n\t/*\n\t * The logical eraseblock is not mapped. We have to get a free physical\n\t * eraseblock and write the volume identifier header there first.\n\t */\n\tvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);\n\n\tvid_hdr->vol_type = UBI_VID_DYNAMIC;\n\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tvid_hdr->vol_id = cpu_to_be32(vol_id);\n\tvid_hdr->lnum = cpu_to_be32(lnum);\n\tvid_hdr->compat = ubi_get_compat(ubi, vol_id);\n\tvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\n\nretry:\n\tpnum = ubi_wl_get_peb(ubi);\n\n\terr = ubi_io_write_vid_hdr(ubi, pnum, vid_hdr);\n\n\tif (len) {\n\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);\n\t}\n\n\tdown_read(&ubi->fm_sem);\n\tvol->eba_tbl[lnum] = pnum;\n\tup_read(&ubi->fm_sem);\n\n\tleb_write_unlock(ubi, vol_id, lnum);\n\tubi_free_vid_hdr(ubi, vid_hdr);\n\treturn 0;\n}\n\nstatic int __wl_get_peb(struct ubi_device *ubi)\n{\n\tint err;\n\tstruct ubi_wl_entry *e;\n\nretry:\n\tif (!ubi->free.rb_node) {\n\t\tif (ubi->works_count == 0) {\n\t\t\tubi_err(\"no free eraseblocks\");\n\t\t\tubi_assert(list_empty(&ubi->works));\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\terr = produce_free_peb(ubi);\n\n\t\tgoto retry;\n\t}\n\n\te = find_mean_wl_entry(ubi, &ubi->free);\n\t/*\n\t * Move the physical eraseblock to the protection queue where it will\n\t * be protected from being moved for some time.\n\t */\n\trb_erase(&e->u.rb, &ubi->free);\n\tubi->free_count--;\n\n\treturn e->pnum;\n}\n```\n#### 3.2.4. fastmap\nfastmap 利用存储在flash 上的fastmap volume 以此来加速attach。 \n__fastmap 一般用于large flash， 例如4Gib Nand chips。__\n是否启用fastmap, 需要考虑到fastmap 本身会占用一些PEB，并且fastmap pool full, volume layout change or detach时，fastmap都需要写入信息到保留的PEB 中。\n\nfastmap volume中存储的信息有：\n- erase value\n- a list of all PEBs and their state  \n- a list of all volumes and their EBA \n- a list of PEBs called fastmap pool   \n\nfastmap 还有一个fastmap pool 概念， 它的size 大约为 5% of the total amount of PEBs。我们从fastmap pool 中取用PEBs，这样我们只需要关心fastmap pool 的PEBs， 而不用关心total PEBs, 减少了需要存储的信息量。\n\n## 参看资料\n[Linux UBI子系统设计初探](https://www.cnblogs.com/wahaha02/p/4814698.html)\n\n[ubi 官方文档](http://www.linux-mtd.infradead.org/doc/ubi.html)\n\n[ubi design pdf from MTD org](http://www.linux-mtd.infradead.org/doc/ubidesign/ubidesign.pdf)\n\n[ubi ppt from MTD org](http://www.linux-mtd.infradead.org/doc/ubi.ppt)\n\n[elinux/ubifs](https://elinux.org/UBIFS)","source":"_posts/kernel-ubi.md","raw":"---\ntitle: kernel_ubi\ndate: 2019-07-05 16:55:03\ntags: \n    - mtd\n    - ubi\ncategories: \n    - drivers\n---\n\n## 1. 背景\n\nFlash 设备存在如下缺点\n- 存在坏块  \n- 使用寿命较短  \n- 存储介质不稳定(bitflip)  \n- 读写速度慢  \n- 只能通过擦除将0改成1  \n- 最小读写单位为page or sub-page  \n\n<!--more-->\n\nKernel 引入UBI (Unsorted Block Images)来解决这些问题。<font color=red>UBI 本身就是针对RAW Flash的一个卷管理系统，并且提供基于磨损均衡的逻辑到物理的映射</font>。它类似于LVM（Logical Volume Manager)\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/mtd%20partition%20vs%20ubi%20volume.png)\n\n因此UBI 具有如下特点：\n- UBI provides volumes which may be dynamically created, removed, or re-sized\n- UBI implements wear-leveling across whole flash device \n- UBI transparently handles bad physical eraseblocks;\n- UBI minimizes chances to lose data by means of scrubbing. （针对Nand Flash 的bit flip现象，将有bit-flips的数据块移动到好的数据块上）\n\n<!--more-->\n\n## 2. 框架\n在kernel MTD 模块看来， UBI 子系统的框架如下图：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi%20structure.png)\n\nUBI 子模块的文件组织结构如下图：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi%20software%20structure.png)\n\n文件名 | 说明\n:-: | :-\ncdev.c | 字符设备节点访问操作, attach/detach MTD, volume add/remove/rename/resize\nbuild.c | /dev/ubictrl, /sys 等节点注册\nattach.c | attach MTD sub-system\nvmt.c | volume 逻辑操作，增删， 重命名， 重新设定size \nvtbl.c | vmt.c 的下层，实际操作读写\nfastmap.c | 支持快速扫描MTD 设备\nupd.c | update volume, 考虑到突然掉电等引起的更新错误\neba.c | Erase Block Association sub-system 子系统， 逻辑映射\nwl.c | wear-leveling sub-system 磨损均衡子系统\nio.c | <font color=red>与MTD 设备I/O 交互, R/W data, VID(volume ID)/EC(Erase Counter) header </font>  \nkapi.c | 向UBIFS 提供的api 接口\n\n\n## 3. 代码分析\n### 3.1. 数据结构\n#### 3.1.1. UBI Headers\nUBI 包含两个被CRC32 保护的64 bytes header在每一个非坏块的开始：\n- erase counter(EC) header\n- volume identifier(VID) header\n\n因此，LEB < PEB 就是因为存储了UBI headers.\n\n参见 drivers/mtd/ubi/ubi-media.h\n```c\nstruct ubi_ec_hdr {\n\t__be32  magic;\n\t__u8    version;\n\t__u8    padding1[3];\n\t__be64  ec; /* Warning: the current limit is 31-bit anyway! */\n\t__be32  vid_hdr_offset;\n\t__be32  data_offset;\n\t__be32  image_seq;\n\t__u8    padding2[32];\n\t__be32  hdr_crc;\n} __packed;\n```\n每一次Erase 都会将EC 值增加。在unclean reboot 发生或者数据被corrupted， EC 将会被写入attach MTD 设备扫描的EC average。\n\n```c\nstruct ubi_vid_hdr {\n\t__be32  magic;\n\t__u8    version;\n\t__u8    vol_type;\n\t__u8    copy_flag;\n\t__u8    compat;\n\t__be32  vol_id;\n\t__be32  lnum;\n\t__u8    padding1[4];\n\t__be32  data_size;\n\t__be32  used_ebs;\n\t__be32  data_pad;\n\t__be32  data_crc;\n\t__u8    padding2[4];\n\t__be64  sqnum;\n\t__u8    padding3[12];\n\t__be32  hdr_crc;\n} __packed;\n```\nEC header 存储offset 为0， 而VID header 存储offset 为next min I/O Unit, sub-page or page.\n- NOR Flash, min I/O 为 1 byte, VID header offset 为64\n- Nand Flash, sub-page or page\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/UBI%20headers.png)\n\n#### 3.1.2. volume table \n数据是存储在flash 设备上， volume table 是ubit_vtbl_record 的数组，每一个记录它包含了如下meta-data:  \n- 卷名  \n- 保留物理擦除快的数量  \n- 类型(static or dynamica) \n- crc 校验  \n- update marker（用于标记更新volume name or size）  \n\n```c\nstruct ubi_vtbl_record {\n\t__be32  reserved_pebs;\n\t__be32  alignment;\n\t__be32  data_pad;\n\t__u8    vol_type;\n\t__u8    upd_marker;\n\t__be16  name_len;\n\t__u8    name[UBI_VOL_NAME_MAX+1];\n\t__u8    flags;\n\t__u8    padding[23];\n\t__be32  crc;\n} __packed;\n```\n\nUBI 使用了两个逻辑擦除快(Logical EraseBlock)保存record 数据，LEB0 and LEB1. 他们两者相互拷贝，以此来保证突发事件例如掉电等异常情形。当attach MTD 设备时，UBI确保这两个volume table是相同的，否则上次可能是unclean boot导致，使用新的，无corrupted data 拷贝到另一块。\n\nUBI 需要维护三种table:\n- volume table  \n- eraseblock association(EBA) table  \n- erase counter(EC) table  \n\nvolume table 是存储在Flash 上，它的修改只会发生在create, delete, re-size 时。\n\nEBA table 是用于logical to phsical 映射关系。\nEC table 包含每个PEB 的erase conter 值， UBI wear-leveling 将会使用此表格。\n\nEBA, EC table 可以做到存储在flash 上，但是它需要journaling, journal replay, journal commit 等，在boot-loader 时保证简单，代码的size 是不太容易的。\n\n因此， __EBA, EC table 默认在attach MTD 时，根据扫描的EC,VID header 信息在RAM 中构建.__ \n\n在vid_hdr 中包含的vol_id, lnum, squm 指定了他们的volume_id， squm 序列号， lnum 逻辑num 号， UBI attach 子系统在attach 时，根据这些信息创建red-block tree， 就能顺序读取data。\n\n### 3.2. UBI Sub-system\n#### 3.2.1. attach mtd\n本质是扫描(scan_all or scan_fast(fastmap))MTD 设备上的EC、VID header 信息生成volume 等结构体。\n\n相关的数据接口如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_data_structure.png)\n\nubi_ainf_peb -> ubi_ainf_volume.rb -> ubi_attach_info.volume。\n```c\nstruct ubi_attach_info {\n\tstruct rb_root volumes;\n\tstruct list_head corr;\n\tstruct list_head free;\n\tstruct list_head erase;\n\tstruct list_head alien;\n\tint corr_peb_count;\n\tint empty_peb_count;\n\tint alien_peb_count;\n\tint bad_peb_count;\n\tint maybe_bad_peb_count;\n\tint vols_found;\n\tint highest_vol_id;\n\tint is_empty;\n\tint min_ec;\n\tint max_ec;\n\tunsigned long long max_sqnum;\n\tint mean_ec;\n\tuint64_t ec_sum;\n\tint ec_count;\n\tstruct kmem_cache *aeb_slab_cache;\n};\n\nstruct ubi_ainf_volume {\n\tint vol_id;\n\tint highest_lnum;\n\tint leb_count;\n\tint vol_type;\n\tint used_ebs;\n\tint last_data_size;\n\tint data_pad;\n\tint compat;\n\tstruct rb_node rb; /* link in the volume RB-tree */\n\tstruct rb_root root;\n};\n\nstruct ubi_ainf_peb {\n\tint ec;\n\tint pnum;\t/* physical eraseblock number */\n\tint vol_id; /* ID of the volume this LEB belongs to */\n\tint lnum;\t/* logical eraseblock number */\n\tunsigned int scrub:1;\n\tunsigned int copy_flag:1;\n\tunsigned long long sqnum;\n\tunion {\n\t\tstruct rb_node rb;\t/* link in the per-volume RB-tree of &struct ubi_ainf_peb objects */\n\t\tstruct list_head list;\n\t} u;\n};\n```\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_attach.png)\nscan_all() 扫描每一个peb 并读取其中的ec_hdr, vid_hdr。 这里分层了三层结构体：\n- ubi_attach_info  \n- ubi_ainf_volume  \n- ubi_ainf_peb  \n管理volume， 以及属于该volume 的全部pebs 分类清晰，便于管理。\n\nubi_read_volume_table() 会在RAM 中生成volume table record. 他们是存放在具体的vol_id 的前两个LEB[0,1]中， 在process_lvol() 读取数据，并检查是否数据污染。\n\n#### 3.2.2. eba, eraseblock association\n在attach 时候， 调用ubi_eba_init（）, UBI EBA 子系统会根据数据结构 ubi_attach_info -> ubi_ainf_volume -> ubi_ainf_peb, 在ubi_ainf_peb 里面记录了pnum, lnum，这就是物理逻辑映射关系。\n\n```c\nint ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)\n{\n\tfor (i = 0; i < num_volumes; i++) {\n\t\tvol = ubi->volumes[i];\n\t\tif (!vol)\n\t\t\tcontinue;\n\t\tvol->eba_tbl = kmalloc(vol->reserved_pebs * sizeof(int),\n\t\t\t\t       GFP_KERNEL);\n\t\tfor (j = 0; j < vol->reserved_pebs; j++)\n\t\t\tvol->eba_tbl[j] = UBI_LEB_UNMAPPED;\n\n\t\tav = ubi_find_av(ai, idx2vol_id(ubi, i));\n\t\tif (!av)\n\t\t\tcontinue;\n\n\t\tubi_rb_for_each_entry(rb, aeb, &av->root, u.rb) {\n\t\t\tif (aeb->lnum >= vol->reserved_pebs)\n\t\t\t\t/*\n\t\t\t\t * This may happen in case of an unclean reboot\n\t\t\t\t * during re-size.\n\t\t\t\t */\n\t\t\t\tubi_move_aeb_to_list(av, aeb, &ai->erase);\n\t\t\tvol->eba_tbl[aeb->lnum] = aeb->pnum;\n\t\t}\n\t}\n}\t\t\t   \n```\n\n后续的write, read 都是通过在RAM 中的eba_tlb 进行逻辑查询后，再调用到io -> mtd.read/write\n假如EBA 没有映射， 调用Wear-leveling 子系统获取PEB。\n\n至于lnum 的值在UBIFS 中体现，是从上层下来。UBI wear-leveling 会考虑磨损均衡的情况下选择合适的PEBs 映射到某一个lnum 上。\n\n__marking eraseblocks as bad__\n判断依据：\n- 写操作时失败，UBI 将数据搬移，并准备对该eraseblock 进行torturing(拷问，审查)。\n- erase 操作失败EIO error， 直接将它标记为bad\n\ntorturing 主要是两方面\n1. eraseblock, and read check all is 0xFF\n2. write data, and read check\n\n#### 3.2.3. wear-leveling\n磨损均衡是UBI的核心功能之一，负责管理PEB的分配、回收、擦除、scrub、磨损均衡等, 在这些操作时都会触发磨损均衡检查。其中scrub、擦除, 磨损均衡功能由UBI后台线程进行异步调度管理。\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_wl.png)\n```c\nstruct ubi_wl_entry {\n\tunion {\n\t\tstruct rb_node rb;  /* link in the corresponding (free/used) RB-tree*/\n\t\tstruct list_head list;\n\t} u;\n\tint ec;\n\tint pnum;\n};\n```\n\n如果used peb 的EC 与free peb 的EC 差大于 <font color=red>UBI_WL_THRESHOLD</font> 则会考虑使用wear-leveling 子系统进行磨损均衡搬移，避免过多的搬移数据造成本身的反复擦除。\n```c\nstatic int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,\n\t\t\t\tint shutdown)\n{\n\tint err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;\n\tint vol_id = -1, uninitialized_var(lnum);\n\n\tstruct ubi_wl_entry *e1, *e2;\n\tstruct ubi_vid_hdr *vid_hdr;\n\n\tvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);\n\n\tmutex_lock(&ubi->move_mutex);\n\tspin_lock(&ubi->wl_lock);\n\n\tif (!ubi->scrub.rb_node) {\n\t\t/*\n\t\t * Now pick the least worn-out used physical eraseblock and a\n\t\t * highly worn-out free physical eraseblock. If the erase\n\t\t * counters differ much enough, start wear-leveling.\n\t\t */\n\t\te1 = rb_entry(rb_first(&ubi->used), struct ubi_wl_entry, u.rb);\n\t\te2 = get_peb_for_wl(ubi);\n\n\t\tif (!(e2->ec - e1->ec >= UBI_WL_THRESHOLD)) {\n\t\t\tdbg_wl(\"no WL needed: min used EC %d, max free EC %d\",\n\t\t\t       e1->ec, e2->ec);\n\n\t\t\t/* Give the unused PEB back */\n\t\t\twl_tree_add(e2, &ubi->free);\n\t\t\tubi->free_count++;\n\t\t\tgoto out_cancel;\n\t\t}\n\t\trb_erase(&e1->u.rb, &ubi->used);\n\t\tdbg_wl(\"move PEB %d EC %d to PEB %d EC %d\",\n\t\t       e1->pnum, e1->ec, e2->pnum, e2->ec);\n\t} else {\n\t\t/* Perform scrubbing */\n\t\tscrubbing = 1;\n\t\te1 = rb_entry(rb_first(&ubi->scrub), struct ubi_wl_entry, u.rb);\n\t\te2 = get_peb_for_wl(ubi);\n\t\t\n\t\trb_erase(&e1->u.rb, &ubi->scrub);\n\t\tdbg_wl(\"scrub PEB %d to PEB %d\", e1->pnum, e2->pnum);\n\t}\n\n\tubi->move_from = e1;\n\tubi->move_to = e2;\n\tspin_unlock(&ubi->wl_lock);\n\n\t/*\n\t * Now we are going to copy physical eraseblock @e1->pnum to @e2->pnum.\n\t * We so far do not know which logical eraseblock our physical\n\t * eraseblock (@e1) belongs to. We have to read the volume identifier\n\t * header first.\n\t *\n\t * Note, we are protected from this PEB being unmapped and erased. The\n\t * 'ubi_wl_put_peb()' would wait for moving to be finished if the PEB\n\t * which is being moved was unmapped.\n\t */\n\terr = ubi_io_read_vid_hdr(ubi, e1->pnum, vid_hdr, 0);\n\n\tvol_id = be32_to_cpu(vid_hdr->vol_id);\n\tlnum = be32_to_cpu(vid_hdr->lnum);\n\n\terr = ubi_eba_copy_leb(ubi, e1->pnum, e2->pnum, vid_hdr);\n\n\t/* The PEB has been successfully moved */\n\tif (scrubbing)\n\t\tubi_msg(\"scrubbed PEB %d (LEB %d:%d), data moved to PEB %d\",\n\t\t\te1->pnum, vol_id, lnum, e2->pnum);\n\tubi_free_vid_hdr(ubi, vid_hdr);\n\n\tspin_lock(&ubi->wl_lock);\n\tif (!ubi->move_to_put) {\n\t\twl_tree_add(e2, &ubi->used);\n\t\te2 = NULL;\n\t}\n\tubi->move_from = ubi->move_to = NULL;\n\tubi->move_to_put = ubi->wl_scheduled = 0;\n\tspin_unlock(&ubi->wl_lock);\n\n\terr = do_sync_erase(ubi, e1, vol_id, lnum, 0);\n\n\tif (e2) {\n\t\t/*\n\t\t * Well, the target PEB was put meanwhile, schedule it for\n\t\t * erasure.\n\t\t */\n\t\tdbg_wl(\"PEB %d (LEB %d:%d) was put meanwhile, erase\",\n\t\t       e2->pnum, vol_id, lnum);\n\t\terr = do_sync_erase(ubi, e2, vol_id, lnum, 0);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\tmutex_unlock(&ubi->move_mutex);\n\treturn 0;\n}\n```\n\n在EBA write 时，如果没有映射，我们就会调用ubi_wl_get_peb() 获取free PEB。 \n* drivers/mtd/ubi/wl.c *\nubi_wl_get_peb() ->  \n&nbsp;&nbsp;__wl_get_peb() ->  \n\n```c\nint ubi_eba_write_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\n\t\t      const void *buf, int offset, int len)\n{\n\tint err, pnum, tries = 0, vol_id = vol->vol_id;\n\tstruct ubi_vid_hdr *vid_hdr;\n\n\terr = leb_write_lock(ubi, vol_id, lnum);\n\n\tpnum = vol->eba_tbl[lnum];\n\tif (pnum >= 0) {\n\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);\n\t\tleb_write_unlock(ubi, vol_id, lnum);\n\t\treturn err;\n\t}\n\n\t/*\n\t * The logical eraseblock is not mapped. We have to get a free physical\n\t * eraseblock and write the volume identifier header there first.\n\t */\n\tvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);\n\n\tvid_hdr->vol_type = UBI_VID_DYNAMIC;\n\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tvid_hdr->vol_id = cpu_to_be32(vol_id);\n\tvid_hdr->lnum = cpu_to_be32(lnum);\n\tvid_hdr->compat = ubi_get_compat(ubi, vol_id);\n\tvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\n\nretry:\n\tpnum = ubi_wl_get_peb(ubi);\n\n\terr = ubi_io_write_vid_hdr(ubi, pnum, vid_hdr);\n\n\tif (len) {\n\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);\n\t}\n\n\tdown_read(&ubi->fm_sem);\n\tvol->eba_tbl[lnum] = pnum;\n\tup_read(&ubi->fm_sem);\n\n\tleb_write_unlock(ubi, vol_id, lnum);\n\tubi_free_vid_hdr(ubi, vid_hdr);\n\treturn 0;\n}\n\nstatic int __wl_get_peb(struct ubi_device *ubi)\n{\n\tint err;\n\tstruct ubi_wl_entry *e;\n\nretry:\n\tif (!ubi->free.rb_node) {\n\t\tif (ubi->works_count == 0) {\n\t\t\tubi_err(\"no free eraseblocks\");\n\t\t\tubi_assert(list_empty(&ubi->works));\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\terr = produce_free_peb(ubi);\n\n\t\tgoto retry;\n\t}\n\n\te = find_mean_wl_entry(ubi, &ubi->free);\n\t/*\n\t * Move the physical eraseblock to the protection queue where it will\n\t * be protected from being moved for some time.\n\t */\n\trb_erase(&e->u.rb, &ubi->free);\n\tubi->free_count--;\n\n\treturn e->pnum;\n}\n```\n#### 3.2.4. fastmap\nfastmap 利用存储在flash 上的fastmap volume 以此来加速attach。 \n__fastmap 一般用于large flash， 例如4Gib Nand chips。__\n是否启用fastmap, 需要考虑到fastmap 本身会占用一些PEB，并且fastmap pool full, volume layout change or detach时，fastmap都需要写入信息到保留的PEB 中。\n\nfastmap volume中存储的信息有：\n- erase value\n- a list of all PEBs and their state  \n- a list of all volumes and their EBA \n- a list of PEBs called fastmap pool   \n\nfastmap 还有一个fastmap pool 概念， 它的size 大约为 5% of the total amount of PEBs。我们从fastmap pool 中取用PEBs，这样我们只需要关心fastmap pool 的PEBs， 而不用关心total PEBs, 减少了需要存储的信息量。\n\n## 参看资料\n[Linux UBI子系统设计初探](https://www.cnblogs.com/wahaha02/p/4814698.html)\n\n[ubi 官方文档](http://www.linux-mtd.infradead.org/doc/ubi.html)\n\n[ubi design pdf from MTD org](http://www.linux-mtd.infradead.org/doc/ubidesign/ubidesign.pdf)\n\n[ubi ppt from MTD org](http://www.linux-mtd.infradead.org/doc/ubi.ppt)\n\n[elinux/ubifs](https://elinux.org/UBIFS)","slug":"kernel-ubi","published":1,"updated":"2019-11-19T07:28:59.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qm002yzkgrtem0vank","content":"<h2 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1. 背景\"></a>1. 背景</h2><p>Flash 设备存在如下缺点</p>\n<ul>\n<li>存在坏块  </li>\n<li>使用寿命较短  </li>\n<li>存储介质不稳定(bitflip)  </li>\n<li>读写速度慢  </li>\n<li>只能通过擦除将0改成1  </li>\n<li>最小读写单位为page or sub-page  </li>\n</ul>\n<a id=\"more\"></a>\n<p>Kernel 引入UBI (Unsorted Block Images)来解决这些问题。<font color=\"red\">UBI 本身就是针对RAW Flash的一个卷管理系统，并且提供基于磨损均衡的逻辑到物理的映射</font>。它类似于LVM（Logical Volume Manager)</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/mtd%20partition%20vs%20ubi%20volume.png\" alt=\"\"></p>\n<p>因此UBI 具有如下特点：</p>\n<ul>\n<li>UBI provides volumes which may be dynamically created, removed, or re-sized</li>\n<li>UBI implements wear-leveling across whole flash device </li>\n<li>UBI transparently handles bad physical eraseblocks;</li>\n<li>UBI minimizes chances to lose data by means of scrubbing. （针对Nand Flash 的bit flip现象，将有bit-flips的数据块移动到好的数据块上）</li>\n</ul>\n<!--more-->\n<h2 id=\"2-框架\"><a href=\"#2-框架\" class=\"headerlink\" title=\"2. 框架\"></a>2. 框架</h2><p>在kernel MTD 模块看来， UBI 子系统的框架如下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi%20structure.png\" alt=\"\"></p>\n<p>UBI 子模块的文件组织结构如下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi%20software%20structure.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文件名</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">cdev.c</td>\n<td style=\"text-align:left\">字符设备节点访问操作, attach/detach MTD, volume add/remove/rename/resize</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">build.c</td>\n<td style=\"text-align:left\">/dev/ubictrl, /sys 等节点注册</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">attach.c</td>\n<td style=\"text-align:left\">attach MTD sub-system</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vmt.c</td>\n<td style=\"text-align:left\">volume 逻辑操作，增删， 重命名， 重新设定size </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vtbl.c</td>\n<td style=\"text-align:left\">vmt.c 的下层，实际操作读写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">fastmap.c</td>\n<td style=\"text-align:left\">支持快速扫描MTD 设备</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">upd.c</td>\n<td style=\"text-align:left\">update volume, 考虑到突然掉电等引起的更新错误</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eba.c</td>\n<td style=\"text-align:left\">Erase Block Association sub-system 子系统， 逻辑映射</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wl.c</td>\n<td style=\"text-align:left\">wear-leveling sub-system 磨损均衡子系统</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">io.c</td>\n<td style=\"text-align:left\"><font color=\"red\">与MTD 设备I/O 交互, R/W data, VID(volume ID)/EC(Erase Counter) header </font>  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">kapi.c</td>\n<td style=\"text-align:left\">向UBIFS 提供的api 接口</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-代码分析\"><a href=\"#3-代码分析\" class=\"headerlink\" title=\"3. 代码分析\"></a>3. 代码分析</h2><h3 id=\"3-1-数据结构\"><a href=\"#3-1-数据结构\" class=\"headerlink\" title=\"3.1. 数据结构\"></a>3.1. 数据结构</h3><h4 id=\"3-1-1-UBI-Headers\"><a href=\"#3-1-1-UBI-Headers\" class=\"headerlink\" title=\"3.1.1. UBI Headers\"></a>3.1.1. UBI Headers</h4><p>UBI 包含两个被CRC32 保护的64 bytes header在每一个非坏块的开始：</p>\n<ul>\n<li>erase counter(EC) header</li>\n<li>volume identifier(VID) header</li>\n</ul>\n<p>因此，LEB &lt; PEB 就是因为存储了UBI headers.</p>\n<p>参见 drivers/mtd/ubi/ubi-media.h<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_ec_hdr</span> &#123;</span></span><br><span class=\"line\">\t__be32  magic;</span><br><span class=\"line\">\t__u8    version;</span><br><span class=\"line\">\t__u8    padding1[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t__be64  ec; <span class=\"comment\">/* Warning: the current limit is 31-bit anyway! */</span></span><br><span class=\"line\">\t__be32  vid_hdr_offset;</span><br><span class=\"line\">\t__be32  data_offset;</span><br><span class=\"line\">\t__be32  image_seq;</span><br><span class=\"line\">\t__u8    padding2[<span class=\"number\">32</span>];</span><br><span class=\"line\">\t__be32  hdr_crc;</span><br><span class=\"line\">&#125; __packed;</span><br></pre></td></tr></table></figure></p>\n<p>每一次Erase 都会将EC 值增加。在unclean reboot 发生或者数据被corrupted， EC 将会被写入attach MTD 设备扫描的EC average。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_vid_hdr</span> &#123;</span></span><br><span class=\"line\">\t__be32  magic;</span><br><span class=\"line\">\t__u8    version;</span><br><span class=\"line\">\t__u8    vol_type;</span><br><span class=\"line\">\t__u8    copy_flag;</span><br><span class=\"line\">\t__u8    compat;</span><br><span class=\"line\">\t__be32  vol_id;</span><br><span class=\"line\">\t__be32  lnum;</span><br><span class=\"line\">\t__u8    padding1[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t__be32  data_size;</span><br><span class=\"line\">\t__be32  used_ebs;</span><br><span class=\"line\">\t__be32  data_pad;</span><br><span class=\"line\">\t__be32  data_crc;</span><br><span class=\"line\">\t__u8    padding2[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t__be64  sqnum;</span><br><span class=\"line\">\t__u8    padding3[<span class=\"number\">12</span>];</span><br><span class=\"line\">\t__be32  hdr_crc;</span><br><span class=\"line\">&#125; __packed;</span><br></pre></td></tr></table></figure>\n<p>EC header 存储offset 为0， 而VID header 存储offset 为next min I/O Unit, sub-page or page.</p>\n<ul>\n<li>NOR Flash, min I/O 为 1 byte, VID header offset 为64</li>\n<li>Nand Flash, sub-page or page</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/UBI%20headers.png\" alt=\"\"></p>\n<h4 id=\"3-1-2-volume-table\"><a href=\"#3-1-2-volume-table\" class=\"headerlink\" title=\"3.1.2. volume table\"></a>3.1.2. volume table</h4><p>数据是存储在flash 设备上， volume table 是ubit_vtbl_record 的数组，每一个记录它包含了如下meta-data:  </p>\n<ul>\n<li>卷名  </li>\n<li>保留物理擦除快的数量  </li>\n<li>类型(static or dynamica) </li>\n<li>crc 校验  </li>\n<li>update marker（用于标记更新volume name or size）  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_vtbl_record</span> &#123;</span></span><br><span class=\"line\">\t__be32  reserved_pebs;</span><br><span class=\"line\">\t__be32  alignment;</span><br><span class=\"line\">\t__be32  data_pad;</span><br><span class=\"line\">\t__u8    vol_type;</span><br><span class=\"line\">\t__u8    upd_marker;</span><br><span class=\"line\">\t__be16  name_len;</span><br><span class=\"line\">\t__u8    name[UBI_VOL_NAME_MAX+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t__u8    flags;</span><br><span class=\"line\">\t__u8    padding[<span class=\"number\">23</span>];</span><br><span class=\"line\">\t__be32  crc;</span><br><span class=\"line\">&#125; __packed;</span><br></pre></td></tr></table></figure>\n<p>UBI 使用了两个逻辑擦除快(Logical EraseBlock)保存record 数据，LEB0 and LEB1. 他们两者相互拷贝，以此来保证突发事件例如掉电等异常情形。当attach MTD 设备时，UBI确保这两个volume table是相同的，否则上次可能是unclean boot导致，使用新的，无corrupted data 拷贝到另一块。</p>\n<p>UBI 需要维护三种table:</p>\n<ul>\n<li>volume table  </li>\n<li>eraseblock association(EBA) table  </li>\n<li>erase counter(EC) table  </li>\n</ul>\n<p>volume table 是存储在Flash 上，它的修改只会发生在create, delete, re-size 时。</p>\n<p>EBA table 是用于logical to phsical 映射关系。<br>EC table 包含每个PEB 的erase conter 值， UBI wear-leveling 将会使用此表格。</p>\n<p>EBA, EC table 可以做到存储在flash 上，但是它需要journaling, journal replay, journal commit 等，在boot-loader 时保证简单，代码的size 是不太容易的。</p>\n<p>因此， <strong>EBA, EC table 默认在attach MTD 时，根据扫描的EC,VID header 信息在RAM 中构建.</strong> </p>\n<p>在vid_hdr 中包含的vol_id, lnum, squm 指定了他们的volume_id， squm 序列号， lnum 逻辑num 号， UBI attach 子系统在attach 时，根据这些信息创建red-block tree， 就能顺序读取data。</p>\n<h3 id=\"3-2-UBI-Sub-system\"><a href=\"#3-2-UBI-Sub-system\" class=\"headerlink\" title=\"3.2. UBI Sub-system\"></a>3.2. UBI Sub-system</h3><h4 id=\"3-2-1-attach-mtd\"><a href=\"#3-2-1-attach-mtd\" class=\"headerlink\" title=\"3.2.1. attach mtd\"></a>3.2.1. attach mtd</h4><p>本质是扫描(scan_all or scan_fast(fastmap))MTD 设备上的EC、VID header 信息生成volume 等结构体。</p>\n<p>相关的数据接口如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_data_structure.png\" alt=\"\"></p>\n<p>ubi_ainf_peb -&gt; ubi_ainf_volume.rb -&gt; ubi_attach_info.volume。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_attach_info</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_root</span> <span class=\"title\">volumes</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">corr</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">free</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">erase</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">alien</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> corr_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> empty_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> alien_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bad_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maybe_bad_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vols_found;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> highest_vol_id;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> is_empty;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> min_ec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> max_ec;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> max_sqnum;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mean_ec;</span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> ec_sum;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ec_count;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache</span> *<span class=\"title\">aeb_slab_cache</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_ainf_volume</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vol_id;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> highest_lnum;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vol_type;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> used_ebs;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> last_data_size;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> data_pad;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> compat;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb</span>;</span> <span class=\"comment\">/* link in the volume RB-tree */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_root</span> <span class=\"title\">root</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_ainf_peb</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pnum;\t<span class=\"comment\">/* physical eraseblock number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vol_id; <span class=\"comment\">/* ID of the volume this LEB belongs to */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lnum;\t<span class=\"comment\">/* logical eraseblock number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> scrub:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> copy_flag:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sqnum;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb</span>;</span>\t<span class=\"comment\">/* link in the per-volume RB-tree of &amp;struct ubi_ainf_peb objects */</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_attach.png\" alt=\"\"><br>scan_all() 扫描每一个peb 并读取其中的ec_hdr, vid_hdr。 这里分层了三层结构体：</p>\n<ul>\n<li>ubi_attach_info  </li>\n<li>ubi_ainf_volume  </li>\n<li>ubi_ainf_peb<br>管理volume， 以及属于该volume 的全部pebs 分类清晰，便于管理。</li>\n</ul>\n<p>ubi_read_volume_table() 会在RAM 中生成volume table record. 他们是存放在具体的vol_id 的前两个LEB[0,1]中， 在process_lvol() 读取数据，并检查是否数据污染。</p>\n<h4 id=\"3-2-2-eba-eraseblock-association\"><a href=\"#3-2-2-eba-eraseblock-association\" class=\"headerlink\" title=\"3.2.2. eba, eraseblock association\"></a>3.2.2. eba, eraseblock association</h4><p>在attach 时候， 调用ubi_eba_init（）, UBI EBA 子系统会根据数据结构 ubi_attach_info -&gt; ubi_ainf_volume -&gt; ubi_ainf_peb, 在ubi_ainf_peb 里面记录了pnum, lnum，这就是物理逻辑映射关系。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ubi_eba_init</span><span class=\"params\">(struct ubi_device *ubi, struct ubi_attach_info *ai)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; num_volumes; i++) &#123;</span><br><span class=\"line\">\t\tvol = ubi-&gt;volumes[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vol)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tvol-&gt;eba_tbl = kmalloc(vol-&gt;reserved_pebs * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>),</span><br><span class=\"line\">\t\t\t\t       GFP_KERNEL);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; vol-&gt;reserved_pebs; j++)</span><br><span class=\"line\">\t\t\tvol-&gt;eba_tbl[j] = UBI_LEB_UNMAPPED;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tav = ubi_find_av(ai, idx2vol_id(ubi, i));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!av)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tubi_rb_for_each_entry(rb, aeb, &amp;av-&gt;root, u.rb) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (aeb-&gt;lnum &gt;= vol-&gt;reserved_pebs)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * This may happen in case of an unclean reboot</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * during re-size.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t */</span></span><br><span class=\"line\">\t\t\t\tubi_move_aeb_to_list(av, aeb, &amp;ai-&gt;erase);</span><br><span class=\"line\">\t\t\tvol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后续的write, read 都是通过在RAM 中的eba_tlb 进行逻辑查询后，再调用到io -&gt; mtd.read/write<br>假如EBA 没有映射， 调用Wear-leveling 子系统获取PEB。</p>\n<p>至于lnum 的值在UBIFS 中体现，是从上层下来。UBI wear-leveling 会考虑磨损均衡的情况下选择合适的PEBs 映射到某一个lnum 上。</p>\n<p><strong>marking eraseblocks as bad</strong><br>判断依据：</p>\n<ul>\n<li>写操作时失败，UBI 将数据搬移，并准备对该eraseblock 进行torturing(拷问，审查)。</li>\n<li>erase 操作失败EIO error， 直接将它标记为bad</li>\n</ul>\n<p>torturing 主要是两方面</p>\n<ol>\n<li>eraseblock, and read check all is 0xFF</li>\n<li>write data, and read check</li>\n</ol>\n<h4 id=\"3-2-3-wear-leveling\"><a href=\"#3-2-3-wear-leveling\" class=\"headerlink\" title=\"3.2.3. wear-leveling\"></a>3.2.3. wear-leveling</h4><p>磨损均衡是UBI的核心功能之一，负责管理PEB的分配、回收、擦除、scrub、磨损均衡等, 在这些操作时都会触发磨损均衡检查。其中scrub、擦除, 磨损均衡功能由UBI后台线程进行异步调度管理。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_wl.png\" alt=\"\"><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_wl_entry</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb</span>;</span>  <span class=\"comment\">/* link in the corresponding (free/used) RB-tree*/</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pnum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>如果used peb 的EC 与free peb 的EC 差大于 <font color=\"red\">UBI_WL_THRESHOLD</font> 则会考虑使用wear-leveling 子系统进行磨损均衡搬移，避免过多的搬移数据造成本身的反复擦除。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">wear_leveling_worker</span><span class=\"params\">(struct ubi_device *ubi, struct ubi_work *wrk,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">int</span> shutdown)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err, scrubbing = <span class=\"number\">0</span>, torture = <span class=\"number\">0</span>, protect = <span class=\"number\">0</span>, erroneous = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vol_id = <span class=\"number\">-1</span>, uninitialized_var(lnum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_wl_entry</span> *<span class=\"title\">e1</span>, *<span class=\"title\">e2</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_vid_hdr</span> *<span class=\"title\">vid_hdr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmutex_lock(&amp;ubi-&gt;move_mutex);</span><br><span class=\"line\">\tspin_lock(&amp;ubi-&gt;wl_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ubi-&gt;scrub.rb_node) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Now pick the least worn-out used physical eraseblock and a</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * highly worn-out free physical eraseblock. If the erase</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * counters differ much enough, start wear-leveling.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\te1 = rb_entry(rb_first(&amp;ubi-&gt;used), struct ubi_wl_entry, u.rb);</span><br><span class=\"line\">\t\te2 = get_peb_for_wl(ubi);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!(e2-&gt;ec - e1-&gt;ec &gt;= UBI_WL_THRESHOLD)) &#123;</span><br><span class=\"line\">\t\t\tdbg_wl(<span class=\"string\">\"no WL needed: min used EC %d, max free EC %d\"</span>,</span><br><span class=\"line\">\t\t\t       e1-&gt;ec, e2-&gt;ec);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Give the unused PEB back */</span></span><br><span class=\"line\">\t\t\twl_tree_add(e2, &amp;ubi-&gt;<span class=\"built_in\">free</span>);</span><br><span class=\"line\">\t\t\tubi-&gt;free_count++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out_cancel;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\trb_erase(&amp;e1-&gt;u.rb, &amp;ubi-&gt;used);</span><br><span class=\"line\">\t\tdbg_wl(<span class=\"string\">\"move PEB %d EC %d to PEB %d EC %d\"</span>,</span><br><span class=\"line\">\t\t       e1-&gt;pnum, e1-&gt;ec, e2-&gt;pnum, e2-&gt;ec);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* Perform scrubbing */</span></span><br><span class=\"line\">\t\tscrubbing = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\te1 = rb_entry(rb_first(&amp;ubi-&gt;scrub), struct ubi_wl_entry, u.rb);</span><br><span class=\"line\">\t\te2 = get_peb_for_wl(ubi);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\trb_erase(&amp;e1-&gt;u.rb, &amp;ubi-&gt;scrub);</span><br><span class=\"line\">\t\tdbg_wl(<span class=\"string\">\"scrub PEB %d to PEB %d\"</span>, e1-&gt;pnum, e2-&gt;pnum);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tubi-&gt;move_from = e1;</span><br><span class=\"line\">\tubi-&gt;move_to = e2;</span><br><span class=\"line\">\tspin_unlock(&amp;ubi-&gt;wl_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Now we are going to copy physical eraseblock @e1-&gt;pnum to @e2-&gt;pnum.</span></span><br><span class=\"line\"><span class=\"comment\">\t * We so far do not know which logical eraseblock our physical</span></span><br><span class=\"line\"><span class=\"comment\">\t * eraseblock (@e1) belongs to. We have to read the volume identifier</span></span><br><span class=\"line\"><span class=\"comment\">\t * header first.</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * Note, we are protected from this PEB being unmapped and erased. The</span></span><br><span class=\"line\"><span class=\"comment\">\t * 'ubi_wl_put_peb()' would wait for moving to be finished if the PEB</span></span><br><span class=\"line\"><span class=\"comment\">\t * which is being moved was unmapped.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\terr = ubi_io_read_vid_hdr(ubi, e1-&gt;pnum, vid_hdr, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tvol_id = be32_to_cpu(vid_hdr-&gt;vol_id);</span><br><span class=\"line\">\tlnum = be32_to_cpu(vid_hdr-&gt;lnum);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = ubi_eba_copy_leb(ubi, e1-&gt;pnum, e2-&gt;pnum, vid_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* The PEB has been successfully moved */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (scrubbing)</span><br><span class=\"line\">\t\tubi_msg(<span class=\"string\">\"scrubbed PEB %d (LEB %d:%d), data moved to PEB %d\"</span>,</span><br><span class=\"line\">\t\t\te1-&gt;pnum, vol_id, lnum, e2-&gt;pnum);</span><br><span class=\"line\">\tubi_free_vid_hdr(ubi, vid_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">\tspin_lock(&amp;ubi-&gt;wl_lock);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ubi-&gt;move_to_put) &#123;</span><br><span class=\"line\">\t\twl_tree_add(e2, &amp;ubi-&gt;used);</span><br><span class=\"line\">\t\te2 = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tubi-&gt;move_from = ubi-&gt;move_to = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tubi-&gt;move_to_put = ubi-&gt;wl_scheduled = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tspin_unlock(&amp;ubi-&gt;wl_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = do_sync_erase(ubi, e1, vol_id, lnum, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (e2) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Well, the target PEB was put meanwhile, schedule it for</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * erasure.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tdbg_wl(<span class=\"string\">\"PEB %d (LEB %d:%d) was put meanwhile, erase\"</span>,</span><br><span class=\"line\">\t\t       e2-&gt;pnum, vol_id, lnum);</span><br><span class=\"line\">\t\terr = do_sync_erase(ubi, e2, vol_id, lnum, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out_ro;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmutex_unlock(&amp;ubi-&gt;move_mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在EBA write 时，如果没有映射，我们就会调用ubi_wl_get_peb() 获取free PEB。 </p>\n<ul>\n<li>drivers/mtd/ubi/wl.c *<br>ubi_wl_get_peb() -&gt;<br>&nbsp;&nbsp;__wl_get_peb() -&gt;  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ubi_eba_write_leb</span><span class=\"params\">(struct ubi_device *ubi, struct ubi_volume *vol, <span class=\"keyword\">int</span> lnum,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t      <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err, pnum, tries = <span class=\"number\">0</span>, vol_id = vol-&gt;vol_id;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_vid_hdr</span> *<span class=\"title\">vid_hdr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\terr = leb_write_lock(ubi, vol_id, lnum);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpnum = vol-&gt;eba_tbl[lnum];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pnum &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);</span><br><span class=\"line\">\t\tleb_write_unlock(ubi, vol_id, lnum);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * The logical eraseblock is not mapped. We have to get a free physical</span></span><br><span class=\"line\"><span class=\"comment\">\t * eraseblock and write the volume identifier header there first.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);</span><br><span class=\"line\"></span><br><span class=\"line\">\tvid_hdr-&gt;vol_type = UBI_VID_DYNAMIC;</span><br><span class=\"line\">\tvid_hdr-&gt;sqnum = cpu_to_be64(ubi_next_sqnum(ubi));</span><br><span class=\"line\">\tvid_hdr-&gt;vol_id = cpu_to_be32(vol_id);</span><br><span class=\"line\">\tvid_hdr-&gt;lnum = cpu_to_be32(lnum);</span><br><span class=\"line\">\tvid_hdr-&gt;compat = ubi_get_compat(ubi, vol_id);</span><br><span class=\"line\">\tvid_hdr-&gt;data_pad = cpu_to_be32(vol-&gt;data_pad);</span><br><span class=\"line\"></span><br><span class=\"line\">retry:</span><br><span class=\"line\">\tpnum = ubi_wl_get_peb(ubi);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = ubi_io_write_vid_hdr(ubi, pnum, vid_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (len) &#123;</span><br><span class=\"line\">\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdown_read(&amp;ubi-&gt;fm_sem);</span><br><span class=\"line\">\tvol-&gt;eba_tbl[lnum] = pnum;</span><br><span class=\"line\">\tup_read(&amp;ubi-&gt;fm_sem);</span><br><span class=\"line\"></span><br><span class=\"line\">\tleb_write_unlock(ubi, vol_id, lnum);</span><br><span class=\"line\">\tubi_free_vid_hdr(ubi, vid_hdr);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __wl_get_peb(struct ubi_device *ubi)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_wl_entry</span> *<span class=\"title\">e</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">retry:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ubi-&gt;<span class=\"built_in\">free</span>.rb_node) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ubi-&gt;works_count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tubi_err(<span class=\"string\">\"no free eraseblocks\"</span>);</span><br><span class=\"line\">\t\t\tubi_assert(list_empty(&amp;ubi-&gt;works));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -ENOSPC;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\terr = produce_free_peb(ubi);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> retry;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\te = find_mean_wl_entry(ubi, &amp;ubi-&gt;<span class=\"built_in\">free</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Move the physical eraseblock to the protection queue where it will</span></span><br><span class=\"line\"><span class=\"comment\">\t * be protected from being moved for some time.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\trb_erase(&amp;e-&gt;u.rb, &amp;ubi-&gt;<span class=\"built_in\">free</span>);</span><br><span class=\"line\">\tubi-&gt;free_count--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> e-&gt;pnum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-4-fastmap\"><a href=\"#3-2-4-fastmap\" class=\"headerlink\" title=\"3.2.4. fastmap\"></a>3.2.4. fastmap</h4><p>fastmap 利用存储在flash 上的fastmap volume 以此来加速attach。<br><strong>fastmap 一般用于large flash， 例如4Gib Nand chips。</strong><br>是否启用fastmap, 需要考虑到fastmap 本身会占用一些PEB，并且fastmap pool full, volume layout change or detach时，fastmap都需要写入信息到保留的PEB 中。</p>\n<p>fastmap volume中存储的信息有：</p>\n<ul>\n<li>erase value</li>\n<li>a list of all PEBs and their state  </li>\n<li>a list of all volumes and their EBA </li>\n<li>a list of PEBs called fastmap pool   </li>\n</ul>\n<p>fastmap 还有一个fastmap pool 概念， 它的size 大约为 5% of the total amount of PEBs。我们从fastmap pool 中取用PEBs，这样我们只需要关心fastmap pool 的PEBs， 而不用关心total PEBs, 减少了需要存储的信息量。</p>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://www.cnblogs.com/wahaha02/p/4814698.html\" target=\"_blank\" rel=\"noopener\">Linux UBI子系统设计初探</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/ubi.html\" target=\"_blank\" rel=\"noopener\">ubi 官方文档</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/ubidesign/ubidesign.pdf\" target=\"_blank\" rel=\"noopener\">ubi design pdf from MTD org</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/ubi.ppt\" target=\"_blank\" rel=\"noopener\">ubi ppt from MTD org</a></p>\n<p><a href=\"https://elinux.org/UBIFS\" target=\"_blank\" rel=\"noopener\">elinux/ubifs</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1. 背景\"></a>1. 背景</h2><p>Flash 设备存在如下缺点</p>\n<ul>\n<li>存在坏块  </li>\n<li>使用寿命较短  </li>\n<li>存储介质不稳定(bitflip)  </li>\n<li>读写速度慢  </li>\n<li>只能通过擦除将0改成1  </li>\n<li>最小读写单位为page or sub-page  </li>\n</ul>","more":"<p>Kernel 引入UBI (Unsorted Block Images)来解决这些问题。<font color=\"red\">UBI 本身就是针对RAW Flash的一个卷管理系统，并且提供基于磨损均衡的逻辑到物理的映射</font>。它类似于LVM（Logical Volume Manager)</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/mtd%20partition%20vs%20ubi%20volume.png\" alt=\"\"></p>\n<p>因此UBI 具有如下特点：</p>\n<ul>\n<li>UBI provides volumes which may be dynamically created, removed, or re-sized</li>\n<li>UBI implements wear-leveling across whole flash device </li>\n<li>UBI transparently handles bad physical eraseblocks;</li>\n<li>UBI minimizes chances to lose data by means of scrubbing. （针对Nand Flash 的bit flip现象，将有bit-flips的数据块移动到好的数据块上）</li>\n</ul>\n<!--more-->\n<h2 id=\"2-框架\"><a href=\"#2-框架\" class=\"headerlink\" title=\"2. 框架\"></a>2. 框架</h2><p>在kernel MTD 模块看来， UBI 子系统的框架如下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi%20structure.png\" alt=\"\"></p>\n<p>UBI 子模块的文件组织结构如下图：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi%20software%20structure.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文件名</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">cdev.c</td>\n<td style=\"text-align:left\">字符设备节点访问操作, attach/detach MTD, volume add/remove/rename/resize</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">build.c</td>\n<td style=\"text-align:left\">/dev/ubictrl, /sys 等节点注册</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">attach.c</td>\n<td style=\"text-align:left\">attach MTD sub-system</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vmt.c</td>\n<td style=\"text-align:left\">volume 逻辑操作，增删， 重命名， 重新设定size </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vtbl.c</td>\n<td style=\"text-align:left\">vmt.c 的下层，实际操作读写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">fastmap.c</td>\n<td style=\"text-align:left\">支持快速扫描MTD 设备</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">upd.c</td>\n<td style=\"text-align:left\">update volume, 考虑到突然掉电等引起的更新错误</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eba.c</td>\n<td style=\"text-align:left\">Erase Block Association sub-system 子系统， 逻辑映射</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wl.c</td>\n<td style=\"text-align:left\">wear-leveling sub-system 磨损均衡子系统</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">io.c</td>\n<td style=\"text-align:left\"><font color=\"red\">与MTD 设备I/O 交互, R/W data, VID(volume ID)/EC(Erase Counter) header </font>  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">kapi.c</td>\n<td style=\"text-align:left\">向UBIFS 提供的api 接口</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-代码分析\"><a href=\"#3-代码分析\" class=\"headerlink\" title=\"3. 代码分析\"></a>3. 代码分析</h2><h3 id=\"3-1-数据结构\"><a href=\"#3-1-数据结构\" class=\"headerlink\" title=\"3.1. 数据结构\"></a>3.1. 数据结构</h3><h4 id=\"3-1-1-UBI-Headers\"><a href=\"#3-1-1-UBI-Headers\" class=\"headerlink\" title=\"3.1.1. UBI Headers\"></a>3.1.1. UBI Headers</h4><p>UBI 包含两个被CRC32 保护的64 bytes header在每一个非坏块的开始：</p>\n<ul>\n<li>erase counter(EC) header</li>\n<li>volume identifier(VID) header</li>\n</ul>\n<p>因此，LEB &lt; PEB 就是因为存储了UBI headers.</p>\n<p>参见 drivers/mtd/ubi/ubi-media.h<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_ec_hdr</span> &#123;</span></span><br><span class=\"line\">\t__be32  magic;</span><br><span class=\"line\">\t__u8    version;</span><br><span class=\"line\">\t__u8    padding1[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t__be64  ec; <span class=\"comment\">/* Warning: the current limit is 31-bit anyway! */</span></span><br><span class=\"line\">\t__be32  vid_hdr_offset;</span><br><span class=\"line\">\t__be32  data_offset;</span><br><span class=\"line\">\t__be32  image_seq;</span><br><span class=\"line\">\t__u8    padding2[<span class=\"number\">32</span>];</span><br><span class=\"line\">\t__be32  hdr_crc;</span><br><span class=\"line\">&#125; __packed;</span><br></pre></td></tr></table></figure></p>\n<p>每一次Erase 都会将EC 值增加。在unclean reboot 发生或者数据被corrupted， EC 将会被写入attach MTD 设备扫描的EC average。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_vid_hdr</span> &#123;</span></span><br><span class=\"line\">\t__be32  magic;</span><br><span class=\"line\">\t__u8    version;</span><br><span class=\"line\">\t__u8    vol_type;</span><br><span class=\"line\">\t__u8    copy_flag;</span><br><span class=\"line\">\t__u8    compat;</span><br><span class=\"line\">\t__be32  vol_id;</span><br><span class=\"line\">\t__be32  lnum;</span><br><span class=\"line\">\t__u8    padding1[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t__be32  data_size;</span><br><span class=\"line\">\t__be32  used_ebs;</span><br><span class=\"line\">\t__be32  data_pad;</span><br><span class=\"line\">\t__be32  data_crc;</span><br><span class=\"line\">\t__u8    padding2[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t__be64  sqnum;</span><br><span class=\"line\">\t__u8    padding3[<span class=\"number\">12</span>];</span><br><span class=\"line\">\t__be32  hdr_crc;</span><br><span class=\"line\">&#125; __packed;</span><br></pre></td></tr></table></figure>\n<p>EC header 存储offset 为0， 而VID header 存储offset 为next min I/O Unit, sub-page or page.</p>\n<ul>\n<li>NOR Flash, min I/O 为 1 byte, VID header offset 为64</li>\n<li>Nand Flash, sub-page or page</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/UBI%20headers.png\" alt=\"\"></p>\n<h4 id=\"3-1-2-volume-table\"><a href=\"#3-1-2-volume-table\" class=\"headerlink\" title=\"3.1.2. volume table\"></a>3.1.2. volume table</h4><p>数据是存储在flash 设备上， volume table 是ubit_vtbl_record 的数组，每一个记录它包含了如下meta-data:  </p>\n<ul>\n<li>卷名  </li>\n<li>保留物理擦除快的数量  </li>\n<li>类型(static or dynamica) </li>\n<li>crc 校验  </li>\n<li>update marker（用于标记更新volume name or size）  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_vtbl_record</span> &#123;</span></span><br><span class=\"line\">\t__be32  reserved_pebs;</span><br><span class=\"line\">\t__be32  alignment;</span><br><span class=\"line\">\t__be32  data_pad;</span><br><span class=\"line\">\t__u8    vol_type;</span><br><span class=\"line\">\t__u8    upd_marker;</span><br><span class=\"line\">\t__be16  name_len;</span><br><span class=\"line\">\t__u8    name[UBI_VOL_NAME_MAX+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t__u8    flags;</span><br><span class=\"line\">\t__u8    padding[<span class=\"number\">23</span>];</span><br><span class=\"line\">\t__be32  crc;</span><br><span class=\"line\">&#125; __packed;</span><br></pre></td></tr></table></figure>\n<p>UBI 使用了两个逻辑擦除快(Logical EraseBlock)保存record 数据，LEB0 and LEB1. 他们两者相互拷贝，以此来保证突发事件例如掉电等异常情形。当attach MTD 设备时，UBI确保这两个volume table是相同的，否则上次可能是unclean boot导致，使用新的，无corrupted data 拷贝到另一块。</p>\n<p>UBI 需要维护三种table:</p>\n<ul>\n<li>volume table  </li>\n<li>eraseblock association(EBA) table  </li>\n<li>erase counter(EC) table  </li>\n</ul>\n<p>volume table 是存储在Flash 上，它的修改只会发生在create, delete, re-size 时。</p>\n<p>EBA table 是用于logical to phsical 映射关系。<br>EC table 包含每个PEB 的erase conter 值， UBI wear-leveling 将会使用此表格。</p>\n<p>EBA, EC table 可以做到存储在flash 上，但是它需要journaling, journal replay, journal commit 等，在boot-loader 时保证简单，代码的size 是不太容易的。</p>\n<p>因此， <strong>EBA, EC table 默认在attach MTD 时，根据扫描的EC,VID header 信息在RAM 中构建.</strong> </p>\n<p>在vid_hdr 中包含的vol_id, lnum, squm 指定了他们的volume_id， squm 序列号， lnum 逻辑num 号， UBI attach 子系统在attach 时，根据这些信息创建red-block tree， 就能顺序读取data。</p>\n<h3 id=\"3-2-UBI-Sub-system\"><a href=\"#3-2-UBI-Sub-system\" class=\"headerlink\" title=\"3.2. UBI Sub-system\"></a>3.2. UBI Sub-system</h3><h4 id=\"3-2-1-attach-mtd\"><a href=\"#3-2-1-attach-mtd\" class=\"headerlink\" title=\"3.2.1. attach mtd\"></a>3.2.1. attach mtd</h4><p>本质是扫描(scan_all or scan_fast(fastmap))MTD 设备上的EC、VID header 信息生成volume 等结构体。</p>\n<p>相关的数据接口如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_data_structure.png\" alt=\"\"></p>\n<p>ubi_ainf_peb -&gt; ubi_ainf_volume.rb -&gt; ubi_attach_info.volume。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_attach_info</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_root</span> <span class=\"title\">volumes</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">corr</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">free</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">erase</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">alien</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> corr_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> empty_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> alien_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bad_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maybe_bad_peb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vols_found;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> highest_vol_id;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> is_empty;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> min_ec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> max_ec;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> max_sqnum;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mean_ec;</span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> ec_sum;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ec_count;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache</span> *<span class=\"title\">aeb_slab_cache</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_ainf_volume</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vol_id;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> highest_lnum;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leb_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vol_type;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> used_ebs;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> last_data_size;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> data_pad;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> compat;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb</span>;</span> <span class=\"comment\">/* link in the volume RB-tree */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_root</span> <span class=\"title\">root</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_ainf_peb</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pnum;\t<span class=\"comment\">/* physical eraseblock number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vol_id; <span class=\"comment\">/* ID of the volume this LEB belongs to */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lnum;\t<span class=\"comment\">/* logical eraseblock number */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> scrub:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> copy_flag:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sqnum;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb</span>;</span>\t<span class=\"comment\">/* link in the per-volume RB-tree of &amp;struct ubi_ainf_peb objects */</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_attach.png\" alt=\"\"><br>scan_all() 扫描每一个peb 并读取其中的ec_hdr, vid_hdr。 这里分层了三层结构体：</p>\n<ul>\n<li>ubi_attach_info  </li>\n<li>ubi_ainf_volume  </li>\n<li>ubi_ainf_peb<br>管理volume， 以及属于该volume 的全部pebs 分类清晰，便于管理。</li>\n</ul>\n<p>ubi_read_volume_table() 会在RAM 中生成volume table record. 他们是存放在具体的vol_id 的前两个LEB[0,1]中， 在process_lvol() 读取数据，并检查是否数据污染。</p>\n<h4 id=\"3-2-2-eba-eraseblock-association\"><a href=\"#3-2-2-eba-eraseblock-association\" class=\"headerlink\" title=\"3.2.2. eba, eraseblock association\"></a>3.2.2. eba, eraseblock association</h4><p>在attach 时候， 调用ubi_eba_init（）, UBI EBA 子系统会根据数据结构 ubi_attach_info -&gt; ubi_ainf_volume -&gt; ubi_ainf_peb, 在ubi_ainf_peb 里面记录了pnum, lnum，这就是物理逻辑映射关系。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ubi_eba_init</span><span class=\"params\">(struct ubi_device *ubi, struct ubi_attach_info *ai)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; num_volumes; i++) &#123;</span><br><span class=\"line\">\t\tvol = ubi-&gt;volumes[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vol)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tvol-&gt;eba_tbl = kmalloc(vol-&gt;reserved_pebs * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>),</span><br><span class=\"line\">\t\t\t\t       GFP_KERNEL);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; vol-&gt;reserved_pebs; j++)</span><br><span class=\"line\">\t\t\tvol-&gt;eba_tbl[j] = UBI_LEB_UNMAPPED;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tav = ubi_find_av(ai, idx2vol_id(ubi, i));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!av)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tubi_rb_for_each_entry(rb, aeb, &amp;av-&gt;root, u.rb) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (aeb-&gt;lnum &gt;= vol-&gt;reserved_pebs)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * This may happen in case of an unclean reboot</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * during re-size.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t */</span></span><br><span class=\"line\">\t\t\t\tubi_move_aeb_to_list(av, aeb, &amp;ai-&gt;erase);</span><br><span class=\"line\">\t\t\tvol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后续的write, read 都是通过在RAM 中的eba_tlb 进行逻辑查询后，再调用到io -&gt; mtd.read/write<br>假如EBA 没有映射， 调用Wear-leveling 子系统获取PEB。</p>\n<p>至于lnum 的值在UBIFS 中体现，是从上层下来。UBI wear-leveling 会考虑磨损均衡的情况下选择合适的PEBs 映射到某一个lnum 上。</p>\n<p><strong>marking eraseblocks as bad</strong><br>判断依据：</p>\n<ul>\n<li>写操作时失败，UBI 将数据搬移，并准备对该eraseblock 进行torturing(拷问，审查)。</li>\n<li>erase 操作失败EIO error， 直接将它标记为bad</li>\n</ul>\n<p>torturing 主要是两方面</p>\n<ol>\n<li>eraseblock, and read check all is 0xFF</li>\n<li>write data, and read check</li>\n</ol>\n<h4 id=\"3-2-3-wear-leveling\"><a href=\"#3-2-3-wear-leveling\" class=\"headerlink\" title=\"3.2.3. wear-leveling\"></a>3.2.3. wear-leveling</h4><p>磨损均衡是UBI的核心功能之一，负责管理PEB的分配、回收、擦除、scrub、磨损均衡等, 在这些操作时都会触发磨损均衡检查。其中scrub、擦除, 磨损均衡功能由UBI后台线程进行异步调度管理。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubi/ubi_wl.png\" alt=\"\"><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_wl_entry</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb</span>;</span>  <span class=\"comment\">/* link in the corresponding (free/used) RB-tree*/</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pnum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>如果used peb 的EC 与free peb 的EC 差大于 <font color=\"red\">UBI_WL_THRESHOLD</font> 则会考虑使用wear-leveling 子系统进行磨损均衡搬移，避免过多的搬移数据造成本身的反复擦除。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">wear_leveling_worker</span><span class=\"params\">(struct ubi_device *ubi, struct ubi_work *wrk,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">int</span> shutdown)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err, scrubbing = <span class=\"number\">0</span>, torture = <span class=\"number\">0</span>, protect = <span class=\"number\">0</span>, erroneous = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vol_id = <span class=\"number\">-1</span>, uninitialized_var(lnum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_wl_entry</span> *<span class=\"title\">e1</span>, *<span class=\"title\">e2</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_vid_hdr</span> *<span class=\"title\">vid_hdr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmutex_lock(&amp;ubi-&gt;move_mutex);</span><br><span class=\"line\">\tspin_lock(&amp;ubi-&gt;wl_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ubi-&gt;scrub.rb_node) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Now pick the least worn-out used physical eraseblock and a</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * highly worn-out free physical eraseblock. If the erase</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * counters differ much enough, start wear-leveling.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\te1 = rb_entry(rb_first(&amp;ubi-&gt;used), struct ubi_wl_entry, u.rb);</span><br><span class=\"line\">\t\te2 = get_peb_for_wl(ubi);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!(e2-&gt;ec - e1-&gt;ec &gt;= UBI_WL_THRESHOLD)) &#123;</span><br><span class=\"line\">\t\t\tdbg_wl(<span class=\"string\">\"no WL needed: min used EC %d, max free EC %d\"</span>,</span><br><span class=\"line\">\t\t\t       e1-&gt;ec, e2-&gt;ec);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Give the unused PEB back */</span></span><br><span class=\"line\">\t\t\twl_tree_add(e2, &amp;ubi-&gt;<span class=\"built_in\">free</span>);</span><br><span class=\"line\">\t\t\tubi-&gt;free_count++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out_cancel;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\trb_erase(&amp;e1-&gt;u.rb, &amp;ubi-&gt;used);</span><br><span class=\"line\">\t\tdbg_wl(<span class=\"string\">\"move PEB %d EC %d to PEB %d EC %d\"</span>,</span><br><span class=\"line\">\t\t       e1-&gt;pnum, e1-&gt;ec, e2-&gt;pnum, e2-&gt;ec);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* Perform scrubbing */</span></span><br><span class=\"line\">\t\tscrubbing = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\te1 = rb_entry(rb_first(&amp;ubi-&gt;scrub), struct ubi_wl_entry, u.rb);</span><br><span class=\"line\">\t\te2 = get_peb_for_wl(ubi);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\trb_erase(&amp;e1-&gt;u.rb, &amp;ubi-&gt;scrub);</span><br><span class=\"line\">\t\tdbg_wl(<span class=\"string\">\"scrub PEB %d to PEB %d\"</span>, e1-&gt;pnum, e2-&gt;pnum);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tubi-&gt;move_from = e1;</span><br><span class=\"line\">\tubi-&gt;move_to = e2;</span><br><span class=\"line\">\tspin_unlock(&amp;ubi-&gt;wl_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Now we are going to copy physical eraseblock @e1-&gt;pnum to @e2-&gt;pnum.</span></span><br><span class=\"line\"><span class=\"comment\">\t * We so far do not know which logical eraseblock our physical</span></span><br><span class=\"line\"><span class=\"comment\">\t * eraseblock (@e1) belongs to. We have to read the volume identifier</span></span><br><span class=\"line\"><span class=\"comment\">\t * header first.</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * Note, we are protected from this PEB being unmapped and erased. The</span></span><br><span class=\"line\"><span class=\"comment\">\t * 'ubi_wl_put_peb()' would wait for moving to be finished if the PEB</span></span><br><span class=\"line\"><span class=\"comment\">\t * which is being moved was unmapped.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\terr = ubi_io_read_vid_hdr(ubi, e1-&gt;pnum, vid_hdr, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tvol_id = be32_to_cpu(vid_hdr-&gt;vol_id);</span><br><span class=\"line\">\tlnum = be32_to_cpu(vid_hdr-&gt;lnum);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = ubi_eba_copy_leb(ubi, e1-&gt;pnum, e2-&gt;pnum, vid_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* The PEB has been successfully moved */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (scrubbing)</span><br><span class=\"line\">\t\tubi_msg(<span class=\"string\">\"scrubbed PEB %d (LEB %d:%d), data moved to PEB %d\"</span>,</span><br><span class=\"line\">\t\t\te1-&gt;pnum, vol_id, lnum, e2-&gt;pnum);</span><br><span class=\"line\">\tubi_free_vid_hdr(ubi, vid_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">\tspin_lock(&amp;ubi-&gt;wl_lock);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ubi-&gt;move_to_put) &#123;</span><br><span class=\"line\">\t\twl_tree_add(e2, &amp;ubi-&gt;used);</span><br><span class=\"line\">\t\te2 = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tubi-&gt;move_from = ubi-&gt;move_to = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tubi-&gt;move_to_put = ubi-&gt;wl_scheduled = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tspin_unlock(&amp;ubi-&gt;wl_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = do_sync_erase(ubi, e1, vol_id, lnum, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (e2) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Well, the target PEB was put meanwhile, schedule it for</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * erasure.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tdbg_wl(<span class=\"string\">\"PEB %d (LEB %d:%d) was put meanwhile, erase\"</span>,</span><br><span class=\"line\">\t\t       e2-&gt;pnum, vol_id, lnum);</span><br><span class=\"line\">\t\terr = do_sync_erase(ubi, e2, vol_id, lnum, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out_ro;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmutex_unlock(&amp;ubi-&gt;move_mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在EBA write 时，如果没有映射，我们就会调用ubi_wl_get_peb() 获取free PEB。 </p>\n<ul>\n<li>drivers/mtd/ubi/wl.c *<br>ubi_wl_get_peb() -&gt;<br>&nbsp;&nbsp;__wl_get_peb() -&gt;  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ubi_eba_write_leb</span><span class=\"params\">(struct ubi_device *ubi, struct ubi_volume *vol, <span class=\"keyword\">int</span> lnum,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t      <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err, pnum, tries = <span class=\"number\">0</span>, vol_id = vol-&gt;vol_id;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_vid_hdr</span> *<span class=\"title\">vid_hdr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\terr = leb_write_lock(ubi, vol_id, lnum);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpnum = vol-&gt;eba_tbl[lnum];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pnum &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);</span><br><span class=\"line\">\t\tleb_write_unlock(ubi, vol_id, lnum);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * The logical eraseblock is not mapped. We have to get a free physical</span></span><br><span class=\"line\"><span class=\"comment\">\t * eraseblock and write the volume identifier header there first.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);</span><br><span class=\"line\"></span><br><span class=\"line\">\tvid_hdr-&gt;vol_type = UBI_VID_DYNAMIC;</span><br><span class=\"line\">\tvid_hdr-&gt;sqnum = cpu_to_be64(ubi_next_sqnum(ubi));</span><br><span class=\"line\">\tvid_hdr-&gt;vol_id = cpu_to_be32(vol_id);</span><br><span class=\"line\">\tvid_hdr-&gt;lnum = cpu_to_be32(lnum);</span><br><span class=\"line\">\tvid_hdr-&gt;compat = ubi_get_compat(ubi, vol_id);</span><br><span class=\"line\">\tvid_hdr-&gt;data_pad = cpu_to_be32(vol-&gt;data_pad);</span><br><span class=\"line\"></span><br><span class=\"line\">retry:</span><br><span class=\"line\">\tpnum = ubi_wl_get_peb(ubi);</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = ubi_io_write_vid_hdr(ubi, pnum, vid_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (len) &#123;</span><br><span class=\"line\">\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdown_read(&amp;ubi-&gt;fm_sem);</span><br><span class=\"line\">\tvol-&gt;eba_tbl[lnum] = pnum;</span><br><span class=\"line\">\tup_read(&amp;ubi-&gt;fm_sem);</span><br><span class=\"line\"></span><br><span class=\"line\">\tleb_write_unlock(ubi, vol_id, lnum);</span><br><span class=\"line\">\tubi_free_vid_hdr(ubi, vid_hdr);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __wl_get_peb(struct ubi_device *ubi)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ubi_wl_entry</span> *<span class=\"title\">e</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">retry:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ubi-&gt;<span class=\"built_in\">free</span>.rb_node) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ubi-&gt;works_count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tubi_err(<span class=\"string\">\"no free eraseblocks\"</span>);</span><br><span class=\"line\">\t\t\tubi_assert(list_empty(&amp;ubi-&gt;works));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -ENOSPC;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\terr = produce_free_peb(ubi);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> retry;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\te = find_mean_wl_entry(ubi, &amp;ubi-&gt;<span class=\"built_in\">free</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Move the physical eraseblock to the protection queue where it will</span></span><br><span class=\"line\"><span class=\"comment\">\t * be protected from being moved for some time.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\trb_erase(&amp;e-&gt;u.rb, &amp;ubi-&gt;<span class=\"built_in\">free</span>);</span><br><span class=\"line\">\tubi-&gt;free_count--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> e-&gt;pnum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-4-fastmap\"><a href=\"#3-2-4-fastmap\" class=\"headerlink\" title=\"3.2.4. fastmap\"></a>3.2.4. fastmap</h4><p>fastmap 利用存储在flash 上的fastmap volume 以此来加速attach。<br><strong>fastmap 一般用于large flash， 例如4Gib Nand chips。</strong><br>是否启用fastmap, 需要考虑到fastmap 本身会占用一些PEB，并且fastmap pool full, volume layout change or detach时，fastmap都需要写入信息到保留的PEB 中。</p>\n<p>fastmap volume中存储的信息有：</p>\n<ul>\n<li>erase value</li>\n<li>a list of all PEBs and their state  </li>\n<li>a list of all volumes and their EBA </li>\n<li>a list of PEBs called fastmap pool   </li>\n</ul>\n<p>fastmap 还有一个fastmap pool 概念， 它的size 大约为 5% of the total amount of PEBs。我们从fastmap pool 中取用PEBs，这样我们只需要关心fastmap pool 的PEBs， 而不用关心total PEBs, 减少了需要存储的信息量。</p>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><a href=\"https://www.cnblogs.com/wahaha02/p/4814698.html\" target=\"_blank\" rel=\"noopener\">Linux UBI子系统设计初探</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/ubi.html\" target=\"_blank\" rel=\"noopener\">ubi 官方文档</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/ubidesign/ubidesign.pdf\" target=\"_blank\" rel=\"noopener\">ubi design pdf from MTD org</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/ubi.ppt\" target=\"_blank\" rel=\"noopener\">ubi ppt from MTD org</a></p>\n<p><a href=\"https://elinux.org/UBIFS\" target=\"_blank\" rel=\"noopener\">elinux/ubifs</a></p>"},{"title":"kernel-ubifs-design","date":"2019-11-19T07:27:46.000Z","_content":"\nubifs(Unsorted block images file system)之前本设计为jffs3，后改名为ubifs。\n\n<!--more-->\n\njffs2 本身设计是为small size NOR Flash。\n\n他有如下缺点：\n- index 是建立在RAM， 并且内存的消耗与Flash size 成线性关系\n- mount 时间需要scan 整个Flash\n\n但他有如下优点：\n- 支持数据压缩\n- 支持wear-leveling\n- unclean reboot robustness(健壮性)，jffs2 为LOGFS\n\n因此ubifs 的需求有如下：\n- 继承jffs2 的优点\n- mem 消耗与Flash size 不是线性关系\n- cache write （异步方式）实现性能提升，而不是jffs2 的sync 性同步写入\n- 能处理data corruptions, flash bit flip, dynamically bad blocks\n\n\n### 1. index problem\nblock device 与flash device最大的不同在于\"in placed updates\". Flash 设备不能直接写，除非进行了Erase 操作。\n因此， ubifs 采用“out-of-place updates\"， 只在必要的时候（有其他的sector 需要更新时）才将数据真正写入flash。\nubifs 使用log-structured design 记录这些更新。另一方面，这样也可以减少flash的erase cycles。\n\n问题：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/indexing_problem.png)\n\nA 引用了B, A引用了C, B，C 引用了D， 现在D 使用了\"out-of-place updates\" 更新到了D1, 怎么保证B, C 是引用的最新的D1。\n\n#### 1.2. wandering tree\nwandering tree 可以解决如上问题。\n\n![截图 wandering tree](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/wandering_tree.png)\n假设需更新H1， 涉及到的F, A也需更新。\n\nany tree may be called ”wandering tree” if any update in the tree requires updating parent nodes up\nto the root. For example, it makes sense to talk about wandering Red-Black trees or wandering B+-trees and so forth.\n\n#### 1.3. B+ tree\nubifs 采用B+ tree 多路平衡搜索二叉树。__只有叶子节点包含data，非叶子节点只包含keys 和links__。 B+ tree 广泛用于\nblock devices上。\n\n![B+ tree 截图](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree.png)\n\n![B+ non-leaf node 截图](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_non_leaf_node.png)\nnon-leaf node 包含如下：\n- 增序的keys\n- 指向leaf node 或non-leaf node 的 links\n\n当有新的insert 或者remove 发生时， B+ tree 将会重新re-balancing， node 的删除与合并可能发生。\n\n### 2. indexing in ubifs\nUBIFS 参考了Reiser4 file system. 所有的 fs objects（inodes, files, directory entries, extended attributes, etc) 都包含在一个large B+ tree。\n他们的keys 可能如下：\n- file data key: {inode number, offset};\n- directory entry key: {parent directory inode number, direntry name hash};\n- extended attribute key: {target inode number, xattr name hash} and the like\n\n![B+ tree indexing nodes and leaf nodes](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_indexing_nodes_leaf_nodes.png)\n\nnon-leaf node 被称为indexing nodes, 只包含indexing 信息。\nleaf node 有flexible size, 他对应与flash 的sector size， 例如 512, 2K 等（与Flash 的硬件特性有关）。\nleaf node 包含：\n- header (describes the node data and information like the key of the node, the length, and the like)\n- data （some file system data）\n\n__leaf nodes 与indexing nodes 是分开存储在不同的Eraseblock上。__\n\n![B+ tree store of indexing nodes and leaf nodes](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_store_indexing_nodes_leaf_nodes.png)\n\nubifs indexing approach 优点：\n- The leaf nodes may be compressed\n- In case of corruptions of the indexing information, it is possible to re-create it by scanning leaf nodes’ headers\n- There is a clear separation between data and indexing information. indexing and data may be cached separately\n\n### 3. the journal\nubifs tree 本身是B+ tree and wandering tree. 如果某些nodes 需要更新，就update flash data, 这并不理想。\njournal provides a mechanism to avoid this. 因此， ubifs 中有index and journal B+ tree.\n\njournal 有位置不固定的journal eraseblocks组成。\n\n__create__\njournal tree 在ubifs mount 时根据Flash 上journal eraseblocks创建于RAM 中 。\n\n__Write__\n在有更新时，相应的leaf nodes 被写入到journal tree, 而相应的indexing nodes 不更新。\n\n__read__\n首先查询是否在journal tree, 存在则从该树read，否则执行常规tree lookup.\n\n![journal tree in RAM](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/journal_tree_in_ram.png)\n\n![journal tree read flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/journal_tree_read_flow.png)\n\n__update__\njournal tree 在full 或者在适当的时机是会checkpointed。在journal tree 中记录的信息与相应的indexing nodes 将会被写入到Flash 中。\ncheckpointed journal eraseblocks 会被当做leaf eraseblocks， 新的journal eraseblocks 会被UBIFS 通过 wear-leveling 算法选出(这是journal eraseblocks 不固定的产生)。\n\n另外，journal tree 越大，可能会达到更好的性能， 但是在mount 时创建tree耗费的时间也会变长，这需要选取平衡在mount time and journal tree size.\n\n### 4. the superblock\nsuperblock 包含描述整个fs 的数据结构。传统的fs 可以存储superblock 在固定的位置， 但是Flash 由于badblock， 寿命的因素（wear-leveling）的原因，\n导致superblock 不能存储在固定位置。\n\nubifs 将superblock 划分为两种类型：\n- static superblock， 不会被ubifs 改变，可以被external user-level tools 更改（例如name, volume size，compression type等）。\n- superblock, 包含动态数据，时常被更改，使用wear-leveling 算法挑选。\n\nubifs 前3个good eraseblock 如下安排：\n\n.-----------------------------------------------------------------------------------.\n| static superblock(1 eraseblock) | anchor area (2 eraseblocks) |\n`-----------------------------------------------------------------------------------.\n\n2 eraseblocks anchor area 是为了确保数据的安全性在unclean reboots时。\n\nanchor area 与 dynamic superblock 结构如下：\n\n![superblock management scheme](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/superblock%20management%20scheme.png)\n\n为了使superblock 使用上wear-leveling。superblock 的管理方法如下：\n1. 在super eraseblock 上更新数据， 如果写满了则使用wear-leveling 选出新的eraseblock， 同时更新chain eraseblock2 中sector\n2. 如果chain eraseblock2 中sector写满， 则pick up 新的eraseblock 作为chain eraseblock2，并记录信息在chain eraseblock1 中sector\n3. 以此类推记录数据到Anchor area 中的sector。\n   \nsuper eraseblock sector -> chain eraseblock2 sector -> chain eraseblock1 sector -> anchor area sector\n\nSearch 则是存储的相反顺序了。\n\n### Reference\n[ubifs](http://www.linux-mtd.infradead.org/doc/ubifs.pdf)\n\n[ubifs_whitepaper](http://www.linux-mtd.infradead.org/doc/ubifs_whitepaper.pdf)\n\n[jffs3 design](http://www.linux-mtd.infradead.org/doc/JFFS3design.pdf)\n\n[B tree, B+ tree](https://www.cnblogs.com/vianzhang/p/7922426.html)\n\n[B tree and B+ tree](https://www.jianshu.com/p/ac12d2c83708)\n\n[Reiser4 File system](http://www.namesys.com/)\n","source":"_posts/kernel-ubifs-design.md","raw":"---\ntitle: kernel-ubifs-design\ndate: 2019-11-19 15:27:46\ntags: \n    - mtd\n    - ubifs\ncategories: \n    - fs\n---\n\nubifs(Unsorted block images file system)之前本设计为jffs3，后改名为ubifs。\n\n<!--more-->\n\njffs2 本身设计是为small size NOR Flash。\n\n他有如下缺点：\n- index 是建立在RAM， 并且内存的消耗与Flash size 成线性关系\n- mount 时间需要scan 整个Flash\n\n但他有如下优点：\n- 支持数据压缩\n- 支持wear-leveling\n- unclean reboot robustness(健壮性)，jffs2 为LOGFS\n\n因此ubifs 的需求有如下：\n- 继承jffs2 的优点\n- mem 消耗与Flash size 不是线性关系\n- cache write （异步方式）实现性能提升，而不是jffs2 的sync 性同步写入\n- 能处理data corruptions, flash bit flip, dynamically bad blocks\n\n\n### 1. index problem\nblock device 与flash device最大的不同在于\"in placed updates\". Flash 设备不能直接写，除非进行了Erase 操作。\n因此， ubifs 采用“out-of-place updates\"， 只在必要的时候（有其他的sector 需要更新时）才将数据真正写入flash。\nubifs 使用log-structured design 记录这些更新。另一方面，这样也可以减少flash的erase cycles。\n\n问题：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/indexing_problem.png)\n\nA 引用了B, A引用了C, B，C 引用了D， 现在D 使用了\"out-of-place updates\" 更新到了D1, 怎么保证B, C 是引用的最新的D1。\n\n#### 1.2. wandering tree\nwandering tree 可以解决如上问题。\n\n![截图 wandering tree](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/wandering_tree.png)\n假设需更新H1， 涉及到的F, A也需更新。\n\nany tree may be called ”wandering tree” if any update in the tree requires updating parent nodes up\nto the root. For example, it makes sense to talk about wandering Red-Black trees or wandering B+-trees and so forth.\n\n#### 1.3. B+ tree\nubifs 采用B+ tree 多路平衡搜索二叉树。__只有叶子节点包含data，非叶子节点只包含keys 和links__。 B+ tree 广泛用于\nblock devices上。\n\n![B+ tree 截图](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree.png)\n\n![B+ non-leaf node 截图](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_non_leaf_node.png)\nnon-leaf node 包含如下：\n- 增序的keys\n- 指向leaf node 或non-leaf node 的 links\n\n当有新的insert 或者remove 发生时， B+ tree 将会重新re-balancing， node 的删除与合并可能发生。\n\n### 2. indexing in ubifs\nUBIFS 参考了Reiser4 file system. 所有的 fs objects（inodes, files, directory entries, extended attributes, etc) 都包含在一个large B+ tree。\n他们的keys 可能如下：\n- file data key: {inode number, offset};\n- directory entry key: {parent directory inode number, direntry name hash};\n- extended attribute key: {target inode number, xattr name hash} and the like\n\n![B+ tree indexing nodes and leaf nodes](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_indexing_nodes_leaf_nodes.png)\n\nnon-leaf node 被称为indexing nodes, 只包含indexing 信息。\nleaf node 有flexible size, 他对应与flash 的sector size， 例如 512, 2K 等（与Flash 的硬件特性有关）。\nleaf node 包含：\n- header (describes the node data and information like the key of the node, the length, and the like)\n- data （some file system data）\n\n__leaf nodes 与indexing nodes 是分开存储在不同的Eraseblock上。__\n\n![B+ tree store of indexing nodes and leaf nodes](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_store_indexing_nodes_leaf_nodes.png)\n\nubifs indexing approach 优点：\n- The leaf nodes may be compressed\n- In case of corruptions of the indexing information, it is possible to re-create it by scanning leaf nodes’ headers\n- There is a clear separation between data and indexing information. indexing and data may be cached separately\n\n### 3. the journal\nubifs tree 本身是B+ tree and wandering tree. 如果某些nodes 需要更新，就update flash data, 这并不理想。\njournal provides a mechanism to avoid this. 因此， ubifs 中有index and journal B+ tree.\n\njournal 有位置不固定的journal eraseblocks组成。\n\n__create__\njournal tree 在ubifs mount 时根据Flash 上journal eraseblocks创建于RAM 中 。\n\n__Write__\n在有更新时，相应的leaf nodes 被写入到journal tree, 而相应的indexing nodes 不更新。\n\n__read__\n首先查询是否在journal tree, 存在则从该树read，否则执行常规tree lookup.\n\n![journal tree in RAM](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/journal_tree_in_ram.png)\n\n![journal tree read flow](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/journal_tree_read_flow.png)\n\n__update__\njournal tree 在full 或者在适当的时机是会checkpointed。在journal tree 中记录的信息与相应的indexing nodes 将会被写入到Flash 中。\ncheckpointed journal eraseblocks 会被当做leaf eraseblocks， 新的journal eraseblocks 会被UBIFS 通过 wear-leveling 算法选出(这是journal eraseblocks 不固定的产生)。\n\n另外，journal tree 越大，可能会达到更好的性能， 但是在mount 时创建tree耗费的时间也会变长，这需要选取平衡在mount time and journal tree size.\n\n### 4. the superblock\nsuperblock 包含描述整个fs 的数据结构。传统的fs 可以存储superblock 在固定的位置， 但是Flash 由于badblock， 寿命的因素（wear-leveling）的原因，\n导致superblock 不能存储在固定位置。\n\nubifs 将superblock 划分为两种类型：\n- static superblock， 不会被ubifs 改变，可以被external user-level tools 更改（例如name, volume size，compression type等）。\n- superblock, 包含动态数据，时常被更改，使用wear-leveling 算法挑选。\n\nubifs 前3个good eraseblock 如下安排：\n\n.-----------------------------------------------------------------------------------.\n| static superblock(1 eraseblock) | anchor area (2 eraseblocks) |\n`-----------------------------------------------------------------------------------.\n\n2 eraseblocks anchor area 是为了确保数据的安全性在unclean reboots时。\n\nanchor area 与 dynamic superblock 结构如下：\n\n![superblock management scheme](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/superblock%20management%20scheme.png)\n\n为了使superblock 使用上wear-leveling。superblock 的管理方法如下：\n1. 在super eraseblock 上更新数据， 如果写满了则使用wear-leveling 选出新的eraseblock， 同时更新chain eraseblock2 中sector\n2. 如果chain eraseblock2 中sector写满， 则pick up 新的eraseblock 作为chain eraseblock2，并记录信息在chain eraseblock1 中sector\n3. 以此类推记录数据到Anchor area 中的sector。\n   \nsuper eraseblock sector -> chain eraseblock2 sector -> chain eraseblock1 sector -> anchor area sector\n\nSearch 则是存储的相反顺序了。\n\n### Reference\n[ubifs](http://www.linux-mtd.infradead.org/doc/ubifs.pdf)\n\n[ubifs_whitepaper](http://www.linux-mtd.infradead.org/doc/ubifs_whitepaper.pdf)\n\n[jffs3 design](http://www.linux-mtd.infradead.org/doc/JFFS3design.pdf)\n\n[B tree, B+ tree](https://www.cnblogs.com/vianzhang/p/7922426.html)\n\n[B tree and B+ tree](https://www.jianshu.com/p/ac12d2c83708)\n\n[Reiser4 File system](http://www.namesys.com/)\n","slug":"kernel-ubifs-design","published":1,"updated":"2019-11-19T08:46:56.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qn0032zkgrxgjj2dd4","content":"<p>ubifs(Unsorted block images file system)之前本设计为jffs3，后改名为ubifs。</p>\n<a id=\"more\"></a>\n<p>jffs2 本身设计是为small size NOR Flash。</p>\n<p>他有如下缺点：</p>\n<ul>\n<li>index 是建立在RAM， 并且内存的消耗与Flash size 成线性关系</li>\n<li>mount 时间需要scan 整个Flash</li>\n</ul>\n<p>但他有如下优点：</p>\n<ul>\n<li>支持数据压缩</li>\n<li>支持wear-leveling</li>\n<li>unclean reboot robustness(健壮性)，jffs2 为LOGFS</li>\n</ul>\n<p>因此ubifs 的需求有如下：</p>\n<ul>\n<li>继承jffs2 的优点</li>\n<li>mem 消耗与Flash size 不是线性关系</li>\n<li>cache write （异步方式）实现性能提升，而不是jffs2 的sync 性同步写入</li>\n<li>能处理data corruptions, flash bit flip, dynamically bad blocks</li>\n</ul>\n<h3 id=\"1-index-problem\"><a href=\"#1-index-problem\" class=\"headerlink\" title=\"1. index problem\"></a>1. index problem</h3><p>block device 与flash device最大的不同在于”in placed updates”. Flash 设备不能直接写，除非进行了Erase 操作。<br>因此， ubifs 采用“out-of-place updates”， 只在必要的时候（有其他的sector 需要更新时）才将数据真正写入flash。<br>ubifs 使用log-structured design 记录这些更新。另一方面，这样也可以减少flash的erase cycles。</p>\n<p>问题：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/indexing_problem.png\" alt=\"\"></p>\n<p>A 引用了B, A引用了C, B，C 引用了D， 现在D 使用了”out-of-place updates” 更新到了D1, 怎么保证B, C 是引用的最新的D1。</p>\n<h4 id=\"1-2-wandering-tree\"><a href=\"#1-2-wandering-tree\" class=\"headerlink\" title=\"1.2. wandering tree\"></a>1.2. wandering tree</h4><p>wandering tree 可以解决如上问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/wandering_tree.png\" alt=\"截图 wandering tree\"><br>假设需更新H1， 涉及到的F, A也需更新。</p>\n<p>any tree may be called ”wandering tree” if any update in the tree requires updating parent nodes up<br>to the root. For example, it makes sense to talk about wandering Red-Black trees or wandering B+-trees and so forth.</p>\n<h4 id=\"1-3-B-tree\"><a href=\"#1-3-B-tree\" class=\"headerlink\" title=\"1.3. B+ tree\"></a>1.3. B+ tree</h4><p>ubifs 采用B+ tree 多路平衡搜索二叉树。<strong>只有叶子节点包含data，非叶子节点只包含keys 和links</strong>。 B+ tree 广泛用于<br>block devices上。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree.png\" alt=\"B+ tree 截图\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_non_leaf_node.png\" alt=\"B+ non-leaf node 截图\"><br>non-leaf node 包含如下：</p>\n<ul>\n<li>增序的keys</li>\n<li>指向leaf node 或non-leaf node 的 links</li>\n</ul>\n<p>当有新的insert 或者remove 发生时， B+ tree 将会重新re-balancing， node 的删除与合并可能发生。</p>\n<h3 id=\"2-indexing-in-ubifs\"><a href=\"#2-indexing-in-ubifs\" class=\"headerlink\" title=\"2. indexing in ubifs\"></a>2. indexing in ubifs</h3><p>UBIFS 参考了Reiser4 file system. 所有的 fs objects（inodes, files, directory entries, extended attributes, etc) 都包含在一个large B+ tree。<br>他们的keys 可能如下：</p>\n<ul>\n<li>file data key: {inode number, offset};</li>\n<li>directory entry key: {parent directory inode number, direntry name hash};</li>\n<li>extended attribute key: {target inode number, xattr name hash} and the like</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_indexing_nodes_leaf_nodes.png\" alt=\"B+ tree indexing nodes and leaf nodes\"></p>\n<p>non-leaf node 被称为indexing nodes, 只包含indexing 信息。<br>leaf node 有flexible size, 他对应与flash 的sector size， 例如 512, 2K 等（与Flash 的硬件特性有关）。<br>leaf node 包含：</p>\n<ul>\n<li>header (describes the node data and information like the key of the node, the length, and the like)</li>\n<li>data （some file system data）</li>\n</ul>\n<p><strong>leaf nodes 与indexing nodes 是分开存储在不同的Eraseblock上。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_store_indexing_nodes_leaf_nodes.png\" alt=\"B+ tree store of indexing nodes and leaf nodes\"></p>\n<p>ubifs indexing approach 优点：</p>\n<ul>\n<li>The leaf nodes may be compressed</li>\n<li>In case of corruptions of the indexing information, it is possible to re-create it by scanning leaf nodes’ headers</li>\n<li>There is a clear separation between data and indexing information. indexing and data may be cached separately</li>\n</ul>\n<h3 id=\"3-the-journal\"><a href=\"#3-the-journal\" class=\"headerlink\" title=\"3. the journal\"></a>3. the journal</h3><p>ubifs tree 本身是B+ tree and wandering tree. 如果某些nodes 需要更新，就update flash data, 这并不理想。<br>journal provides a mechanism to avoid this. 因此， ubifs 中有index and journal B+ tree.</p>\n<p>journal 有位置不固定的journal eraseblocks组成。</p>\n<p><strong>create</strong><br>journal tree 在ubifs mount 时根据Flash 上journal eraseblocks创建于RAM 中 。</p>\n<p><strong>Write</strong><br>在有更新时，相应的leaf nodes 被写入到journal tree, 而相应的indexing nodes 不更新。</p>\n<p><strong>read</strong><br>首先查询是否在journal tree, 存在则从该树read，否则执行常规tree lookup.</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/journal_tree_in_ram.png\" alt=\"journal tree in RAM\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/journal_tree_read_flow.png\" alt=\"journal tree read flow\"></p>\n<p><strong>update</strong><br>journal tree 在full 或者在适当的时机是会checkpointed。在journal tree 中记录的信息与相应的indexing nodes 将会被写入到Flash 中。<br>checkpointed journal eraseblocks 会被当做leaf eraseblocks， 新的journal eraseblocks 会被UBIFS 通过 wear-leveling 算法选出(这是journal eraseblocks 不固定的产生)。</p>\n<p>另外，journal tree 越大，可能会达到更好的性能， 但是在mount 时创建tree耗费的时间也会变长，这需要选取平衡在mount time and journal tree size.</p>\n<h3 id=\"4-the-superblock\"><a href=\"#4-the-superblock\" class=\"headerlink\" title=\"4. the superblock\"></a>4. the superblock</h3><p>superblock 包含描述整个fs 的数据结构。传统的fs 可以存储superblock 在固定的位置， 但是Flash 由于badblock， 寿命的因素（wear-leveling）的原因，<br>导致superblock 不能存储在固定位置。</p>\n<p>ubifs 将superblock 划分为两种类型：</p>\n<ul>\n<li>static superblock， 不会被ubifs 改变，可以被external user-level tools 更改（例如name, volume size，compression type等）。</li>\n<li>superblock, 包含动态数据，时常被更改，使用wear-leveling 算法挑选。</li>\n</ul>\n<p>ubifs 前3个good eraseblock 如下安排：</p>\n<p>.———————————————————————————–.<br>| static superblock(1 eraseblock) | anchor area (2 eraseblocks) |<br>`———————————————————————————–.</p>\n<p>2 eraseblocks anchor area 是为了确保数据的安全性在unclean reboots时。</p>\n<p>anchor area 与 dynamic superblock 结构如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/superblock%20management%20scheme.png\" alt=\"superblock management scheme\"></p>\n<p>为了使superblock 使用上wear-leveling。superblock 的管理方法如下：</p>\n<ol>\n<li>在super eraseblock 上更新数据， 如果写满了则使用wear-leveling 选出新的eraseblock， 同时更新chain eraseblock2 中sector</li>\n<li>如果chain eraseblock2 中sector写满， 则pick up 新的eraseblock 作为chain eraseblock2，并记录信息在chain eraseblock1 中sector</li>\n<li>以此类推记录数据到Anchor area 中的sector。</li>\n</ol>\n<p>super eraseblock sector -&gt; chain eraseblock2 sector -&gt; chain eraseblock1 sector -&gt; anchor area sector</p>\n<p>Search 则是存储的相反顺序了。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p><a href=\"http://www.linux-mtd.infradead.org/doc/ubifs.pdf\" target=\"_blank\" rel=\"noopener\">ubifs</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/ubifs_whitepaper.pdf\" target=\"_blank\" rel=\"noopener\">ubifs_whitepaper</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/JFFS3design.pdf\" target=\"_blank\" rel=\"noopener\">jffs3 design</a></p>\n<p><a href=\"https://www.cnblogs.com/vianzhang/p/7922426.html\" target=\"_blank\" rel=\"noopener\">B tree, B+ tree</a></p>\n<p><a href=\"https://www.jianshu.com/p/ac12d2c83708\" target=\"_blank\" rel=\"noopener\">B tree and B+ tree</a></p>\n<p><a href=\"http://www.namesys.com/\" target=\"_blank\" rel=\"noopener\">Reiser4 File system</a></p>\n","site":{"data":{}},"excerpt":"<p>ubifs(Unsorted block images file system)之前本设计为jffs3，后改名为ubifs。</p>","more":"<p>jffs2 本身设计是为small size NOR Flash。</p>\n<p>他有如下缺点：</p>\n<ul>\n<li>index 是建立在RAM， 并且内存的消耗与Flash size 成线性关系</li>\n<li>mount 时间需要scan 整个Flash</li>\n</ul>\n<p>但他有如下优点：</p>\n<ul>\n<li>支持数据压缩</li>\n<li>支持wear-leveling</li>\n<li>unclean reboot robustness(健壮性)，jffs2 为LOGFS</li>\n</ul>\n<p>因此ubifs 的需求有如下：</p>\n<ul>\n<li>继承jffs2 的优点</li>\n<li>mem 消耗与Flash size 不是线性关系</li>\n<li>cache write （异步方式）实现性能提升，而不是jffs2 的sync 性同步写入</li>\n<li>能处理data corruptions, flash bit flip, dynamically bad blocks</li>\n</ul>\n<h3 id=\"1-index-problem\"><a href=\"#1-index-problem\" class=\"headerlink\" title=\"1. index problem\"></a>1. index problem</h3><p>block device 与flash device最大的不同在于”in placed updates”. Flash 设备不能直接写，除非进行了Erase 操作。<br>因此， ubifs 采用“out-of-place updates”， 只在必要的时候（有其他的sector 需要更新时）才将数据真正写入flash。<br>ubifs 使用log-structured design 记录这些更新。另一方面，这样也可以减少flash的erase cycles。</p>\n<p>问题：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/indexing_problem.png\" alt=\"\"></p>\n<p>A 引用了B, A引用了C, B，C 引用了D， 现在D 使用了”out-of-place updates” 更新到了D1, 怎么保证B, C 是引用的最新的D1。</p>\n<h4 id=\"1-2-wandering-tree\"><a href=\"#1-2-wandering-tree\" class=\"headerlink\" title=\"1.2. wandering tree\"></a>1.2. wandering tree</h4><p>wandering tree 可以解决如上问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/wandering_tree.png\" alt=\"截图 wandering tree\"><br>假设需更新H1， 涉及到的F, A也需更新。</p>\n<p>any tree may be called ”wandering tree” if any update in the tree requires updating parent nodes up<br>to the root. For example, it makes sense to talk about wandering Red-Black trees or wandering B+-trees and so forth.</p>\n<h4 id=\"1-3-B-tree\"><a href=\"#1-3-B-tree\" class=\"headerlink\" title=\"1.3. B+ tree\"></a>1.3. B+ tree</h4><p>ubifs 采用B+ tree 多路平衡搜索二叉树。<strong>只有叶子节点包含data，非叶子节点只包含keys 和links</strong>。 B+ tree 广泛用于<br>block devices上。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree.png\" alt=\"B+ tree 截图\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_non_leaf_node.png\" alt=\"B+ non-leaf node 截图\"><br>non-leaf node 包含如下：</p>\n<ul>\n<li>增序的keys</li>\n<li>指向leaf node 或non-leaf node 的 links</li>\n</ul>\n<p>当有新的insert 或者remove 发生时， B+ tree 将会重新re-balancing， node 的删除与合并可能发生。</p>\n<h3 id=\"2-indexing-in-ubifs\"><a href=\"#2-indexing-in-ubifs\" class=\"headerlink\" title=\"2. indexing in ubifs\"></a>2. indexing in ubifs</h3><p>UBIFS 参考了Reiser4 file system. 所有的 fs objects（inodes, files, directory entries, extended attributes, etc) 都包含在一个large B+ tree。<br>他们的keys 可能如下：</p>\n<ul>\n<li>file data key: {inode number, offset};</li>\n<li>directory entry key: {parent directory inode number, direntry name hash};</li>\n<li>extended attribute key: {target inode number, xattr name hash} and the like</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_indexing_nodes_leaf_nodes.png\" alt=\"B+ tree indexing nodes and leaf nodes\"></p>\n<p>non-leaf node 被称为indexing nodes, 只包含indexing 信息。<br>leaf node 有flexible size, 他对应与flash 的sector size， 例如 512, 2K 等（与Flash 的硬件特性有关）。<br>leaf node 包含：</p>\n<ul>\n<li>header (describes the node data and information like the key of the node, the length, and the like)</li>\n<li>data （some file system data）</li>\n</ul>\n<p><strong>leaf nodes 与indexing nodes 是分开存储在不同的Eraseblock上。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/B%2B_tree_store_indexing_nodes_leaf_nodes.png\" alt=\"B+ tree store of indexing nodes and leaf nodes\"></p>\n<p>ubifs indexing approach 优点：</p>\n<ul>\n<li>The leaf nodes may be compressed</li>\n<li>In case of corruptions of the indexing information, it is possible to re-create it by scanning leaf nodes’ headers</li>\n<li>There is a clear separation between data and indexing information. indexing and data may be cached separately</li>\n</ul>\n<h3 id=\"3-the-journal\"><a href=\"#3-the-journal\" class=\"headerlink\" title=\"3. the journal\"></a>3. the journal</h3><p>ubifs tree 本身是B+ tree and wandering tree. 如果某些nodes 需要更新，就update flash data, 这并不理想。<br>journal provides a mechanism to avoid this. 因此， ubifs 中有index and journal B+ tree.</p>\n<p>journal 有位置不固定的journal eraseblocks组成。</p>\n<p><strong>create</strong><br>journal tree 在ubifs mount 时根据Flash 上journal eraseblocks创建于RAM 中 。</p>\n<p><strong>Write</strong><br>在有更新时，相应的leaf nodes 被写入到journal tree, 而相应的indexing nodes 不更新。</p>\n<p><strong>read</strong><br>首先查询是否在journal tree, 存在则从该树read，否则执行常规tree lookup.</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/journal_tree_in_ram.png\" alt=\"journal tree in RAM\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/journal_tree_read_flow.png\" alt=\"journal tree read flow\"></p>\n<p><strong>update</strong><br>journal tree 在full 或者在适当的时机是会checkpointed。在journal tree 中记录的信息与相应的indexing nodes 将会被写入到Flash 中。<br>checkpointed journal eraseblocks 会被当做leaf eraseblocks， 新的journal eraseblocks 会被UBIFS 通过 wear-leveling 算法选出(这是journal eraseblocks 不固定的产生)。</p>\n<p>另外，journal tree 越大，可能会达到更好的性能， 但是在mount 时创建tree耗费的时间也会变长，这需要选取平衡在mount time and journal tree size.</p>\n<h3 id=\"4-the-superblock\"><a href=\"#4-the-superblock\" class=\"headerlink\" title=\"4. the superblock\"></a>4. the superblock</h3><p>superblock 包含描述整个fs 的数据结构。传统的fs 可以存储superblock 在固定的位置， 但是Flash 由于badblock， 寿命的因素（wear-leveling）的原因，<br>导致superblock 不能存储在固定位置。</p>\n<p>ubifs 将superblock 划分为两种类型：</p>\n<ul>\n<li>static superblock， 不会被ubifs 改变，可以被external user-level tools 更改（例如name, volume size，compression type等）。</li>\n<li>superblock, 包含动态数据，时常被更改，使用wear-leveling 算法挑选。</li>\n</ul>\n<p>ubifs 前3个good eraseblock 如下安排：</p>\n<p>.———————————————————————————–.<br>| static superblock(1 eraseblock) | anchor area (2 eraseblocks) |<br>`———————————————————————————–.</p>\n<p>2 eraseblocks anchor area 是为了确保数据的安全性在unclean reboots时。</p>\n<p>anchor area 与 dynamic superblock 结构如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_ubifs_design/superblock%20management%20scheme.png\" alt=\"superblock management scheme\"></p>\n<p>为了使superblock 使用上wear-leveling。superblock 的管理方法如下：</p>\n<ol>\n<li>在super eraseblock 上更新数据， 如果写满了则使用wear-leveling 选出新的eraseblock， 同时更新chain eraseblock2 中sector</li>\n<li>如果chain eraseblock2 中sector写满， 则pick up 新的eraseblock 作为chain eraseblock2，并记录信息在chain eraseblock1 中sector</li>\n<li>以此类推记录数据到Anchor area 中的sector。</li>\n</ol>\n<p>super eraseblock sector -&gt; chain eraseblock2 sector -&gt; chain eraseblock1 sector -&gt; anchor area sector</p>\n<p>Search 则是存储的相反顺序了。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p><a href=\"http://www.linux-mtd.infradead.org/doc/ubifs.pdf\" target=\"_blank\" rel=\"noopener\">ubifs</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/ubifs_whitepaper.pdf\" target=\"_blank\" rel=\"noopener\">ubifs_whitepaper</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/JFFS3design.pdf\" target=\"_blank\" rel=\"noopener\">jffs3 design</a></p>\n<p><a href=\"https://www.cnblogs.com/vianzhang/p/7922426.html\" target=\"_blank\" rel=\"noopener\">B tree, B+ tree</a></p>\n<p><a href=\"https://www.jianshu.com/p/ac12d2c83708\" target=\"_blank\" rel=\"noopener\">B tree and B+ tree</a></p>\n<p><a href=\"http://www.namesys.com/\" target=\"_blank\" rel=\"noopener\">Reiser4 File system</a></p>"},{"title":"kernel_virtual_addr_map","date":"2019-07-12T02:51:28.000Z","_content":"\n## 1. User space\nmmap, munmap - map or unmap files or devices into memory. \n将文件或者设备与内存映射起来。\n\n```c\n#include <sys/mman.h>\n\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\nint munmap(void *addr, size_t length);\n\n\n#include <unistd.h>\nint getpagesize(void);\n\n```\n<!--more-->\n\n## 2. Kernel space\n### 2.1. 静态映射\nstart_kernel() ->  \n&nbsp;&nbsp;setup_arch() ->  \n&nbsp;&nbsp;&nbsp;&nbsp; paging_init() ->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devicemaps_init(const struct machine_desc *mdesc) ->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdesc->map_io()\n\n涉及到的结构体__struct machine_desc__\n```c\nstruct machine_desc {\n\tunsigned int\t\tnr;\t\t/* architecture number\t*/\n\tconst char\t\t*name;\t\t/* architecture \n\n\tunsigned int\t\tnr_irqs;\t/* number of IRQs */\n\n#ifdef CONFIG_ZONE_DMA\n\tphys_addr_t\t\tdma_zone_size;\t/* size of DMA-able area */\n#endif\n\tvoid\t\t\t(*init_meminfo)(void);\n\tvoid\t\t\t(*reserve)(void);/* reserve mem blocks\t*/\n\tvoid\t\t\t(*map_io)(void);/* IO mapping function\t*/\n\tvoid\t\t\t(*init_early)(void);\n\tvoid\t\t\t(*init_irq)(void);\n\tvoid\t\t\t(*init_time)(void);\n\tvoid\t\t\t(*init_machine)(void);\n\tvoid\t\t\t(*init_late)(void);\n#ifdef CONFIG_MULTI_IRQ_HANDLER\n\tvoid\t\t\t(*handle_irq)(struct pt_regs *);\n#endif\n\tvoid\t\t\t(*restart)(enum reboot_mode, const char *);\n};\n\nstruct map_desc {\n\tunsigned long virtual;\n\tunsigned long pfn;\n\tunsigned long length;\n\tunsigned int type;\n};\n```\n例如我们在arch/arm/mach-s3c24xx/mach-smdk2440.c\nsmdk2440_map_io() ->  \n&nbsp;&nbsp;iotable_init(mach_desc, size)\n\n```c\nstatic struct map_desc smdk2440_iodesc[] __initdata = {\n\t{\n\t\t.virtual\t= (u32)S3C24XX_VA_ISA_WORD,\n\t\t.pfn\t\t= __phys_to_pfn(S3C2410_CS2),\n\t\t.length\t\t= 0x10000,\n\t\t.type\t\t= MT_DEVICE,\n\t}, \n};\n\nMACHINE_START(S3C2440, \"SMDK2440\")\n\t/* Maintainer: Ben Dooks <ben-linux@fluff.org> */\n\t.atag_offset\t= 0x100,\n\n\t.init_irq\t= s3c2440_init_irq,\n\t.map_io\t\t= smdk2440_map_io,\n\t.init_machine\t= smdk2440_machine_init,\n\t.init_time\t= smdk2440_init_time,\nMACHINE_END\n```\n在这一步定义了物理与虚拟地址之间的映射关系，一旦编译完成就不会修改，<font color=red> 静态编译常用于不容易变动的物理地址与虚拟地址之间的映射，例如寄存器的映射。</font>\n\n### 2.2. 页表创建\nLinux下的页表映射分为两种，一是Linux自身的页表映射，另一种是ARM32 MMU硬件的映射。这样是为了更大的灵活性，可以映射Linux bits 到 硬件tables 上，例如有YOUNG, DIRTY bits.\n\n参见 linux/arch/arm/include/asm/pagetable-2level.h 注释：\n```c\n/*\n * Hardware-wise, we have a two level page table structure, where the first\n * level has 4096 entries, and the second level has 256 entries.  Each entry\n * is one 32-bit word.  Most of the bits in the second level entry are used\n * by hardware, and there aren't any \"accessed\" and \"dirty\" bits.\n *\n * Linux on the other hand has a three level page table structure, which can\n * be wrapped to fit a two level page table structure easily - using the PGD\n * and PTE only.  However, Linux also expects one \"PTE\" table per page, and\n * at least a \"dirty\" bit.\n *\n * Therefore, we tweak the implementation slightly - we tell Linux that we\n * have 2048 entries in the first level, each of which is 8 bytes (iow, two\n * hardware pointers to the second level.)  The second level contains two\n * hardware PTE tables arranged contiguously, preceded by Linux versions\n * which contain the state information Linux needs.  We, therefore, end up\n * with 512 entries in the \"PTE\" level.\n *\n * This leads to the page tables having the following layout:\n *\n *    pgd             pte\n * |        |\n * +--------+\n * |        |       +------------+ +0\n * +- - - - +       | Linux pt 0 |\n * |        |       +------------+ +1024\n * +--------+ +0    | Linux pt 1 |\n * |        |-----> +------------+ +2048\n * +- - - - + +4    |  h/w pt 0  |\n * |        |-----> +------------+ +3072\n * +--------+ +8    |  h/w pt 1  |\n * |        |       +------------+ +4096\n *\n * See L_PTE_xxx below for definitions of bits in the \"Linux pt\", and\n * PTE_xxx for definitions of bits appearing in the \"h/w pt\".\n```\n\n32bit的Linux采用三级映射：PGD-->PMD-->PTE，64bit的Linux采用四级映射：PGD-->PUD-->PMD-->PTE，多了个PUD\n\n>PGD - Page Global Directory\nPUD - Page Upper Directory\nPMD - Page Middle Directory\nPTE - Page Table Entry。\n\n在ARM32 Linux采用两层映射，省略了PMD，除非在定义了CONFIG_ARM_LPAE才会使用3级映射。\n\n![页表转换过程](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/page_to_addr.png)\n\n![1 level page table](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/1level_page_table.png)\n\n![2 level page table](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/2level_page_table.png)\n\n更多可以参看<<ARM ® Architecture Reference Manual -- ARMv7-A and ARMv7-R edition>> (ARM DDI 0406C.c (ID051414)) B3 Virtual Memory System Architecture (VMSA)\n\niotable_init()->  \n&nbsp;&nbsp;create_mapping()->  \n&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pud()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pmd()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pte()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_ext->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_set_pte_ext()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_v7_set_pte_ext() （linux/arm/arm/mm/proc-v7-2level.S）\n\n```c\nvoid __init create_mapping(struct map_desc *md)\n{\n\t...\n\tpgd = pgd_offset_k(addr);\n\tend = addr + length;\n\tdo {\n\t\tunsigned long next = pgd_addr_end(addr, end);\n\n\t\talloc_init_pud(pgd, addr, next, phys, type);\n\n\t\tphys += next - addr;\n\t\taddr = next;\n\t} while (pgd++, addr != end);\t\n}\n\nstatic void __init alloc_init_pte(pmd_t *pmd, unsigned long addr,\n\t\t\t\t  unsigned long end, unsigned long pfn,\n\t\t\t\t  const struct mem_type *type)\n{\n\tpte_t *pte = early_pte_alloc(pmd, addr, type->prot_l1);\n\tdo {\n\t\tset_pte_ext(pte, pfn_pte(pfn, __pgprot(type->prot_pte)), 0);\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n}\n```\n\nset_pte_ext()函数，根据配置情况最终指向的是cpu_v7_set_pte_ext()\n```c\n/*\n *\tcpu_v7_set_pte_ext(ptep, pte)\n *\n *\tSet a level 2 translation table entry.\n *\n *\t- ptep  - pointer to level 2 translation table entry\n *\t\t  (hardware version is stored at +2048 bytes)\n *\t- pte   - PTE value to store\n *\t- ext\t- value for extended PTE bits\n */\nENTRY(cpu_v7_set_pte_ext)\n#ifdef CONFIG_MMU\n\tstr\tr1, [r0]\t\t\t@ linux version\n\n\tbic\tr3, r1, #0x000003f0\n\tbic\tr3, r3, #PTE_TYPE_MASK\n\torr\tr3, r3, r2\n\torr\tr3, r3, #PTE_EXT_AP0 | 2\n\n\ttst\tr1, #1 << 4\n\torrne\tr3, r3, #PTE_EXT_TEX(1)\n\n\teor\tr1, r1, #L_PTE_DIRTY\n\ttst\tr1, #L_PTE_RDONLY | L_PTE_DIRTY\n\torrne\tr3, r3, #PTE_EXT_APX\n\n\ttst\tr1, #L_PTE_USER\n\torrne\tr3, r3, #PTE_EXT_AP1\n\n\ttst\tr1, #L_PTE_XN\n\torrne\tr3, r3, #PTE_EXT_XN\n\n\ttst\tr1, #L_PTE_YOUNG\n\ttstne\tr1, #L_PTE_VALID\n\teorne\tr1, r1, #L_PTE_NONE\n\ttstne\tr1, #L_PTE_NONE\n\tmoveq\tr3, #0\n\n ARM(\tstr\tr3, [r0, #2048]! )\n THUMB(\tadd\tr0, r0, #2048 )\n THUMB(\tstr\tr3, [r0] )\n\tALT_SMP(W(nop))\n\tALT_UP (mcr\tp15, 0, r0, c7, c10, 1)\t\t@ flush_pte\n#endif\n\tbx\tlr\nENDPROC(cpu_v7_set_pte_ext)\n```\n\n### 2.3. 动态映射\n#### 2.3.1. virtual memory data struct\nlinux/include/linux/mm_types.h\n\n```c\nstruct mm_struct {\n\tstruct vm_area_struct *mmap;\t\t/* list of VMAs */\n\t\n#ifdef CONFIG_MMU\n\tunsigned long (*get_unmapped_area) (struct file *filp,\n\t\t\t\tunsigned long addr, unsigned long len,\n\t\t\t\tunsigned long pgoff, unsigned long flags);\n#endif\n\tunsigned long mmap_base;\t\t/* base of mmap area */\n\t\n\tunsigned long task_size;\t\t/* size of task vm space */\n\tunsigned long highest_vm_end;\t\t/* highest vma end address */\n\tpgd_t * pgd;\n\t\n\tatomic_long_t nr_ptes;\t\t\t/* Page table pages */\n\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long start_brk, brk, start_stack;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\n\t/* Architecture-specific MM context */\n\tmm_context_t context;\n\t...\n}\n\nstruct vm_area_struct {\n\tunsigned long vm_start;\t\t/* Our start address within vm_mm. */\n\tunsigned long vm_end;\t\t/* The first byte after our end address\n\t\t\t\t\t   within vm_mm. */\n\t\t\t\t\t   \n\tstruct vm_area_struct *vm_next, *vm_prev;\n\n\t/* Second cache line starts here. */\n\tstruct mm_struct *vm_mm;\t/* The address space we belong to. */\n\tpgprot_t vm_page_prot;\t\t/* Access permissions of this VMA. */\n\tunsigned long vm_flags;\t\t/* Flags, see mm.h. */\n\n\t/* Information about our backing store: */\n\tunsigned long vm_pgoff;\t\t/* Offset (within vm_file) in PAGE_SIZE\n\t\t\t\t\t   units, *not* PAGE_CACHE_SIZE */\n};\n```\n我们在kernel 中想要访问当前进程的mm_struct，可以使用<font color=red>current</font>\n```c\n\tstruct mm_struct *mm = current->mm;\n```\n\n另外，我们可以访问 /proc/<pid>/maps 得到某一进程的内存区域。（/proc/self 始终指向正在运行的进程）\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/proc_self_maps.png)\n\n字段 | 含义\n:-: | :-\n00400000-0040b000 | vma->vm_start ~ vma->vm_end\nr-xp | vma->vm_flags\n00000000 | vma->vm_pgoff\n08:01 | 主从设备号\n1171031 | 设备节点inode 值\nbin/cat | 设备节点名字\n\n#### 2.3.2. memory mapping\n在使用high mem addr时，我们需要如下函数：\n```c\nvoid *kmap(struct page * page)\nvoid kunmap(struct page *page)\n\nvoid *kmap_atomic(struct page * page)\nvoid kumap_atomic(struct page *page)\n```\n如果* page 是low mem addr 直接返回，反之，是high mem addr kmap()在内核专用的空间创建特殊的映射。kmap() 可能会睡眠，而kmap_atomic() 会进行原子操作，不允许sleep.\n\nkernel 映射函数 __remap_pfn_range()__\n\n__注意:__\n__<font color=red> 如果使用的high mem， vmalloc() 分配的空间，我们只能PAGE_SIZE 的进行映射，他们本身逻辑连续，而物理地址非连续。</font>__\n\n```c\nint remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,\n\t\t    unsigned long pfn, unsigned long size, pgprot_t prot)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, pgd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}\n```\n调用关系如下：\nremap_pfn_range()->  \n&nbsp;&nbsp;remap_pud_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;remap_pmd_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remap_pte_range()\n\n```c\n/*\n * maps a range of physical memory into the requested pages. the old\n * mappings are removed. any references to nonexistent pages results\n * in null mappings (currently treated as \"copy-on-access\")\n */\nstatic int remap_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tpte = pte_alloc_map_lock(mm, pmd, addr, &ptl);\n\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\n\tpte_unmap_unlock(pte - 1, ptl);\n\treturn 0;\n}\n\nstatic inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pteval)\n{\n\tunsigned long ext = 0;\n\n\tif (addr < TASK_SIZE && pte_valid_user(pteval)) {\n\t\tif (!pte_special(pteval))\n\t\t\t__sync_icache_dcache(pteval);\n\t\text |= PTE_EXT_NG;\n\t}\n\n\tset_pte_ext(ptep, pteval, ext);\n}\n```\n可以看到与上面的静态映射其实也是差不多的，最终也会调用到set_pte_ext() -> cpu_v7_set_pte_ext() 函数。\n\n__<font color=red>因此，映射的本质都是重新建立页表2-level 或 3-level，并刷新页表</font>__\n\n#### 2.3.3. io memory mapping\nioremap将一个IO地址空间映射到内核的虚拟地址空间上去，便于访问。[ioremap 百度百科](https://baike.baidu.com/item/ioremap/994207)\n\n```c\n#define ioremap(cookie,size)\t\t__arm_ioremap((cookie), (size), MT_DEVICE)\n#define ioremap_nocache(cookie,size)\t__arm_ioremap((cookie), (size), MT_DEVICE)\n#define ioremap_cache(cookie,size)\t__arm_ioremap((cookie), (size), MT_DEVICE_CACHED)\n#define ioremap_wc(cookie,size)\t\t__arm_ioremap((cookie), (size), MT_DEVICE_WC)\n#define iounmap\t\t\t\t__arm_iounmap\n```\n&nbsp;&nbsp;ioremap()->  \n&nbsp;&nbsp;&nbsp;&nbsp;__arm_ioremap()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__arm_ioremap_caller()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__arm_ioremap_pfn_caller()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__ioremap_page_range() ->__  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_page_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pud_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pmd_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pte_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_at()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_ext()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_set_pte_ext()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_v7_set_pte_ext() （linux/arm/arm/mm/proc-v7-2level.S）\n\n可以看见，大致与上面的静态映射，动态映射是相同的， 只是不同点在于__arm_ioremap_pfn_caller（） 函数中调用get_vm_area_caller（）进行vm_area 空间的申请。\n\n```c\nvoid __iomem * __arm_ioremap_pfn_caller(unsigned long pfn,\n\tunsigned long offset, size_t size, unsigned int mtype, void *caller)\n{\n\tconst struct mem_type *type;\n\tint err;\n\tunsigned long addr;\n\tstruct vm_struct *area;\n\tphys_addr_t paddr = __pfn_to_phys(pfn);\n\n#ifndef CONFIG_ARM_LPAE\n\t/*\n\t * High mappings must be supersection aligned\n\t */\n\tif (pfn >= 0x100000 && (paddr & ~SUPERSECTION_MASK))\n\t\treturn NULL;\n#endif\n\n\ttype = get_mem_type(mtype);\n\tif (!type)\n\t\treturn NULL;\n\n\tsize = PAGE_ALIGN(offset + size);\n\n\t/*\n\t * Try to reuse one of the static mapping whenever possible.\n\t */\n\tif (size && !(sizeof(phys_addr_t) == 4 && pfn >= 0x100000)) {\n\t\tstruct static_vm *svm;\n\n\t\tsvm = find_static_vm_paddr(paddr, size, mtype);\n\t\tif (svm) {\n\t\t\taddr = (unsigned long)svm->vm.addr;\n\t\t\taddr += paddr - svm->vm.phys_addr;\n\t\t\treturn (void __iomem *) (offset + addr);\n\t\t}\n\t}\n\n\tarea = get_vm_area_caller(size, VM_IOREMAP, caller);\n \n \taddr = (unsigned long)area->addr;\n\tarea->phys_addr = paddr;\n\n\terr = ioremap_page_range(addr, addr + size, paddr,\n\t\t\t\t __pgprot(type->prot_pte));\n\n\tflush_cache_vmap(addr, addr + size);\n\treturn (void __iomem *) (offset + addr);\n}\n\n```\n\nget_vm_area_caller（）函数可以看见是从 VMALLOC_START ~ VMALLOC_END区域内分配一个空间。 \n\n__注:__\n由于我们的ioremap（）是将IO 连续的物理地址映射成Kernel 能访问的虚拟地址， 所以本身物理地址的连续性是能保证的。vmalloc.c 中的核心函数get_vm_area_caller（）详细分析可见最后的参看资料。\n```c\nstruct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\tconst void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);\n}\n```\n\n```c\nstatic int ioremap_pte_range(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, phys_addr_t phys_addr, pgprot_t prot)\n{\n\tpte_t *pte;\n\tu64 pfn;\n\n\tpfn = phys_addr >> PAGE_SHIFT;\n\tpte = pte_alloc_kernel(pmd, addr);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(&init_mm, addr, pte, pfn_pte(pfn, prot));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\treturn 0;\n}\n```\n\nio_remap_page_range() 如果没有定义，则该函数是等效于**remap_pfn_range()**\n```c\n#ifndef io_remap_pfn_range\n#define io_remap_pfn_range remap_pfn_range\n#endif\n```\n\n#### 2.3.4. dma memory mapping\n参见之前文章 -> [DMA memory mapping](https://jshell07.github.io/2019/06/28/kernel-dma-mem/)\n\n## 参看资料\n__basic__\n[虚拟地址映射机制--动态、静态](https://www.cnblogs.com/embeded-linux/p/11108930.html)\n\n[Linux的mmap内存映射机制解析](https://blog.csdn.net/zqixiao_09/article/details/51088478)\n\n[ARM MMU页表框架](https://blog.csdn.net/vichie2008/article/details/48274967)\n\n[Linux内存管理 (2)页表的映射过程](https://www.cnblogs.com/arnoldlu/p/8087022.html)\n\n__memory mapping__\n[内存映射函数remap_pfn_range学习——示例分析（1）](https://www.cnblogs.com/pengdonglin137/p/8149859.html)\n\n[内存映射函数remap_pfn_range学习——示例分析（2）](https://www.cnblogs.com/pengdonglin137/p/8150462.html)\n\n[内存映射函数remap_pfn_range学习——代码分析（3）](https://www.cnblogs.com/pengdonglin137/p/8150981.html)\n\n__ioremap__\n[Linux 字符设备驱动开发基础（五）—— ioremap() 函数解析](https://blog.csdn.net/zqixiao_09/article/details/50859505)\n\n__vmalloc__\n[Linux高端内存映射(下)](https://blog.csdn.net/vanbreaker/article/details/7591844)\n\n[高端内存映射之vmalloc分配内存中不连续的页--Linux内存管理(十九)](https://cloud.tencent.com/developer/article/1381130)","source":"_posts/kernel-virtual-addr-map.md","raw":"---\ntitle: kernel_virtual_addr_map\ndate: 2019-07-12 10:51:28\ntags:\n    - memory\n    - kernel\ncategories:\n    - memory\n---\n\n## 1. User space\nmmap, munmap - map or unmap files or devices into memory. \n将文件或者设备与内存映射起来。\n\n```c\n#include <sys/mman.h>\n\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\nint munmap(void *addr, size_t length);\n\n\n#include <unistd.h>\nint getpagesize(void);\n\n```\n<!--more-->\n\n## 2. Kernel space\n### 2.1. 静态映射\nstart_kernel() ->  \n&nbsp;&nbsp;setup_arch() ->  \n&nbsp;&nbsp;&nbsp;&nbsp; paging_init() ->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devicemaps_init(const struct machine_desc *mdesc) ->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdesc->map_io()\n\n涉及到的结构体__struct machine_desc__\n```c\nstruct machine_desc {\n\tunsigned int\t\tnr;\t\t/* architecture number\t*/\n\tconst char\t\t*name;\t\t/* architecture \n\n\tunsigned int\t\tnr_irqs;\t/* number of IRQs */\n\n#ifdef CONFIG_ZONE_DMA\n\tphys_addr_t\t\tdma_zone_size;\t/* size of DMA-able area */\n#endif\n\tvoid\t\t\t(*init_meminfo)(void);\n\tvoid\t\t\t(*reserve)(void);/* reserve mem blocks\t*/\n\tvoid\t\t\t(*map_io)(void);/* IO mapping function\t*/\n\tvoid\t\t\t(*init_early)(void);\n\tvoid\t\t\t(*init_irq)(void);\n\tvoid\t\t\t(*init_time)(void);\n\tvoid\t\t\t(*init_machine)(void);\n\tvoid\t\t\t(*init_late)(void);\n#ifdef CONFIG_MULTI_IRQ_HANDLER\n\tvoid\t\t\t(*handle_irq)(struct pt_regs *);\n#endif\n\tvoid\t\t\t(*restart)(enum reboot_mode, const char *);\n};\n\nstruct map_desc {\n\tunsigned long virtual;\n\tunsigned long pfn;\n\tunsigned long length;\n\tunsigned int type;\n};\n```\n例如我们在arch/arm/mach-s3c24xx/mach-smdk2440.c\nsmdk2440_map_io() ->  \n&nbsp;&nbsp;iotable_init(mach_desc, size)\n\n```c\nstatic struct map_desc smdk2440_iodesc[] __initdata = {\n\t{\n\t\t.virtual\t= (u32)S3C24XX_VA_ISA_WORD,\n\t\t.pfn\t\t= __phys_to_pfn(S3C2410_CS2),\n\t\t.length\t\t= 0x10000,\n\t\t.type\t\t= MT_DEVICE,\n\t}, \n};\n\nMACHINE_START(S3C2440, \"SMDK2440\")\n\t/* Maintainer: Ben Dooks <ben-linux@fluff.org> */\n\t.atag_offset\t= 0x100,\n\n\t.init_irq\t= s3c2440_init_irq,\n\t.map_io\t\t= smdk2440_map_io,\n\t.init_machine\t= smdk2440_machine_init,\n\t.init_time\t= smdk2440_init_time,\nMACHINE_END\n```\n在这一步定义了物理与虚拟地址之间的映射关系，一旦编译完成就不会修改，<font color=red> 静态编译常用于不容易变动的物理地址与虚拟地址之间的映射，例如寄存器的映射。</font>\n\n### 2.2. 页表创建\nLinux下的页表映射分为两种，一是Linux自身的页表映射，另一种是ARM32 MMU硬件的映射。这样是为了更大的灵活性，可以映射Linux bits 到 硬件tables 上，例如有YOUNG, DIRTY bits.\n\n参见 linux/arch/arm/include/asm/pagetable-2level.h 注释：\n```c\n/*\n * Hardware-wise, we have a two level page table structure, where the first\n * level has 4096 entries, and the second level has 256 entries.  Each entry\n * is one 32-bit word.  Most of the bits in the second level entry are used\n * by hardware, and there aren't any \"accessed\" and \"dirty\" bits.\n *\n * Linux on the other hand has a three level page table structure, which can\n * be wrapped to fit a two level page table structure easily - using the PGD\n * and PTE only.  However, Linux also expects one \"PTE\" table per page, and\n * at least a \"dirty\" bit.\n *\n * Therefore, we tweak the implementation slightly - we tell Linux that we\n * have 2048 entries in the first level, each of which is 8 bytes (iow, two\n * hardware pointers to the second level.)  The second level contains two\n * hardware PTE tables arranged contiguously, preceded by Linux versions\n * which contain the state information Linux needs.  We, therefore, end up\n * with 512 entries in the \"PTE\" level.\n *\n * This leads to the page tables having the following layout:\n *\n *    pgd             pte\n * |        |\n * +--------+\n * |        |       +------------+ +0\n * +- - - - +       | Linux pt 0 |\n * |        |       +------------+ +1024\n * +--------+ +0    | Linux pt 1 |\n * |        |-----> +------------+ +2048\n * +- - - - + +4    |  h/w pt 0  |\n * |        |-----> +------------+ +3072\n * +--------+ +8    |  h/w pt 1  |\n * |        |       +------------+ +4096\n *\n * See L_PTE_xxx below for definitions of bits in the \"Linux pt\", and\n * PTE_xxx for definitions of bits appearing in the \"h/w pt\".\n```\n\n32bit的Linux采用三级映射：PGD-->PMD-->PTE，64bit的Linux采用四级映射：PGD-->PUD-->PMD-->PTE，多了个PUD\n\n>PGD - Page Global Directory\nPUD - Page Upper Directory\nPMD - Page Middle Directory\nPTE - Page Table Entry。\n\n在ARM32 Linux采用两层映射，省略了PMD，除非在定义了CONFIG_ARM_LPAE才会使用3级映射。\n\n![页表转换过程](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/page_to_addr.png)\n\n![1 level page table](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/1level_page_table.png)\n\n![2 level page table](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/2level_page_table.png)\n\n更多可以参看<<ARM ® Architecture Reference Manual -- ARMv7-A and ARMv7-R edition>> (ARM DDI 0406C.c (ID051414)) B3 Virtual Memory System Architecture (VMSA)\n\niotable_init()->  \n&nbsp;&nbsp;create_mapping()->  \n&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pud()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pmd()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pte()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_ext->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_set_pte_ext()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_v7_set_pte_ext() （linux/arm/arm/mm/proc-v7-2level.S）\n\n```c\nvoid __init create_mapping(struct map_desc *md)\n{\n\t...\n\tpgd = pgd_offset_k(addr);\n\tend = addr + length;\n\tdo {\n\t\tunsigned long next = pgd_addr_end(addr, end);\n\n\t\talloc_init_pud(pgd, addr, next, phys, type);\n\n\t\tphys += next - addr;\n\t\taddr = next;\n\t} while (pgd++, addr != end);\t\n}\n\nstatic void __init alloc_init_pte(pmd_t *pmd, unsigned long addr,\n\t\t\t\t  unsigned long end, unsigned long pfn,\n\t\t\t\t  const struct mem_type *type)\n{\n\tpte_t *pte = early_pte_alloc(pmd, addr, type->prot_l1);\n\tdo {\n\t\tset_pte_ext(pte, pfn_pte(pfn, __pgprot(type->prot_pte)), 0);\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n}\n```\n\nset_pte_ext()函数，根据配置情况最终指向的是cpu_v7_set_pte_ext()\n```c\n/*\n *\tcpu_v7_set_pte_ext(ptep, pte)\n *\n *\tSet a level 2 translation table entry.\n *\n *\t- ptep  - pointer to level 2 translation table entry\n *\t\t  (hardware version is stored at +2048 bytes)\n *\t- pte   - PTE value to store\n *\t- ext\t- value for extended PTE bits\n */\nENTRY(cpu_v7_set_pte_ext)\n#ifdef CONFIG_MMU\n\tstr\tr1, [r0]\t\t\t@ linux version\n\n\tbic\tr3, r1, #0x000003f0\n\tbic\tr3, r3, #PTE_TYPE_MASK\n\torr\tr3, r3, r2\n\torr\tr3, r3, #PTE_EXT_AP0 | 2\n\n\ttst\tr1, #1 << 4\n\torrne\tr3, r3, #PTE_EXT_TEX(1)\n\n\teor\tr1, r1, #L_PTE_DIRTY\n\ttst\tr1, #L_PTE_RDONLY | L_PTE_DIRTY\n\torrne\tr3, r3, #PTE_EXT_APX\n\n\ttst\tr1, #L_PTE_USER\n\torrne\tr3, r3, #PTE_EXT_AP1\n\n\ttst\tr1, #L_PTE_XN\n\torrne\tr3, r3, #PTE_EXT_XN\n\n\ttst\tr1, #L_PTE_YOUNG\n\ttstne\tr1, #L_PTE_VALID\n\teorne\tr1, r1, #L_PTE_NONE\n\ttstne\tr1, #L_PTE_NONE\n\tmoveq\tr3, #0\n\n ARM(\tstr\tr3, [r0, #2048]! )\n THUMB(\tadd\tr0, r0, #2048 )\n THUMB(\tstr\tr3, [r0] )\n\tALT_SMP(W(nop))\n\tALT_UP (mcr\tp15, 0, r0, c7, c10, 1)\t\t@ flush_pte\n#endif\n\tbx\tlr\nENDPROC(cpu_v7_set_pte_ext)\n```\n\n### 2.3. 动态映射\n#### 2.3.1. virtual memory data struct\nlinux/include/linux/mm_types.h\n\n```c\nstruct mm_struct {\n\tstruct vm_area_struct *mmap;\t\t/* list of VMAs */\n\t\n#ifdef CONFIG_MMU\n\tunsigned long (*get_unmapped_area) (struct file *filp,\n\t\t\t\tunsigned long addr, unsigned long len,\n\t\t\t\tunsigned long pgoff, unsigned long flags);\n#endif\n\tunsigned long mmap_base;\t\t/* base of mmap area */\n\t\n\tunsigned long task_size;\t\t/* size of task vm space */\n\tunsigned long highest_vm_end;\t\t/* highest vma end address */\n\tpgd_t * pgd;\n\t\n\tatomic_long_t nr_ptes;\t\t\t/* Page table pages */\n\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long start_brk, brk, start_stack;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\n\t/* Architecture-specific MM context */\n\tmm_context_t context;\n\t...\n}\n\nstruct vm_area_struct {\n\tunsigned long vm_start;\t\t/* Our start address within vm_mm. */\n\tunsigned long vm_end;\t\t/* The first byte after our end address\n\t\t\t\t\t   within vm_mm. */\n\t\t\t\t\t   \n\tstruct vm_area_struct *vm_next, *vm_prev;\n\n\t/* Second cache line starts here. */\n\tstruct mm_struct *vm_mm;\t/* The address space we belong to. */\n\tpgprot_t vm_page_prot;\t\t/* Access permissions of this VMA. */\n\tunsigned long vm_flags;\t\t/* Flags, see mm.h. */\n\n\t/* Information about our backing store: */\n\tunsigned long vm_pgoff;\t\t/* Offset (within vm_file) in PAGE_SIZE\n\t\t\t\t\t   units, *not* PAGE_CACHE_SIZE */\n};\n```\n我们在kernel 中想要访问当前进程的mm_struct，可以使用<font color=red>current</font>\n```c\n\tstruct mm_struct *mm = current->mm;\n```\n\n另外，我们可以访问 /proc/<pid>/maps 得到某一进程的内存区域。（/proc/self 始终指向正在运行的进程）\n\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/proc_self_maps.png)\n\n字段 | 含义\n:-: | :-\n00400000-0040b000 | vma->vm_start ~ vma->vm_end\nr-xp | vma->vm_flags\n00000000 | vma->vm_pgoff\n08:01 | 主从设备号\n1171031 | 设备节点inode 值\nbin/cat | 设备节点名字\n\n#### 2.3.2. memory mapping\n在使用high mem addr时，我们需要如下函数：\n```c\nvoid *kmap(struct page * page)\nvoid kunmap(struct page *page)\n\nvoid *kmap_atomic(struct page * page)\nvoid kumap_atomic(struct page *page)\n```\n如果* page 是low mem addr 直接返回，反之，是high mem addr kmap()在内核专用的空间创建特殊的映射。kmap() 可能会睡眠，而kmap_atomic() 会进行原子操作，不允许sleep.\n\nkernel 映射函数 __remap_pfn_range()__\n\n__注意:__\n__<font color=red> 如果使用的high mem， vmalloc() 分配的空间，我们只能PAGE_SIZE 的进行映射，他们本身逻辑连续，而物理地址非连续。</font>__\n\n```c\nint remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,\n\t\t    unsigned long pfn, unsigned long size, pgprot_t prot)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, pgd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}\n```\n调用关系如下：\nremap_pfn_range()->  \n&nbsp;&nbsp;remap_pud_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;remap_pmd_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remap_pte_range()\n\n```c\n/*\n * maps a range of physical memory into the requested pages. the old\n * mappings are removed. any references to nonexistent pages results\n * in null mappings (currently treated as \"copy-on-access\")\n */\nstatic int remap_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tpte = pte_alloc_map_lock(mm, pmd, addr, &ptl);\n\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\n\tpte_unmap_unlock(pte - 1, ptl);\n\treturn 0;\n}\n\nstatic inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pteval)\n{\n\tunsigned long ext = 0;\n\n\tif (addr < TASK_SIZE && pte_valid_user(pteval)) {\n\t\tif (!pte_special(pteval))\n\t\t\t__sync_icache_dcache(pteval);\n\t\text |= PTE_EXT_NG;\n\t}\n\n\tset_pte_ext(ptep, pteval, ext);\n}\n```\n可以看到与上面的静态映射其实也是差不多的，最终也会调用到set_pte_ext() -> cpu_v7_set_pte_ext() 函数。\n\n__<font color=red>因此，映射的本质都是重新建立页表2-level 或 3-level，并刷新页表</font>__\n\n#### 2.3.3. io memory mapping\nioremap将一个IO地址空间映射到内核的虚拟地址空间上去，便于访问。[ioremap 百度百科](https://baike.baidu.com/item/ioremap/994207)\n\n```c\n#define ioremap(cookie,size)\t\t__arm_ioremap((cookie), (size), MT_DEVICE)\n#define ioremap_nocache(cookie,size)\t__arm_ioremap((cookie), (size), MT_DEVICE)\n#define ioremap_cache(cookie,size)\t__arm_ioremap((cookie), (size), MT_DEVICE_CACHED)\n#define ioremap_wc(cookie,size)\t\t__arm_ioremap((cookie), (size), MT_DEVICE_WC)\n#define iounmap\t\t\t\t__arm_iounmap\n```\n&nbsp;&nbsp;ioremap()->  \n&nbsp;&nbsp;&nbsp;&nbsp;__arm_ioremap()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__arm_ioremap_caller()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__arm_ioremap_pfn_caller()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__ioremap_page_range() ->__  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_page_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pud_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pmd_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pte_range()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_at()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_ext()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_set_pte_ext()->  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_v7_set_pte_ext() （linux/arm/arm/mm/proc-v7-2level.S）\n\n可以看见，大致与上面的静态映射，动态映射是相同的， 只是不同点在于__arm_ioremap_pfn_caller（） 函数中调用get_vm_area_caller（）进行vm_area 空间的申请。\n\n```c\nvoid __iomem * __arm_ioremap_pfn_caller(unsigned long pfn,\n\tunsigned long offset, size_t size, unsigned int mtype, void *caller)\n{\n\tconst struct mem_type *type;\n\tint err;\n\tunsigned long addr;\n\tstruct vm_struct *area;\n\tphys_addr_t paddr = __pfn_to_phys(pfn);\n\n#ifndef CONFIG_ARM_LPAE\n\t/*\n\t * High mappings must be supersection aligned\n\t */\n\tif (pfn >= 0x100000 && (paddr & ~SUPERSECTION_MASK))\n\t\treturn NULL;\n#endif\n\n\ttype = get_mem_type(mtype);\n\tif (!type)\n\t\treturn NULL;\n\n\tsize = PAGE_ALIGN(offset + size);\n\n\t/*\n\t * Try to reuse one of the static mapping whenever possible.\n\t */\n\tif (size && !(sizeof(phys_addr_t) == 4 && pfn >= 0x100000)) {\n\t\tstruct static_vm *svm;\n\n\t\tsvm = find_static_vm_paddr(paddr, size, mtype);\n\t\tif (svm) {\n\t\t\taddr = (unsigned long)svm->vm.addr;\n\t\t\taddr += paddr - svm->vm.phys_addr;\n\t\t\treturn (void __iomem *) (offset + addr);\n\t\t}\n\t}\n\n\tarea = get_vm_area_caller(size, VM_IOREMAP, caller);\n \n \taddr = (unsigned long)area->addr;\n\tarea->phys_addr = paddr;\n\n\terr = ioremap_page_range(addr, addr + size, paddr,\n\t\t\t\t __pgprot(type->prot_pte));\n\n\tflush_cache_vmap(addr, addr + size);\n\treturn (void __iomem *) (offset + addr);\n}\n\n```\n\nget_vm_area_caller（）函数可以看见是从 VMALLOC_START ~ VMALLOC_END区域内分配一个空间。 \n\n__注:__\n由于我们的ioremap（）是将IO 连续的物理地址映射成Kernel 能访问的虚拟地址， 所以本身物理地址的连续性是能保证的。vmalloc.c 中的核心函数get_vm_area_caller（）详细分析可见最后的参看资料。\n```c\nstruct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\tconst void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);\n}\n```\n\n```c\nstatic int ioremap_pte_range(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, phys_addr_t phys_addr, pgprot_t prot)\n{\n\tpte_t *pte;\n\tu64 pfn;\n\n\tpfn = phys_addr >> PAGE_SHIFT;\n\tpte = pte_alloc_kernel(pmd, addr);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(&init_mm, addr, pte, pfn_pte(pfn, prot));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\treturn 0;\n}\n```\n\nio_remap_page_range() 如果没有定义，则该函数是等效于**remap_pfn_range()**\n```c\n#ifndef io_remap_pfn_range\n#define io_remap_pfn_range remap_pfn_range\n#endif\n```\n\n#### 2.3.4. dma memory mapping\n参见之前文章 -> [DMA memory mapping](https://jshell07.github.io/2019/06/28/kernel-dma-mem/)\n\n## 参看资料\n__basic__\n[虚拟地址映射机制--动态、静态](https://www.cnblogs.com/embeded-linux/p/11108930.html)\n\n[Linux的mmap内存映射机制解析](https://blog.csdn.net/zqixiao_09/article/details/51088478)\n\n[ARM MMU页表框架](https://blog.csdn.net/vichie2008/article/details/48274967)\n\n[Linux内存管理 (2)页表的映射过程](https://www.cnblogs.com/arnoldlu/p/8087022.html)\n\n__memory mapping__\n[内存映射函数remap_pfn_range学习——示例分析（1）](https://www.cnblogs.com/pengdonglin137/p/8149859.html)\n\n[内存映射函数remap_pfn_range学习——示例分析（2）](https://www.cnblogs.com/pengdonglin137/p/8150462.html)\n\n[内存映射函数remap_pfn_range学习——代码分析（3）](https://www.cnblogs.com/pengdonglin137/p/8150981.html)\n\n__ioremap__\n[Linux 字符设备驱动开发基础（五）—— ioremap() 函数解析](https://blog.csdn.net/zqixiao_09/article/details/50859505)\n\n__vmalloc__\n[Linux高端内存映射(下)](https://blog.csdn.net/vanbreaker/article/details/7591844)\n\n[高端内存映射之vmalloc分配内存中不连续的页--Linux内存管理(十九)](https://cloud.tencent.com/developer/article/1381130)","slug":"kernel-virtual-addr-map","published":1,"updated":"2019-08-06T12:12:42.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qp0035zkgrg66wih32","content":"<h2 id=\"1-User-space\"><a href=\"#1-User-space\" class=\"headerlink\" title=\"1. User space\"></a>1. User space</h2><p>mmap, munmap - map or unmap files or devices into memory.<br>将文件或者设备与内存映射起来。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> prot, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getpagesize</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"2-Kernel-space\"><a href=\"#2-Kernel-space\" class=\"headerlink\" title=\"2. Kernel space\"></a>2. Kernel space</h2><h3 id=\"2-1-静态映射\"><a href=\"#2-1-静态映射\" class=\"headerlink\" title=\"2.1. 静态映射\"></a>2.1. 静态映射</h3><p>start_kernel() -&gt;<br>&nbsp;&nbsp;setup_arch() -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp; paging_init() -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devicemaps_init(const struct machine_desc *mdesc) -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdesc-&gt;map_io()</p>\n<p>涉及到的结构体<strong>struct machine_desc</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">machine_desc</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\t\tnr;\t\t<span class=\"comment\">/* architecture number\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t\t*name;\t\t<span class=\"comment\">/* architecture </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tunsigned int\t\tnr_irqs;\t/* number of IRQs */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class=\"line\">\t<span class=\"keyword\">phys_addr_t</span>\t\tdma_zone_size;\t<span class=\"comment\">/* size of DMA-able area */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_meminfo)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*reserve)(<span class=\"keyword\">void</span>);<span class=\"comment\">/* reserve mem blocks\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*map_io)(<span class=\"keyword\">void</span>);<span class=\"comment\">/* IO mapping function\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_early)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_irq)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_time)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_machine)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_late)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_MULTI_IRQ_HANDLER</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*handle_irq)(struct pt_regs *);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*restart)(<span class=\"keyword\">enum</span> reboot_mode, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">map_desc</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">virtual</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> type;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>例如我们在arch/arm/mach-s3c24xx/mach-smdk2440.c<br>smdk2440_map_io() -&gt;<br>&nbsp;&nbsp;iotable_init(mach_desc, size)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">map_desc</span> <span class=\"title\">smdk2440_iodesc</span>[] __<span class=\"title\">initdata</span> = &#123;</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t.<span class=\"keyword\">virtual</span>\t= (u32)S3C24XX_VA_ISA_WORD,</span><br><span class=\"line\">\t\t.pfn\t\t= __phys_to_pfn(S3C2410_CS2),</span><br><span class=\"line\">\t\t.length\t\t= <span class=\"number\">0x10000</span>,</span><br><span class=\"line\">\t\t.type\t\t= MT_DEVICE,</span><br><span class=\"line\">\t&#125;, </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MACHINE_START(S3C2440, <span class=\"string\">\"SMDK2440\"</span>)</span><br><span class=\"line\">\t<span class=\"comment\">/* Maintainer: Ben Dooks &lt;ben-linux@fluff.org&gt; */</span></span><br><span class=\"line\">\t.atag_offset\t= <span class=\"number\">0x100</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\t.init_irq\t= s3c2440_init_irq,</span><br><span class=\"line\">\t.map_io\t\t= smdk2440_map_io,</span><br><span class=\"line\">\t.init_machine\t= smdk2440_machine_init,</span><br><span class=\"line\">\t.init_time\t= smdk2440_init_time,</span><br><span class=\"line\">MACHINE_END</span><br></pre></td></tr></table></figure>\n<p>在这一步定义了物理与虚拟地址之间的映射关系，一旦编译完成就不会修改，<font color=\"red\"> 静态编译常用于不容易变动的物理地址与虚拟地址之间的映射，例如寄存器的映射。</font></p>\n<h3 id=\"2-2-页表创建\"><a href=\"#2-2-页表创建\" class=\"headerlink\" title=\"2.2. 页表创建\"></a>2.2. 页表创建</h3><p>Linux下的页表映射分为两种，一是Linux自身的页表映射，另一种是ARM32 MMU硬件的映射。这样是为了更大的灵活性，可以映射Linux bits 到 硬件tables 上，例如有YOUNG, DIRTY bits.</p>\n<p>参见 linux/arch/arm/include/asm/pagetable-2level.h 注释：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Hardware-wise, we have a two level page table structure, where the first</span></span><br><span class=\"line\"><span class=\"comment\"> * level has 4096 entries, and the second level has 256 entries.  Each entry</span></span><br><span class=\"line\"><span class=\"comment\"> * is one 32-bit word.  Most of the bits in the second level entry are used</span></span><br><span class=\"line\"><span class=\"comment\"> * by hardware, and there aren't any \"accessed\" and \"dirty\" bits.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Linux on the other hand has a three level page table structure, which can</span></span><br><span class=\"line\"><span class=\"comment\"> * be wrapped to fit a two level page table structure easily - using the PGD</span></span><br><span class=\"line\"><span class=\"comment\"> * and PTE only.  However, Linux also expects one \"PTE\" table per page, and</span></span><br><span class=\"line\"><span class=\"comment\"> * at least a \"dirty\" bit.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Therefore, we tweak the implementation slightly - we tell Linux that we</span></span><br><span class=\"line\"><span class=\"comment\"> * have 2048 entries in the first level, each of which is 8 bytes (iow, two</span></span><br><span class=\"line\"><span class=\"comment\"> * hardware pointers to the second level.)  The second level contains two</span></span><br><span class=\"line\"><span class=\"comment\"> * hardware PTE tables arranged contiguously, preceded by Linux versions</span></span><br><span class=\"line\"><span class=\"comment\"> * which contain the state information Linux needs.  We, therefore, end up</span></span><br><span class=\"line\"><span class=\"comment\"> * with 512 entries in the \"PTE\" level.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This leads to the page tables having the following layout:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *    pgd             pte</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |</span></span><br><span class=\"line\"><span class=\"comment\"> * +--------+</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |       +------------+ +0</span></span><br><span class=\"line\"><span class=\"comment\"> * +- - - - +       | Linux pt 0 |</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |       +------------+ +1024</span></span><br><span class=\"line\"><span class=\"comment\"> * +--------+ +0    | Linux pt 1 |</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |-----&gt; +------------+ +2048</span></span><br><span class=\"line\"><span class=\"comment\"> * +- - - - + +4    |  h/w pt 0  |</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |-----&gt; +------------+ +3072</span></span><br><span class=\"line\"><span class=\"comment\"> * +--------+ +8    |  h/w pt 1  |</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |       +------------+ +4096</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * See L_PTE_xxx below for definitions of bits in the \"Linux pt\", and</span></span><br><span class=\"line\"><span class=\"comment\"> * PTE_xxx for definitions of bits appearing in the \"h/w pt\".</span></span><br></pre></td></tr></table></figure></p>\n<p>32bit的Linux采用三级映射：PGD–&gt;PMD–&gt;PTE，64bit的Linux采用四级映射：PGD–&gt;PUD–&gt;PMD–&gt;PTE，多了个PUD</p>\n<blockquote>\n<p>PGD - Page Global Directory<br>PUD - Page Upper Directory<br>PMD - Page Middle Directory<br>PTE - Page Table Entry。</p>\n</blockquote>\n<p>在ARM32 Linux采用两层映射，省略了PMD，除非在定义了CONFIG_ARM_LPAE才会使用3级映射。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/page_to_addr.png\" alt=\"页表转换过程\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/1level_page_table.png\" alt=\"1 level page table\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/2level_page_table.png\" alt=\"2 level page table\"></p>\n<p>更多可以参看&lt;<arm ®=\"\" architecture=\"\" reference=\"\" manual=\"\" --=\"\" armv7-a=\"\" and=\"\" armv7-r=\"\" edition=\"\">&gt; (ARM DDI 0406C.c (ID051414)) B3 Virtual Memory System Architecture (VMSA)</arm></p>\n<p>iotable_init()-&gt;<br>&nbsp;&nbsp;create_mapping()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pud()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pmd()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pte()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_ext-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_set_pte_ext()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_v7_set_pte_ext() （linux/arm/arm/mm/proc-v7-2level.S）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">create_mapping</span><span class=\"params\">(struct map_desc *md)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tpgd = pgd_offset_k(addr);</span><br><span class=\"line\">\tend = addr + length;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> next = pgd_addr_end(addr, end);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\talloc_init_pud(pgd, addr, next, phys, type);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tphys += next - addr;</span><br><span class=\"line\">\t\taddr = next;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pgd++, addr != end);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">alloc_init_pte</span><span class=\"params\">(<span class=\"keyword\">pmd_t</span> *pmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> end, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t  <span class=\"keyword\">const</span> struct mem_type *type)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pte_t</span> *pte = early_pte_alloc(pmd, addr, type-&gt;prot_l1);</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tset_pte_ext(pte, pfn_pte(pfn, __pgprot(type-&gt;prot_pte)), <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tpfn++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pte++, addr += PAGE_SIZE, addr != end);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>set_pte_ext()函数，根据配置情况最终指向的是cpu_v7_set_pte_ext()<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcpu_v7_set_pte_ext(ptep, pte)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *\tSet a level 2 translation table entry.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *\t- ptep  - pointer to level 2 translation table entry</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t  (hardware version is stored at +2048 bytes)</span></span><br><span class=\"line\"><span class=\"comment\"> *\t- pte   - PTE value to store</span></span><br><span class=\"line\"><span class=\"comment\"> *\t- ext\t- value for extended PTE bits</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">ENTRY(cpu_v7_set_pte_ext)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_MMU</span></span><br><span class=\"line\">\tstr\tr1, [r0]\t\t\t@ linux version</span><br><span class=\"line\"></span><br><span class=\"line\">\tbic\tr3, r1, #<span class=\"number\">0x000003f0</span></span><br><span class=\"line\">\tbic\tr3, r3, #PTE_TYPE_MASK</span><br><span class=\"line\">\torr\tr3, r3, r2</span><br><span class=\"line\">\torr\tr3, r3, #PTE_EXT_AP0 | <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\ttst\tr1, #<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span></span><br><span class=\"line\">\torrne\tr3, r3, #PTE_EXT_TEX(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\teor\tr1, r1, #L_PTE_DIRTY</span><br><span class=\"line\">\ttst\tr1, #L_PTE_RDONLY | L_PTE_DIRTY</span><br><span class=\"line\">\torrne\tr3, r3, #PTE_EXT_APX</span><br><span class=\"line\"></span><br><span class=\"line\">\ttst\tr1, #L_PTE_USER</span><br><span class=\"line\">\torrne\tr3, r3, #PTE_EXT_AP1</span><br><span class=\"line\"></span><br><span class=\"line\">\ttst\tr1, #L_PTE_XN</span><br><span class=\"line\">\torrne\tr3, r3, #PTE_EXT_XN</span><br><span class=\"line\"></span><br><span class=\"line\">\ttst\tr1, #L_PTE_YOUNG</span><br><span class=\"line\">\ttstne\tr1, #L_PTE_VALID</span><br><span class=\"line\">\teorne\tr1, r1, #L_PTE_NONE</span><br><span class=\"line\">\ttstne\tr1, #L_PTE_NONE</span><br><span class=\"line\">\tmoveq\tr3, #<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> ARM(\tstr\tr3, [r0, #<span class=\"number\">2048</span>]! )</span><br><span class=\"line\"> THUMB(\tadd\tr0, r0, #<span class=\"number\">2048</span> )</span><br><span class=\"line\"> THUMB(\tstr\tr3, [r0] )</span><br><span class=\"line\">\tALT_SMP(W(nop))</span><br><span class=\"line\">\tALT_UP (mcr\tp15, <span class=\"number\">0</span>, r0, c7, c10, <span class=\"number\">1</span>)\t\t@ flush_pte</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\tbx\tlr</span><br><span class=\"line\">ENDPROC(cpu_v7_set_pte_ext)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-动态映射\"><a href=\"#2-3-动态映射\" class=\"headerlink\" title=\"2.3. 动态映射\"></a>2.3. 动态映射</h3><h4 id=\"2-3-1-virtual-memory-data-struct\"><a href=\"#2-3-1-virtual-memory-data-struct\" class=\"headerlink\" title=\"2.3.1. virtual memory data struct\"></a>2.3.1. virtual memory data struct</h4><p>linux/include/linux/mm_types.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> *<span class=\"title\">mmap</span>;</span>\t\t<span class=\"comment\">/* list of VMAs */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_MMU</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">long</span> <span class=\"params\">(*get_unmapped_area)</span> <span class=\"params\">(struct file *filp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pgoff, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> mmap_base;\t\t<span class=\"comment\">/* base of mmap area */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> task_size;\t\t<span class=\"comment\">/* size of task vm space */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> highest_vm_end;\t\t<span class=\"comment\">/* highest vma end address */</span></span><br><span class=\"line\">\t<span class=\"keyword\">pgd_t</span> * pgd;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">atomic_long_t</span> nr_ptes;\t\t\t<span class=\"comment\">/* Page table pages */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start_code, end_code, start_data, end_data;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start_brk, brk, start_stack;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Architecture-specific MM context */</span></span><br><span class=\"line\">\t<span class=\"keyword\">mm_context_t</span> context;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> vm_start;\t\t<span class=\"comment\">/* Our start address within vm_mm. */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> vm_end;\t\t<span class=\"comment\">/* The first byte after our end address</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t   within vm_mm. */</span></span><br><span class=\"line\">\t\t\t\t\t   </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> *<span class=\"title\">vm_next</span>, *<span class=\"title\">vm_prev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Second cache line starts here. */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> *<span class=\"title\">vm_mm</span>;</span>\t<span class=\"comment\">/* The address space we belong to. */</span></span><br><span class=\"line\">\t<span class=\"keyword\">pgprot_t</span> vm_page_prot;\t\t<span class=\"comment\">/* Access permissions of this VMA. */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> vm_flags;\t\t<span class=\"comment\">/* Flags, see mm.h. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Information about our backing store: */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> vm_pgoff;\t\t<span class=\"comment\">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t   units, *not* PAGE_CACHE_SIZE */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们在kernel 中想要访问当前进程的mm_struct，可以使用<font color=\"red\">current</font><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> *<span class=\"title\">mm</span> = <span class=\"title\">current</span>-&gt;<span class=\"title\">mm</span>;</span></span><br></pre></td></tr></table></figure></p>\n<p>另外，我们可以访问 /proc/<pid>/maps 得到某一进程的内存区域。（/proc/self 始终指向正在运行的进程）</pid></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/proc_self_maps.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字段</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">00400000-0040b000</td>\n<td style=\"text-align:left\">vma-&gt;vm_start ~ vma-&gt;vm_end</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">r-xp</td>\n<td style=\"text-align:left\">vma-&gt;vm_flags</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">00000000</td>\n<td style=\"text-align:left\">vma-&gt;vm_pgoff</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">08:01</td>\n<td style=\"text-align:left\">主从设备号</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1171031</td>\n<td style=\"text-align:left\">设备节点inode 值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bin/cat</td>\n<td style=\"text-align:left\">设备节点名字</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-3-2-memory-mapping\"><a href=\"#2-3-2-memory-mapping\" class=\"headerlink\" title=\"2.3.2. memory mapping\"></a>2.3.2. memory mapping</h4><p>在使用high mem addr时，我们需要如下函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmap</span><span class=\"params\">(struct page * page)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kunmap</span><span class=\"params\">(struct page *page)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmap_atomic</span><span class=\"params\">(struct page * page)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kumap_atomic</span><span class=\"params\">(struct page *page)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果* page 是low mem addr 直接返回，反之，是high mem addr kmap()在内核专用的空间创建特殊的映射。kmap() 可能会睡眠，而kmap_atomic() 会进行原子操作，不允许sleep.</p>\n<p>kernel 映射函数 <strong>remap_pfn_range()</strong></p>\n<p><strong>注意:</strong><br><strong><font color=\"red\"> 如果使用的high mem， vmalloc() 分配的空间，我们只能PAGE_SIZE 的进行映射，他们本身逻辑连续，而物理地址非连续。</font></strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">remap_pfn_range</span><span class=\"params\">(struct vm_area_struct *vma, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size, <span class=\"keyword\">pgprot_t</span> prot)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pgd_t</span> *pgd;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> next;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> end = addr + PAGE_ALIGN(size);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> *<span class=\"title\">mm</span> = <span class=\"title\">vma</span>-&gt;<span class=\"title\">vm_mm</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpfn -= addr &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">\tpgd = pgd_offset(mm, addr);</span><br><span class=\"line\">\tflush_cache_range(vma, addr, end);</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tnext = pgd_addr_end(addr, end);</span><br><span class=\"line\">\t\terr = remap_pud_range(mm, pgd, addr, next,</span><br><span class=\"line\">\t\t\t\tpfn + (addr &gt;&gt; PAGE_SHIFT), prot);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pgd++, addr = next, addr != end);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用关系如下：<br>remap_pfn_range()-&gt;<br>&nbsp;&nbsp;remap_pud_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;remap_pmd_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remap_pte_range()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * maps a range of physical memory into the requested pages. the old</span></span><br><span class=\"line\"><span class=\"comment\"> * mappings are removed. any references to nonexistent pages results</span></span><br><span class=\"line\"><span class=\"comment\"> * in null mappings (currently treated as \"copy-on-access\")</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">remap_pte_range</span><span class=\"params\">(struct mm_struct *mm, <span class=\"keyword\">pmd_t</span> *pmd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> end,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn, <span class=\"keyword\">pgprot_t</span> prot)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">\t<span class=\"keyword\">spinlock_t</span> *ptl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpte = pte_alloc_map_lock(mm, pmd, addr, &amp;ptl);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tBUG_ON(!pte_none(*pte));</span><br><span class=\"line\">\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));</span><br><span class=\"line\">\t\tpfn++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pte++, addr += PAGE_SIZE, addr != end);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpte_unmap_unlock(pte - <span class=\"number\">1</span>, ptl);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">set_pte_at</span><span class=\"params\">(struct mm_struct *mm, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t      <span class=\"keyword\">pte_t</span> *ptep, <span class=\"keyword\">pte_t</span> pteval)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ext = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (addr &lt; TASK_SIZE &amp;&amp; pte_valid_user(pteval)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!pte_special(pteval))</span><br><span class=\"line\">\t\t\t__sync_icache_dcache(pteval);</span><br><span class=\"line\">\t\text |= PTE_EXT_NG;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tset_pte_ext(ptep, pteval, ext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到与上面的静态映射其实也是差不多的，最终也会调用到set_pte_ext() -&gt; cpu_v7_set_pte_ext() 函数。</p>\n<p><strong><font color=\"red\">因此，映射的本质都是重新建立页表2-level 或 3-level，并刷新页表</font></strong></p>\n<h4 id=\"2-3-3-io-memory-mapping\"><a href=\"#2-3-3-io-memory-mapping\" class=\"headerlink\" title=\"2.3.3. io memory mapping\"></a>2.3.3. io memory mapping</h4><p>ioremap将一个IO地址空间映射到内核的虚拟地址空间上去，便于访问。<a href=\"https://baike.baidu.com/item/ioremap/994207\" target=\"_blank\" rel=\"noopener\">ioremap 百度百科</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ioremap(cookie,size)\t\t__arm_ioremap((cookie), (size), MT_DEVICE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ioremap_nocache(cookie,size)\t__arm_ioremap((cookie), (size), MT_DEVICE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ioremap_cache(cookie,size)\t__arm_ioremap((cookie), (size), MT_DEVICE_CACHED)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ioremap_wc(cookie,size)\t\t__arm_ioremap((cookie), (size), MT_DEVICE_WC)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> iounmap\t\t\t\t__arm_iounmap</span></span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;ioremap()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>arm_ioremap()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>arm_ioremap_caller()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>arm_ioremap_pfn_caller()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>ioremap_page_range() -&gt;__<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_page_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pud_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pmd_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pte_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_at()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_ext()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_set_pte_ext()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_v7_set_pte_ext() （linux/arm/arm/mm/proc-v7-2level.S）</p>\n<p>可以看见，大致与上面的静态映射，动态映射是相同的， 只是不同点在于__arm_ioremap_pfn_caller（） 函数中调用get_vm_area_caller（）进行vm_area 空间的申请。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __iomem * __arm_ioremap_pfn_caller(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn,</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> offset, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> mtype, <span class=\"keyword\">void</span> *caller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mem_type</span> *<span class=\"title\">type</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_struct</span> *<span class=\"title\">area</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">phys_addr_t</span> paddr = __pfn_to_phys(pfn);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> CONFIG_ARM_LPAE</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * High mappings must be supersection aligned</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pfn &gt;= <span class=\"number\">0x100000</span> &amp;&amp; (paddr &amp; ~SUPERSECTION_MASK))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\ttype = get_mem_type(mtype);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!type)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsize = PAGE_ALIGN(offset + size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Try to reuse one of the static mapping whenever possible.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (size &amp;&amp; !(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">phys_addr_t</span>) == <span class=\"number\">4</span> &amp;&amp; pfn &gt;= <span class=\"number\">0x100000</span>)) &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">static_vm</span> *<span class=\"title\">svm</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsvm = find_static_vm_paddr(paddr, size, mtype);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (svm) &#123;</span><br><span class=\"line\">\t\t\taddr = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)svm-&gt;vm.addr;</span><br><span class=\"line\">\t\t\taddr += paddr - svm-&gt;vm.phys_addr;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> (<span class=\"keyword\">void</span> __iomem *) (offset + addr);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tarea = get_vm_area_caller(size, VM_IOREMAP, caller);</span><br><span class=\"line\"> </span><br><span class=\"line\"> \taddr = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)area-&gt;addr;</span><br><span class=\"line\">\tarea-&gt;phys_addr = paddr;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = ioremap_page_range(addr, addr + size, paddr,</span><br><span class=\"line\">\t\t\t\t __pgprot(type-&gt;prot_pte));</span><br><span class=\"line\"></span><br><span class=\"line\">\tflush_cache_vmap(addr, addr + size);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">void</span> __iomem *) (offset + addr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>get_vm_area_caller（）函数可以看见是从 VMALLOC_START ~ VMALLOC_END区域内分配一个空间。 </p>\n<p><strong>注:</strong><br>由于我们的ioremap（）是将IO 连续的物理地址映射成Kernel 能访问的虚拟地址， 所以本身物理地址的连续性是能保证的。vmalloc.c 中的核心函数get_vm_area_caller（）详细分析可见最后的参看资料。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct vm_struct *<span class=\"title\">get_vm_area_caller</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *caller)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __get_vm_area_node(size, <span class=\"number\">1</span>, flags, VMALLOC_START, VMALLOC_END,</span><br><span class=\"line\">\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ioremap_pte_range</span><span class=\"params\">(<span class=\"keyword\">pmd_t</span> *pmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> end, <span class=\"keyword\">phys_addr_t</span> phys_addr, <span class=\"keyword\">pgprot_t</span> prot)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">\tu64 pfn;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpfn = phys_addr &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">\tpte = pte_alloc_kernel(pmd, addr);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!pte)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tBUG_ON(!pte_none(*pte));</span><br><span class=\"line\">\t\tset_pte_at(&amp;init_mm, addr, pte, pfn_pte(pfn, prot));</span><br><span class=\"line\">\t\tpfn++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pte++, addr += PAGE_SIZE, addr != end);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>io_remap_page_range() 如果没有定义，则该函数是等效于<strong>remap_pfn_range()</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> io_remap_pfn_range</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> io_remap_pfn_range remap_pfn_range</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-3-4-dma-memory-mapping\"><a href=\"#2-3-4-dma-memory-mapping\" class=\"headerlink\" title=\"2.3.4. dma memory mapping\"></a>2.3.4. dma memory mapping</h4><p>参见之前文章 -&gt; <a href=\"https://jshell07.github.io/2019/06/28/kernel-dma-mem/\" target=\"_blank\" rel=\"noopener\">DMA memory mapping</a></p>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><strong>basic</strong><br><a href=\"https://www.cnblogs.com/embeded-linux/p/11108930.html\" target=\"_blank\" rel=\"noopener\">虚拟地址映射机制–动态、静态</a></p>\n<p><a href=\"https://blog.csdn.net/zqixiao_09/article/details/51088478\" target=\"_blank\" rel=\"noopener\">Linux的mmap内存映射机制解析</a></p>\n<p><a href=\"https://blog.csdn.net/vichie2008/article/details/48274967\" target=\"_blank\" rel=\"noopener\">ARM MMU页表框架</a></p>\n<p><a href=\"https://www.cnblogs.com/arnoldlu/p/8087022.html\" target=\"_blank\" rel=\"noopener\">Linux内存管理 (2)页表的映射过程</a></p>\n<p><strong>memory mapping</strong><br><a href=\"https://www.cnblogs.com/pengdonglin137/p/8149859.html\" target=\"_blank\" rel=\"noopener\">内存映射函数remap_pfn_range学习——示例分析（1）</a></p>\n<p><a href=\"https://www.cnblogs.com/pengdonglin137/p/8150462.html\" target=\"_blank\" rel=\"noopener\">内存映射函数remap_pfn_range学习——示例分析（2）</a></p>\n<p><a href=\"https://www.cnblogs.com/pengdonglin137/p/8150981.html\" target=\"_blank\" rel=\"noopener\">内存映射函数remap_pfn_range学习——代码分析（3）</a></p>\n<p><strong>ioremap</strong><br><a href=\"https://blog.csdn.net/zqixiao_09/article/details/50859505\" target=\"_blank\" rel=\"noopener\">Linux 字符设备驱动开发基础（五）—— ioremap() 函数解析</a></p>\n<p><strong>vmalloc</strong><br><a href=\"https://blog.csdn.net/vanbreaker/article/details/7591844\" target=\"_blank\" rel=\"noopener\">Linux高端内存映射(下)</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1381130\" target=\"_blank\" rel=\"noopener\">高端内存映射之vmalloc分配内存中不连续的页–Linux内存管理(十九)</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-User-space\"><a href=\"#1-User-space\" class=\"headerlink\" title=\"1. User space\"></a>1. User space</h2><p>mmap, munmap - map or unmap files or devices into memory.<br>将文件或者设备与内存映射起来。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> prot, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getpagesize</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"2-Kernel-space\"><a href=\"#2-Kernel-space\" class=\"headerlink\" title=\"2. Kernel space\"></a>2. Kernel space</h2><h3 id=\"2-1-静态映射\"><a href=\"#2-1-静态映射\" class=\"headerlink\" title=\"2.1. 静态映射\"></a>2.1. 静态映射</h3><p>start_kernel() -&gt;<br>&nbsp;&nbsp;setup_arch() -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp; paging_init() -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devicemaps_init(const struct machine_desc *mdesc) -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdesc-&gt;map_io()</p>\n<p>涉及到的结构体<strong>struct machine_desc</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">machine_desc</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\t\tnr;\t\t<span class=\"comment\">/* architecture number\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>\t\t*name;\t\t<span class=\"comment\">/* architecture </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tunsigned int\t\tnr_irqs;\t/* number of IRQs */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class=\"line\">\t<span class=\"keyword\">phys_addr_t</span>\t\tdma_zone_size;\t<span class=\"comment\">/* size of DMA-able area */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_meminfo)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*reserve)(<span class=\"keyword\">void</span>);<span class=\"comment\">/* reserve mem blocks\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*map_io)(<span class=\"keyword\">void</span>);<span class=\"comment\">/* IO mapping function\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_early)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_irq)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_time)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_machine)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*init_late)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_MULTI_IRQ_HANDLER</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*handle_irq)(struct pt_regs *);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t\t(*restart)(<span class=\"keyword\">enum</span> reboot_mode, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">map_desc</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">virtual</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> type;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>例如我们在arch/arm/mach-s3c24xx/mach-smdk2440.c<br>smdk2440_map_io() -&gt;<br>&nbsp;&nbsp;iotable_init(mach_desc, size)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">map_desc</span> <span class=\"title\">smdk2440_iodesc</span>[] __<span class=\"title\">initdata</span> = &#123;</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t.<span class=\"keyword\">virtual</span>\t= (u32)S3C24XX_VA_ISA_WORD,</span><br><span class=\"line\">\t\t.pfn\t\t= __phys_to_pfn(S3C2410_CS2),</span><br><span class=\"line\">\t\t.length\t\t= <span class=\"number\">0x10000</span>,</span><br><span class=\"line\">\t\t.type\t\t= MT_DEVICE,</span><br><span class=\"line\">\t&#125;, </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MACHINE_START(S3C2440, <span class=\"string\">\"SMDK2440\"</span>)</span><br><span class=\"line\">\t<span class=\"comment\">/* Maintainer: Ben Dooks &lt;ben-linux@fluff.org&gt; */</span></span><br><span class=\"line\">\t.atag_offset\t= <span class=\"number\">0x100</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\t.init_irq\t= s3c2440_init_irq,</span><br><span class=\"line\">\t.map_io\t\t= smdk2440_map_io,</span><br><span class=\"line\">\t.init_machine\t= smdk2440_machine_init,</span><br><span class=\"line\">\t.init_time\t= smdk2440_init_time,</span><br><span class=\"line\">MACHINE_END</span><br></pre></td></tr></table></figure>\n<p>在这一步定义了物理与虚拟地址之间的映射关系，一旦编译完成就不会修改，<font color=\"red\"> 静态编译常用于不容易变动的物理地址与虚拟地址之间的映射，例如寄存器的映射。</font></p>\n<h3 id=\"2-2-页表创建\"><a href=\"#2-2-页表创建\" class=\"headerlink\" title=\"2.2. 页表创建\"></a>2.2. 页表创建</h3><p>Linux下的页表映射分为两种，一是Linux自身的页表映射，另一种是ARM32 MMU硬件的映射。这样是为了更大的灵活性，可以映射Linux bits 到 硬件tables 上，例如有YOUNG, DIRTY bits.</p>\n<p>参见 linux/arch/arm/include/asm/pagetable-2level.h 注释：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Hardware-wise, we have a two level page table structure, where the first</span></span><br><span class=\"line\"><span class=\"comment\"> * level has 4096 entries, and the second level has 256 entries.  Each entry</span></span><br><span class=\"line\"><span class=\"comment\"> * is one 32-bit word.  Most of the bits in the second level entry are used</span></span><br><span class=\"line\"><span class=\"comment\"> * by hardware, and there aren't any \"accessed\" and \"dirty\" bits.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Linux on the other hand has a three level page table structure, which can</span></span><br><span class=\"line\"><span class=\"comment\"> * be wrapped to fit a two level page table structure easily - using the PGD</span></span><br><span class=\"line\"><span class=\"comment\"> * and PTE only.  However, Linux also expects one \"PTE\" table per page, and</span></span><br><span class=\"line\"><span class=\"comment\"> * at least a \"dirty\" bit.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Therefore, we tweak the implementation slightly - we tell Linux that we</span></span><br><span class=\"line\"><span class=\"comment\"> * have 2048 entries in the first level, each of which is 8 bytes (iow, two</span></span><br><span class=\"line\"><span class=\"comment\"> * hardware pointers to the second level.)  The second level contains two</span></span><br><span class=\"line\"><span class=\"comment\"> * hardware PTE tables arranged contiguously, preceded by Linux versions</span></span><br><span class=\"line\"><span class=\"comment\"> * which contain the state information Linux needs.  We, therefore, end up</span></span><br><span class=\"line\"><span class=\"comment\"> * with 512 entries in the \"PTE\" level.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This leads to the page tables having the following layout:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *    pgd             pte</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |</span></span><br><span class=\"line\"><span class=\"comment\"> * +--------+</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |       +------------+ +0</span></span><br><span class=\"line\"><span class=\"comment\"> * +- - - - +       | Linux pt 0 |</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |       +------------+ +1024</span></span><br><span class=\"line\"><span class=\"comment\"> * +--------+ +0    | Linux pt 1 |</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |-----&gt; +------------+ +2048</span></span><br><span class=\"line\"><span class=\"comment\"> * +- - - - + +4    |  h/w pt 0  |</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |-----&gt; +------------+ +3072</span></span><br><span class=\"line\"><span class=\"comment\"> * +--------+ +8    |  h/w pt 1  |</span></span><br><span class=\"line\"><span class=\"comment\"> * |        |       +------------+ +4096</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * See L_PTE_xxx below for definitions of bits in the \"Linux pt\", and</span></span><br><span class=\"line\"><span class=\"comment\"> * PTE_xxx for definitions of bits appearing in the \"h/w pt\".</span></span><br></pre></td></tr></table></figure></p>\n<p>32bit的Linux采用三级映射：PGD–&gt;PMD–&gt;PTE，64bit的Linux采用四级映射：PGD–&gt;PUD–&gt;PMD–&gt;PTE，多了个PUD</p>\n<blockquote>\n<p>PGD - Page Global Directory<br>PUD - Page Upper Directory<br>PMD - Page Middle Directory<br>PTE - Page Table Entry。</p>\n</blockquote>\n<p>在ARM32 Linux采用两层映射，省略了PMD，除非在定义了CONFIG_ARM_LPAE才会使用3级映射。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/page_to_addr.png\" alt=\"页表转换过程\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/1level_page_table.png\" alt=\"1 level page table\"></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/2level_page_table.png\" alt=\"2 level page table\"></p>\n<p>更多可以参看&lt;<arm ®=\"\" architecture=\"\" reference=\"\" manual=\"\" --=\"\" armv7-a=\"\" and=\"\" armv7-r=\"\" edition=\"\">&gt; (ARM DDI 0406C.c (ID051414)) B3 Virtual Memory System Architecture (VMSA)</arm></p>\n<p>iotable_init()-&gt;<br>&nbsp;&nbsp;create_mapping()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pud()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pmd()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alloc_init_pte()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_ext-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_set_pte_ext()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_v7_set_pte_ext() （linux/arm/arm/mm/proc-v7-2level.S）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">create_mapping</span><span class=\"params\">(struct map_desc *md)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tpgd = pgd_offset_k(addr);</span><br><span class=\"line\">\tend = addr + length;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> next = pgd_addr_end(addr, end);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\talloc_init_pud(pgd, addr, next, phys, type);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tphys += next - addr;</span><br><span class=\"line\">\t\taddr = next;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pgd++, addr != end);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">alloc_init_pte</span><span class=\"params\">(<span class=\"keyword\">pmd_t</span> *pmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> end, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t  <span class=\"keyword\">const</span> struct mem_type *type)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pte_t</span> *pte = early_pte_alloc(pmd, addr, type-&gt;prot_l1);</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tset_pte_ext(pte, pfn_pte(pfn, __pgprot(type-&gt;prot_pte)), <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tpfn++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pte++, addr += PAGE_SIZE, addr != end);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>set_pte_ext()函数，根据配置情况最终指向的是cpu_v7_set_pte_ext()<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *\tcpu_v7_set_pte_ext(ptep, pte)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *\tSet a level 2 translation table entry.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *\t- ptep  - pointer to level 2 translation table entry</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t  (hardware version is stored at +2048 bytes)</span></span><br><span class=\"line\"><span class=\"comment\"> *\t- pte   - PTE value to store</span></span><br><span class=\"line\"><span class=\"comment\"> *\t- ext\t- value for extended PTE bits</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">ENTRY(cpu_v7_set_pte_ext)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_MMU</span></span><br><span class=\"line\">\tstr\tr1, [r0]\t\t\t@ linux version</span><br><span class=\"line\"></span><br><span class=\"line\">\tbic\tr3, r1, #<span class=\"number\">0x000003f0</span></span><br><span class=\"line\">\tbic\tr3, r3, #PTE_TYPE_MASK</span><br><span class=\"line\">\torr\tr3, r3, r2</span><br><span class=\"line\">\torr\tr3, r3, #PTE_EXT_AP0 | <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\ttst\tr1, #<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span></span><br><span class=\"line\">\torrne\tr3, r3, #PTE_EXT_TEX(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\teor\tr1, r1, #L_PTE_DIRTY</span><br><span class=\"line\">\ttst\tr1, #L_PTE_RDONLY | L_PTE_DIRTY</span><br><span class=\"line\">\torrne\tr3, r3, #PTE_EXT_APX</span><br><span class=\"line\"></span><br><span class=\"line\">\ttst\tr1, #L_PTE_USER</span><br><span class=\"line\">\torrne\tr3, r3, #PTE_EXT_AP1</span><br><span class=\"line\"></span><br><span class=\"line\">\ttst\tr1, #L_PTE_XN</span><br><span class=\"line\">\torrne\tr3, r3, #PTE_EXT_XN</span><br><span class=\"line\"></span><br><span class=\"line\">\ttst\tr1, #L_PTE_YOUNG</span><br><span class=\"line\">\ttstne\tr1, #L_PTE_VALID</span><br><span class=\"line\">\teorne\tr1, r1, #L_PTE_NONE</span><br><span class=\"line\">\ttstne\tr1, #L_PTE_NONE</span><br><span class=\"line\">\tmoveq\tr3, #<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> ARM(\tstr\tr3, [r0, #<span class=\"number\">2048</span>]! )</span><br><span class=\"line\"> THUMB(\tadd\tr0, r0, #<span class=\"number\">2048</span> )</span><br><span class=\"line\"> THUMB(\tstr\tr3, [r0] )</span><br><span class=\"line\">\tALT_SMP(W(nop))</span><br><span class=\"line\">\tALT_UP (mcr\tp15, <span class=\"number\">0</span>, r0, c7, c10, <span class=\"number\">1</span>)\t\t@ flush_pte</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\tbx\tlr</span><br><span class=\"line\">ENDPROC(cpu_v7_set_pte_ext)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-动态映射\"><a href=\"#2-3-动态映射\" class=\"headerlink\" title=\"2.3. 动态映射\"></a>2.3. 动态映射</h3><h4 id=\"2-3-1-virtual-memory-data-struct\"><a href=\"#2-3-1-virtual-memory-data-struct\" class=\"headerlink\" title=\"2.3.1. virtual memory data struct\"></a>2.3.1. virtual memory data struct</h4><p>linux/include/linux/mm_types.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> *<span class=\"title\">mmap</span>;</span>\t\t<span class=\"comment\">/* list of VMAs */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_MMU</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">long</span> <span class=\"params\">(*get_unmapped_area)</span> <span class=\"params\">(struct file *filp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pgoff, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> mmap_base;\t\t<span class=\"comment\">/* base of mmap area */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> task_size;\t\t<span class=\"comment\">/* size of task vm space */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> highest_vm_end;\t\t<span class=\"comment\">/* highest vma end address */</span></span><br><span class=\"line\">\t<span class=\"keyword\">pgd_t</span> * pgd;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">atomic_long_t</span> nr_ptes;\t\t\t<span class=\"comment\">/* Page table pages */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start_code, end_code, start_data, end_data;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start_brk, brk, start_stack;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Architecture-specific MM context */</span></span><br><span class=\"line\">\t<span class=\"keyword\">mm_context_t</span> context;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> vm_start;\t\t<span class=\"comment\">/* Our start address within vm_mm. */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> vm_end;\t\t<span class=\"comment\">/* The first byte after our end address</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t   within vm_mm. */</span></span><br><span class=\"line\">\t\t\t\t\t   </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> *<span class=\"title\">vm_next</span>, *<span class=\"title\">vm_prev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Second cache line starts here. */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> *<span class=\"title\">vm_mm</span>;</span>\t<span class=\"comment\">/* The address space we belong to. */</span></span><br><span class=\"line\">\t<span class=\"keyword\">pgprot_t</span> vm_page_prot;\t\t<span class=\"comment\">/* Access permissions of this VMA. */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> vm_flags;\t\t<span class=\"comment\">/* Flags, see mm.h. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Information about our backing store: */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> vm_pgoff;\t\t<span class=\"comment\">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t   units, *not* PAGE_CACHE_SIZE */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们在kernel 中想要访问当前进程的mm_struct，可以使用<font color=\"red\">current</font><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> *<span class=\"title\">mm</span> = <span class=\"title\">current</span>-&gt;<span class=\"title\">mm</span>;</span></span><br></pre></td></tr></table></figure></p>\n<p>另外，我们可以访问 /proc/<pid>/maps 得到某一进程的内存区域。（/proc/self 始终指向正在运行的进程）</pid></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_virtual_addr_map/proc_self_maps.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字段</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">00400000-0040b000</td>\n<td style=\"text-align:left\">vma-&gt;vm_start ~ vma-&gt;vm_end</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">r-xp</td>\n<td style=\"text-align:left\">vma-&gt;vm_flags</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">00000000</td>\n<td style=\"text-align:left\">vma-&gt;vm_pgoff</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">08:01</td>\n<td style=\"text-align:left\">主从设备号</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1171031</td>\n<td style=\"text-align:left\">设备节点inode 值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bin/cat</td>\n<td style=\"text-align:left\">设备节点名字</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-3-2-memory-mapping\"><a href=\"#2-3-2-memory-mapping\" class=\"headerlink\" title=\"2.3.2. memory mapping\"></a>2.3.2. memory mapping</h4><p>在使用high mem addr时，我们需要如下函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmap</span><span class=\"params\">(struct page * page)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kunmap</span><span class=\"params\">(struct page *page)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmap_atomic</span><span class=\"params\">(struct page * page)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kumap_atomic</span><span class=\"params\">(struct page *page)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果* page 是low mem addr 直接返回，反之，是high mem addr kmap()在内核专用的空间创建特殊的映射。kmap() 可能会睡眠，而kmap_atomic() 会进行原子操作，不允许sleep.</p>\n<p>kernel 映射函数 <strong>remap_pfn_range()</strong></p>\n<p><strong>注意:</strong><br><strong><font color=\"red\"> 如果使用的high mem， vmalloc() 分配的空间，我们只能PAGE_SIZE 的进行映射，他们本身逻辑连续，而物理地址非连续。</font></strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">remap_pfn_range</span><span class=\"params\">(struct vm_area_struct *vma, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size, <span class=\"keyword\">pgprot_t</span> prot)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pgd_t</span> *pgd;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> next;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> end = addr + PAGE_ALIGN(size);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> *<span class=\"title\">mm</span> = <span class=\"title\">vma</span>-&gt;<span class=\"title\">vm_mm</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpfn -= addr &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">\tpgd = pgd_offset(mm, addr);</span><br><span class=\"line\">\tflush_cache_range(vma, addr, end);</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tnext = pgd_addr_end(addr, end);</span><br><span class=\"line\">\t\terr = remap_pud_range(mm, pgd, addr, next,</span><br><span class=\"line\">\t\t\t\tpfn + (addr &gt;&gt; PAGE_SHIFT), prot);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pgd++, addr = next, addr != end);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用关系如下：<br>remap_pfn_range()-&gt;<br>&nbsp;&nbsp;remap_pud_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;remap_pmd_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remap_pte_range()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * maps a range of physical memory into the requested pages. the old</span></span><br><span class=\"line\"><span class=\"comment\"> * mappings are removed. any references to nonexistent pages results</span></span><br><span class=\"line\"><span class=\"comment\"> * in null mappings (currently treated as \"copy-on-access\")</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">remap_pte_range</span><span class=\"params\">(struct mm_struct *mm, <span class=\"keyword\">pmd_t</span> *pmd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> end,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn, <span class=\"keyword\">pgprot_t</span> prot)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">\t<span class=\"keyword\">spinlock_t</span> *ptl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpte = pte_alloc_map_lock(mm, pmd, addr, &amp;ptl);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tBUG_ON(!pte_none(*pte));</span><br><span class=\"line\">\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));</span><br><span class=\"line\">\t\tpfn++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pte++, addr += PAGE_SIZE, addr != end);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpte_unmap_unlock(pte - <span class=\"number\">1</span>, ptl);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">set_pte_at</span><span class=\"params\">(struct mm_struct *mm, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t      <span class=\"keyword\">pte_t</span> *ptep, <span class=\"keyword\">pte_t</span> pteval)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ext = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (addr &lt; TASK_SIZE &amp;&amp; pte_valid_user(pteval)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!pte_special(pteval))</span><br><span class=\"line\">\t\t\t__sync_icache_dcache(pteval);</span><br><span class=\"line\">\t\text |= PTE_EXT_NG;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tset_pte_ext(ptep, pteval, ext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到与上面的静态映射其实也是差不多的，最终也会调用到set_pte_ext() -&gt; cpu_v7_set_pte_ext() 函数。</p>\n<p><strong><font color=\"red\">因此，映射的本质都是重新建立页表2-level 或 3-level，并刷新页表</font></strong></p>\n<h4 id=\"2-3-3-io-memory-mapping\"><a href=\"#2-3-3-io-memory-mapping\" class=\"headerlink\" title=\"2.3.3. io memory mapping\"></a>2.3.3. io memory mapping</h4><p>ioremap将一个IO地址空间映射到内核的虚拟地址空间上去，便于访问。<a href=\"https://baike.baidu.com/item/ioremap/994207\" target=\"_blank\" rel=\"noopener\">ioremap 百度百科</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ioremap(cookie,size)\t\t__arm_ioremap((cookie), (size), MT_DEVICE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ioremap_nocache(cookie,size)\t__arm_ioremap((cookie), (size), MT_DEVICE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ioremap_cache(cookie,size)\t__arm_ioremap((cookie), (size), MT_DEVICE_CACHED)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ioremap_wc(cookie,size)\t\t__arm_ioremap((cookie), (size), MT_DEVICE_WC)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> iounmap\t\t\t\t__arm_iounmap</span></span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;ioremap()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>arm_ioremap()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>arm_ioremap_caller()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>arm_ioremap_pfn_caller()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>ioremap_page_range() -&gt;__<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_page_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pud_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pmd_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioremap_pte_range()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_at()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte_ext()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_set_pte_ext()-&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_v7_set_pte_ext() （linux/arm/arm/mm/proc-v7-2level.S）</p>\n<p>可以看见，大致与上面的静态映射，动态映射是相同的， 只是不同点在于__arm_ioremap_pfn_caller（） 函数中调用get_vm_area_caller（）进行vm_area 空间的申请。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __iomem * __arm_ioremap_pfn_caller(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> pfn,</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> offset, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> mtype, <span class=\"keyword\">void</span> *caller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mem_type</span> *<span class=\"title\">type</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> err;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_struct</span> *<span class=\"title\">area</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">phys_addr_t</span> paddr = __pfn_to_phys(pfn);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> CONFIG_ARM_LPAE</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * High mappings must be supersection aligned</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pfn &gt;= <span class=\"number\">0x100000</span> &amp;&amp; (paddr &amp; ~SUPERSECTION_MASK))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\ttype = get_mem_type(mtype);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!type)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsize = PAGE_ALIGN(offset + size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Try to reuse one of the static mapping whenever possible.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (size &amp;&amp; !(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">phys_addr_t</span>) == <span class=\"number\">4</span> &amp;&amp; pfn &gt;= <span class=\"number\">0x100000</span>)) &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">static_vm</span> *<span class=\"title\">svm</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsvm = find_static_vm_paddr(paddr, size, mtype);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (svm) &#123;</span><br><span class=\"line\">\t\t\taddr = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)svm-&gt;vm.addr;</span><br><span class=\"line\">\t\t\taddr += paddr - svm-&gt;vm.phys_addr;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> (<span class=\"keyword\">void</span> __iomem *) (offset + addr);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tarea = get_vm_area_caller(size, VM_IOREMAP, caller);</span><br><span class=\"line\"> </span><br><span class=\"line\"> \taddr = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)area-&gt;addr;</span><br><span class=\"line\">\tarea-&gt;phys_addr = paddr;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = ioremap_page_range(addr, addr + size, paddr,</span><br><span class=\"line\">\t\t\t\t __pgprot(type-&gt;prot_pte));</span><br><span class=\"line\"></span><br><span class=\"line\">\tflush_cache_vmap(addr, addr + size);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">void</span> __iomem *) (offset + addr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>get_vm_area_caller（）函数可以看见是从 VMALLOC_START ~ VMALLOC_END区域内分配一个空间。 </p>\n<p><strong>注:</strong><br>由于我们的ioremap（）是将IO 连续的物理地址映射成Kernel 能访问的虚拟地址， 所以本身物理地址的连续性是能保证的。vmalloc.c 中的核心函数get_vm_area_caller（）详细分析可见最后的参看资料。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct vm_struct *<span class=\"title\">get_vm_area_caller</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *caller)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __get_vm_area_node(size, <span class=\"number\">1</span>, flags, VMALLOC_START, VMALLOC_END,</span><br><span class=\"line\">\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ioremap_pte_range</span><span class=\"params\">(<span class=\"keyword\">pmd_t</span> *pmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> end, <span class=\"keyword\">phys_addr_t</span> phys_addr, <span class=\"keyword\">pgprot_t</span> prot)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">\tu64 pfn;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpfn = phys_addr &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">\tpte = pte_alloc_kernel(pmd, addr);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!pte)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tBUG_ON(!pte_none(*pte));</span><br><span class=\"line\">\t\tset_pte_at(&amp;init_mm, addr, pte, pfn_pte(pfn, prot));</span><br><span class=\"line\">\t\tpfn++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (pte++, addr += PAGE_SIZE, addr != end);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>io_remap_page_range() 如果没有定义，则该函数是等效于<strong>remap_pfn_range()</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> io_remap_pfn_range</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> io_remap_pfn_range remap_pfn_range</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-3-4-dma-memory-mapping\"><a href=\"#2-3-4-dma-memory-mapping\" class=\"headerlink\" title=\"2.3.4. dma memory mapping\"></a>2.3.4. dma memory mapping</h4><p>参见之前文章 -&gt; <a href=\"https://jshell07.github.io/2019/06/28/kernel-dma-mem/\" target=\"_blank\" rel=\"noopener\">DMA memory mapping</a></p>\n<h2 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h2><p><strong>basic</strong><br><a href=\"https://www.cnblogs.com/embeded-linux/p/11108930.html\" target=\"_blank\" rel=\"noopener\">虚拟地址映射机制–动态、静态</a></p>\n<p><a href=\"https://blog.csdn.net/zqixiao_09/article/details/51088478\" target=\"_blank\" rel=\"noopener\">Linux的mmap内存映射机制解析</a></p>\n<p><a href=\"https://blog.csdn.net/vichie2008/article/details/48274967\" target=\"_blank\" rel=\"noopener\">ARM MMU页表框架</a></p>\n<p><a href=\"https://www.cnblogs.com/arnoldlu/p/8087022.html\" target=\"_blank\" rel=\"noopener\">Linux内存管理 (2)页表的映射过程</a></p>\n<p><strong>memory mapping</strong><br><a href=\"https://www.cnblogs.com/pengdonglin137/p/8149859.html\" target=\"_blank\" rel=\"noopener\">内存映射函数remap_pfn_range学习——示例分析（1）</a></p>\n<p><a href=\"https://www.cnblogs.com/pengdonglin137/p/8150462.html\" target=\"_blank\" rel=\"noopener\">内存映射函数remap_pfn_range学习——示例分析（2）</a></p>\n<p><a href=\"https://www.cnblogs.com/pengdonglin137/p/8150981.html\" target=\"_blank\" rel=\"noopener\">内存映射函数remap_pfn_range学习——代码分析（3）</a></p>\n<p><strong>ioremap</strong><br><a href=\"https://blog.csdn.net/zqixiao_09/article/details/50859505\" target=\"_blank\" rel=\"noopener\">Linux 字符设备驱动开发基础（五）—— ioremap() 函数解析</a></p>\n<p><strong>vmalloc</strong><br><a href=\"https://blog.csdn.net/vanbreaker/article/details/7591844\" target=\"_blank\" rel=\"noopener\">Linux高端内存映射(下)</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1381130\" target=\"_blank\" rel=\"noopener\">高端内存映射之vmalloc分配内存中不连续的页–Linux内存管理(十九)</a></p>"},{"title":"kernel_mtd","date":"2019-06-25T03:43:30.000Z","_content":"\n## 1. Flash 大致分类  \n- Nor Flash (intel 开发)\n- Nand Flash (Toshiba 开发)\n- OneNand Flash(Samsung 开发)\n\n<!--more-->\n\nNAND Flash在容量、功耗、使用寿命、写速度快、芯片面积小、单元密度高、擦除速度快、成本低等方面的优势使其成为高数据存储密度的理想解决方案。\nNOR Flash的传输效率很高，但写入和擦除速度较低；\n\nOneNAND结合了NAND存储密度高、写入速度快和NOR读取速度快的优点，整体性能完全超越常规的NAND和NOR。\n__OneNAND采用NAND逻辑结构的存储内核和NOR的控制接口，并直接在系统内整合一定容量SRAM静态随即存储器作为高速缓冲区。__\n\n当OneNAND执行程序时，代码必须从OneNAND存储核心载入到SRAM，然后在SRAM上执行。由于SRAM的速度优势，数据载入动作几乎可以在瞬间完成，用户感觉不到迟滞现象，加上SRAM被直接封装在OneNAND芯片内部，外界看起来就好像是OneNAND也具备程序的本地执行功能。\n\n Flash | 读 | 写 | 擦除 | 坏块 | XIP(eXecute In Place) | 容量 | 寿命 | 成本 \n:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: \nNor Flash | 100MBps | 0.5MBps | 0.3MBps | - | YES | 常见<= 32M | 10几万 | 较高\nNand Flash | 15MBps | 7MBps | 64MBps |有 | - | 大容量 | 100万 | 低\nOneNand Flash | 100MBps | 10MBps | 64MBps | 有 | YES | 较大容量 |  100万 | 较低\n\n### 1.1. 总线接口\n\n#### 1.1.1. Nand Flash\nNand Flash 常见有：\n- 总线接口Flash    \n- SPI Flash  \n总线flash需要你的MCU上有外部总线接口，SPI flash就是通过SPI口对flash进行读写。\n速度上，总线flash比SPI的快，但是SPI 芯片封装布局具有优势。\n\n如果Nand Flash 使用总线接口，一般pin 如下：\n\nPins | Function  \n:-: | :-  \nI/O 0-7(15) | Data input or output(16 bit buswidth chips are supported in kernel)  \n/CE | Chip Enable  \n/CLE | Command Latch Enable  \nALE | Address Latch Enable  \n/RE | Read Enable  \n/WE | Write Enable  \n/WP | Write Protect  \n/SE | Spare area Enable ( link to GND)  \nR/B | Ready / Busy Output  \n\nAt the moment there are only a few filesystems which support NAND:\n- JFFS2 and YAFFS for bare NAND Flash and SmartMediaCards  \n- NTFL for DiskOnChip devices  \n- TRUEFFS from M-Systems for DiskOnChip devices  \n- SmartMedia DOS-FAT as defined by the SSFDC Forum  \n- UBIFS for bare NAND flash\n\n\n#### 1.1.2. Nor Flash\n在通信方式上Nor Flash 分为两种类型：CFI Flash和 SPI Flash。\n_CFI Flash_\n英文全称是common flash interface,也就是公共闪存接口，是由存储芯片工业界定义的一种获取闪存芯片物理参数和结构参数的操作规程和标准。CFI有许多关于闪存芯片的规定，有利于嵌入式对FLASH的编程。现在的很多NOR FLASH 都支持CFI，但并不是所有的都支持。  \n\nCFI接口，相对于串口的SPI来说，也被称为parallel接口，并行接口；另外，CFI接口是JEDEC定义的，所以，有的又成CFI接口为JEDEC接口。所以，可以简单理解为：对于Nor Flash来说，CFI接口＝JEDEC接口＝Parallel接口 = 并行接口\n\n_SPI Flash_\nserial peripheral interface串行外围设备接口,是一种常见的时钟同步串行通信接口。\n\n_两者不同处_\nCFI接口的的Nor Flash的针脚较多，芯片较大。之所有会有SPI接口, 可以减少针脚数目，减少芯片封装大小，采用了SPI后的Nor Flash，针脚只有8个。SPI容量都不是很大，读写速度慢，但是价格便宜，操作简单。而parallel接口速度快，容量上市场上已经有1Gmbit的容量，价格昂贵。\n\n## 2. 延伸扩展  \n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=47c8a31259ee3d6d36cb8f99227f0647/e1fe9925bc315c60225ddb5a8db1cb13485477be.jpg)\n\n### 2.1. SSD [SATA](https://baike.baidu.com/item/SATA) 接口 （串行口）  \n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=226f2bbbb13533faf5b6942890d2fdca/d53f8794a4c27d1ee9ac99711bd5ad6edcc438f8.jpg)\n\n### 2.2. SSD [NVME](https://baike.baidu.com/item/NVMe/20293531) 接口 （PCIe 口）\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=61b517595866d0166a14967af642bf62/cefc1e178a82b90112fe57a7798da9773812efd7.jpg)\n\n[SSD技术扫盲之：什么是NVMe？ NVMe SSD有什么特点？](http://www.chinastor.com/baike/ssd/04103A942017.html)\n\n## 3. Kernel MTD Source code\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/block%20device%20vs%20mtd%20device.png)\n\nKernel 中MTD 的源码如下图所示：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_source_code_tree.png)\n\nMTD 组成的源代码框架如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_source_code_structure.png)\n\n项目 | 说明 \n:-: | :-\nFTL | Flash Translation Layer, 需要PCMCIA 硬件授权专利\nNFTL | Nand flash translation layer, 需要DiskOnChip 硬件授权专利\nINFTL | Inverse Nand flash translation layer, 需要DiskOnChip 硬件授权专利\nspi-nor | spi nor flash source code\nchips, maps | CFI Nor Flash\nnand | nand flash\nubi | unsorted block images, 基于raw flash 的卷管理系统\n\n在mtd 目录下还有一些有意思的code, 他们分别是：\n- mtdconcat.c 将多个MTD 设备组成一个MTD， 功能类似于rapid 磁盘阵列  \n- cmdlinepart.c 提供解析启动参数中的MTD 信息  \n- mtdswap.c  交换分区，用于wear leveling 记录erase counter， 但UBI 已经具备此功能\n- mtdsuper.c  用于向fs/jffs2, fs/romfs 提供挂载接口\n\n## 4. 源代码框架\nKernel MTD 在Kernel 中的结构如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd%20softeware%20structure.png)\n\n在MTD Sub-system 中的结构如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_structure.png)\n\nmtdchar.c 向flash tools 或者用户层提供IOCTL 操作。\nmtdblock.c 向kernel 提供block read/write sector访问。\n\n他们两者的动态加载是通过mtdcore.c 中的add_mtd_device()函数。 例如在mtdblock.c 中：\n```c\nstatic struct mtd_notifier blktrans_notifier = {\n\t.add = blktrans_notify_add,\n\t.remove = blktrans_notify_remove,\n};\n\nint register_mtd_blktrans(struct mtd_blktrans_ops *tr)\n{\n    ...\n    register_mtd_user(&blktrans_notifier);\n}\n```\n在mtdcore.c 中\n```c\nint add_mtd_device(struct mtd_info *mtd)\n{\n\n    /* register char dev node */\n\tmtd->dev.type = &mtd_devtype;\n\tmtd->dev.class = &mtd_class;\n\tmtd->dev.devt = MTD_DEVT(i);\n\tdev_set_name(&mtd->dev, \"mtd%d\", i);\n\tdev_set_drvdata(&mtd->dev, mtd);\n\tif (device_register(&mtd->dev) != 0)\n\t\tgoto fail_added;\n\n    /* call mtd_notifiers, so it will call mtdblock.c blktrans_notify_add() */\n\tlist_for_each_entry(not, &mtd_notifiers, list)\n\t\tnot->add(mtd);\n}\n```\n大致流程如下图所示：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/register%20partition.png)\n\n注册相关数据结构：\n```c\nstruct mtd_part {\n\tstruct mtd_info mtd;\n\tstruct mtd_info *master;\n\tuint64_t offset;\n\tstruct list_head list;\n};\n\nstruct mtd_partition {\n\tconst char *name;\t\t/* identifier string */\n\tuint64_t size;\t\t\t/* partition size */\n\tuint64_t offset;\t\t/* offset within the master MTD space */\n\tuint32_t mask_flags;\t\t/* master MTD flags to mask out for this partition */\n\tstruct nand_ecclayout *ecclayout;\t/* out of band layout for this partition (NAND only) */\n};\n```\n## 参看资源：  \n[OneNAND](https://blog.csdn.net/programxiao/article/details/6214607)\n\n[三星OneNAND技术](https://www.chinaflashmarket.com/Instructor/102570)\n\n[Nand Flash，Nor Flash，CFI Flash，SPI Flash 之间的关系](https://www.cnblogs.com/zhangj95/p/5649518.html) \n\n[CFI与SPI flash区别](https://blog.csdn.net/pine222/article/details/47090041)\n\n[MTD 官网](http://www.linux-mtd.infradead.org/doc/general.html)","source":"_posts/kernel-mtd.md","raw":"---\ntitle: kernel_mtd\ndate: 2019-06-25 11:43:30\ntags:\n    - mtd\ncategories:\n    - drivers\n---\n\n## 1. Flash 大致分类  \n- Nor Flash (intel 开发)\n- Nand Flash (Toshiba 开发)\n- OneNand Flash(Samsung 开发)\n\n<!--more-->\n\nNAND Flash在容量、功耗、使用寿命、写速度快、芯片面积小、单元密度高、擦除速度快、成本低等方面的优势使其成为高数据存储密度的理想解决方案。\nNOR Flash的传输效率很高，但写入和擦除速度较低；\n\nOneNAND结合了NAND存储密度高、写入速度快和NOR读取速度快的优点，整体性能完全超越常规的NAND和NOR。\n__OneNAND采用NAND逻辑结构的存储内核和NOR的控制接口，并直接在系统内整合一定容量SRAM静态随即存储器作为高速缓冲区。__\n\n当OneNAND执行程序时，代码必须从OneNAND存储核心载入到SRAM，然后在SRAM上执行。由于SRAM的速度优势，数据载入动作几乎可以在瞬间完成，用户感觉不到迟滞现象，加上SRAM被直接封装在OneNAND芯片内部，外界看起来就好像是OneNAND也具备程序的本地执行功能。\n\n Flash | 读 | 写 | 擦除 | 坏块 | XIP(eXecute In Place) | 容量 | 寿命 | 成本 \n:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: \nNor Flash | 100MBps | 0.5MBps | 0.3MBps | - | YES | 常见<= 32M | 10几万 | 较高\nNand Flash | 15MBps | 7MBps | 64MBps |有 | - | 大容量 | 100万 | 低\nOneNand Flash | 100MBps | 10MBps | 64MBps | 有 | YES | 较大容量 |  100万 | 较低\n\n### 1.1. 总线接口\n\n#### 1.1.1. Nand Flash\nNand Flash 常见有：\n- 总线接口Flash    \n- SPI Flash  \n总线flash需要你的MCU上有外部总线接口，SPI flash就是通过SPI口对flash进行读写。\n速度上，总线flash比SPI的快，但是SPI 芯片封装布局具有优势。\n\n如果Nand Flash 使用总线接口，一般pin 如下：\n\nPins | Function  \n:-: | :-  \nI/O 0-7(15) | Data input or output(16 bit buswidth chips are supported in kernel)  \n/CE | Chip Enable  \n/CLE | Command Latch Enable  \nALE | Address Latch Enable  \n/RE | Read Enable  \n/WE | Write Enable  \n/WP | Write Protect  \n/SE | Spare area Enable ( link to GND)  \nR/B | Ready / Busy Output  \n\nAt the moment there are only a few filesystems which support NAND:\n- JFFS2 and YAFFS for bare NAND Flash and SmartMediaCards  \n- NTFL for DiskOnChip devices  \n- TRUEFFS from M-Systems for DiskOnChip devices  \n- SmartMedia DOS-FAT as defined by the SSFDC Forum  \n- UBIFS for bare NAND flash\n\n\n#### 1.1.2. Nor Flash\n在通信方式上Nor Flash 分为两种类型：CFI Flash和 SPI Flash。\n_CFI Flash_\n英文全称是common flash interface,也就是公共闪存接口，是由存储芯片工业界定义的一种获取闪存芯片物理参数和结构参数的操作规程和标准。CFI有许多关于闪存芯片的规定，有利于嵌入式对FLASH的编程。现在的很多NOR FLASH 都支持CFI，但并不是所有的都支持。  \n\nCFI接口，相对于串口的SPI来说，也被称为parallel接口，并行接口；另外，CFI接口是JEDEC定义的，所以，有的又成CFI接口为JEDEC接口。所以，可以简单理解为：对于Nor Flash来说，CFI接口＝JEDEC接口＝Parallel接口 = 并行接口\n\n_SPI Flash_\nserial peripheral interface串行外围设备接口,是一种常见的时钟同步串行通信接口。\n\n_两者不同处_\nCFI接口的的Nor Flash的针脚较多，芯片较大。之所有会有SPI接口, 可以减少针脚数目，减少芯片封装大小，采用了SPI后的Nor Flash，针脚只有8个。SPI容量都不是很大，读写速度慢，但是价格便宜，操作简单。而parallel接口速度快，容量上市场上已经有1Gmbit的容量，价格昂贵。\n\n## 2. 延伸扩展  \n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=47c8a31259ee3d6d36cb8f99227f0647/e1fe9925bc315c60225ddb5a8db1cb13485477be.jpg)\n\n### 2.1. SSD [SATA](https://baike.baidu.com/item/SATA) 接口 （串行口）  \n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=226f2bbbb13533faf5b6942890d2fdca/d53f8794a4c27d1ee9ac99711bd5ad6edcc438f8.jpg)\n\n### 2.2. SSD [NVME](https://baike.baidu.com/item/NVMe/20293531) 接口 （PCIe 口）\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=61b517595866d0166a14967af642bf62/cefc1e178a82b90112fe57a7798da9773812efd7.jpg)\n\n[SSD技术扫盲之：什么是NVMe？ NVMe SSD有什么特点？](http://www.chinastor.com/baike/ssd/04103A942017.html)\n\n## 3. Kernel MTD Source code\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/block%20device%20vs%20mtd%20device.png)\n\nKernel 中MTD 的源码如下图所示：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_source_code_tree.png)\n\nMTD 组成的源代码框架如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_source_code_structure.png)\n\n项目 | 说明 \n:-: | :-\nFTL | Flash Translation Layer, 需要PCMCIA 硬件授权专利\nNFTL | Nand flash translation layer, 需要DiskOnChip 硬件授权专利\nINFTL | Inverse Nand flash translation layer, 需要DiskOnChip 硬件授权专利\nspi-nor | spi nor flash source code\nchips, maps | CFI Nor Flash\nnand | nand flash\nubi | unsorted block images, 基于raw flash 的卷管理系统\n\n在mtd 目录下还有一些有意思的code, 他们分别是：\n- mtdconcat.c 将多个MTD 设备组成一个MTD， 功能类似于rapid 磁盘阵列  \n- cmdlinepart.c 提供解析启动参数中的MTD 信息  \n- mtdswap.c  交换分区，用于wear leveling 记录erase counter， 但UBI 已经具备此功能\n- mtdsuper.c  用于向fs/jffs2, fs/romfs 提供挂载接口\n\n## 4. 源代码框架\nKernel MTD 在Kernel 中的结构如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd%20softeware%20structure.png)\n\n在MTD Sub-system 中的结构如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_structure.png)\n\nmtdchar.c 向flash tools 或者用户层提供IOCTL 操作。\nmtdblock.c 向kernel 提供block read/write sector访问。\n\n他们两者的动态加载是通过mtdcore.c 中的add_mtd_device()函数。 例如在mtdblock.c 中：\n```c\nstatic struct mtd_notifier blktrans_notifier = {\n\t.add = blktrans_notify_add,\n\t.remove = blktrans_notify_remove,\n};\n\nint register_mtd_blktrans(struct mtd_blktrans_ops *tr)\n{\n    ...\n    register_mtd_user(&blktrans_notifier);\n}\n```\n在mtdcore.c 中\n```c\nint add_mtd_device(struct mtd_info *mtd)\n{\n\n    /* register char dev node */\n\tmtd->dev.type = &mtd_devtype;\n\tmtd->dev.class = &mtd_class;\n\tmtd->dev.devt = MTD_DEVT(i);\n\tdev_set_name(&mtd->dev, \"mtd%d\", i);\n\tdev_set_drvdata(&mtd->dev, mtd);\n\tif (device_register(&mtd->dev) != 0)\n\t\tgoto fail_added;\n\n    /* call mtd_notifiers, so it will call mtdblock.c blktrans_notify_add() */\n\tlist_for_each_entry(not, &mtd_notifiers, list)\n\t\tnot->add(mtd);\n}\n```\n大致流程如下图所示：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/register%20partition.png)\n\n注册相关数据结构：\n```c\nstruct mtd_part {\n\tstruct mtd_info mtd;\n\tstruct mtd_info *master;\n\tuint64_t offset;\n\tstruct list_head list;\n};\n\nstruct mtd_partition {\n\tconst char *name;\t\t/* identifier string */\n\tuint64_t size;\t\t\t/* partition size */\n\tuint64_t offset;\t\t/* offset within the master MTD space */\n\tuint32_t mask_flags;\t\t/* master MTD flags to mask out for this partition */\n\tstruct nand_ecclayout *ecclayout;\t/* out of band layout for this partition (NAND only) */\n};\n```\n## 参看资源：  \n[OneNAND](https://blog.csdn.net/programxiao/article/details/6214607)\n\n[三星OneNAND技术](https://www.chinaflashmarket.com/Instructor/102570)\n\n[Nand Flash，Nor Flash，CFI Flash，SPI Flash 之间的关系](https://www.cnblogs.com/zhangj95/p/5649518.html) \n\n[CFI与SPI flash区别](https://blog.csdn.net/pine222/article/details/47090041)\n\n[MTD 官网](http://www.linux-mtd.infradead.org/doc/general.html)","slug":"kernel-mtd","published":1,"updated":"2020-03-11T03:04:01.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qr0039zkgr75zmklsk","content":"<h2 id=\"1-Flash-大致分类\"><a href=\"#1-Flash-大致分类\" class=\"headerlink\" title=\"1. Flash 大致分类\"></a>1. Flash 大致分类</h2><ul>\n<li>Nor Flash (intel 开发)</li>\n<li>Nand Flash (Toshiba 开发)</li>\n<li>OneNand Flash(Samsung 开发)</li>\n</ul>\n<a id=\"more\"></a>\n<p>NAND Flash在容量、功耗、使用寿命、写速度快、芯片面积小、单元密度高、擦除速度快、成本低等方面的优势使其成为高数据存储密度的理想解决方案。<br>NOR Flash的传输效率很高，但写入和擦除速度较低；</p>\n<p>OneNAND结合了NAND存储密度高、写入速度快和NOR读取速度快的优点，整体性能完全超越常规的NAND和NOR。<br><strong>OneNAND采用NAND逻辑结构的存储内核和NOR的控制接口，并直接在系统内整合一定容量SRAM静态随即存储器作为高速缓冲区。</strong></p>\n<p>当OneNAND执行程序时，代码必须从OneNAND存储核心载入到SRAM，然后在SRAM上执行。由于SRAM的速度优势，数据载入动作几乎可以在瞬间完成，用户感觉不到迟滞现象，加上SRAM被直接封装在OneNAND芯片内部，外界看起来就好像是OneNAND也具备程序的本地执行功能。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Flash</th>\n<th style=\"text-align:center\">读</th>\n<th style=\"text-align:center\">写</th>\n<th style=\"text-align:center\">擦除</th>\n<th style=\"text-align:center\">坏块</th>\n<th style=\"text-align:center\">XIP(eXecute In Place)</th>\n<th style=\"text-align:center\">容量</th>\n<th style=\"text-align:center\">寿命</th>\n<th style=\"text-align:center\">成本 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Nor Flash</td>\n<td style=\"text-align:center\">100MBps</td>\n<td style=\"text-align:center\">0.5MBps</td>\n<td style=\"text-align:center\">0.3MBps</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">YES</td>\n<td style=\"text-align:center\">常见&lt;= 32M</td>\n<td style=\"text-align:center\">10几万</td>\n<td style=\"text-align:center\">较高</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Nand Flash</td>\n<td style=\"text-align:center\">15MBps</td>\n<td style=\"text-align:center\">7MBps</td>\n<td style=\"text-align:center\">64MBps</td>\n<td style=\"text-align:center\">有</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">大容量</td>\n<td style=\"text-align:center\">100万</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OneNand Flash</td>\n<td style=\"text-align:center\">100MBps</td>\n<td style=\"text-align:center\">10MBps</td>\n<td style=\"text-align:center\">64MBps</td>\n<td style=\"text-align:center\">有</td>\n<td style=\"text-align:center\">YES</td>\n<td style=\"text-align:center\">较大容量</td>\n<td style=\"text-align:center\">100万</td>\n<td style=\"text-align:center\">较低</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-1-总线接口\"><a href=\"#1-1-总线接口\" class=\"headerlink\" title=\"1.1. 总线接口\"></a>1.1. 总线接口</h3><h4 id=\"1-1-1-Nand-Flash\"><a href=\"#1-1-1-Nand-Flash\" class=\"headerlink\" title=\"1.1.1. Nand Flash\"></a>1.1.1. Nand Flash</h4><p>Nand Flash 常见有：</p>\n<ul>\n<li>总线接口Flash    </li>\n<li>SPI Flash<br>总线flash需要你的MCU上有外部总线接口，SPI flash就是通过SPI口对flash进行读写。<br>速度上，总线flash比SPI的快，但是SPI 芯片封装布局具有优势。</li>\n</ul>\n<p>如果Nand Flash 使用总线接口，一般pin 如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Pins</th>\n<th style=\"text-align:left\">Function  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">I/O 0-7(15)</td>\n<td style=\"text-align:left\">Data input or output(16 bit buswidth chips are supported in kernel)  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/CE</td>\n<td style=\"text-align:left\">Chip Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/CLE</td>\n<td style=\"text-align:left\">Command Latch Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ALE</td>\n<td style=\"text-align:left\">Address Latch Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/RE</td>\n<td style=\"text-align:left\">Read Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/WE</td>\n<td style=\"text-align:left\">Write Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/WP</td>\n<td style=\"text-align:left\">Write Protect  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/SE</td>\n<td style=\"text-align:left\">Spare area Enable ( link to GND)  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">R/B</td>\n<td style=\"text-align:left\">Ready / Busy Output  </td>\n</tr>\n</tbody>\n</table>\n<p>At the moment there are only a few filesystems which support NAND:</p>\n<ul>\n<li>JFFS2 and YAFFS for bare NAND Flash and SmartMediaCards  </li>\n<li>NTFL for DiskOnChip devices  </li>\n<li>TRUEFFS from M-Systems for DiskOnChip devices  </li>\n<li>SmartMedia DOS-FAT as defined by the SSFDC Forum  </li>\n<li>UBIFS for bare NAND flash</li>\n</ul>\n<h4 id=\"1-1-2-Nor-Flash\"><a href=\"#1-1-2-Nor-Flash\" class=\"headerlink\" title=\"1.1.2. Nor Flash\"></a>1.1.2. Nor Flash</h4><p>在通信方式上Nor Flash 分为两种类型：CFI Flash和 SPI Flash。<br><em>CFI Flash</em><br>英文全称是common flash interface,也就是公共闪存接口，是由存储芯片工业界定义的一种获取闪存芯片物理参数和结构参数的操作规程和标准。CFI有许多关于闪存芯片的规定，有利于嵌入式对FLASH的编程。现在的很多NOR FLASH 都支持CFI，但并不是所有的都支持。  </p>\n<p>CFI接口，相对于串口的SPI来说，也被称为parallel接口，并行接口；另外，CFI接口是JEDEC定义的，所以，有的又成CFI接口为JEDEC接口。所以，可以简单理解为：对于Nor Flash来说，CFI接口＝JEDEC接口＝Parallel接口 = 并行接口</p>\n<p><em>SPI Flash</em><br>serial peripheral interface串行外围设备接口,是一种常见的时钟同步串行通信接口。</p>\n<p><em>两者不同处</em><br>CFI接口的的Nor Flash的针脚较多，芯片较大。之所有会有SPI接口, 可以减少针脚数目，减少芯片封装大小，采用了SPI后的Nor Flash，针脚只有8个。SPI容量都不是很大，读写速度慢，但是价格便宜，操作简单。而parallel接口速度快，容量上市场上已经有1Gmbit的容量，价格昂贵。</p>\n<h2 id=\"2-延伸扩展\"><a href=\"#2-延伸扩展\" class=\"headerlink\" title=\"2. 延伸扩展\"></a>2. 延伸扩展</h2><p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=47c8a31259ee3d6d36cb8f99227f0647/e1fe9925bc315c60225ddb5a8db1cb13485477be.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-SSD-SATA-接口-（串行口）\"><a href=\"#2-1-SSD-SATA-接口-（串行口）\" class=\"headerlink\" title=\"2.1. SSD SATA 接口 （串行口）\"></a>2.1. SSD <a href=\"https://baike.baidu.com/item/SATA\" target=\"_blank\" rel=\"noopener\">SATA</a> 接口 （串行口）</h3><p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=226f2bbbb13533faf5b6942890d2fdca/d53f8794a4c27d1ee9ac99711bd5ad6edcc438f8.jpg\" alt=\"\"></p>\n<h3 id=\"2-2-SSD-NVME-接口-（PCIe-口）\"><a href=\"#2-2-SSD-NVME-接口-（PCIe-口）\" class=\"headerlink\" title=\"2.2. SSD NVME 接口 （PCIe 口）\"></a>2.2. SSD <a href=\"https://baike.baidu.com/item/NVMe/20293531\" target=\"_blank\" rel=\"noopener\">NVME</a> 接口 （PCIe 口）</h3><p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=61b517595866d0166a14967af642bf62/cefc1e178a82b90112fe57a7798da9773812efd7.jpg\" alt=\"\"></p>\n<p><a href=\"http://www.chinastor.com/baike/ssd/04103A942017.html\" target=\"_blank\" rel=\"noopener\">SSD技术扫盲之：什么是NVMe？ NVMe SSD有什么特点？</a></p>\n<h2 id=\"3-Kernel-MTD-Source-code\"><a href=\"#3-Kernel-MTD-Source-code\" class=\"headerlink\" title=\"3. Kernel MTD Source code\"></a>3. Kernel MTD Source code</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/block%20device%20vs%20mtd%20device.png\" alt=\"\"></p>\n<p>Kernel 中MTD 的源码如下图所示：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_source_code_tree.png\" alt=\"\"></p>\n<p>MTD 组成的源代码框架如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_source_code_structure.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">项目</th>\n<th style=\"text-align:left\">说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">FTL</td>\n<td style=\"text-align:left\">Flash Translation Layer, 需要PCMCIA 硬件授权专利</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NFTL</td>\n<td style=\"text-align:left\">Nand flash translation layer, 需要DiskOnChip 硬件授权专利</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">INFTL</td>\n<td style=\"text-align:left\">Inverse Nand flash translation layer, 需要DiskOnChip 硬件授权专利</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">spi-nor</td>\n<td style=\"text-align:left\">spi nor flash source code</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chips, maps</td>\n<td style=\"text-align:left\">CFI Nor Flash</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nand</td>\n<td style=\"text-align:left\">nand flash</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ubi</td>\n<td style=\"text-align:left\">unsorted block images, 基于raw flash 的卷管理系统</td>\n</tr>\n</tbody>\n</table>\n<p>在mtd 目录下还有一些有意思的code, 他们分别是：</p>\n<ul>\n<li>mtdconcat.c 将多个MTD 设备组成一个MTD， 功能类似于rapid 磁盘阵列  </li>\n<li>cmdlinepart.c 提供解析启动参数中的MTD 信息  </li>\n<li>mtdswap.c  交换分区，用于wear leveling 记录erase counter， 但UBI 已经具备此功能</li>\n<li>mtdsuper.c  用于向fs/jffs2, fs/romfs 提供挂载接口</li>\n</ul>\n<h2 id=\"4-源代码框架\"><a href=\"#4-源代码框架\" class=\"headerlink\" title=\"4. 源代码框架\"></a>4. 源代码框架</h2><p>Kernel MTD 在Kernel 中的结构如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd%20softeware%20structure.png\" alt=\"\"></p>\n<p>在MTD Sub-system 中的结构如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_structure.png\" alt=\"\"></p>\n<p>mtdchar.c 向flash tools 或者用户层提供IOCTL 操作。<br>mtdblock.c 向kernel 提供block read/write sector访问。</p>\n<p>他们两者的动态加载是通过mtdcore.c 中的add_mtd_device()函数。 例如在mtdblock.c 中：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_notifier</span> <span class=\"title\">blktrans_notifier</span> = &#123;</span></span><br><span class=\"line\">\t.add = blktrans_notify_add,</span><br><span class=\"line\">\t.remove = blktrans_notify_remove,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">register_mtd_blktrans</span><span class=\"params\">(struct mtd_blktrans_ops *tr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    register_mtd_user(&amp;blktrans_notifier);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在mtdcore.c 中<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add_mtd_device</span><span class=\"params\">(struct mtd_info *mtd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* register char dev node */</span></span><br><span class=\"line\">\tmtd-&gt;dev.type = &amp;mtd_devtype;</span><br><span class=\"line\">\tmtd-&gt;dev.class = &amp;mtd_class;</span><br><span class=\"line\">\tmtd-&gt;dev.devt = MTD_DEVT(i);</span><br><span class=\"line\">\tdev_set_name(&amp;mtd-&gt;dev, <span class=\"string\">\"mtd%d\"</span>, i);</span><br><span class=\"line\">\tdev_set_drvdata(&amp;mtd-&gt;dev, mtd);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (device_register(&amp;mtd-&gt;dev) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> fail_added;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* call mtd_notifiers, so it will call mtdblock.c blktrans_notify_add() */</span></span><br><span class=\"line\">\tlist_for_each_entry(<span class=\"keyword\">not</span>, &amp;mtd_notifiers, <span class=\"built_in\">list</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">not</span>-&gt;add(mtd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大致流程如下图所示：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/register%20partition.png\" alt=\"\"></p>\n<p>注册相关数据结构：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_part</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_info</span> <span class=\"title\">mtd</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_info</span> *<span class=\"title\">master</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> offset;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_partition</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;\t\t<span class=\"comment\">/* identifier string */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> size;\t\t\t<span class=\"comment\">/* partition size */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> offset;\t\t<span class=\"comment\">/* offset within the master MTD space */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> mask_flags;\t\t<span class=\"comment\">/* master MTD flags to mask out for this partition */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nand_ecclayout</span> *<span class=\"title\">ecclayout</span>;</span>\t<span class=\"comment\">/* out of band layout for this partition (NAND only) */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参看资源：\"><a href=\"#参看资源：\" class=\"headerlink\" title=\"参看资源：\"></a>参看资源：</h2><p><a href=\"https://blog.csdn.net/programxiao/article/details/6214607\" target=\"_blank\" rel=\"noopener\">OneNAND</a></p>\n<p><a href=\"https://www.chinaflashmarket.com/Instructor/102570\" target=\"_blank\" rel=\"noopener\">三星OneNAND技术</a></p>\n<p><a href=\"https://www.cnblogs.com/zhangj95/p/5649518.html\" target=\"_blank\" rel=\"noopener\">Nand Flash，Nor Flash，CFI Flash，SPI Flash 之间的关系</a> </p>\n<p><a href=\"https://blog.csdn.net/pine222/article/details/47090041\" target=\"_blank\" rel=\"noopener\">CFI与SPI flash区别</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/general.html\" target=\"_blank\" rel=\"noopener\">MTD 官网</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-Flash-大致分类\"><a href=\"#1-Flash-大致分类\" class=\"headerlink\" title=\"1. Flash 大致分类\"></a>1. Flash 大致分类</h2><ul>\n<li>Nor Flash (intel 开发)</li>\n<li>Nand Flash (Toshiba 开发)</li>\n<li>OneNand Flash(Samsung 开发)</li>\n</ul>","more":"<p>NAND Flash在容量、功耗、使用寿命、写速度快、芯片面积小、单元密度高、擦除速度快、成本低等方面的优势使其成为高数据存储密度的理想解决方案。<br>NOR Flash的传输效率很高，但写入和擦除速度较低；</p>\n<p>OneNAND结合了NAND存储密度高、写入速度快和NOR读取速度快的优点，整体性能完全超越常规的NAND和NOR。<br><strong>OneNAND采用NAND逻辑结构的存储内核和NOR的控制接口，并直接在系统内整合一定容量SRAM静态随即存储器作为高速缓冲区。</strong></p>\n<p>当OneNAND执行程序时，代码必须从OneNAND存储核心载入到SRAM，然后在SRAM上执行。由于SRAM的速度优势，数据载入动作几乎可以在瞬间完成，用户感觉不到迟滞现象，加上SRAM被直接封装在OneNAND芯片内部，外界看起来就好像是OneNAND也具备程序的本地执行功能。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Flash</th>\n<th style=\"text-align:center\">读</th>\n<th style=\"text-align:center\">写</th>\n<th style=\"text-align:center\">擦除</th>\n<th style=\"text-align:center\">坏块</th>\n<th style=\"text-align:center\">XIP(eXecute In Place)</th>\n<th style=\"text-align:center\">容量</th>\n<th style=\"text-align:center\">寿命</th>\n<th style=\"text-align:center\">成本 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Nor Flash</td>\n<td style=\"text-align:center\">100MBps</td>\n<td style=\"text-align:center\">0.5MBps</td>\n<td style=\"text-align:center\">0.3MBps</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">YES</td>\n<td style=\"text-align:center\">常见&lt;= 32M</td>\n<td style=\"text-align:center\">10几万</td>\n<td style=\"text-align:center\">较高</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Nand Flash</td>\n<td style=\"text-align:center\">15MBps</td>\n<td style=\"text-align:center\">7MBps</td>\n<td style=\"text-align:center\">64MBps</td>\n<td style=\"text-align:center\">有</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">大容量</td>\n<td style=\"text-align:center\">100万</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OneNand Flash</td>\n<td style=\"text-align:center\">100MBps</td>\n<td style=\"text-align:center\">10MBps</td>\n<td style=\"text-align:center\">64MBps</td>\n<td style=\"text-align:center\">有</td>\n<td style=\"text-align:center\">YES</td>\n<td style=\"text-align:center\">较大容量</td>\n<td style=\"text-align:center\">100万</td>\n<td style=\"text-align:center\">较低</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-1-总线接口\"><a href=\"#1-1-总线接口\" class=\"headerlink\" title=\"1.1. 总线接口\"></a>1.1. 总线接口</h3><h4 id=\"1-1-1-Nand-Flash\"><a href=\"#1-1-1-Nand-Flash\" class=\"headerlink\" title=\"1.1.1. Nand Flash\"></a>1.1.1. Nand Flash</h4><p>Nand Flash 常见有：</p>\n<ul>\n<li>总线接口Flash    </li>\n<li>SPI Flash<br>总线flash需要你的MCU上有外部总线接口，SPI flash就是通过SPI口对flash进行读写。<br>速度上，总线flash比SPI的快，但是SPI 芯片封装布局具有优势。</li>\n</ul>\n<p>如果Nand Flash 使用总线接口，一般pin 如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Pins</th>\n<th style=\"text-align:left\">Function  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">I/O 0-7(15)</td>\n<td style=\"text-align:left\">Data input or output(16 bit buswidth chips are supported in kernel)  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/CE</td>\n<td style=\"text-align:left\">Chip Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/CLE</td>\n<td style=\"text-align:left\">Command Latch Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ALE</td>\n<td style=\"text-align:left\">Address Latch Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/RE</td>\n<td style=\"text-align:left\">Read Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/WE</td>\n<td style=\"text-align:left\">Write Enable  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/WP</td>\n<td style=\"text-align:left\">Write Protect  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/SE</td>\n<td style=\"text-align:left\">Spare area Enable ( link to GND)  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">R/B</td>\n<td style=\"text-align:left\">Ready / Busy Output  </td>\n</tr>\n</tbody>\n</table>\n<p>At the moment there are only a few filesystems which support NAND:</p>\n<ul>\n<li>JFFS2 and YAFFS for bare NAND Flash and SmartMediaCards  </li>\n<li>NTFL for DiskOnChip devices  </li>\n<li>TRUEFFS from M-Systems for DiskOnChip devices  </li>\n<li>SmartMedia DOS-FAT as defined by the SSFDC Forum  </li>\n<li>UBIFS for bare NAND flash</li>\n</ul>\n<h4 id=\"1-1-2-Nor-Flash\"><a href=\"#1-1-2-Nor-Flash\" class=\"headerlink\" title=\"1.1.2. Nor Flash\"></a>1.1.2. Nor Flash</h4><p>在通信方式上Nor Flash 分为两种类型：CFI Flash和 SPI Flash。<br><em>CFI Flash</em><br>英文全称是common flash interface,也就是公共闪存接口，是由存储芯片工业界定义的一种获取闪存芯片物理参数和结构参数的操作规程和标准。CFI有许多关于闪存芯片的规定，有利于嵌入式对FLASH的编程。现在的很多NOR FLASH 都支持CFI，但并不是所有的都支持。  </p>\n<p>CFI接口，相对于串口的SPI来说，也被称为parallel接口，并行接口；另外，CFI接口是JEDEC定义的，所以，有的又成CFI接口为JEDEC接口。所以，可以简单理解为：对于Nor Flash来说，CFI接口＝JEDEC接口＝Parallel接口 = 并行接口</p>\n<p><em>SPI Flash</em><br>serial peripheral interface串行外围设备接口,是一种常见的时钟同步串行通信接口。</p>\n<p><em>两者不同处</em><br>CFI接口的的Nor Flash的针脚较多，芯片较大。之所有会有SPI接口, 可以减少针脚数目，减少芯片封装大小，采用了SPI后的Nor Flash，针脚只有8个。SPI容量都不是很大，读写速度慢，但是价格便宜，操作简单。而parallel接口速度快，容量上市场上已经有1Gmbit的容量，价格昂贵。</p>\n<h2 id=\"2-延伸扩展\"><a href=\"#2-延伸扩展\" class=\"headerlink\" title=\"2. 延伸扩展\"></a>2. 延伸扩展</h2><p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=47c8a31259ee3d6d36cb8f99227f0647/e1fe9925bc315c60225ddb5a8db1cb13485477be.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-SSD-SATA-接口-（串行口）\"><a href=\"#2-1-SSD-SATA-接口-（串行口）\" class=\"headerlink\" title=\"2.1. SSD SATA 接口 （串行口）\"></a>2.1. SSD <a href=\"https://baike.baidu.com/item/SATA\" target=\"_blank\" rel=\"noopener\">SATA</a> 接口 （串行口）</h3><p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=226f2bbbb13533faf5b6942890d2fdca/d53f8794a4c27d1ee9ac99711bd5ad6edcc438f8.jpg\" alt=\"\"></p>\n<h3 id=\"2-2-SSD-NVME-接口-（PCIe-口）\"><a href=\"#2-2-SSD-NVME-接口-（PCIe-口）\" class=\"headerlink\" title=\"2.2. SSD NVME 接口 （PCIe 口）\"></a>2.2. SSD <a href=\"https://baike.baidu.com/item/NVMe/20293531\" target=\"_blank\" rel=\"noopener\">NVME</a> 接口 （PCIe 口）</h3><p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=61b517595866d0166a14967af642bf62/cefc1e178a82b90112fe57a7798da9773812efd7.jpg\" alt=\"\"></p>\n<p><a href=\"http://www.chinastor.com/baike/ssd/04103A942017.html\" target=\"_blank\" rel=\"noopener\">SSD技术扫盲之：什么是NVMe？ NVMe SSD有什么特点？</a></p>\n<h2 id=\"3-Kernel-MTD-Source-code\"><a href=\"#3-Kernel-MTD-Source-code\" class=\"headerlink\" title=\"3. Kernel MTD Source code\"></a>3. Kernel MTD Source code</h2><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/block%20device%20vs%20mtd%20device.png\" alt=\"\"></p>\n<p>Kernel 中MTD 的源码如下图所示：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_source_code_tree.png\" alt=\"\"></p>\n<p>MTD 组成的源代码框架如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_source_code_structure.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">项目</th>\n<th style=\"text-align:left\">说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">FTL</td>\n<td style=\"text-align:left\">Flash Translation Layer, 需要PCMCIA 硬件授权专利</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NFTL</td>\n<td style=\"text-align:left\">Nand flash translation layer, 需要DiskOnChip 硬件授权专利</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">INFTL</td>\n<td style=\"text-align:left\">Inverse Nand flash translation layer, 需要DiskOnChip 硬件授权专利</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">spi-nor</td>\n<td style=\"text-align:left\">spi nor flash source code</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chips, maps</td>\n<td style=\"text-align:left\">CFI Nor Flash</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nand</td>\n<td style=\"text-align:left\">nand flash</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ubi</td>\n<td style=\"text-align:left\">unsorted block images, 基于raw flash 的卷管理系统</td>\n</tr>\n</tbody>\n</table>\n<p>在mtd 目录下还有一些有意思的code, 他们分别是：</p>\n<ul>\n<li>mtdconcat.c 将多个MTD 设备组成一个MTD， 功能类似于rapid 磁盘阵列  </li>\n<li>cmdlinepart.c 提供解析启动参数中的MTD 信息  </li>\n<li>mtdswap.c  交换分区，用于wear leveling 记录erase counter， 但UBI 已经具备此功能</li>\n<li>mtdsuper.c  用于向fs/jffs2, fs/romfs 提供挂载接口</li>\n</ul>\n<h2 id=\"4-源代码框架\"><a href=\"#4-源代码框架\" class=\"headerlink\" title=\"4. 源代码框架\"></a>4. 源代码框架</h2><p>Kernel MTD 在Kernel 中的结构如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd%20softeware%20structure.png\" alt=\"\"></p>\n<p>在MTD Sub-system 中的结构如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/mtd_structure.png\" alt=\"\"></p>\n<p>mtdchar.c 向flash tools 或者用户层提供IOCTL 操作。<br>mtdblock.c 向kernel 提供block read/write sector访问。</p>\n<p>他们两者的动态加载是通过mtdcore.c 中的add_mtd_device()函数。 例如在mtdblock.c 中：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_notifier</span> <span class=\"title\">blktrans_notifier</span> = &#123;</span></span><br><span class=\"line\">\t.add = blktrans_notify_add,</span><br><span class=\"line\">\t.remove = blktrans_notify_remove,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">register_mtd_blktrans</span><span class=\"params\">(struct mtd_blktrans_ops *tr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    register_mtd_user(&amp;blktrans_notifier);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在mtdcore.c 中<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add_mtd_device</span><span class=\"params\">(struct mtd_info *mtd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* register char dev node */</span></span><br><span class=\"line\">\tmtd-&gt;dev.type = &amp;mtd_devtype;</span><br><span class=\"line\">\tmtd-&gt;dev.class = &amp;mtd_class;</span><br><span class=\"line\">\tmtd-&gt;dev.devt = MTD_DEVT(i);</span><br><span class=\"line\">\tdev_set_name(&amp;mtd-&gt;dev, <span class=\"string\">\"mtd%d\"</span>, i);</span><br><span class=\"line\">\tdev_set_drvdata(&amp;mtd-&gt;dev, mtd);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (device_register(&amp;mtd-&gt;dev) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> fail_added;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* call mtd_notifiers, so it will call mtdblock.c blktrans_notify_add() */</span></span><br><span class=\"line\">\tlist_for_each_entry(<span class=\"keyword\">not</span>, &amp;mtd_notifiers, <span class=\"built_in\">list</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">not</span>-&gt;add(mtd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大致流程如下图所示：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mtd/register%20partition.png\" alt=\"\"></p>\n<p>注册相关数据结构：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_part</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_info</span> <span class=\"title\">mtd</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_info</span> *<span class=\"title\">master</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> offset;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mtd_partition</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;\t\t<span class=\"comment\">/* identifier string */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> size;\t\t\t<span class=\"comment\">/* partition size */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> offset;\t\t<span class=\"comment\">/* offset within the master MTD space */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> mask_flags;\t\t<span class=\"comment\">/* master MTD flags to mask out for this partition */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nand_ecclayout</span> *<span class=\"title\">ecclayout</span>;</span>\t<span class=\"comment\">/* out of band layout for this partition (NAND only) */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参看资源：\"><a href=\"#参看资源：\" class=\"headerlink\" title=\"参看资源：\"></a>参看资源：</h2><p><a href=\"https://blog.csdn.net/programxiao/article/details/6214607\" target=\"_blank\" rel=\"noopener\">OneNAND</a></p>\n<p><a href=\"https://www.chinaflashmarket.com/Instructor/102570\" target=\"_blank\" rel=\"noopener\">三星OneNAND技术</a></p>\n<p><a href=\"https://www.cnblogs.com/zhangj95/p/5649518.html\" target=\"_blank\" rel=\"noopener\">Nand Flash，Nor Flash，CFI Flash，SPI Flash 之间的关系</a> </p>\n<p><a href=\"https://blog.csdn.net/pine222/article/details/47090041\" target=\"_blank\" rel=\"noopener\">CFI与SPI flash区别</a></p>\n<p><a href=\"http://www.linux-mtd.infradead.org/doc/general.html\" target=\"_blank\" rel=\"noopener\">MTD 官网</a></p>"},{"title":"kernel-zero-copy","date":"2019-08-21T07:35:06.000Z","_content":"\n在看openssl 1.1.1c 版本源码时，看到有一个zero copy 的字样。这里zero copy(零拷贝)主要指Kernel space 与user space 之间的拷贝过程。\n\n\n<!--more-->\n\n### 1.Normal R/W\n\n```c\n#include <unistd.h>\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\n\n#include <sys/mman.h>\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\nint munmap(void *addr, size_t length);\n```\n\n在read/write 时，需要将userspace 的数据copy 到kernel space。kerne 中用到的函数就有：\n>copy_from_user()\ncopy_to_user()\n\n![normal read/write image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/normal%20read%20write.png)\n\nmmap() 能减少read 的copy 动作，直接映射kernel空间到用户空间，但是在write时， 还是需要将write_data_buffer 拷贝到kernel space.\n\n![mmap read/write image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/mmap%20read%20write.png)\n\n在拷贝文件时，我们可以这样减少copy 的次数。\n```c\nsize_t filesize = stat_buf.st_size;\nsource = mmap(0, filesize, PROT_READ, MAP_SHARED, f_in, 0);\ntarget = mmap(0, filesize, PROT_WRITE, MAP_SHARED, f_out, 0);\nmemcpy(target, source, filesize);\n```\n\n### 2.zero copy\n常见的zero copy 涉及到的函数有：\n- sendfile\n- vmsplice, splice\n- tee\n\n除vmsplice（） 是映射函数外，其他借助管道实现，而管道有众所周知的空间限制问题，超过了限制就会hang住，所以每次写入管道的数据量好严格控制，保守的建议值是一个内存页大小，即PAGE_SIZE, 常见为4k。\n\nsplice用于在两个文件间移动数据，而无需内核态和用户态的内存拷贝，但需要借助管道（pipe）实现。<font color=red>大概原理就是通过pipe buffer实现一组内核内存页（pages of kernel memory）的引用计数指针（reference-counted pointers），数据拷贝过程中并不真正拷贝数据，而是创建一个新的指向内存页的指针。也就是说拷贝过程实质是指针的拷贝.</font>\n\n![zero copy image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/splice%20read%20write.png)\n\n```c\n#include <sys/sendfile.h>\nssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n\n\n#include <fcntl.h>\n#include <sys/uio.h>\nssize_t vmsplice(int fd, const struct iovec *iov,unsigned long nr_segs, unsigned int flags);\n\n\n#include <fcntl.h>\nssize_t splice(int fd_in, loff_t *off_in, int fd_out,loff_t *off_out, size_t len, unsigned int flags);\n\n\n#include <fcntl.h>\nssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);                      \n```\n\nsystem api | remarks\n:-: | :-\nsendfile() | sendfile的in_fd必须指向支持mmap的文件，也就是真实存在的文件，而不能是socket、管道等文件\nsplice() | splice()函数可以在两个文件描述符之间移动数据，且 __其中一个描述符必须是管道描述符__\ntee() | 仅支持在<font color=red>两个管道描述符之间</font>复制数据\n\n\nsplice() 通过pipe 零拷贝文件的用例。\n\n>file_in -> pipe[1] (write end) -> pipe[0](read end) -> file_out\n\n```c\nint pipefd[2], off_in = 0, off_out = 0;\nint file_in, file_out, size, flags;\n\nfile_in = open(\"input_file\", O_RDONLY);\nfile_out = open(\"output_file\", O_RDWR);\n\npipe(pipefd);\n\nsplice(file_in, &off_in, pipefd[1], NULL, size, flags);\nsplice(pipefd[0], NULL, file_out, &off_out, size, flags);\n\nclose(file_in);\nclose(file_out);\nclose(pipefd[0]);\nclose(pipefd[1]);\n```\n\n### 参看资料\n\n[零复制(zero copy)技术](https://www.cnblogs.com/f-ck-need-u/p/7615914.html)\n\n[linux网络编程：splice函数和tee( )函数高效的零拷贝](https://www.cnblogs.com/kex1n/p/7446291.html)\n\n[Linux 中的零拷贝技术 splice](http://abcdxyzk.github.io/blog/2015/05/07/kernel-mm-splice/)\n\n![Linux 中的零拷贝技术，第 2 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/)\n\n[Linux下提高性能的系统调用sendfile，splice和tee](https://blog.csdn.net/wzjking0929/article/details/51831478)\n\n[splice and pipes](https://www.kernel.org/doc/html/latest/filesystems/splice.html)","source":"_posts/kernel-zero-copy.md","raw":"---\ntitle: kernel-zero-copy\ndate: 2019-08-21 15:35:06\ntags: \n    - memory\n    - kernel\ncategories: memory\n---\n\n在看openssl 1.1.1c 版本源码时，看到有一个zero copy 的字样。这里zero copy(零拷贝)主要指Kernel space 与user space 之间的拷贝过程。\n\n\n<!--more-->\n\n### 1.Normal R/W\n\n```c\n#include <unistd.h>\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\n\n#include <sys/mman.h>\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\nint munmap(void *addr, size_t length);\n```\n\n在read/write 时，需要将userspace 的数据copy 到kernel space。kerne 中用到的函数就有：\n>copy_from_user()\ncopy_to_user()\n\n![normal read/write image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/normal%20read%20write.png)\n\nmmap() 能减少read 的copy 动作，直接映射kernel空间到用户空间，但是在write时， 还是需要将write_data_buffer 拷贝到kernel space.\n\n![mmap read/write image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/mmap%20read%20write.png)\n\n在拷贝文件时，我们可以这样减少copy 的次数。\n```c\nsize_t filesize = stat_buf.st_size;\nsource = mmap(0, filesize, PROT_READ, MAP_SHARED, f_in, 0);\ntarget = mmap(0, filesize, PROT_WRITE, MAP_SHARED, f_out, 0);\nmemcpy(target, source, filesize);\n```\n\n### 2.zero copy\n常见的zero copy 涉及到的函数有：\n- sendfile\n- vmsplice, splice\n- tee\n\n除vmsplice（） 是映射函数外，其他借助管道实现，而管道有众所周知的空间限制问题，超过了限制就会hang住，所以每次写入管道的数据量好严格控制，保守的建议值是一个内存页大小，即PAGE_SIZE, 常见为4k。\n\nsplice用于在两个文件间移动数据，而无需内核态和用户态的内存拷贝，但需要借助管道（pipe）实现。<font color=red>大概原理就是通过pipe buffer实现一组内核内存页（pages of kernel memory）的引用计数指针（reference-counted pointers），数据拷贝过程中并不真正拷贝数据，而是创建一个新的指向内存页的指针。也就是说拷贝过程实质是指针的拷贝.</font>\n\n![zero copy image](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/splice%20read%20write.png)\n\n```c\n#include <sys/sendfile.h>\nssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n\n\n#include <fcntl.h>\n#include <sys/uio.h>\nssize_t vmsplice(int fd, const struct iovec *iov,unsigned long nr_segs, unsigned int flags);\n\n\n#include <fcntl.h>\nssize_t splice(int fd_in, loff_t *off_in, int fd_out,loff_t *off_out, size_t len, unsigned int flags);\n\n\n#include <fcntl.h>\nssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);                      \n```\n\nsystem api | remarks\n:-: | :-\nsendfile() | sendfile的in_fd必须指向支持mmap的文件，也就是真实存在的文件，而不能是socket、管道等文件\nsplice() | splice()函数可以在两个文件描述符之间移动数据，且 __其中一个描述符必须是管道描述符__\ntee() | 仅支持在<font color=red>两个管道描述符之间</font>复制数据\n\n\nsplice() 通过pipe 零拷贝文件的用例。\n\n>file_in -> pipe[1] (write end) -> pipe[0](read end) -> file_out\n\n```c\nint pipefd[2], off_in = 0, off_out = 0;\nint file_in, file_out, size, flags;\n\nfile_in = open(\"input_file\", O_RDONLY);\nfile_out = open(\"output_file\", O_RDWR);\n\npipe(pipefd);\n\nsplice(file_in, &off_in, pipefd[1], NULL, size, flags);\nsplice(pipefd[0], NULL, file_out, &off_out, size, flags);\n\nclose(file_in);\nclose(file_out);\nclose(pipefd[0]);\nclose(pipefd[1]);\n```\n\n### 参看资料\n\n[零复制(zero copy)技术](https://www.cnblogs.com/f-ck-need-u/p/7615914.html)\n\n[linux网络编程：splice函数和tee( )函数高效的零拷贝](https://www.cnblogs.com/kex1n/p/7446291.html)\n\n[Linux 中的零拷贝技术 splice](http://abcdxyzk.github.io/blog/2015/05/07/kernel-mm-splice/)\n\n![Linux 中的零拷贝技术，第 2 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/)\n\n[Linux下提高性能的系统调用sendfile，splice和tee](https://blog.csdn.net/wzjking0929/article/details/51831478)\n\n[splice and pipes](https://www.kernel.org/doc/html/latest/filesystems/splice.html)","slug":"kernel-zero-copy","published":1,"updated":"2019-08-26T09:45:10.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qt003czkgrqievcv6v","content":"<p>在看openssl 1.1.1c 版本源码时，看到有一个zero copy 的字样。这里zero copy(零拷贝)主要指Kernel space 与user space 之间的拷贝过程。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-Normal-R-W\"><a href=\"#1-Normal-R-W\" class=\"headerlink\" title=\"1.Normal R/W\"></a>1.Normal R/W</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> read(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> write(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> prot, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在read/write 时，需要将userspace 的数据copy 到kernel space。kerne 中用到的函数就有：</p>\n<blockquote>\n<p>copy_from_user()<br>copy_to_user()</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/normal%20read%20write.png\" alt=\"normal read/write image\"></p>\n<p>mmap() 能减少read 的copy 动作，直接映射kernel空间到用户空间，但是在write时， 还是需要将write_data_buffer 拷贝到kernel space.</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/mmap%20read%20write.png\" alt=\"mmap read/write image\"></p>\n<p>在拷贝文件时，我们可以这样减少copy 的次数。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">size_t</span> filesize = stat_buf.st_size;</span><br><span class=\"line\">source = mmap(<span class=\"number\">0</span>, filesize, PROT_READ, MAP_SHARED, f_in, <span class=\"number\">0</span>);</span><br><span class=\"line\">target = mmap(<span class=\"number\">0</span>, filesize, PROT_WRITE, MAP_SHARED, f_out, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">memcpy</span>(target, source, filesize);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-zero-copy\"><a href=\"#2-zero-copy\" class=\"headerlink\" title=\"2.zero copy\"></a>2.zero copy</h3><p>常见的zero copy 涉及到的函数有：</p>\n<ul>\n<li>sendfile</li>\n<li>vmsplice, splice</li>\n<li>tee</li>\n</ul>\n<p>除vmsplice（） 是映射函数外，其他借助管道实现，而管道有众所周知的空间限制问题，超过了限制就会hang住，所以每次写入管道的数据量好严格控制，保守的建议值是一个内存页大小，即PAGE_SIZE, 常见为4k。</p>\n<p>splice用于在两个文件间移动数据，而无需内核态和用户态的内存拷贝，但需要借助管道（pipe）实现。<font color=\"red\">大概原理就是通过pipe buffer实现一组内核内存页（pages of kernel memory）的引用计数指针（reference-counted pointers），数据拷贝过程中并不真正拷贝数据，而是创建一个新的指向内存页的指针。也就是说拷贝过程实质是指针的拷贝.</font></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/splice%20read%20write.png\" alt=\"zero copy image\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/sendfile.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> sendfile(<span class=\"keyword\">int</span> out_fd, <span class=\"keyword\">int</span> in_fd, <span class=\"keyword\">off_t</span> *offset, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/uio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> vmsplice(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec *iov,<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nr_segs, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> splice(<span class=\"keyword\">int</span> fd_in, <span class=\"keyword\">loff_t</span> *off_in, <span class=\"keyword\">int</span> fd_out,<span class=\"keyword\">loff_t</span> *off_out, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> tee(<span class=\"keyword\">int</span> fd_in, <span class=\"keyword\">int</span> fd_out, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">system api</th>\n<th style=\"text-align:left\">remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">sendfile()</td>\n<td style=\"text-align:left\">sendfile的in_fd必须指向支持mmap的文件，也就是真实存在的文件，而不能是socket、管道等文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">splice()</td>\n<td style=\"text-align:left\">splice()函数可以在两个文件描述符之间移动数据，且 <strong>其中一个描述符必须是管道描述符</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tee()</td>\n<td style=\"text-align:left\">仅支持在<font color=\"red\">两个管道描述符之间</font>复制数据</td>\n</tr>\n</tbody>\n</table>\n<p>splice() 通过pipe 零拷贝文件的用例。</p>\n<blockquote>\n<p>file_in -&gt; pipe[1] (write end) -&gt; pipe<a href=\"read end\">0</a> -&gt; file_out</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> pipefd[<span class=\"number\">2</span>], off_in = <span class=\"number\">0</span>, off_out = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> file_in, file_out, size, flags;</span><br><span class=\"line\"></span><br><span class=\"line\">file_in = open(<span class=\"string\">\"input_file\"</span>, O_RDONLY);</span><br><span class=\"line\">file_out = open(<span class=\"string\">\"output_file\"</span>, O_RDWR);</span><br><span class=\"line\"></span><br><span class=\"line\">pipe(pipefd);</span><br><span class=\"line\"></span><br><span class=\"line\">splice(file_in, &amp;off_in, pipefd[<span class=\"number\">1</span>], <span class=\"literal\">NULL</span>, size, flags);</span><br><span class=\"line\">splice(pipefd[<span class=\"number\">0</span>], <span class=\"literal\">NULL</span>, file_out, &amp;off_out, size, flags);</span><br><span class=\"line\"></span><br><span class=\"line\">close(file_in);</span><br><span class=\"line\">close(file_out);</span><br><span class=\"line\">close(pipefd[<span class=\"number\">0</span>]);</span><br><span class=\"line\">close(pipefd[<span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://www.cnblogs.com/f-ck-need-u/p/7615914.html\" target=\"_blank\" rel=\"noopener\">零复制(zero copy)技术</a></p>\n<p><a href=\"https://www.cnblogs.com/kex1n/p/7446291.html\" target=\"_blank\" rel=\"noopener\">linux网络编程：splice函数和tee( )函数高效的零拷贝</a></p>\n<p><a href=\"http://abcdxyzk.github.io/blog/2015/05/07/kernel-mm-splice/\" target=\"_blank\" rel=\"noopener\">Linux 中的零拷贝技术 splice</a></p>\n<p><img src=\"https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/\" alt=\"Linux 中的零拷贝技术，第 2 部分\"></p>\n<p><a href=\"https://blog.csdn.net/wzjking0929/article/details/51831478\" target=\"_blank\" rel=\"noopener\">Linux下提高性能的系统调用sendfile，splice和tee</a></p>\n<p><a href=\"https://www.kernel.org/doc/html/latest/filesystems/splice.html\" target=\"_blank\" rel=\"noopener\">splice and pipes</a></p>\n","site":{"data":{}},"excerpt":"<p>在看openssl 1.1.1c 版本源码时，看到有一个zero copy 的字样。这里zero copy(零拷贝)主要指Kernel space 与user space 之间的拷贝过程。</p>","more":"<h3 id=\"1-Normal-R-W\"><a href=\"#1-Normal-R-W\" class=\"headerlink\" title=\"1.Normal R/W\"></a>1.Normal R/W</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> read(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> write(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> prot, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在read/write 时，需要将userspace 的数据copy 到kernel space。kerne 中用到的函数就有：</p>\n<blockquote>\n<p>copy_from_user()<br>copy_to_user()</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/normal%20read%20write.png\" alt=\"normal read/write image\"></p>\n<p>mmap() 能减少read 的copy 动作，直接映射kernel空间到用户空间，但是在write时， 还是需要将write_data_buffer 拷贝到kernel space.</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/mmap%20read%20write.png\" alt=\"mmap read/write image\"></p>\n<p>在拷贝文件时，我们可以这样减少copy 的次数。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">size_t</span> filesize = stat_buf.st_size;</span><br><span class=\"line\">source = mmap(<span class=\"number\">0</span>, filesize, PROT_READ, MAP_SHARED, f_in, <span class=\"number\">0</span>);</span><br><span class=\"line\">target = mmap(<span class=\"number\">0</span>, filesize, PROT_WRITE, MAP_SHARED, f_out, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">memcpy</span>(target, source, filesize);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-zero-copy\"><a href=\"#2-zero-copy\" class=\"headerlink\" title=\"2.zero copy\"></a>2.zero copy</h3><p>常见的zero copy 涉及到的函数有：</p>\n<ul>\n<li>sendfile</li>\n<li>vmsplice, splice</li>\n<li>tee</li>\n</ul>\n<p>除vmsplice（） 是映射函数外，其他借助管道实现，而管道有众所周知的空间限制问题，超过了限制就会hang住，所以每次写入管道的数据量好严格控制，保守的建议值是一个内存页大小，即PAGE_SIZE, 常见为4k。</p>\n<p>splice用于在两个文件间移动数据，而无需内核态和用户态的内存拷贝，但需要借助管道（pipe）实现。<font color=\"red\">大概原理就是通过pipe buffer实现一组内核内存页（pages of kernel memory）的引用计数指针（reference-counted pointers），数据拷贝过程中并不真正拷贝数据，而是创建一个新的指向内存页的指针。也就是说拷贝过程实质是指针的拷贝.</font></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_zero_copy/splice%20read%20write.png\" alt=\"zero copy image\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/sendfile.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> sendfile(<span class=\"keyword\">int</span> out_fd, <span class=\"keyword\">int</span> in_fd, <span class=\"keyword\">off_t</span> *offset, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/uio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> vmsplice(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec *iov,<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nr_segs, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> splice(<span class=\"keyword\">int</span> fd_in, <span class=\"keyword\">loff_t</span> *off_in, <span class=\"keyword\">int</span> fd_out,<span class=\"keyword\">loff_t</span> *off_out, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> tee(<span class=\"keyword\">int</span> fd_in, <span class=\"keyword\">int</span> fd_out, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">system api</th>\n<th style=\"text-align:left\">remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">sendfile()</td>\n<td style=\"text-align:left\">sendfile的in_fd必须指向支持mmap的文件，也就是真实存在的文件，而不能是socket、管道等文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">splice()</td>\n<td style=\"text-align:left\">splice()函数可以在两个文件描述符之间移动数据，且 <strong>其中一个描述符必须是管道描述符</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tee()</td>\n<td style=\"text-align:left\">仅支持在<font color=\"red\">两个管道描述符之间</font>复制数据</td>\n</tr>\n</tbody>\n</table>\n<p>splice() 通过pipe 零拷贝文件的用例。</p>\n<blockquote>\n<p>file_in -&gt; pipe[1] (write end) -&gt; pipe<a href=\"read end\">0</a> -&gt; file_out</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> pipefd[<span class=\"number\">2</span>], off_in = <span class=\"number\">0</span>, off_out = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> file_in, file_out, size, flags;</span><br><span class=\"line\"></span><br><span class=\"line\">file_in = open(<span class=\"string\">\"input_file\"</span>, O_RDONLY);</span><br><span class=\"line\">file_out = open(<span class=\"string\">\"output_file\"</span>, O_RDWR);</span><br><span class=\"line\"></span><br><span class=\"line\">pipe(pipefd);</span><br><span class=\"line\"></span><br><span class=\"line\">splice(file_in, &amp;off_in, pipefd[<span class=\"number\">1</span>], <span class=\"literal\">NULL</span>, size, flags);</span><br><span class=\"line\">splice(pipefd[<span class=\"number\">0</span>], <span class=\"literal\">NULL</span>, file_out, &amp;off_out, size, flags);</span><br><span class=\"line\"></span><br><span class=\"line\">close(file_in);</span><br><span class=\"line\">close(file_out);</span><br><span class=\"line\">close(pipefd[<span class=\"number\">0</span>]);</span><br><span class=\"line\">close(pipefd[<span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n<h3 id=\"参看资料\"><a href=\"#参看资料\" class=\"headerlink\" title=\"参看资料\"></a>参看资料</h3><p><a href=\"https://www.cnblogs.com/f-ck-need-u/p/7615914.html\" target=\"_blank\" rel=\"noopener\">零复制(zero copy)技术</a></p>\n<p><a href=\"https://www.cnblogs.com/kex1n/p/7446291.html\" target=\"_blank\" rel=\"noopener\">linux网络编程：splice函数和tee( )函数高效的零拷贝</a></p>\n<p><a href=\"http://abcdxyzk.github.io/blog/2015/05/07/kernel-mm-splice/\" target=\"_blank\" rel=\"noopener\">Linux 中的零拷贝技术 splice</a></p>\n<p><img src=\"https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/\" alt=\"Linux 中的零拷贝技术，第 2 部分\"></p>\n<p><a href=\"https://blog.csdn.net/wzjking0929/article/details/51831478\" target=\"_blank\" rel=\"noopener\">Linux下提高性能的系统调用sendfile，splice和tee</a></p>\n<p><a href=\"https://www.kernel.org/doc/html/latest/filesystems/splice.html\" target=\"_blank\" rel=\"noopener\">splice and pipes</a></p>"},{"title":"kernel_slub","date":"2020-03-16T10:04:28.000Z","_content":"\n![slab allocator](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slab.jpg)\n\n<!--more-->\n## 1. 前言\n在linux mm 的分配主要有两种算法：伙伴算法(buddy system), slab alloctor。\n\n伙伴算法 | slab 分配器\n:- | :-\n以页为单位进行管理分配 | 以字节为单位，8B, 16B, 32B, ... 192B等\n\nslab alloctor 从linux 的发展看已有三种分配策略：\n- slab  \n- slub \n- slob\n\n>Q: 为什么出现slab?\nA: 伙伴算法管理粒度page 为单位， slab 的出现是为了管理小size 的内存\n\n>Q: 为什么出现slub, slob?\nslab 管理数据复杂， 不支持NUMA(Non unified memory arcihtecture), 调试困难。\nslub 对算法做了简化，针对SMP， NUMA系统优化，slub 对slab 的API 兼容。\nslob 用于小size 的mm 上管理内存。\n\n因此， 下面主要分析slub 分配算法。\n\n## 2. data structure\nslab 相当于零售商，`struct kmem_cache`下有两个部门，仓库 `struct kmem_cache_node`, 营业厅`struct kmem_cache_cpu`。营业厅销售某种类型的object(如8 byte， 16 byte ...， 具体的size 有零售商slab `struct kmem_cache` 决定), 我们可以从如下的`kmem_cache_create()` 函数看出`strcut kmem_cache`与size 的关系。\n\n```c\nstruct kmem_cache *kmem_cache_create(const char *name,\n\t\tsize_t size,\n\t\tsize_t align,\n\t\tunsigned long flags,\n\t\tvoid (*ctor)(void *));\nvoid kmem_cache_destroy(struct kmem_cache *);\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, int flags);\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp);\n```\n\n![slub data structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_data_structure.png)\n\n```c\n/* Slab cache management. */\nstruct kmem_cache {\n\tstruct kmem_cache_cpu __percpu *cpu_slab;\n\t/* Used for retriving partial slabs etc */\n\tunsigned long flags;\n\tunsigned long min_partial;\n\tint size;\t\t/* The size of an object including meta data */\n\tint object_size;\t/* The size of an object without meta data */\n\tint offset;\t\t/* Free pointer offset. */\n\t/* Number of per cpu partial objects to keep around */\n\tunsigned int cpu_partial;\n\tstruct kmem_cache_order_objects oo;\n\n\t/* Allocation and freeing of slabs */\n\tstruct kmem_cache_order_objects max;\n\tstruct kmem_cache_order_objects min;\n\tgfp_t allocflags;\t/* gfp flags to use on each alloc */\n\tint refcount;\t\t/* Refcount for slab cache destroy */\n\tvoid (*ctor)(void *);\n\tint inuse;\t\t/* Offset to metadata */\n\tint align;\t\t/* Alignment */\n\tint reserved;\t\t/* Reserved bytes at the end of slabs */\n\tconst char *name;\t/* Name (only for display!) */\n\tstruct list_head list;\t/* List of slab caches */\n\tint red_left_pad;\t/* Left redzone padding size */\n\n#ifdef CONFIG_NUMA\n\t/* Defragmentation by allocating from a remote node.*/\n\tint remote_node_defrag_ratio;\n#endif\n\tstruct kmem_cache_node *node[MAX_NUMNODES];\n};\n```\n`struct kmem_cache_cpu __percpu *cpu_slab` 中限定<font color=red>__percpu</font> 指明了是每一个CPU，可以理解为本地缓冲池。\n\n`struct kmem_cache_node *node[MAX_NUMNODES];` 是所有CPU 共享的， 而__percpu *cpu_slab 是每个CPU 独占的。\n\n```c\nstruct kmem_cache_cpu {\n\tvoid **freelist;\t/* Pointer to next available object */\n\tunsigned long tid;\t/* Globally unique transaction id */\n\tstruct page *page;\t/* The slab from which we are allocating */\n\tstruct page *partial;\t/* Partially allocated frozen slabs */\n};\n```\n当从full object 上free 时，*partial 将会指向此page。`struct kmem_cache` 中**cpu_partial** 将会限制 * partial 的total 数目，过多的 * partial 将会回收到`struct kemem_cache_node` 仓库中。\n\n```c\n/*\n * The slab lists for all objects.\n */\nstruct kmem_cache_node {\n\tspinlock_t list_lock;\n#ifdef CONFIG_SLAB\n\t...\n#endif\n\n#ifdef CONFIG_SLUB\n\tunsigned long nr_partial;\n\tstruct list_head partial;\n#endif\n};\n```\npartial 指向仍有空闲object page， 当nr_partial 大于`struct kmem_cache` 中**min_partial** 时，完全free object 的page 将会伙伴系统回收。\n\n## 3. work flow\n slub把内存分组管理，每个组分别包含2^3、2^4、...2^11个字节，在4K页大小的默认情况下，另外还有两个特殊的组，分别是96B和192B，共11组。之所以这样分配是因为如果申请2^12B大小的内存，就可以使用伙伴系统提供的接口直接申请一个完整的页面即可。\n\n### 3.1. allocate\n当内存申请的时候，优先从本地cpu缓存池申请。在分配初期，本地缓存池为空，自然从伙伴系统分配一定页数的内存。kmem_cacche_cpu中page就会指向正在使用的slab的页帧。freelist成员指向第一个可用内存object首地址。\n\n1. kmem_cache 初始阶段，没有对象可分配时，从伙伴系统获取一个slab\n![slub_allocate_from_buddy_system](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_buddy_system.png)\n\n2. 若kmem_cache_cpu 中无可用object时，尝试从kmem_cache_cpu 指向仍有可用object 的partial 获取\n![slub_allocate_from_kmem_cache_cpu_partial](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_kmem_cache_cpu_partial.png)\n\n3. 若kmem_cache_cpu 与 partial 中无可用object时，尝试从kmem_cache_node 获取\n![slub_allocate_from_kmem_cache_node](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_kmem_cache_node.png)\n\n### 3.2. free\n我们再free 时，free 的对象可能来自：\n- full object page\n- kmem_cache_cpu\n- kmem_cache_cpu partial\n- kmem_cache_node\n\n总的原则是：kmem_cache_cpu 保有一定量的partial， kmem_cache_node 保有一定量partial\n- free full 中object， 将kmem_cache_cpu partial 指向他\n- 若kmem_cache_cpu partial 数目大于kmem_cache 中cpu_partial 时，将多的partial 放置到仓库kmem_cache_node\n- 若kmem_cache_node partial 数目大于kmem_cache 中min_partial 时，则将free page 给budy system\n\n1. free object in kmem_cache_cpu partial && kmem_cache_cpu && kmem_cache_node\n直接标记该object 为free 状态\n![free object in kmem_cahce_cpu](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/free_object_in_kmem_cache_cpu.png)\n\n2. free object in full object page\n![free object in full object page](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/free_object_in_full_objects.png)\n\n若kmem_cache_cpu partial 数目多于设定kmem_cache cpu_partial， 则将存储指仓库kmem_cache_node\n![kmem_cache_cpu_partial_great_than_cpu_partial](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kmem_cache_cpu_partial_great_than_cpu_partial.png)\n\n若仓库中堆满，kmem_cache_node partial 数目多于设定kmem_cache min_partial，则将规划至伙伴系统\n![kmem_cache_node_partial_great_than_min_partial](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kmem_cache_node_partial_great_than_min_partial.png)\n\n我们可以看看kmalloc 的实现, 其中返回`kmalloc_caches[index]`， 那他是在哪里被初始化呢？\n\n```c\nstruct kmem_cache *kmalloc_caches[KMALLOC_SHIFT_HIGH + 1];\nEXPORT_SYMBOL(kmalloc_caches);\n\nstatic __always_inline void *kmalloc(size_t size, gfp_t flags)\n{\n\tif (__builtin_constant_p(size)) {\n\t\tif (size > KMALLOC_MAX_CACHE_SIZE)\n\t\t\treturn kmalloc_large(size, flags);\n#ifndef CONFIG_SLOB\n\t\tif (!(flags & GFP_DMA)) {\n\t\t\tint index = kmalloc_index(size);\n\n\t\t\tif (!index)\n\t\t\t\treturn ZERO_SIZE_PTR;\n\n\t\t\treturn kmem_cache_alloc_trace(kmalloc_caches[index],\n\t\t\t\t\tflags, size);\n\t\t}\n#endif\n\t}\n\treturn __kmalloc(size, flags);\n}\n```\n\n在slub.c\n```c\n/** linux/mm/slub.c*/\nvoid __init kmem_cache_init(void)\n{\n    ...\n    create_kmalloc_caches(0); \n}\n\nvoid __init create_kmalloc_caches(unsigned long flags)\n{\n\tint i;\n\tfor (i = KMALLOC_SHIFT_LOW; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\tif (!kmalloc_caches[i])\n\t\t\tnew_kmalloc_cache(i, flags);\n\n\t\t/*\n\t\t * Caches that are not of the two-to-the-power-of size.\n\t\t * These have to be created immediately after the\n\t\t * earlier power of two caches\n\t\t */\n\t\tif (KMALLOC_MIN_SIZE <= 32 && !kmalloc_caches[1] && i == 6)\n\t\t\tnew_kmalloc_cache(1, flags);\n\t\tif (KMALLOC_MIN_SIZE <= 64 && !kmalloc_caches[2] && i == 7)\n\t\t\tnew_kmalloc_cache(2, flags);\n\t}\n\n\t/* Kmalloc array is now usable */\n\tslab_state = UP;\n}\n\n/*\n * kmalloc_info[] is to make slub_debug=,kmalloc-xx option work at boot time.\n * kmalloc_index() supports up to 2^26=64MB, so the final entry of the table is\n * kmalloc-67108864.\n */\nstatic struct {\n\tconst char *name;\n\tunsigned long size;\n} const kmalloc_info[] __initconst = {\n\t{NULL,                      0},\t\t{\"kmalloc-96\",             96},\n\t{\"kmalloc-192\",           192},\t\t{\"kmalloc-8\",               8},\n\t{\"kmalloc-16\",             16},\t\t{\"kmalloc-32\",             32},\n\t{\"kmalloc-64\",             64},\t\t{\"kmalloc-128\",           128},\n\t{\"kmalloc-256\",           256},\t\t{\"kmalloc-512\",           512},\n\t{\"kmalloc-1024\",         1024},\t\t{\"kmalloc-2048\",         2048},\n\t{\"kmalloc-4096\",         4096},\t\t{\"kmalloc-8192\",         8192},\n\t{\"kmalloc-16384\",       16384},\t\t{\"kmalloc-32768\",       32768},\n\t{\"kmalloc-65536\",       65536},\t\t{\"kmalloc-131072\",     131072},\n\t{\"kmalloc-262144\",     262144},\t\t{\"kmalloc-524288\",     524288},\n\t{\"kmalloc-1048576\",   1048576},\t\t{\"kmalloc-2097152\",   2097152},\n\t{\"kmalloc-4194304\",   4194304},\t\t{\"kmalloc-8388608\",   8388608},\n\t{\"kmalloc-16777216\", 16777216},\t\t{\"kmalloc-33554432\", 33554432},\n\t{\"kmalloc-67108864\", 67108864}\n};\nstatic void __init new_kmalloc_cache(int idx, unsigned long flags)\n{\n\tkmalloc_caches[idx] = create_kmalloc_cache(kmalloc_info[idx].name,\n\t\t\t\t\tkmalloc_info[idx].size, flags);\n}\n```\n后面的`create_kmalloc_cache()`，则是尝试找到freelist, 例如从kmem_cache_cpu freelist， partial获取object， 若都为空则使用new_slab()->alloc_slab_page()->alloc_pages() 分配page 生成free objects。\n\n## 4. 调试手段\n\n### 4.1. SLUB_DEBUG\n\nSLUB DEBUG检测oob(out-of-bounds)问题原理:<font color=red>在分配出去的内存尾部添加额外空间--red zone, 并填充MAGIC，之后检测其内容。</font>\n\nSLUB DEBUG 检测uaf(use-after-free)问题原理：<font color=red>free 后，将object 数据填充MAGIC NUM(0X6B)</font>\n\nslub 管理的object 对象的格式如下：\n![slub object format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_debug_object_structure.png)\n\nfree pointer是从object后移就是因为为了检测use-after-free问题,当free object时会在将object填充magic num(0x6b)。\n\n`red zone`\n可以检测向后的越界访问\n\n`red left pad`\n可以检测向前的越界访问\n\n![red zone && red left pad](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/red_zone_red_left_pad.png)\n\n`padding`\n填充填充magic num，可以检测较大空间的overwritten\n\n`Magic number`\n```c\n//linux/include/linux/poison.h\n\n#define SLUB_RED_INACTIVE\t0xbb\n#define SLUB_RED_ACTIVE\t\t0xcc\n\n/* ...and for poisoning */\n#define\tPOISON_INUSE\t0x5a\t/* for use-uninitialised poisoning */\n#define POISON_FREE\t0x6b\t/* for use-after-free poisoning */\n#define\tPOISON_END\t0xa5\t/* end-byte of poisoning */\n```\n在slub alloc 一个object，经过init_object 填充magic num 后，会如下所示：\n![slub object after init object](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_object_after_init_object.png)\n- red_left_pad和Red zone填充了SLUB_RED_INACTIVE（0xbb）；\n- object填充了POISON_FREE（0x6b），但是最后一个byte填充POISON_END（<font color=red>0xa5</font>）；\n- padding在allocate_slab的时候就已经被填充POISON_INUSE（0x5a）\n\n如果是oob(out-of-bounds)，这red zone/red left pad magic num 会被修改，在kfree 时检测red zone/red left pad， 反之是uaf(use-after-free)时， 我们再free 后将object 填充为POISON_FREE(0x6b) + POISON_END(0xa5)， 之后使用slabinfo 工具进行遍历检测free list mem，object 区域是否有被修改过。\n\n### 4.2. KASAN\nKASAN (kernel address sanitizer) runtime memory debugger， 是一个动态检测工具。Kernel doc 可参见Documentation/dev-tool/kasan.rst 文档。\n我们从kernel menuconfig 中help 信息可以看出：\n- GCC 4.9.2以上版本才支持debug 功能\n- GCC 5.0以上版本支持栈、全局变量的越界访问\n- 消耗1/8 内存用于跟踪记录\n  \n>designed to find <font color=red>out-of-bounds accesses</font> and <font color=red>use-after-free</font> bugs.\n>This is strictly a debugging feature and it requires a gcc version\n>of **4.9.2 or later**. Detection of out of bounds accesses to stack or\n>global variables requires **gcc 5.0 or later**.\n>This feature **consumes about 1/8 of available memory** and brings about\n>~x3 performance slowdown.\n\n`原理`\nKASAN 利用额外的内存(shadow memory, 影子区)标记内存状态，使用magic num 填充shadow memory，每一次R/w mem时都会检测shadow memory 是否valid。每连续8 bytes 使用1 byte shadow memory 标记。\n\n![kasan shadow memory](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kasan_shadow_mm.png)\n\n```c\n#define KASAN_FREE_PAGE         0xFF  /* page was freed */\n#define KASAN_PAGE_REDZONE      0xFE  /* redzone for kmalloc_large allocations */\n#define KASAN_KMALLOC_REDZONE   0xFC  /* redzone inside slub object */\n#define KASAN_KMALLOC_FREE      0xFB  /* object was freed (kmem_cache_free/kfree) */\n#define KASAN_GLOBAL_REDZONE    0xFA  /* redzone for global variable */\n\n/*\n * Stack redzone shadow values\n * (Those are compiler's ABI, don't change them)\n */\n#define KASAN_STACK_LEFT        0xF1\n#define KASAN_STACK_MID         0xF2\n#define KASAN_STACK_RIGHT       0xF3\n#define KASAN_STACK_PARTIAL     0xF4\n#define KASAN_USE_AFTER_SCOPE   0xF8\n```\n\n在高版本的gcc 中编译器编译时在mm access 插入__asan_load/__asan_store 函数。\n\narm64, VA_BITS=48, kernel 的mem layout. (KERNEL是不是位于linear mapping区域，这里怎么变成了VMALLOC区域？这里是Ard Biesheuvel提交的修改。主要是为了迎接ARM64世界的KASLR（which allows the kernel image to be located anywhere in the vmalloc area）的到来。)\n![arm64, va_bits 48, mem layout](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/arm64_va_bits48_mem_layout.png)\n\n<font color=red>shadow_addr = (kaddr >> 3)  + KASAN_SHADOW_OFFSE</font>,在kasan_init()之后KASAN 就能正常工作，kernel 与 linear mapping 区域建立与shadow memory映射。若是module，则在load 时建立映射关系。\n\n`检测`\n大致与SLUB_DEBUG相同，通过填充KASAN_FREE_PAGE/KASAN_KMALLOC_FREE 来检测UAF(use-after-free), 填充KASAN_KMALLOC_REDZONE 到red zone检测OOB(out-of-bounds), 这针对于伙伴算法与slub allocator。在debug stack或global 变量时则需要GCC 编译器插入red zone。组成类似结构体:\n```c\nstruct {\n\ttype data;\n\tchar redzone;\n}\n```\n\n`结果`\n参见kernel 中Documentation/dev-tool/kasan.rst\n```txt\n==================================================================\n    BUG: AddressSanitizer: out of bounds access in kmalloc_oob_right+0x65/0x75 [test_kasan] at addr ffff8800693bc5d3\n    Write of size 1 by task modprobe/1689\n    =============================================================================\n    BUG kmalloc-128 (Not tainted): kasan error\n    -----------------------------------------------------------------------------\n\n    Disabling lock debugging due to kernel taint\n    INFO: Allocated in kmalloc_oob_right+0x3d/0x75 [test_kasan] age=0 cpu=0 pid=1689\n     __slab_alloc+0x4b4/0x4f0\n     kmem_cache_alloc_trace+0x10b/0x190\n     kmalloc_oob_right+0x3d/0x75 [test_kasan]\n     init_module+0x9/0x47 [test_kasan]\n     do_one_initcall+0x99/0x200\n     load_module+0x2cb3/0x3b20\n     SyS_finit_module+0x76/0x80\n     system_call_fastpath+0x12/0x17\n    INFO: Slab 0xffffea0001a4ef00 objects=17 used=7 fp=0xffff8800693bd728 flags=0x100000000004080\n    INFO: Object 0xffff8800693bc558 @offset=1368 fp=0xffff8800693bc720\n\n    Bytes b4 ffff8800693bc548: 00 00 00 00 00 00 00 00 5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ\n    Object ffff8800693bc558: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc568: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc578: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc588: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc598: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc5a8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc5b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc5c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.\n    Redzone ffff8800693bc5d8: cc cc cc cc cc cc cc cc                          ........\n    Padding ffff8800693bc718: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ\n    CPU: 0 PID: 1689 Comm: modprobe Tainted: G    B          3.18.0-rc1-mm1+ #98\n    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014\n     ffff8800693bc000 0000000000000000 ffff8800693bc558 ffff88006923bb78\n     ffffffff81cc68ae 00000000000000f3 ffff88006d407600 ffff88006923bba8\n     ffffffff811fd848 ffff88006d407600 ffffea0001a4ef00 ffff8800693bc558\n    Call Trace:\n     [<ffffffff81cc68ae>] dump_stack+0x46/0x58\n     [<ffffffff811fd848>] print_trailer+0xf8/0x160\n     [<ffffffffa00026a7>] ? kmem_cache_oob+0xc3/0xc3 [test_kasan]\n     [<ffffffff811ff0f5>] object_err+0x35/0x40\n     [<ffffffffa0002065>] ? kmalloc_oob_right+0x65/0x75 [test_kasan]\n     [<ffffffff8120b9fa>] kasan_report_error+0x38a/0x3f0\n     [<ffffffff8120a79f>] ? kasan_poison_shadow+0x2f/0x40\n     [<ffffffff8120b344>] ? kasan_unpoison_shadow+0x14/0x40\n     [<ffffffff8120a79f>] ? kasan_poison_shadow+0x2f/0x40\n     [<ffffffffa00026a7>] ? kmem_cache_oob+0xc3/0xc3 [test_kasan]\n     [<ffffffff8120a995>] __asan_store1+0x75/0xb0\n     [<ffffffffa0002601>] ? kmem_cache_oob+0x1d/0xc3 [test_kasan]\n     [<ffffffffa0002065>] ? kmalloc_oob_right+0x65/0x75 [test_kasan]\n     [<ffffffffa0002065>] kmalloc_oob_right+0x65/0x75 [test_kasan]\n     [<ffffffffa00026b0>] init_module+0x9/0x47 [test_kasan]\n     [<ffffffff810002d9>] do_one_initcall+0x99/0x200\n     [<ffffffff811e4e5c>] ? __vunmap+0xec/0x160\n     [<ffffffff81114f63>] load_module+0x2cb3/0x3b20\n     [<ffffffff8110fd70>] ? m_show+0x240/0x240\n     [<ffffffff81115f06>] SyS_finit_module+0x76/0x80\n     [<ffffffff81cd3129>] system_call_fastpath+0x12/0x17\n    Memory state around the buggy address:\n     ffff8800693bc300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc380: fc fc 00 00 00 00 00 00 00 00 00 00 00 00 00 fc\n     ffff8800693bc400: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc500: fc fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00\n    >ffff8800693bc580: 00 00 00 00 00 00 00 00 00 00 03 fc fc fc fc fc\n                                                 ^\n     ffff8800693bc600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc700: fc fc fc fc fb fb fb fb fb fb fb fb fb fb fb fb\n     ffff8800693bc780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n     ffff8800693bc800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n    ==================================================================\n```\n\n## Reference\n[linux 内核 内存管理 slub算法 （一） 原理](https://blog.csdn.net/lukuen/article/details/6935068)\n\n[图解slub](http://www.wowotech.net/memory_management/426.html)\n\n[slub分配器](http://www.wowotech.net/memory_management/247.html)\n\n[SLUB DEBUG原理](http://www.wowotech.net/memory_management/427.html)\n\n[KASAN实现原理](http://www.wowotech.net/memory_management/424.html)","source":"_posts/kernel-slub.md","raw":"---\ntitle: kernel_slub\ndate: 2020-03-16 18:04:28\ntags: slub\ncategories: memory\n---\n\n![slab allocator](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slab.jpg)\n\n<!--more-->\n## 1. 前言\n在linux mm 的分配主要有两种算法：伙伴算法(buddy system), slab alloctor。\n\n伙伴算法 | slab 分配器\n:- | :-\n以页为单位进行管理分配 | 以字节为单位，8B, 16B, 32B, ... 192B等\n\nslab alloctor 从linux 的发展看已有三种分配策略：\n- slab  \n- slub \n- slob\n\n>Q: 为什么出现slab?\nA: 伙伴算法管理粒度page 为单位， slab 的出现是为了管理小size 的内存\n\n>Q: 为什么出现slub, slob?\nslab 管理数据复杂， 不支持NUMA(Non unified memory arcihtecture), 调试困难。\nslub 对算法做了简化，针对SMP， NUMA系统优化，slub 对slab 的API 兼容。\nslob 用于小size 的mm 上管理内存。\n\n因此， 下面主要分析slub 分配算法。\n\n## 2. data structure\nslab 相当于零售商，`struct kmem_cache`下有两个部门，仓库 `struct kmem_cache_node`, 营业厅`struct kmem_cache_cpu`。营业厅销售某种类型的object(如8 byte， 16 byte ...， 具体的size 有零售商slab `struct kmem_cache` 决定), 我们可以从如下的`kmem_cache_create()` 函数看出`strcut kmem_cache`与size 的关系。\n\n```c\nstruct kmem_cache *kmem_cache_create(const char *name,\n\t\tsize_t size,\n\t\tsize_t align,\n\t\tunsigned long flags,\n\t\tvoid (*ctor)(void *));\nvoid kmem_cache_destroy(struct kmem_cache *);\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, int flags);\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp);\n```\n\n![slub data structure](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_data_structure.png)\n\n```c\n/* Slab cache management. */\nstruct kmem_cache {\n\tstruct kmem_cache_cpu __percpu *cpu_slab;\n\t/* Used for retriving partial slabs etc */\n\tunsigned long flags;\n\tunsigned long min_partial;\n\tint size;\t\t/* The size of an object including meta data */\n\tint object_size;\t/* The size of an object without meta data */\n\tint offset;\t\t/* Free pointer offset. */\n\t/* Number of per cpu partial objects to keep around */\n\tunsigned int cpu_partial;\n\tstruct kmem_cache_order_objects oo;\n\n\t/* Allocation and freeing of slabs */\n\tstruct kmem_cache_order_objects max;\n\tstruct kmem_cache_order_objects min;\n\tgfp_t allocflags;\t/* gfp flags to use on each alloc */\n\tint refcount;\t\t/* Refcount for slab cache destroy */\n\tvoid (*ctor)(void *);\n\tint inuse;\t\t/* Offset to metadata */\n\tint align;\t\t/* Alignment */\n\tint reserved;\t\t/* Reserved bytes at the end of slabs */\n\tconst char *name;\t/* Name (only for display!) */\n\tstruct list_head list;\t/* List of slab caches */\n\tint red_left_pad;\t/* Left redzone padding size */\n\n#ifdef CONFIG_NUMA\n\t/* Defragmentation by allocating from a remote node.*/\n\tint remote_node_defrag_ratio;\n#endif\n\tstruct kmem_cache_node *node[MAX_NUMNODES];\n};\n```\n`struct kmem_cache_cpu __percpu *cpu_slab` 中限定<font color=red>__percpu</font> 指明了是每一个CPU，可以理解为本地缓冲池。\n\n`struct kmem_cache_node *node[MAX_NUMNODES];` 是所有CPU 共享的， 而__percpu *cpu_slab 是每个CPU 独占的。\n\n```c\nstruct kmem_cache_cpu {\n\tvoid **freelist;\t/* Pointer to next available object */\n\tunsigned long tid;\t/* Globally unique transaction id */\n\tstruct page *page;\t/* The slab from which we are allocating */\n\tstruct page *partial;\t/* Partially allocated frozen slabs */\n};\n```\n当从full object 上free 时，*partial 将会指向此page。`struct kmem_cache` 中**cpu_partial** 将会限制 * partial 的total 数目，过多的 * partial 将会回收到`struct kemem_cache_node` 仓库中。\n\n```c\n/*\n * The slab lists for all objects.\n */\nstruct kmem_cache_node {\n\tspinlock_t list_lock;\n#ifdef CONFIG_SLAB\n\t...\n#endif\n\n#ifdef CONFIG_SLUB\n\tunsigned long nr_partial;\n\tstruct list_head partial;\n#endif\n};\n```\npartial 指向仍有空闲object page， 当nr_partial 大于`struct kmem_cache` 中**min_partial** 时，完全free object 的page 将会伙伴系统回收。\n\n## 3. work flow\n slub把内存分组管理，每个组分别包含2^3、2^4、...2^11个字节，在4K页大小的默认情况下，另外还有两个特殊的组，分别是96B和192B，共11组。之所以这样分配是因为如果申请2^12B大小的内存，就可以使用伙伴系统提供的接口直接申请一个完整的页面即可。\n\n### 3.1. allocate\n当内存申请的时候，优先从本地cpu缓存池申请。在分配初期，本地缓存池为空，自然从伙伴系统分配一定页数的内存。kmem_cacche_cpu中page就会指向正在使用的slab的页帧。freelist成员指向第一个可用内存object首地址。\n\n1. kmem_cache 初始阶段，没有对象可分配时，从伙伴系统获取一个slab\n![slub_allocate_from_buddy_system](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_buddy_system.png)\n\n2. 若kmem_cache_cpu 中无可用object时，尝试从kmem_cache_cpu 指向仍有可用object 的partial 获取\n![slub_allocate_from_kmem_cache_cpu_partial](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_kmem_cache_cpu_partial.png)\n\n3. 若kmem_cache_cpu 与 partial 中无可用object时，尝试从kmem_cache_node 获取\n![slub_allocate_from_kmem_cache_node](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_kmem_cache_node.png)\n\n### 3.2. free\n我们再free 时，free 的对象可能来自：\n- full object page\n- kmem_cache_cpu\n- kmem_cache_cpu partial\n- kmem_cache_node\n\n总的原则是：kmem_cache_cpu 保有一定量的partial， kmem_cache_node 保有一定量partial\n- free full 中object， 将kmem_cache_cpu partial 指向他\n- 若kmem_cache_cpu partial 数目大于kmem_cache 中cpu_partial 时，将多的partial 放置到仓库kmem_cache_node\n- 若kmem_cache_node partial 数目大于kmem_cache 中min_partial 时，则将free page 给budy system\n\n1. free object in kmem_cache_cpu partial && kmem_cache_cpu && kmem_cache_node\n直接标记该object 为free 状态\n![free object in kmem_cahce_cpu](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/free_object_in_kmem_cache_cpu.png)\n\n2. free object in full object page\n![free object in full object page](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/free_object_in_full_objects.png)\n\n若kmem_cache_cpu partial 数目多于设定kmem_cache cpu_partial， 则将存储指仓库kmem_cache_node\n![kmem_cache_cpu_partial_great_than_cpu_partial](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kmem_cache_cpu_partial_great_than_cpu_partial.png)\n\n若仓库中堆满，kmem_cache_node partial 数目多于设定kmem_cache min_partial，则将规划至伙伴系统\n![kmem_cache_node_partial_great_than_min_partial](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kmem_cache_node_partial_great_than_min_partial.png)\n\n我们可以看看kmalloc 的实现, 其中返回`kmalloc_caches[index]`， 那他是在哪里被初始化呢？\n\n```c\nstruct kmem_cache *kmalloc_caches[KMALLOC_SHIFT_HIGH + 1];\nEXPORT_SYMBOL(kmalloc_caches);\n\nstatic __always_inline void *kmalloc(size_t size, gfp_t flags)\n{\n\tif (__builtin_constant_p(size)) {\n\t\tif (size > KMALLOC_MAX_CACHE_SIZE)\n\t\t\treturn kmalloc_large(size, flags);\n#ifndef CONFIG_SLOB\n\t\tif (!(flags & GFP_DMA)) {\n\t\t\tint index = kmalloc_index(size);\n\n\t\t\tif (!index)\n\t\t\t\treturn ZERO_SIZE_PTR;\n\n\t\t\treturn kmem_cache_alloc_trace(kmalloc_caches[index],\n\t\t\t\t\tflags, size);\n\t\t}\n#endif\n\t}\n\treturn __kmalloc(size, flags);\n}\n```\n\n在slub.c\n```c\n/** linux/mm/slub.c*/\nvoid __init kmem_cache_init(void)\n{\n    ...\n    create_kmalloc_caches(0); \n}\n\nvoid __init create_kmalloc_caches(unsigned long flags)\n{\n\tint i;\n\tfor (i = KMALLOC_SHIFT_LOW; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\tif (!kmalloc_caches[i])\n\t\t\tnew_kmalloc_cache(i, flags);\n\n\t\t/*\n\t\t * Caches that are not of the two-to-the-power-of size.\n\t\t * These have to be created immediately after the\n\t\t * earlier power of two caches\n\t\t */\n\t\tif (KMALLOC_MIN_SIZE <= 32 && !kmalloc_caches[1] && i == 6)\n\t\t\tnew_kmalloc_cache(1, flags);\n\t\tif (KMALLOC_MIN_SIZE <= 64 && !kmalloc_caches[2] && i == 7)\n\t\t\tnew_kmalloc_cache(2, flags);\n\t}\n\n\t/* Kmalloc array is now usable */\n\tslab_state = UP;\n}\n\n/*\n * kmalloc_info[] is to make slub_debug=,kmalloc-xx option work at boot time.\n * kmalloc_index() supports up to 2^26=64MB, so the final entry of the table is\n * kmalloc-67108864.\n */\nstatic struct {\n\tconst char *name;\n\tunsigned long size;\n} const kmalloc_info[] __initconst = {\n\t{NULL,                      0},\t\t{\"kmalloc-96\",             96},\n\t{\"kmalloc-192\",           192},\t\t{\"kmalloc-8\",               8},\n\t{\"kmalloc-16\",             16},\t\t{\"kmalloc-32\",             32},\n\t{\"kmalloc-64\",             64},\t\t{\"kmalloc-128\",           128},\n\t{\"kmalloc-256\",           256},\t\t{\"kmalloc-512\",           512},\n\t{\"kmalloc-1024\",         1024},\t\t{\"kmalloc-2048\",         2048},\n\t{\"kmalloc-4096\",         4096},\t\t{\"kmalloc-8192\",         8192},\n\t{\"kmalloc-16384\",       16384},\t\t{\"kmalloc-32768\",       32768},\n\t{\"kmalloc-65536\",       65536},\t\t{\"kmalloc-131072\",     131072},\n\t{\"kmalloc-262144\",     262144},\t\t{\"kmalloc-524288\",     524288},\n\t{\"kmalloc-1048576\",   1048576},\t\t{\"kmalloc-2097152\",   2097152},\n\t{\"kmalloc-4194304\",   4194304},\t\t{\"kmalloc-8388608\",   8388608},\n\t{\"kmalloc-16777216\", 16777216},\t\t{\"kmalloc-33554432\", 33554432},\n\t{\"kmalloc-67108864\", 67108864}\n};\nstatic void __init new_kmalloc_cache(int idx, unsigned long flags)\n{\n\tkmalloc_caches[idx] = create_kmalloc_cache(kmalloc_info[idx].name,\n\t\t\t\t\tkmalloc_info[idx].size, flags);\n}\n```\n后面的`create_kmalloc_cache()`，则是尝试找到freelist, 例如从kmem_cache_cpu freelist， partial获取object， 若都为空则使用new_slab()->alloc_slab_page()->alloc_pages() 分配page 生成free objects。\n\n## 4. 调试手段\n\n### 4.1. SLUB_DEBUG\n\nSLUB DEBUG检测oob(out-of-bounds)问题原理:<font color=red>在分配出去的内存尾部添加额外空间--red zone, 并填充MAGIC，之后检测其内容。</font>\n\nSLUB DEBUG 检测uaf(use-after-free)问题原理：<font color=red>free 后，将object 数据填充MAGIC NUM(0X6B)</font>\n\nslub 管理的object 对象的格式如下：\n![slub object format](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_debug_object_structure.png)\n\nfree pointer是从object后移就是因为为了检测use-after-free问题,当free object时会在将object填充magic num(0x6b)。\n\n`red zone`\n可以检测向后的越界访问\n\n`red left pad`\n可以检测向前的越界访问\n\n![red zone && red left pad](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/red_zone_red_left_pad.png)\n\n`padding`\n填充填充magic num，可以检测较大空间的overwritten\n\n`Magic number`\n```c\n//linux/include/linux/poison.h\n\n#define SLUB_RED_INACTIVE\t0xbb\n#define SLUB_RED_ACTIVE\t\t0xcc\n\n/* ...and for poisoning */\n#define\tPOISON_INUSE\t0x5a\t/* for use-uninitialised poisoning */\n#define POISON_FREE\t0x6b\t/* for use-after-free poisoning */\n#define\tPOISON_END\t0xa5\t/* end-byte of poisoning */\n```\n在slub alloc 一个object，经过init_object 填充magic num 后，会如下所示：\n![slub object after init object](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_object_after_init_object.png)\n- red_left_pad和Red zone填充了SLUB_RED_INACTIVE（0xbb）；\n- object填充了POISON_FREE（0x6b），但是最后一个byte填充POISON_END（<font color=red>0xa5</font>）；\n- padding在allocate_slab的时候就已经被填充POISON_INUSE（0x5a）\n\n如果是oob(out-of-bounds)，这red zone/red left pad magic num 会被修改，在kfree 时检测red zone/red left pad， 反之是uaf(use-after-free)时， 我们再free 后将object 填充为POISON_FREE(0x6b) + POISON_END(0xa5)， 之后使用slabinfo 工具进行遍历检测free list mem，object 区域是否有被修改过。\n\n### 4.2. KASAN\nKASAN (kernel address sanitizer) runtime memory debugger， 是一个动态检测工具。Kernel doc 可参见Documentation/dev-tool/kasan.rst 文档。\n我们从kernel menuconfig 中help 信息可以看出：\n- GCC 4.9.2以上版本才支持debug 功能\n- GCC 5.0以上版本支持栈、全局变量的越界访问\n- 消耗1/8 内存用于跟踪记录\n  \n>designed to find <font color=red>out-of-bounds accesses</font> and <font color=red>use-after-free</font> bugs.\n>This is strictly a debugging feature and it requires a gcc version\n>of **4.9.2 or later**. Detection of out of bounds accesses to stack or\n>global variables requires **gcc 5.0 or later**.\n>This feature **consumes about 1/8 of available memory** and brings about\n>~x3 performance slowdown.\n\n`原理`\nKASAN 利用额外的内存(shadow memory, 影子区)标记内存状态，使用magic num 填充shadow memory，每一次R/w mem时都会检测shadow memory 是否valid。每连续8 bytes 使用1 byte shadow memory 标记。\n\n![kasan shadow memory](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kasan_shadow_mm.png)\n\n```c\n#define KASAN_FREE_PAGE         0xFF  /* page was freed */\n#define KASAN_PAGE_REDZONE      0xFE  /* redzone for kmalloc_large allocations */\n#define KASAN_KMALLOC_REDZONE   0xFC  /* redzone inside slub object */\n#define KASAN_KMALLOC_FREE      0xFB  /* object was freed (kmem_cache_free/kfree) */\n#define KASAN_GLOBAL_REDZONE    0xFA  /* redzone for global variable */\n\n/*\n * Stack redzone shadow values\n * (Those are compiler's ABI, don't change them)\n */\n#define KASAN_STACK_LEFT        0xF1\n#define KASAN_STACK_MID         0xF2\n#define KASAN_STACK_RIGHT       0xF3\n#define KASAN_STACK_PARTIAL     0xF4\n#define KASAN_USE_AFTER_SCOPE   0xF8\n```\n\n在高版本的gcc 中编译器编译时在mm access 插入__asan_load/__asan_store 函数。\n\narm64, VA_BITS=48, kernel 的mem layout. (KERNEL是不是位于linear mapping区域，这里怎么变成了VMALLOC区域？这里是Ard Biesheuvel提交的修改。主要是为了迎接ARM64世界的KASLR（which allows the kernel image to be located anywhere in the vmalloc area）的到来。)\n![arm64, va_bits 48, mem layout](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/arm64_va_bits48_mem_layout.png)\n\n<font color=red>shadow_addr = (kaddr >> 3)  + KASAN_SHADOW_OFFSE</font>,在kasan_init()之后KASAN 就能正常工作，kernel 与 linear mapping 区域建立与shadow memory映射。若是module，则在load 时建立映射关系。\n\n`检测`\n大致与SLUB_DEBUG相同，通过填充KASAN_FREE_PAGE/KASAN_KMALLOC_FREE 来检测UAF(use-after-free), 填充KASAN_KMALLOC_REDZONE 到red zone检测OOB(out-of-bounds), 这针对于伙伴算法与slub allocator。在debug stack或global 变量时则需要GCC 编译器插入red zone。组成类似结构体:\n```c\nstruct {\n\ttype data;\n\tchar redzone;\n}\n```\n\n`结果`\n参见kernel 中Documentation/dev-tool/kasan.rst\n```txt\n==================================================================\n    BUG: AddressSanitizer: out of bounds access in kmalloc_oob_right+0x65/0x75 [test_kasan] at addr ffff8800693bc5d3\n    Write of size 1 by task modprobe/1689\n    =============================================================================\n    BUG kmalloc-128 (Not tainted): kasan error\n    -----------------------------------------------------------------------------\n\n    Disabling lock debugging due to kernel taint\n    INFO: Allocated in kmalloc_oob_right+0x3d/0x75 [test_kasan] age=0 cpu=0 pid=1689\n     __slab_alloc+0x4b4/0x4f0\n     kmem_cache_alloc_trace+0x10b/0x190\n     kmalloc_oob_right+0x3d/0x75 [test_kasan]\n     init_module+0x9/0x47 [test_kasan]\n     do_one_initcall+0x99/0x200\n     load_module+0x2cb3/0x3b20\n     SyS_finit_module+0x76/0x80\n     system_call_fastpath+0x12/0x17\n    INFO: Slab 0xffffea0001a4ef00 objects=17 used=7 fp=0xffff8800693bd728 flags=0x100000000004080\n    INFO: Object 0xffff8800693bc558 @offset=1368 fp=0xffff8800693bc720\n\n    Bytes b4 ffff8800693bc548: 00 00 00 00 00 00 00 00 5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ\n    Object ffff8800693bc558: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc568: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc578: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc588: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc598: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc5a8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc5b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    Object ffff8800693bc5c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.\n    Redzone ffff8800693bc5d8: cc cc cc cc cc cc cc cc                          ........\n    Padding ffff8800693bc718: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ\n    CPU: 0 PID: 1689 Comm: modprobe Tainted: G    B          3.18.0-rc1-mm1+ #98\n    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014\n     ffff8800693bc000 0000000000000000 ffff8800693bc558 ffff88006923bb78\n     ffffffff81cc68ae 00000000000000f3 ffff88006d407600 ffff88006923bba8\n     ffffffff811fd848 ffff88006d407600 ffffea0001a4ef00 ffff8800693bc558\n    Call Trace:\n     [<ffffffff81cc68ae>] dump_stack+0x46/0x58\n     [<ffffffff811fd848>] print_trailer+0xf8/0x160\n     [<ffffffffa00026a7>] ? kmem_cache_oob+0xc3/0xc3 [test_kasan]\n     [<ffffffff811ff0f5>] object_err+0x35/0x40\n     [<ffffffffa0002065>] ? kmalloc_oob_right+0x65/0x75 [test_kasan]\n     [<ffffffff8120b9fa>] kasan_report_error+0x38a/0x3f0\n     [<ffffffff8120a79f>] ? kasan_poison_shadow+0x2f/0x40\n     [<ffffffff8120b344>] ? kasan_unpoison_shadow+0x14/0x40\n     [<ffffffff8120a79f>] ? kasan_poison_shadow+0x2f/0x40\n     [<ffffffffa00026a7>] ? kmem_cache_oob+0xc3/0xc3 [test_kasan]\n     [<ffffffff8120a995>] __asan_store1+0x75/0xb0\n     [<ffffffffa0002601>] ? kmem_cache_oob+0x1d/0xc3 [test_kasan]\n     [<ffffffffa0002065>] ? kmalloc_oob_right+0x65/0x75 [test_kasan]\n     [<ffffffffa0002065>] kmalloc_oob_right+0x65/0x75 [test_kasan]\n     [<ffffffffa00026b0>] init_module+0x9/0x47 [test_kasan]\n     [<ffffffff810002d9>] do_one_initcall+0x99/0x200\n     [<ffffffff811e4e5c>] ? __vunmap+0xec/0x160\n     [<ffffffff81114f63>] load_module+0x2cb3/0x3b20\n     [<ffffffff8110fd70>] ? m_show+0x240/0x240\n     [<ffffffff81115f06>] SyS_finit_module+0x76/0x80\n     [<ffffffff81cd3129>] system_call_fastpath+0x12/0x17\n    Memory state around the buggy address:\n     ffff8800693bc300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc380: fc fc 00 00 00 00 00 00 00 00 00 00 00 00 00 fc\n     ffff8800693bc400: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc500: fc fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00\n    >ffff8800693bc580: 00 00 00 00 00 00 00 00 00 00 03 fc fc fc fc fc\n                                                 ^\n     ffff8800693bc600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n     ffff8800693bc700: fc fc fc fc fb fb fb fb fb fb fb fb fb fb fb fb\n     ffff8800693bc780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n     ffff8800693bc800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n    ==================================================================\n```\n\n## Reference\n[linux 内核 内存管理 slub算法 （一） 原理](https://blog.csdn.net/lukuen/article/details/6935068)\n\n[图解slub](http://www.wowotech.net/memory_management/426.html)\n\n[slub分配器](http://www.wowotech.net/memory_management/247.html)\n\n[SLUB DEBUG原理](http://www.wowotech.net/memory_management/427.html)\n\n[KASAN实现原理](http://www.wowotech.net/memory_management/424.html)","slug":"kernel-slub","published":1,"updated":"2020-04-15T09:57:32.176Z","_id":"ck915p0qv003gzkgr3qzuxywo","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slab.jpg\" alt=\"slab allocator\"></p>\n<a id=\"more\"></a>\n<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>在linux mm 的分配主要有两种算法：伙伴算法(buddy system), slab alloctor。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">伙伴算法</th>\n<th style=\"text-align:left\">slab 分配器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">以页为单位进行管理分配</td>\n<td style=\"text-align:left\">以字节为单位，8B, 16B, 32B, … 192B等</td>\n</tr>\n</tbody>\n</table>\n<p>slab alloctor 从linux 的发展看已有三种分配策略：</p>\n<ul>\n<li>slab  </li>\n<li>slub </li>\n<li>slob</li>\n</ul>\n<blockquote>\n<p>Q: 为什么出现slab?<br>A: 伙伴算法管理粒度page 为单位， slab 的出现是为了管理小size 的内存</p>\n</blockquote>\n<blockquote>\n<p>Q: 为什么出现slub, slob?<br>slab 管理数据复杂， 不支持NUMA(Non unified memory arcihtecture), 调试困难。<br>slub 对算法做了简化，针对SMP， NUMA系统优化，slub 对slab 的API 兼容。<br>slob 用于小size 的mm 上管理内存。</p>\n</blockquote>\n<p>因此， 下面主要分析slub 分配算法。</p>\n<h2 id=\"2-data-structure\"><a href=\"#2-data-structure\" class=\"headerlink\" title=\"2. data structure\"></a>2. data structure</h2><p>slab 相当于零售商，<code>struct kmem_cache</code>下有两个部门，仓库 <code>struct kmem_cache_node</code>, 营业厅<code>struct kmem_cache_cpu</code>。营业厅销售某种类型的object(如8 byte， 16 byte …， 具体的size 有零售商slab <code>struct kmem_cache</code> 决定), 我们可以从如下的<code>kmem_cache_create()</code> 函数看出<code>strcut kmem_cache</code>与size 的关系。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct kmem_cache *<span class=\"title\">kmem_cache_create</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t<span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t<span class=\"keyword\">size_t</span> align,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags,</span></span></span><br><span class=\"line\">\t\tvoid (*ctor)(void *));</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kmem_cache_destroy</span><span class=\"params\">(struct kmem_cache *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmem_cache_alloc</span><span class=\"params\">(struct kmem_cache *cachep, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kmem_cache_free</span><span class=\"params\">(struct kmem_cache *cachep, <span class=\"keyword\">void</span> *objp)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_data_structure.png\" alt=\"slub data structure\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Slab cache management. */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_cpu</span> __<span class=\"title\">percpu</span> *<span class=\"title\">cpu_slab</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Used for retriving partial slabs etc */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> min_partial;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;\t\t<span class=\"comment\">/* The size of an object including meta data */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> object_size;\t<span class=\"comment\">/* The size of an object without meta data */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> offset;\t\t<span class=\"comment\">/* Free pointer offset. */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Number of per cpu partial objects to keep around */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cpu_partial;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_order_objects</span> <span class=\"title\">oo</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Allocation and freeing of slabs */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_order_objects</span> <span class=\"title\">max</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_order_objects</span> <span class=\"title\">min</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">gfp_t</span> allocflags;\t<span class=\"comment\">/* gfp flags to use on each alloc */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> refcount;\t\t<span class=\"comment\">/* Refcount for slab cache destroy */</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*ctor)(<span class=\"keyword\">void</span> *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> inuse;\t\t<span class=\"comment\">/* Offset to metadata */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> align;\t\t<span class=\"comment\">/* Alignment */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> reserved;\t\t<span class=\"comment\">/* Reserved bytes at the end of slabs */</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;\t<span class=\"comment\">/* Name (only for display!) */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span>\t<span class=\"comment\">/* List of slab caches */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> red_left_pad;\t<span class=\"comment\">/* Left redzone padding size */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_NUMA</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Defragmentation by allocating from a remote node.*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> remote_node_defrag_ratio;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_node</span> *<span class=\"title\">node</span>[<span class=\"title\">MAX_NUMNODES</span>];</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>struct kmem_cache_cpu __percpu *cpu_slab</code> 中限定<font color=\"red\">__percpu</font> 指明了是每一个CPU，可以理解为本地缓冲池。</p>\n<p><code>struct kmem_cache_node *node[MAX_NUMNODES];</code> 是所有CPU 共享的， 而__percpu *cpu_slab 是每个CPU 独占的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_cpu</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> **freelist;\t<span class=\"comment\">/* Pointer to next available object */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> tid;\t<span class=\"comment\">/* Globally unique transaction id */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span>;</span>\t<span class=\"comment\">/* The slab from which we are allocating */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">partial</span>;</span>\t<span class=\"comment\">/* Partially allocated frozen slabs */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当从full object 上free 时，<em>partial 将会指向此page。<code>struct kmem_cache</code> 中<strong>cpu_partial</strong> 将会限制 </em> partial 的total 数目，过多的 * partial 将会回收到<code>struct kemem_cache_node</code> 仓库中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * The slab lists for all objects.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">spinlock_t</span> list_lock;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SLAB</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SLUB</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nr_partial;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">partial</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>partial 指向仍有空闲object page， 当nr_partial 大于<code>struct kmem_cache</code> 中<strong>min_partial</strong> 时，完全free object 的page 将会伙伴系统回收。</p>\n<h2 id=\"3-work-flow\"><a href=\"#3-work-flow\" class=\"headerlink\" title=\"3. work flow\"></a>3. work flow</h2><p> slub把内存分组管理，每个组分别包含2^3、2^4、…2^11个字节，在4K页大小的默认情况下，另外还有两个特殊的组，分别是96B和192B，共11组。之所以这样分配是因为如果申请2^12B大小的内存，就可以使用伙伴系统提供的接口直接申请一个完整的页面即可。</p>\n<h3 id=\"3-1-allocate\"><a href=\"#3-1-allocate\" class=\"headerlink\" title=\"3.1. allocate\"></a>3.1. allocate</h3><p>当内存申请的时候，优先从本地cpu缓存池申请。在分配初期，本地缓存池为空，自然从伙伴系统分配一定页数的内存。kmem_cacche_cpu中page就会指向正在使用的slab的页帧。freelist成员指向第一个可用内存object首地址。</p>\n<ol>\n<li><p>kmem_cache 初始阶段，没有对象可分配时，从伙伴系统获取一个slab<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_buddy_system.png\" alt=\"slub_allocate_from_buddy_system\"></p>\n</li>\n<li><p>若kmem_cache_cpu 中无可用object时，尝试从kmem_cache_cpu 指向仍有可用object 的partial 获取<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_kmem_cache_cpu_partial.png\" alt=\"slub_allocate_from_kmem_cache_cpu_partial\"></p>\n</li>\n<li><p>若kmem_cache_cpu 与 partial 中无可用object时，尝试从kmem_cache_node 获取<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_kmem_cache_node.png\" alt=\"slub_allocate_from_kmem_cache_node\"></p>\n</li>\n</ol>\n<h3 id=\"3-2-free\"><a href=\"#3-2-free\" class=\"headerlink\" title=\"3.2. free\"></a>3.2. free</h3><p>我们再free 时，free 的对象可能来自：</p>\n<ul>\n<li>full object page</li>\n<li>kmem_cache_cpu</li>\n<li>kmem_cache_cpu partial</li>\n<li>kmem_cache_node</li>\n</ul>\n<p>总的原则是：kmem_cache_cpu 保有一定量的partial， kmem_cache_node 保有一定量partial</p>\n<ul>\n<li>free full 中object， 将kmem_cache_cpu partial 指向他</li>\n<li>若kmem_cache_cpu partial 数目大于kmem_cache 中cpu_partial 时，将多的partial 放置到仓库kmem_cache_node</li>\n<li>若kmem_cache_node partial 数目大于kmem_cache 中min_partial 时，则将free page 给budy system</li>\n</ul>\n<ol>\n<li><p>free object in kmem_cache_cpu partial &amp;&amp; kmem_cache_cpu &amp;&amp; kmem_cache_node<br>直接标记该object 为free 状态<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/free_object_in_kmem_cache_cpu.png\" alt=\"free object in kmem_cahce_cpu\"></p>\n</li>\n<li><p>free object in full object page<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/free_object_in_full_objects.png\" alt=\"free object in full object page\"></p>\n</li>\n</ol>\n<p>若kmem_cache_cpu partial 数目多于设定kmem_cache cpu_partial， 则将存储指仓库kmem_cache_node<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kmem_cache_cpu_partial_great_than_cpu_partial.png\" alt=\"kmem_cache_cpu_partial_great_than_cpu_partial\"></p>\n<p>若仓库中堆满，kmem_cache_node partial 数目多于设定kmem_cache min_partial，则将规划至伙伴系统<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kmem_cache_node_partial_great_than_min_partial.png\" alt=\"kmem_cache_node_partial_great_than_min_partial\"></p>\n<p>我们可以看看kmalloc 的实现, 其中返回<code>kmalloc_caches[index]</code>， 那他是在哪里被初始化呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache</span> *<span class=\"title\">kmalloc_caches</span>[<span class=\"title\">KMALLOC_SHIFT_HIGH</span> + 1];</span></span><br><span class=\"line\">EXPORT_SYMBOL(kmalloc_caches);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> __<span class=\"function\">always_inline <span class=\"keyword\">void</span> *<span class=\"title\">kmalloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size, <span class=\"keyword\">gfp_t</span> flags)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kmalloc_large(size, flags);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> CONFIG_SLOB</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!(flags &amp; GFP_DMA)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> index = kmalloc_index(size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!index)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ZERO_SIZE_PTR;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kmem_cache_alloc_trace(kmalloc_caches[index],</span><br><span class=\"line\">\t\t\t\t\tflags, size);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __kmalloc(size, flags);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在slub.c<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** linux/mm/slub.c*/</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">kmem_cache_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    create_kmalloc_caches(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">create_kmalloc_caches</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = KMALLOC_SHIFT_LOW; i &lt;= KMALLOC_SHIFT_HIGH; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!kmalloc_caches[i])</span><br><span class=\"line\">\t\t\tnew_kmalloc_cache(i, flags);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Caches that are not of the two-to-the-power-of size.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * These have to be created immediately after the</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * earlier power of two caches</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (KMALLOC_MIN_SIZE &lt;= <span class=\"number\">32</span> &amp;&amp; !kmalloc_caches[<span class=\"number\">1</span>] &amp;&amp; i == <span class=\"number\">6</span>)</span><br><span class=\"line\">\t\t\tnew_kmalloc_cache(<span class=\"number\">1</span>, flags);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (KMALLOC_MIN_SIZE &lt;= <span class=\"number\">64</span> &amp;&amp; !kmalloc_caches[<span class=\"number\">2</span>] &amp;&amp; i == <span class=\"number\">7</span>)</span><br><span class=\"line\">\t\t\tnew_kmalloc_cache(<span class=\"number\">2</span>, flags);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Kmalloc array is now usable */</span></span><br><span class=\"line\">\tslab_state = UP;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * kmalloc_info[] is to make slub_debug=,kmalloc-xx option work at boot time.</span></span><br><span class=\"line\"><span class=\"comment\"> * kmalloc_index() supports up to 2^26=64MB, so the final entry of the table is</span></span><br><span class=\"line\"><span class=\"comment\"> * kmalloc-67108864.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">&#125; <span class=\"keyword\">const</span> kmalloc_info[] __initconst = &#123;</span><br><span class=\"line\">\t&#123;<span class=\"literal\">NULL</span>,                      <span class=\"number\">0</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-96\"</span>,             <span class=\"number\">96</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-192\"</span>,           <span class=\"number\">192</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-8\"</span>,               <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-16\"</span>,             <span class=\"number\">16</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-32\"</span>,             <span class=\"number\">32</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-64\"</span>,             <span class=\"number\">64</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-128\"</span>,           <span class=\"number\">128</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-256\"</span>,           <span class=\"number\">256</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-512\"</span>,           <span class=\"number\">512</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-1024\"</span>,         <span class=\"number\">1024</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-2048\"</span>,         <span class=\"number\">2048</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-4096\"</span>,         <span class=\"number\">4096</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-8192\"</span>,         <span class=\"number\">8192</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-16384\"</span>,       <span class=\"number\">16384</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-32768\"</span>,       <span class=\"number\">32768</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-65536\"</span>,       <span class=\"number\">65536</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-131072\"</span>,     <span class=\"number\">131072</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-262144\"</span>,     <span class=\"number\">262144</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-524288\"</span>,     <span class=\"number\">524288</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-1048576\"</span>,   <span class=\"number\">1048576</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-2097152\"</span>,   <span class=\"number\">2097152</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-4194304\"</span>,   <span class=\"number\">4194304</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-8388608\"</span>,   <span class=\"number\">8388608</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-16777216\"</span>, <span class=\"number\">16777216</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-33554432\"</span>, <span class=\"number\">33554432</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-67108864\"</span>, <span class=\"number\">67108864</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">new_kmalloc_cache</span><span class=\"params\">(<span class=\"keyword\">int</span> idx, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tkmalloc_caches[idx] = create_kmalloc_cache(kmalloc_info[idx].name,</span><br><span class=\"line\">\t\t\t\t\tkmalloc_info[idx].size, flags);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>后面的<code>create_kmalloc_cache()</code>，则是尝试找到freelist, 例如从kmem_cache_cpu freelist， partial获取object， 若都为空则使用new_slab()-&gt;alloc_slab_page()-&gt;alloc_pages() 分配page 生成free objects。</p>\n<h2 id=\"4-调试手段\"><a href=\"#4-调试手段\" class=\"headerlink\" title=\"4. 调试手段\"></a>4. 调试手段</h2><h3 id=\"4-1-SLUB-DEBUG\"><a href=\"#4-1-SLUB-DEBUG\" class=\"headerlink\" title=\"4.1. SLUB_DEBUG\"></a>4.1. SLUB_DEBUG</h3><p>SLUB DEBUG检测oob(out-of-bounds)问题原理:<font color=\"red\">在分配出去的内存尾部添加额外空间–red zone, 并填充MAGIC，之后检测其内容。</font></p>\n<p>SLUB DEBUG 检测uaf(use-after-free)问题原理：<font color=\"red\">free 后，将object 数据填充MAGIC NUM(0X6B)</font></p>\n<p>slub 管理的object 对象的格式如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_debug_object_structure.png\" alt=\"slub object format\"></p>\n<p>free pointer是从object后移就是因为为了检测use-after-free问题,当free object时会在将object填充magic num(0x6b)。</p>\n<p><code>red zone</code><br>可以检测向后的越界访问</p>\n<p><code>red left pad</code><br>可以检测向前的越界访问</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/red_zone_red_left_pad.png\" alt=\"red zone &amp;&amp; red left pad\"></p>\n<p><code>padding</code><br>填充填充magic num，可以检测较大空间的overwritten</p>\n<p><code>Magic number</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//linux/include/linux/poison.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SLUB_RED_INACTIVE\t0xbb</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SLUB_RED_ACTIVE\t\t0xcc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* ...and for poisoning */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>\tPOISON_INUSE\t0x5a\t<span class=\"comment\">/* for use-uninitialised poisoning */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> POISON_FREE\t0x6b\t<span class=\"comment\">/* for use-after-free poisoning */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>\tPOISON_END\t0xa5\t<span class=\"comment\">/* end-byte of poisoning */</span></span></span><br></pre></td></tr></table></figure></p>\n<p>在slub alloc 一个object，经过init_object 填充magic num 后，会如下所示：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_object_after_init_object.png\" alt=\"slub object after init object\"></p>\n<ul>\n<li>red_left_pad和Red zone填充了SLUB_RED_INACTIVE（0xbb）；</li>\n<li>object填充了POISON_FREE（0x6b），但是最后一个byte填充POISON_END（<font color=\"red\">0xa5</font>）；</li>\n<li>padding在allocate_slab的时候就已经被填充POISON_INUSE（0x5a）</li>\n</ul>\n<p>如果是oob(out-of-bounds)，这red zone/red left pad magic num 会被修改，在kfree 时检测red zone/red left pad， 反之是uaf(use-after-free)时， 我们再free 后将object 填充为POISON_FREE(0x6b) + POISON_END(0xa5)， 之后使用slabinfo 工具进行遍历检测free list mem，object 区域是否有被修改过。</p>\n<h3 id=\"4-2-KASAN\"><a href=\"#4-2-KASAN\" class=\"headerlink\" title=\"4.2. KASAN\"></a>4.2. KASAN</h3><p>KASAN (kernel address sanitizer) runtime memory debugger， 是一个动态检测工具。Kernel doc 可参见Documentation/dev-tool/kasan.rst 文档。<br>我们从kernel menuconfig 中help 信息可以看出：</p>\n<ul>\n<li>GCC 4.9.2以上版本才支持debug 功能</li>\n<li>GCC 5.0以上版本支持栈、全局变量的越界访问</li>\n<li>消耗1/8 内存用于跟踪记录</li>\n</ul>\n<blockquote>\n<p>designed to find <font color=\"red\">out-of-bounds accesses</font> and <font color=\"red\">use-after-free</font> bugs.<br>This is strictly a debugging feature and it requires a gcc version<br>of <strong>4.9.2 or later</strong>. Detection of out of bounds accesses to stack or<br>global variables requires <strong>gcc 5.0 or later</strong>.<br>This feature <strong>consumes about 1/8 of available memory</strong> and brings about<br>~x3 performance slowdown.</p>\n</blockquote>\n<p><code>原理</code><br>KASAN 利用额外的内存(shadow memory, 影子区)标记内存状态，使用magic num 填充shadow memory，每一次R/w mem时都会检测shadow memory 是否valid。每连续8 bytes 使用1 byte shadow memory 标记。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kasan_shadow_mm.png\" alt=\"kasan shadow memory\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_FREE_PAGE         0xFF  <span class=\"comment\">/* page was freed */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_PAGE_REDZONE      0xFE  <span class=\"comment\">/* redzone for kmalloc_large allocations */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_KMALLOC_REDZONE   0xFC  <span class=\"comment\">/* redzone inside slub object */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_KMALLOC_FREE      0xFB  <span class=\"comment\">/* object was freed (kmem_cache_free/kfree) */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_GLOBAL_REDZONE    0xFA  <span class=\"comment\">/* redzone for global variable */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Stack redzone shadow values</span></span><br><span class=\"line\"><span class=\"comment\"> * (Those are compiler's ABI, don't change them)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_STACK_LEFT        0xF1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_STACK_MID         0xF2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_STACK_RIGHT       0xF3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_STACK_PARTIAL     0xF4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_USE_AFTER_SCOPE   0xF8</span></span><br></pre></td></tr></table></figure>\n<p>在高版本的gcc 中编译器编译时在mm access 插入<strong>asan_load/</strong>asan_store 函数。</p>\n<p>arm64, VA_BITS=48, kernel 的mem layout. (KERNEL是不是位于linear mapping区域，这里怎么变成了VMALLOC区域？这里是Ard Biesheuvel提交的修改。主要是为了迎接ARM64世界的KASLR（which allows the kernel image to be located anywhere in the vmalloc area）的到来。)<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/arm64_va_bits48_mem_layout.png\" alt=\"arm64, va_bits 48, mem layout\"></p>\n<p><font color=\"red\">shadow_addr = (kaddr &gt;&gt; 3)  + KASAN_SHADOW_OFFSE</font>,在kasan_init()之后KASAN 就能正常工作，kernel 与 linear mapping 区域建立与shadow memory映射。若是module，则在load 时建立映射关系。</p>\n<p><code>检测</code><br>大致与SLUB_DEBUG相同，通过填充KASAN_FREE_PAGE/KASAN_KMALLOC_FREE 来检测UAF(use-after-free), 填充KASAN_KMALLOC_REDZONE 到red zone检测OOB(out-of-bounds), 这针对于伙伴算法与slub allocator。在debug stack或global 变量时则需要GCC 编译器插入red zone。组成类似结构体:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\ttype data;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> redzone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>结果</code><br>参见kernel 中Documentation/dev-tool/kasan.rst<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==================================================================</span><br><span class=\"line\">    BUG: AddressSanitizer: out of bounds access in kmalloc_oob_right+0x65/0x75 [test_kasan] at addr ffff8800693bc5d3</span><br><span class=\"line\">    Write of size 1 by task modprobe/1689</span><br><span class=\"line\">    =============================================================================</span><br><span class=\"line\">    BUG kmalloc-128 (Not tainted): kasan error</span><br><span class=\"line\">    -----------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">    Disabling lock debugging due to kernel taint</span><br><span class=\"line\">    INFO: Allocated in kmalloc_oob_right+0x3d/0x75 [test_kasan] age=0 cpu=0 pid=1689</span><br><span class=\"line\">     __slab_alloc+0x4b4/0x4f0</span><br><span class=\"line\">     kmem_cache_alloc_trace+0x10b/0x190</span><br><span class=\"line\">     kmalloc_oob_right+0x3d/0x75 [test_kasan]</span><br><span class=\"line\">     init_module+0x9/0x47 [test_kasan]</span><br><span class=\"line\">     do_one_initcall+0x99/0x200</span><br><span class=\"line\">     load_module+0x2cb3/0x3b20</span><br><span class=\"line\">     SyS_finit_module+0x76/0x80</span><br><span class=\"line\">     system_call_fastpath+0x12/0x17</span><br><span class=\"line\">    INFO: Slab 0xffffea0001a4ef00 objects=17 used=7 fp=0xffff8800693bd728 flags=0x100000000004080</span><br><span class=\"line\">    INFO: Object 0xffff8800693bc558 @offset=1368 fp=0xffff8800693bc720</span><br><span class=\"line\"></span><br><span class=\"line\">    Bytes b4 ffff8800693bc548: 00 00 00 00 00 00 00 00 5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ</span><br><span class=\"line\">    Object ffff8800693bc558: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc568: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc578: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc588: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc598: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc5a8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc5b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc5c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.</span><br><span class=\"line\">    Redzone ffff8800693bc5d8: cc cc cc cc cc cc cc cc                          ........</span><br><span class=\"line\">    Padding ffff8800693bc718: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ</span><br><span class=\"line\">    CPU: 0 PID: 1689 Comm: modprobe Tainted: G    B          3.18.0-rc1-mm1+ #98</span><br><span class=\"line\">    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014</span><br><span class=\"line\">     ffff8800693bc000 0000000000000000 ffff8800693bc558 ffff88006923bb78</span><br><span class=\"line\">     ffffffff81cc68ae 00000000000000f3 ffff88006d407600 ffff88006923bba8</span><br><span class=\"line\">     ffffffff811fd848 ffff88006d407600 ffffea0001a4ef00 ffff8800693bc558</span><br><span class=\"line\">    Call Trace:</span><br><span class=\"line\">     [&lt;ffffffff81cc68ae&gt;] dump_stack+0x46/0x58</span><br><span class=\"line\">     [&lt;ffffffff811fd848&gt;] print_trailer+0xf8/0x160</span><br><span class=\"line\">     [&lt;ffffffffa00026a7&gt;] ? kmem_cache_oob+0xc3/0xc3 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffff811ff0f5&gt;] object_err+0x35/0x40</span><br><span class=\"line\">     [&lt;ffffffffa0002065&gt;] ? kmalloc_oob_right+0x65/0x75 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffff8120b9fa&gt;] kasan_report_error+0x38a/0x3f0</span><br><span class=\"line\">     [&lt;ffffffff8120a79f&gt;] ? kasan_poison_shadow+0x2f/0x40</span><br><span class=\"line\">     [&lt;ffffffff8120b344&gt;] ? kasan_unpoison_shadow+0x14/0x40</span><br><span class=\"line\">     [&lt;ffffffff8120a79f&gt;] ? kasan_poison_shadow+0x2f/0x40</span><br><span class=\"line\">     [&lt;ffffffffa00026a7&gt;] ? kmem_cache_oob+0xc3/0xc3 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffff8120a995&gt;] __asan_store1+0x75/0xb0</span><br><span class=\"line\">     [&lt;ffffffffa0002601&gt;] ? kmem_cache_oob+0x1d/0xc3 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffffa0002065&gt;] ? kmalloc_oob_right+0x65/0x75 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffffa0002065&gt;] kmalloc_oob_right+0x65/0x75 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffffa00026b0&gt;] init_module+0x9/0x47 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffff810002d9&gt;] do_one_initcall+0x99/0x200</span><br><span class=\"line\">     [&lt;ffffffff811e4e5c&gt;] ? __vunmap+0xec/0x160</span><br><span class=\"line\">     [&lt;ffffffff81114f63&gt;] load_module+0x2cb3/0x3b20</span><br><span class=\"line\">     [&lt;ffffffff8110fd70&gt;] ? m_show+0x240/0x240</span><br><span class=\"line\">     [&lt;ffffffff81115f06&gt;] SyS_finit_module+0x76/0x80</span><br><span class=\"line\">     [&lt;ffffffff81cd3129&gt;] system_call_fastpath+0x12/0x17</span><br><span class=\"line\">    Memory state around the buggy address:</span><br><span class=\"line\">     ffff8800693bc300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc380: fc fc 00 00 00 00 00 00 00 00 00 00 00 00 00 fc</span><br><span class=\"line\">     ffff8800693bc400: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc500: fc fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00</span><br><span class=\"line\">    &gt;ffff8800693bc580: 00 00 00 00 00 00 00 00 00 00 03 fc fc fc fc fc</span><br><span class=\"line\">                                                 ^</span><br><span class=\"line\">     ffff8800693bc600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc700: fc fc fc fc fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class=\"line\">     ffff8800693bc780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class=\"line\">     ffff8800693bc800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class=\"line\">    ==================================================================</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://blog.csdn.net/lukuen/article/details/6935068\" target=\"_blank\" rel=\"noopener\">linux 内核 内存管理 slub算法 （一） 原理</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/426.html\" target=\"_blank\" rel=\"noopener\">图解slub</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/247.html\" target=\"_blank\" rel=\"noopener\">slub分配器</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/427.html\" target=\"_blank\" rel=\"noopener\">SLUB DEBUG原理</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/424.html\" target=\"_blank\" rel=\"noopener\">KASAN实现原理</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slab.jpg\" alt=\"slab allocator\"></p>","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>在linux mm 的分配主要有两种算法：伙伴算法(buddy system), slab alloctor。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">伙伴算法</th>\n<th style=\"text-align:left\">slab 分配器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">以页为单位进行管理分配</td>\n<td style=\"text-align:left\">以字节为单位，8B, 16B, 32B, … 192B等</td>\n</tr>\n</tbody>\n</table>\n<p>slab alloctor 从linux 的发展看已有三种分配策略：</p>\n<ul>\n<li>slab  </li>\n<li>slub </li>\n<li>slob</li>\n</ul>\n<blockquote>\n<p>Q: 为什么出现slab?<br>A: 伙伴算法管理粒度page 为单位， slab 的出现是为了管理小size 的内存</p>\n</blockquote>\n<blockquote>\n<p>Q: 为什么出现slub, slob?<br>slab 管理数据复杂， 不支持NUMA(Non unified memory arcihtecture), 调试困难。<br>slub 对算法做了简化，针对SMP， NUMA系统优化，slub 对slab 的API 兼容。<br>slob 用于小size 的mm 上管理内存。</p>\n</blockquote>\n<p>因此， 下面主要分析slub 分配算法。</p>\n<h2 id=\"2-data-structure\"><a href=\"#2-data-structure\" class=\"headerlink\" title=\"2. data structure\"></a>2. data structure</h2><p>slab 相当于零售商，<code>struct kmem_cache</code>下有两个部门，仓库 <code>struct kmem_cache_node</code>, 营业厅<code>struct kmem_cache_cpu</code>。营业厅销售某种类型的object(如8 byte， 16 byte …， 具体的size 有零售商slab <code>struct kmem_cache</code> 决定), 我们可以从如下的<code>kmem_cache_create()</code> 函数看出<code>strcut kmem_cache</code>与size 的关系。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct kmem_cache *<span class=\"title\">kmem_cache_create</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t<span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t<span class=\"keyword\">size_t</span> align,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags,</span></span></span><br><span class=\"line\">\t\tvoid (*ctor)(void *));</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kmem_cache_destroy</span><span class=\"params\">(struct kmem_cache *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmem_cache_alloc</span><span class=\"params\">(struct kmem_cache *cachep, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kmem_cache_free</span><span class=\"params\">(struct kmem_cache *cachep, <span class=\"keyword\">void</span> *objp)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_data_structure.png\" alt=\"slub data structure\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Slab cache management. */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_cpu</span> __<span class=\"title\">percpu</span> *<span class=\"title\">cpu_slab</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Used for retriving partial slabs etc */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> min_partial;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;\t\t<span class=\"comment\">/* The size of an object including meta data */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> object_size;\t<span class=\"comment\">/* The size of an object without meta data */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> offset;\t\t<span class=\"comment\">/* Free pointer offset. */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Number of per cpu partial objects to keep around */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cpu_partial;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_order_objects</span> <span class=\"title\">oo</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Allocation and freeing of slabs */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_order_objects</span> <span class=\"title\">max</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_order_objects</span> <span class=\"title\">min</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">gfp_t</span> allocflags;\t<span class=\"comment\">/* gfp flags to use on each alloc */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> refcount;\t\t<span class=\"comment\">/* Refcount for slab cache destroy */</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*ctor)(<span class=\"keyword\">void</span> *);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> inuse;\t\t<span class=\"comment\">/* Offset to metadata */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> align;\t\t<span class=\"comment\">/* Alignment */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> reserved;\t\t<span class=\"comment\">/* Reserved bytes at the end of slabs */</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;\t<span class=\"comment\">/* Name (only for display!) */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span>\t<span class=\"comment\">/* List of slab caches */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> red_left_pad;\t<span class=\"comment\">/* Left redzone padding size */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_NUMA</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Defragmentation by allocating from a remote node.*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> remote_node_defrag_ratio;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_node</span> *<span class=\"title\">node</span>[<span class=\"title\">MAX_NUMNODES</span>];</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>struct kmem_cache_cpu __percpu *cpu_slab</code> 中限定<font color=\"red\">__percpu</font> 指明了是每一个CPU，可以理解为本地缓冲池。</p>\n<p><code>struct kmem_cache_node *node[MAX_NUMNODES];</code> 是所有CPU 共享的， 而__percpu *cpu_slab 是每个CPU 独占的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_cpu</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> **freelist;\t<span class=\"comment\">/* Pointer to next available object */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> tid;\t<span class=\"comment\">/* Globally unique transaction id */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span>;</span>\t<span class=\"comment\">/* The slab from which we are allocating */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">partial</span>;</span>\t<span class=\"comment\">/* Partially allocated frozen slabs */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当从full object 上free 时，<em>partial 将会指向此page。<code>struct kmem_cache</code> 中<strong>cpu_partial</strong> 将会限制 </em> partial 的total 数目，过多的 * partial 将会回收到<code>struct kemem_cache_node</code> 仓库中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * The slab lists for all objects.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">spinlock_t</span> list_lock;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SLAB</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SLUB</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nr_partial;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">partial</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>partial 指向仍有空闲object page， 当nr_partial 大于<code>struct kmem_cache</code> 中<strong>min_partial</strong> 时，完全free object 的page 将会伙伴系统回收。</p>\n<h2 id=\"3-work-flow\"><a href=\"#3-work-flow\" class=\"headerlink\" title=\"3. work flow\"></a>3. work flow</h2><p> slub把内存分组管理，每个组分别包含2^3、2^4、…2^11个字节，在4K页大小的默认情况下，另外还有两个特殊的组，分别是96B和192B，共11组。之所以这样分配是因为如果申请2^12B大小的内存，就可以使用伙伴系统提供的接口直接申请一个完整的页面即可。</p>\n<h3 id=\"3-1-allocate\"><a href=\"#3-1-allocate\" class=\"headerlink\" title=\"3.1. allocate\"></a>3.1. allocate</h3><p>当内存申请的时候，优先从本地cpu缓存池申请。在分配初期，本地缓存池为空，自然从伙伴系统分配一定页数的内存。kmem_cacche_cpu中page就会指向正在使用的slab的页帧。freelist成员指向第一个可用内存object首地址。</p>\n<ol>\n<li><p>kmem_cache 初始阶段，没有对象可分配时，从伙伴系统获取一个slab<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_buddy_system.png\" alt=\"slub_allocate_from_buddy_system\"></p>\n</li>\n<li><p>若kmem_cache_cpu 中无可用object时，尝试从kmem_cache_cpu 指向仍有可用object 的partial 获取<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_kmem_cache_cpu_partial.png\" alt=\"slub_allocate_from_kmem_cache_cpu_partial\"></p>\n</li>\n<li><p>若kmem_cache_cpu 与 partial 中无可用object时，尝试从kmem_cache_node 获取<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_allocate_from_kmem_cache_node.png\" alt=\"slub_allocate_from_kmem_cache_node\"></p>\n</li>\n</ol>\n<h3 id=\"3-2-free\"><a href=\"#3-2-free\" class=\"headerlink\" title=\"3.2. free\"></a>3.2. free</h3><p>我们再free 时，free 的对象可能来自：</p>\n<ul>\n<li>full object page</li>\n<li>kmem_cache_cpu</li>\n<li>kmem_cache_cpu partial</li>\n<li>kmem_cache_node</li>\n</ul>\n<p>总的原则是：kmem_cache_cpu 保有一定量的partial， kmem_cache_node 保有一定量partial</p>\n<ul>\n<li>free full 中object， 将kmem_cache_cpu partial 指向他</li>\n<li>若kmem_cache_cpu partial 数目大于kmem_cache 中cpu_partial 时，将多的partial 放置到仓库kmem_cache_node</li>\n<li>若kmem_cache_node partial 数目大于kmem_cache 中min_partial 时，则将free page 给budy system</li>\n</ul>\n<ol>\n<li><p>free object in kmem_cache_cpu partial &amp;&amp; kmem_cache_cpu &amp;&amp; kmem_cache_node<br>直接标记该object 为free 状态<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/free_object_in_kmem_cache_cpu.png\" alt=\"free object in kmem_cahce_cpu\"></p>\n</li>\n<li><p>free object in full object page<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/free_object_in_full_objects.png\" alt=\"free object in full object page\"></p>\n</li>\n</ol>\n<p>若kmem_cache_cpu partial 数目多于设定kmem_cache cpu_partial， 则将存储指仓库kmem_cache_node<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kmem_cache_cpu_partial_great_than_cpu_partial.png\" alt=\"kmem_cache_cpu_partial_great_than_cpu_partial\"></p>\n<p>若仓库中堆满，kmem_cache_node partial 数目多于设定kmem_cache min_partial，则将规划至伙伴系统<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kmem_cache_node_partial_great_than_min_partial.png\" alt=\"kmem_cache_node_partial_great_than_min_partial\"></p>\n<p>我们可以看看kmalloc 的实现, 其中返回<code>kmalloc_caches[index]</code>， 那他是在哪里被初始化呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache</span> *<span class=\"title\">kmalloc_caches</span>[<span class=\"title\">KMALLOC_SHIFT_HIGH</span> + 1];</span></span><br><span class=\"line\">EXPORT_SYMBOL(kmalloc_caches);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> __<span class=\"function\">always_inline <span class=\"keyword\">void</span> *<span class=\"title\">kmalloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size, <span class=\"keyword\">gfp_t</span> flags)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kmalloc_large(size, flags);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> CONFIG_SLOB</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!(flags &amp; GFP_DMA)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> index = kmalloc_index(size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!index)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ZERO_SIZE_PTR;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kmem_cache_alloc_trace(kmalloc_caches[index],</span><br><span class=\"line\">\t\t\t\t\tflags, size);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __kmalloc(size, flags);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在slub.c<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** linux/mm/slub.c*/</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">kmem_cache_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    create_kmalloc_caches(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">create_kmalloc_caches</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = KMALLOC_SHIFT_LOW; i &lt;= KMALLOC_SHIFT_HIGH; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!kmalloc_caches[i])</span><br><span class=\"line\">\t\t\tnew_kmalloc_cache(i, flags);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Caches that are not of the two-to-the-power-of size.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * These have to be created immediately after the</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * earlier power of two caches</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (KMALLOC_MIN_SIZE &lt;= <span class=\"number\">32</span> &amp;&amp; !kmalloc_caches[<span class=\"number\">1</span>] &amp;&amp; i == <span class=\"number\">6</span>)</span><br><span class=\"line\">\t\t\tnew_kmalloc_cache(<span class=\"number\">1</span>, flags);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (KMALLOC_MIN_SIZE &lt;= <span class=\"number\">64</span> &amp;&amp; !kmalloc_caches[<span class=\"number\">2</span>] &amp;&amp; i == <span class=\"number\">7</span>)</span><br><span class=\"line\">\t\t\tnew_kmalloc_cache(<span class=\"number\">2</span>, flags);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Kmalloc array is now usable */</span></span><br><span class=\"line\">\tslab_state = UP;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * kmalloc_info[] is to make slub_debug=,kmalloc-xx option work at boot time.</span></span><br><span class=\"line\"><span class=\"comment\"> * kmalloc_index() supports up to 2^26=64MB, so the final entry of the table is</span></span><br><span class=\"line\"><span class=\"comment\"> * kmalloc-67108864.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">&#125; <span class=\"keyword\">const</span> kmalloc_info[] __initconst = &#123;</span><br><span class=\"line\">\t&#123;<span class=\"literal\">NULL</span>,                      <span class=\"number\">0</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-96\"</span>,             <span class=\"number\">96</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-192\"</span>,           <span class=\"number\">192</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-8\"</span>,               <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-16\"</span>,             <span class=\"number\">16</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-32\"</span>,             <span class=\"number\">32</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-64\"</span>,             <span class=\"number\">64</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-128\"</span>,           <span class=\"number\">128</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-256\"</span>,           <span class=\"number\">256</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-512\"</span>,           <span class=\"number\">512</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-1024\"</span>,         <span class=\"number\">1024</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-2048\"</span>,         <span class=\"number\">2048</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-4096\"</span>,         <span class=\"number\">4096</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-8192\"</span>,         <span class=\"number\">8192</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-16384\"</span>,       <span class=\"number\">16384</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-32768\"</span>,       <span class=\"number\">32768</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-65536\"</span>,       <span class=\"number\">65536</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-131072\"</span>,     <span class=\"number\">131072</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-262144\"</span>,     <span class=\"number\">262144</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-524288\"</span>,     <span class=\"number\">524288</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-1048576\"</span>,   <span class=\"number\">1048576</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-2097152\"</span>,   <span class=\"number\">2097152</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-4194304\"</span>,   <span class=\"number\">4194304</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-8388608\"</span>,   <span class=\"number\">8388608</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-16777216\"</span>, <span class=\"number\">16777216</span>&#125;,\t\t&#123;<span class=\"string\">\"kmalloc-33554432\"</span>, <span class=\"number\">33554432</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">\"kmalloc-67108864\"</span>, <span class=\"number\">67108864</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">new_kmalloc_cache</span><span class=\"params\">(<span class=\"keyword\">int</span> idx, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tkmalloc_caches[idx] = create_kmalloc_cache(kmalloc_info[idx].name,</span><br><span class=\"line\">\t\t\t\t\tkmalloc_info[idx].size, flags);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>后面的<code>create_kmalloc_cache()</code>，则是尝试找到freelist, 例如从kmem_cache_cpu freelist， partial获取object， 若都为空则使用new_slab()-&gt;alloc_slab_page()-&gt;alloc_pages() 分配page 生成free objects。</p>\n<h2 id=\"4-调试手段\"><a href=\"#4-调试手段\" class=\"headerlink\" title=\"4. 调试手段\"></a>4. 调试手段</h2><h3 id=\"4-1-SLUB-DEBUG\"><a href=\"#4-1-SLUB-DEBUG\" class=\"headerlink\" title=\"4.1. SLUB_DEBUG\"></a>4.1. SLUB_DEBUG</h3><p>SLUB DEBUG检测oob(out-of-bounds)问题原理:<font color=\"red\">在分配出去的内存尾部添加额外空间–red zone, 并填充MAGIC，之后检测其内容。</font></p>\n<p>SLUB DEBUG 检测uaf(use-after-free)问题原理：<font color=\"red\">free 后，将object 数据填充MAGIC NUM(0X6B)</font></p>\n<p>slub 管理的object 对象的格式如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_debug_object_structure.png\" alt=\"slub object format\"></p>\n<p>free pointer是从object后移就是因为为了检测use-after-free问题,当free object时会在将object填充magic num(0x6b)。</p>\n<p><code>red zone</code><br>可以检测向后的越界访问</p>\n<p><code>red left pad</code><br>可以检测向前的越界访问</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/red_zone_red_left_pad.png\" alt=\"red zone &amp;&amp; red left pad\"></p>\n<p><code>padding</code><br>填充填充magic num，可以检测较大空间的overwritten</p>\n<p><code>Magic number</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//linux/include/linux/poison.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SLUB_RED_INACTIVE\t0xbb</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SLUB_RED_ACTIVE\t\t0xcc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* ...and for poisoning */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>\tPOISON_INUSE\t0x5a\t<span class=\"comment\">/* for use-uninitialised poisoning */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> POISON_FREE\t0x6b\t<span class=\"comment\">/* for use-after-free poisoning */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>\tPOISON_END\t0xa5\t<span class=\"comment\">/* end-byte of poisoning */</span></span></span><br></pre></td></tr></table></figure></p>\n<p>在slub alloc 一个object，经过init_object 填充magic num 后，会如下所示：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/slub_object_after_init_object.png\" alt=\"slub object after init object\"></p>\n<ul>\n<li>red_left_pad和Red zone填充了SLUB_RED_INACTIVE（0xbb）；</li>\n<li>object填充了POISON_FREE（0x6b），但是最后一个byte填充POISON_END（<font color=\"red\">0xa5</font>）；</li>\n<li>padding在allocate_slab的时候就已经被填充POISON_INUSE（0x5a）</li>\n</ul>\n<p>如果是oob(out-of-bounds)，这red zone/red left pad magic num 会被修改，在kfree 时检测red zone/red left pad， 反之是uaf(use-after-free)时， 我们再free 后将object 填充为POISON_FREE(0x6b) + POISON_END(0xa5)， 之后使用slabinfo 工具进行遍历检测free list mem，object 区域是否有被修改过。</p>\n<h3 id=\"4-2-KASAN\"><a href=\"#4-2-KASAN\" class=\"headerlink\" title=\"4.2. KASAN\"></a>4.2. KASAN</h3><p>KASAN (kernel address sanitizer) runtime memory debugger， 是一个动态检测工具。Kernel doc 可参见Documentation/dev-tool/kasan.rst 文档。<br>我们从kernel menuconfig 中help 信息可以看出：</p>\n<ul>\n<li>GCC 4.9.2以上版本才支持debug 功能</li>\n<li>GCC 5.0以上版本支持栈、全局变量的越界访问</li>\n<li>消耗1/8 内存用于跟踪记录</li>\n</ul>\n<blockquote>\n<p>designed to find <font color=\"red\">out-of-bounds accesses</font> and <font color=\"red\">use-after-free</font> bugs.<br>This is strictly a debugging feature and it requires a gcc version<br>of <strong>4.9.2 or later</strong>. Detection of out of bounds accesses to stack or<br>global variables requires <strong>gcc 5.0 or later</strong>.<br>This feature <strong>consumes about 1/8 of available memory</strong> and brings about<br>~x3 performance slowdown.</p>\n</blockquote>\n<p><code>原理</code><br>KASAN 利用额外的内存(shadow memory, 影子区)标记内存状态，使用magic num 填充shadow memory，每一次R/w mem时都会检测shadow memory 是否valid。每连续8 bytes 使用1 byte shadow memory 标记。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/kasan_shadow_mm.png\" alt=\"kasan shadow memory\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_FREE_PAGE         0xFF  <span class=\"comment\">/* page was freed */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_PAGE_REDZONE      0xFE  <span class=\"comment\">/* redzone for kmalloc_large allocations */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_KMALLOC_REDZONE   0xFC  <span class=\"comment\">/* redzone inside slub object */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_KMALLOC_FREE      0xFB  <span class=\"comment\">/* object was freed (kmem_cache_free/kfree) */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_GLOBAL_REDZONE    0xFA  <span class=\"comment\">/* redzone for global variable */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Stack redzone shadow values</span></span><br><span class=\"line\"><span class=\"comment\"> * (Those are compiler's ABI, don't change them)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_STACK_LEFT        0xF1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_STACK_MID         0xF2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_STACK_RIGHT       0xF3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_STACK_PARTIAL     0xF4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KASAN_USE_AFTER_SCOPE   0xF8</span></span><br></pre></td></tr></table></figure>\n<p>在高版本的gcc 中编译器编译时在mm access 插入<strong>asan_load/</strong>asan_store 函数。</p>\n<p>arm64, VA_BITS=48, kernel 的mem layout. (KERNEL是不是位于linear mapping区域，这里怎么变成了VMALLOC区域？这里是Ard Biesheuvel提交的修改。主要是为了迎接ARM64世界的KASLR（which allows the kernel image to be located anywhere in the vmalloc area）的到来。)<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/kernel_mm/slab/arm64_va_bits48_mem_layout.png\" alt=\"arm64, va_bits 48, mem layout\"></p>\n<p><font color=\"red\">shadow_addr = (kaddr &gt;&gt; 3)  + KASAN_SHADOW_OFFSE</font>,在kasan_init()之后KASAN 就能正常工作，kernel 与 linear mapping 区域建立与shadow memory映射。若是module，则在load 时建立映射关系。</p>\n<p><code>检测</code><br>大致与SLUB_DEBUG相同，通过填充KASAN_FREE_PAGE/KASAN_KMALLOC_FREE 来检测UAF(use-after-free), 填充KASAN_KMALLOC_REDZONE 到red zone检测OOB(out-of-bounds), 这针对于伙伴算法与slub allocator。在debug stack或global 变量时则需要GCC 编译器插入red zone。组成类似结构体:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\ttype data;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> redzone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>结果</code><br>参见kernel 中Documentation/dev-tool/kasan.rst<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==================================================================</span><br><span class=\"line\">    BUG: AddressSanitizer: out of bounds access in kmalloc_oob_right+0x65/0x75 [test_kasan] at addr ffff8800693bc5d3</span><br><span class=\"line\">    Write of size 1 by task modprobe/1689</span><br><span class=\"line\">    =============================================================================</span><br><span class=\"line\">    BUG kmalloc-128 (Not tainted): kasan error</span><br><span class=\"line\">    -----------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">    Disabling lock debugging due to kernel taint</span><br><span class=\"line\">    INFO: Allocated in kmalloc_oob_right+0x3d/0x75 [test_kasan] age=0 cpu=0 pid=1689</span><br><span class=\"line\">     __slab_alloc+0x4b4/0x4f0</span><br><span class=\"line\">     kmem_cache_alloc_trace+0x10b/0x190</span><br><span class=\"line\">     kmalloc_oob_right+0x3d/0x75 [test_kasan]</span><br><span class=\"line\">     init_module+0x9/0x47 [test_kasan]</span><br><span class=\"line\">     do_one_initcall+0x99/0x200</span><br><span class=\"line\">     load_module+0x2cb3/0x3b20</span><br><span class=\"line\">     SyS_finit_module+0x76/0x80</span><br><span class=\"line\">     system_call_fastpath+0x12/0x17</span><br><span class=\"line\">    INFO: Slab 0xffffea0001a4ef00 objects=17 used=7 fp=0xffff8800693bd728 flags=0x100000000004080</span><br><span class=\"line\">    INFO: Object 0xffff8800693bc558 @offset=1368 fp=0xffff8800693bc720</span><br><span class=\"line\"></span><br><span class=\"line\">    Bytes b4 ffff8800693bc548: 00 00 00 00 00 00 00 00 5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ</span><br><span class=\"line\">    Object ffff8800693bc558: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc568: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc578: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc588: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc598: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc5a8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc5b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class=\"line\">    Object ffff8800693bc5c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.</span><br><span class=\"line\">    Redzone ffff8800693bc5d8: cc cc cc cc cc cc cc cc                          ........</span><br><span class=\"line\">    Padding ffff8800693bc718: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ</span><br><span class=\"line\">    CPU: 0 PID: 1689 Comm: modprobe Tainted: G    B          3.18.0-rc1-mm1+ #98</span><br><span class=\"line\">    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014</span><br><span class=\"line\">     ffff8800693bc000 0000000000000000 ffff8800693bc558 ffff88006923bb78</span><br><span class=\"line\">     ffffffff81cc68ae 00000000000000f3 ffff88006d407600 ffff88006923bba8</span><br><span class=\"line\">     ffffffff811fd848 ffff88006d407600 ffffea0001a4ef00 ffff8800693bc558</span><br><span class=\"line\">    Call Trace:</span><br><span class=\"line\">     [&lt;ffffffff81cc68ae&gt;] dump_stack+0x46/0x58</span><br><span class=\"line\">     [&lt;ffffffff811fd848&gt;] print_trailer+0xf8/0x160</span><br><span class=\"line\">     [&lt;ffffffffa00026a7&gt;] ? kmem_cache_oob+0xc3/0xc3 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffff811ff0f5&gt;] object_err+0x35/0x40</span><br><span class=\"line\">     [&lt;ffffffffa0002065&gt;] ? kmalloc_oob_right+0x65/0x75 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffff8120b9fa&gt;] kasan_report_error+0x38a/0x3f0</span><br><span class=\"line\">     [&lt;ffffffff8120a79f&gt;] ? kasan_poison_shadow+0x2f/0x40</span><br><span class=\"line\">     [&lt;ffffffff8120b344&gt;] ? kasan_unpoison_shadow+0x14/0x40</span><br><span class=\"line\">     [&lt;ffffffff8120a79f&gt;] ? kasan_poison_shadow+0x2f/0x40</span><br><span class=\"line\">     [&lt;ffffffffa00026a7&gt;] ? kmem_cache_oob+0xc3/0xc3 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffff8120a995&gt;] __asan_store1+0x75/0xb0</span><br><span class=\"line\">     [&lt;ffffffffa0002601&gt;] ? kmem_cache_oob+0x1d/0xc3 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffffa0002065&gt;] ? kmalloc_oob_right+0x65/0x75 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffffa0002065&gt;] kmalloc_oob_right+0x65/0x75 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffffa00026b0&gt;] init_module+0x9/0x47 [test_kasan]</span><br><span class=\"line\">     [&lt;ffffffff810002d9&gt;] do_one_initcall+0x99/0x200</span><br><span class=\"line\">     [&lt;ffffffff811e4e5c&gt;] ? __vunmap+0xec/0x160</span><br><span class=\"line\">     [&lt;ffffffff81114f63&gt;] load_module+0x2cb3/0x3b20</span><br><span class=\"line\">     [&lt;ffffffff8110fd70&gt;] ? m_show+0x240/0x240</span><br><span class=\"line\">     [&lt;ffffffff81115f06&gt;] SyS_finit_module+0x76/0x80</span><br><span class=\"line\">     [&lt;ffffffff81cd3129&gt;] system_call_fastpath+0x12/0x17</span><br><span class=\"line\">    Memory state around the buggy address:</span><br><span class=\"line\">     ffff8800693bc300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc380: fc fc 00 00 00 00 00 00 00 00 00 00 00 00 00 fc</span><br><span class=\"line\">     ffff8800693bc400: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc500: fc fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00</span><br><span class=\"line\">    &gt;ffff8800693bc580: 00 00 00 00 00 00 00 00 00 00 03 fc fc fc fc fc</span><br><span class=\"line\">                                                 ^</span><br><span class=\"line\">     ffff8800693bc600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class=\"line\">     ffff8800693bc700: fc fc fc fc fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class=\"line\">     ffff8800693bc780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class=\"line\">     ffff8800693bc800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class=\"line\">    ==================================================================</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://blog.csdn.net/lukuen/article/details/6935068\" target=\"_blank\" rel=\"noopener\">linux 内核 内存管理 slub算法 （一） 原理</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/426.html\" target=\"_blank\" rel=\"noopener\">图解slub</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/247.html\" target=\"_blank\" rel=\"noopener\">slub分配器</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/427.html\" target=\"_blank\" rel=\"noopener\">SLUB DEBUG原理</a></p>\n<p><a href=\"http://www.wowotech.net/memory_management/424.html\" target=\"_blank\" rel=\"noopener\">KASAN实现原理</a></p>"},{"title":"measure cpu loading by /proc/stat","date":"2020-04-10T02:38:59.000Z","_content":"\n常见的测量CPU loading 的工具有:\n- sar\n- top\n- iostat\n- mpstat\n- cat /proc/stat\n\n<!--more-->\n\n我们参看busybox 中src code，可以发现top，iostat, mpstat 都是使用到/proc/stat, 或者/proc/<pid>stat 文件并进行解析呈现。\n\n`iostat`\n![iostat](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/iostat.png)\n\n`mpstat`\n![mpstat](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/mpstat.png)\n\n`cat /proc/1/stat`\n![proc_pid_stat](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_pid_stat.png)\n\n## 1. /proc/stat\n\n`CPU time = user + nice + system + idle + iowait + irq + softirq + Steal `\n\n|     item     | remarks                             |\n| :----------: | :---------------------------------- |\n|  user time   | 普通用户进程占用时间                |\n|  nice time   | 高优先级用户进程占用时间            |\n| system time  | OS 中运行时间                       |\n|  idle time   | CPU 空闲时间                        |\n| iowait time  | I/O 等待时间                        |\n|   irq time   | 硬中断处理时间                      |\n| softirq time | 软中断处理时间                      |\n|  steal time  | 类似于guest os 切换等未统计到的时间 |\n\n![proc_stat](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_stat.png)\n\n### 1.1. 原理\n\n```c\n/* kernel/fs/proc/stat.c, kernel-4.9.198 */\nstatic int stat_open(struct inode *inode, struct file *file)\n{\n\tsize_t size = 1024 + 128 * num_online_cpus();\n\n\t/* minimum size to display an interrupt count : 2 bytes */\n\tsize += 2 * nr_irqs;\n\treturn single_open_size(file, show_stat, NULL, size);\n}\n\nstatic int show_stat(struct seq_file *p, void *v)\n{\n\tint i, j;\n\tu64 user, nice, system, idle, iowait, irq, softirq, steal;\n\tu64 guest, guest_nice;\n\n\tuser = nice = system = idle = iowait =\n\t\tirq = softirq = steal = 0;\n\tguest = guest_nice = 0;\n\n\tgetboottime64(&boottime);\n\n\tfor_each_possible_cpu(i) {\n\t\tuser += kcpustat_cpu(i).cpustat[CPUTIME_USER];\n\t\tnice += kcpustat_cpu(i).cpustat[CPUTIME_NICE];\n\t\tsystem += kcpustat_cpu(i).cpustat[CPUTIME_SYSTEM];\n\t\tidle += get_idle_time(i);\n\t\tiowait += get_iowait_time(i);\n\t\tirq += kcpustat_cpu(i).cpustat[CPUTIME_IRQ];\n\t\tsoftirq += kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ];\n\t\tsteal += kcpustat_cpu(i).cpustat[CPUTIME_STEAL];\n\t\tguest += kcpustat_cpu(i).cpustat[CPUTIME_GUEST];\n\t\tguest_nice += kcpustat_cpu(i).cpustat[CPUTIME_GUEST_NICE];\n\t\tsum += kstat_cpu_irqs_sum(i);\n\t\tsum += arch_irq_stat_cpu(i);\n\t}\n}\n```\n在show_stat() 中<font color=red>kcpustat_cpu(i).cpustat[CPUTIME_USER]</font> 这个变量时一个关键全局变量。per_cpu 的用法大致是在kernel init 时拷贝CPU NUM 份变量到不同的内存空间，访问时加上CPU NUM(i) 的偏移量。\n\n```c\nstruct kernel_cpustat {\n\tu64 cpustat[NR_STATS];\n};\n\n#define kstat_cpu(cpu) per_cpu(kstat, cpu)\n#define kcpustat_cpu(cpu) per_cpu(kernel_cpustat, cpu)\n```\n\n### 1.2. 何时更新\n那kernel_cpustat 是在什么时候更新的呢？答案是在Timer 的中断函数中进行更新。\n\n我们可以使用`dump_stack()`函数打印调用栈。在`clockevents_config_and_register()` 进行clock event 注册时有如下关系：\n\n```c\nclockevents_config_and_register() ->\n    tick_check_new_device() -> \n        tick_setup_device() -> \n            tick_setup_periodic() -> \n                tick_set_periodic_handle()\n```\n\n那之后timer 将会在1/HZ 时raise 中断， 则有如下调用关系起来：\n\n```c\ntick_handle_periodic()->\n    update_process_times() ->\n        account_process_tick() ->\n            account_system_time()\n```\n\n在`account_system_time()` 函数中会进行分类统计CPU 占用时间。\n```c\n/* linux/kernel/sched/cputime.c, kernel-4.9.18 */\nvoid account_process_tick(struct task_struct *p, int user_tick)\n{\n\tcputime_t cputime, scaled, steal;\n\tstruct rq *rq = this_rq();\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_process_tick(p, user_tick, rq, 1);\n\t\treturn;\n\t}\n\n\tcputime = cputime_one_jiffy;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\tscaled = cputime_to_scaled(cputime);\n\n\tif (user_tick)\n\t\taccount_user_time(p, cputime, scaled);\n\telse if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime, scaled);\n\telse\n\t\taccount_idle_time(cputime);\n}\n```\n\n### 1.3. 怎么分类\n接下来的问题是我们怎么知道何时是user, system, idle 等呢？\n\n#### 1.3.1 user or system?\n\nARM CPU 可以从CPSR reg 得到当前的运行态，下面函数大概也是基于此思想：\n```c\n/*\ntick_handle_periodic() ->\n    tick_periodic()\n*/\nstatic void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\twrite_seqlock(&jiffies_lock);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add(tick_next_period, tick_period);\n\n\t\tdo_timer(1);\n\t\twrite_sequnlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}\n\n#define user_mode(regs)\t\\\n\t(((regs)->ARM_cpsr & 0xf) == 0)\n\nstatic inline struct pt_regs *get_irq_regs(void)\n{\n\treturn __this_cpu_read(__irq_regs);\n}  \n```\n\n#### 1.3.2. system, irq, softirq ?\n\n__判断idle or system__\n主要通过`struct rq -> runqueue` 运行队列上状态判断是否是IDLE。\n```c\nvoid account_process_tick(struct task_struct *p, int user_tick)\n{\n\tstruct rq *rq = this_rq();\n    ...\n\tif (user_tick)\n\t\taccount_user_time(p, cputime, scaled);\n\telse if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime, scaled);\n\telse\n\t\taccount_idle_time(cputime);\n}\n```\n\n__判断system, irq, softirq__\n\nkernel 判断通过thread_info 中<font color=red>preempt_count</font> 进行判断。 \n在进入中断时，preempt_count 会进行设定。\n\n```c\n#define __irq_enter()\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\taccount_irq_enter_time(current);\t\\\n\t\tpreempt_count_add(HARDIRQ_OFFSET);\t\\\n\t\ttrace_hardirq_enter();\t\t\t\\\n\t} while (0)\n\n#define in_irq()\t\t        (hardirq_count())\n#define in_softirq()\t\t    (softirq_count())\n#define in_interrupt()\t\t    (irq_count())\n#define in_serving_softirq()\t(softirq_count() & SOFTIRQ_OFFSET)\n\n#define hardirq_count()\t(preempt_count() & HARDIRQ_MASK)\n#define softirq_count()\t(preempt_count() & SOFTIRQ_MASK)\n\nstatic __always_inline int preempt_count(void)\n{\n\treturn READ_ONCE(current_thread_info()->preempt_count);\n}\n\n\nvoid account_system_time(struct task_struct *p, int hardirq_offset,\n\t\t\t cputime_t cputime, cputime_t cputime_scaled)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime, cputime_scaled);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\t__account_system_time(p, cputime, cputime_scaled, index);\n}\n```\n\n### 1.4. 准确性\n通过上面的分析，我们知道数据更新频率是1/HZ。 如果在一个timer 中断周期内有进程的调度，那么我们在timer 周期中断函数统计就可能漏掉了调度前进程占用CPU 的时间。这就最终与我们的Kernel HZ 的配置有一定的关系， 不过一般情况下kenrel 进程切换的频率并没有达到如此频繁程度。\n\n如下图所示， 在前一个Timer 周期内，Process A, Process B 在调度，那么在中断时，我们只统计到了process B， 我们就漏了Process A 占用时间。\n\n![proc_stat_precision](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_stat_precision.png)\n\n引起进程调度的常见原因有：\n- 进程调用sleep(), exit() 等函数\n- 进程时间片耗尽\n- driver 中主动调用schedule()\n- 从中断等异常，系统调用返回用户态\n\n我们可以通过如下方式得到当前OS 调度程度 `watch -d -n 1 'cat /proc/sched_debug | grep nr_switches'` \n![cpu_process_switch](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/cpu_process_switch.png)\n\n## 2. 总结\n- Linux CPU占用率是根据/proc/stat文件中的数据计算而来；\n- /proc/stat中的数据精度为ticks，即1/HZ秒；\n- 内核每个ticks会更新一次CPU使用信息；\n- CPU 占用率的精度为1/HZ秒, 数据信息单位是ticks\n\n## Reference\n[linux cpu usage analysis](http://www.ilinuxkernel.com/files/Linux_CPU_Usage_Analysis.pdf)\n\n[理解 CPU 利用率](https://www.jianshu.com/p/f595ee986b55?from=singlemessage)\n\n[Linux系统中的CPU利用率](https://blog.csdn.net/lihualoveyou/article/details/78392229)\n\n[借助perf工具分析CPU使用率](http://linuxperf.com/?p=36)\n\n[我是如何把CPU使用率从70%降到25%的](https://www.jianshu.com/p/919c75dbc420)\n\n[solaris上应该如何监控CPU使用情况](https://www.iteye.com/blog/sunrise-king-1697486)\n\n[kernel per_cpu](https://blog.csdn.net/dayancn/article/details/51169241 )","source":"_posts/measure-cpu-loading-by-proc-stat.md","raw":"---\ntitle: measure cpu loading by /proc/stat\ndate: 2020-04-10 10:38:59\ntags: cpu_loading\ncategories: tools\n---\n\n常见的测量CPU loading 的工具有:\n- sar\n- top\n- iostat\n- mpstat\n- cat /proc/stat\n\n<!--more-->\n\n我们参看busybox 中src code，可以发现top，iostat, mpstat 都是使用到/proc/stat, 或者/proc/<pid>stat 文件并进行解析呈现。\n\n`iostat`\n![iostat](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/iostat.png)\n\n`mpstat`\n![mpstat](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/mpstat.png)\n\n`cat /proc/1/stat`\n![proc_pid_stat](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_pid_stat.png)\n\n## 1. /proc/stat\n\n`CPU time = user + nice + system + idle + iowait + irq + softirq + Steal `\n\n|     item     | remarks                             |\n| :----------: | :---------------------------------- |\n|  user time   | 普通用户进程占用时间                |\n|  nice time   | 高优先级用户进程占用时间            |\n| system time  | OS 中运行时间                       |\n|  idle time   | CPU 空闲时间                        |\n| iowait time  | I/O 等待时间                        |\n|   irq time   | 硬中断处理时间                      |\n| softirq time | 软中断处理时间                      |\n|  steal time  | 类似于guest os 切换等未统计到的时间 |\n\n![proc_stat](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_stat.png)\n\n### 1.1. 原理\n\n```c\n/* kernel/fs/proc/stat.c, kernel-4.9.198 */\nstatic int stat_open(struct inode *inode, struct file *file)\n{\n\tsize_t size = 1024 + 128 * num_online_cpus();\n\n\t/* minimum size to display an interrupt count : 2 bytes */\n\tsize += 2 * nr_irqs;\n\treturn single_open_size(file, show_stat, NULL, size);\n}\n\nstatic int show_stat(struct seq_file *p, void *v)\n{\n\tint i, j;\n\tu64 user, nice, system, idle, iowait, irq, softirq, steal;\n\tu64 guest, guest_nice;\n\n\tuser = nice = system = idle = iowait =\n\t\tirq = softirq = steal = 0;\n\tguest = guest_nice = 0;\n\n\tgetboottime64(&boottime);\n\n\tfor_each_possible_cpu(i) {\n\t\tuser += kcpustat_cpu(i).cpustat[CPUTIME_USER];\n\t\tnice += kcpustat_cpu(i).cpustat[CPUTIME_NICE];\n\t\tsystem += kcpustat_cpu(i).cpustat[CPUTIME_SYSTEM];\n\t\tidle += get_idle_time(i);\n\t\tiowait += get_iowait_time(i);\n\t\tirq += kcpustat_cpu(i).cpustat[CPUTIME_IRQ];\n\t\tsoftirq += kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ];\n\t\tsteal += kcpustat_cpu(i).cpustat[CPUTIME_STEAL];\n\t\tguest += kcpustat_cpu(i).cpustat[CPUTIME_GUEST];\n\t\tguest_nice += kcpustat_cpu(i).cpustat[CPUTIME_GUEST_NICE];\n\t\tsum += kstat_cpu_irqs_sum(i);\n\t\tsum += arch_irq_stat_cpu(i);\n\t}\n}\n```\n在show_stat() 中<font color=red>kcpustat_cpu(i).cpustat[CPUTIME_USER]</font> 这个变量时一个关键全局变量。per_cpu 的用法大致是在kernel init 时拷贝CPU NUM 份变量到不同的内存空间，访问时加上CPU NUM(i) 的偏移量。\n\n```c\nstruct kernel_cpustat {\n\tu64 cpustat[NR_STATS];\n};\n\n#define kstat_cpu(cpu) per_cpu(kstat, cpu)\n#define kcpustat_cpu(cpu) per_cpu(kernel_cpustat, cpu)\n```\n\n### 1.2. 何时更新\n那kernel_cpustat 是在什么时候更新的呢？答案是在Timer 的中断函数中进行更新。\n\n我们可以使用`dump_stack()`函数打印调用栈。在`clockevents_config_and_register()` 进行clock event 注册时有如下关系：\n\n```c\nclockevents_config_and_register() ->\n    tick_check_new_device() -> \n        tick_setup_device() -> \n            tick_setup_periodic() -> \n                tick_set_periodic_handle()\n```\n\n那之后timer 将会在1/HZ 时raise 中断， 则有如下调用关系起来：\n\n```c\ntick_handle_periodic()->\n    update_process_times() ->\n        account_process_tick() ->\n            account_system_time()\n```\n\n在`account_system_time()` 函数中会进行分类统计CPU 占用时间。\n```c\n/* linux/kernel/sched/cputime.c, kernel-4.9.18 */\nvoid account_process_tick(struct task_struct *p, int user_tick)\n{\n\tcputime_t cputime, scaled, steal;\n\tstruct rq *rq = this_rq();\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_process_tick(p, user_tick, rq, 1);\n\t\treturn;\n\t}\n\n\tcputime = cputime_one_jiffy;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\tscaled = cputime_to_scaled(cputime);\n\n\tif (user_tick)\n\t\taccount_user_time(p, cputime, scaled);\n\telse if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime, scaled);\n\telse\n\t\taccount_idle_time(cputime);\n}\n```\n\n### 1.3. 怎么分类\n接下来的问题是我们怎么知道何时是user, system, idle 等呢？\n\n#### 1.3.1 user or system?\n\nARM CPU 可以从CPSR reg 得到当前的运行态，下面函数大概也是基于此思想：\n```c\n/*\ntick_handle_periodic() ->\n    tick_periodic()\n*/\nstatic void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\twrite_seqlock(&jiffies_lock);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add(tick_next_period, tick_period);\n\n\t\tdo_timer(1);\n\t\twrite_sequnlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}\n\n#define user_mode(regs)\t\\\n\t(((regs)->ARM_cpsr & 0xf) == 0)\n\nstatic inline struct pt_regs *get_irq_regs(void)\n{\n\treturn __this_cpu_read(__irq_regs);\n}  \n```\n\n#### 1.3.2. system, irq, softirq ?\n\n__判断idle or system__\n主要通过`struct rq -> runqueue` 运行队列上状态判断是否是IDLE。\n```c\nvoid account_process_tick(struct task_struct *p, int user_tick)\n{\n\tstruct rq *rq = this_rq();\n    ...\n\tif (user_tick)\n\t\taccount_user_time(p, cputime, scaled);\n\telse if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime, scaled);\n\telse\n\t\taccount_idle_time(cputime);\n}\n```\n\n__判断system, irq, softirq__\n\nkernel 判断通过thread_info 中<font color=red>preempt_count</font> 进行判断。 \n在进入中断时，preempt_count 会进行设定。\n\n```c\n#define __irq_enter()\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\taccount_irq_enter_time(current);\t\\\n\t\tpreempt_count_add(HARDIRQ_OFFSET);\t\\\n\t\ttrace_hardirq_enter();\t\t\t\\\n\t} while (0)\n\n#define in_irq()\t\t        (hardirq_count())\n#define in_softirq()\t\t    (softirq_count())\n#define in_interrupt()\t\t    (irq_count())\n#define in_serving_softirq()\t(softirq_count() & SOFTIRQ_OFFSET)\n\n#define hardirq_count()\t(preempt_count() & HARDIRQ_MASK)\n#define softirq_count()\t(preempt_count() & SOFTIRQ_MASK)\n\nstatic __always_inline int preempt_count(void)\n{\n\treturn READ_ONCE(current_thread_info()->preempt_count);\n}\n\n\nvoid account_system_time(struct task_struct *p, int hardirq_offset,\n\t\t\t cputime_t cputime, cputime_t cputime_scaled)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime, cputime_scaled);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\t__account_system_time(p, cputime, cputime_scaled, index);\n}\n```\n\n### 1.4. 准确性\n通过上面的分析，我们知道数据更新频率是1/HZ。 如果在一个timer 中断周期内有进程的调度，那么我们在timer 周期中断函数统计就可能漏掉了调度前进程占用CPU 的时间。这就最终与我们的Kernel HZ 的配置有一定的关系， 不过一般情况下kenrel 进程切换的频率并没有达到如此频繁程度。\n\n如下图所示， 在前一个Timer 周期内，Process A, Process B 在调度，那么在中断时，我们只统计到了process B， 我们就漏了Process A 占用时间。\n\n![proc_stat_precision](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_stat_precision.png)\n\n引起进程调度的常见原因有：\n- 进程调用sleep(), exit() 等函数\n- 进程时间片耗尽\n- driver 中主动调用schedule()\n- 从中断等异常，系统调用返回用户态\n\n我们可以通过如下方式得到当前OS 调度程度 `watch -d -n 1 'cat /proc/sched_debug | grep nr_switches'` \n![cpu_process_switch](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/cpu_process_switch.png)\n\n## 2. 总结\n- Linux CPU占用率是根据/proc/stat文件中的数据计算而来；\n- /proc/stat中的数据精度为ticks，即1/HZ秒；\n- 内核每个ticks会更新一次CPU使用信息；\n- CPU 占用率的精度为1/HZ秒, 数据信息单位是ticks\n\n## Reference\n[linux cpu usage analysis](http://www.ilinuxkernel.com/files/Linux_CPU_Usage_Analysis.pdf)\n\n[理解 CPU 利用率](https://www.jianshu.com/p/f595ee986b55?from=singlemessage)\n\n[Linux系统中的CPU利用率](https://blog.csdn.net/lihualoveyou/article/details/78392229)\n\n[借助perf工具分析CPU使用率](http://linuxperf.com/?p=36)\n\n[我是如何把CPU使用率从70%降到25%的](https://www.jianshu.com/p/919c75dbc420)\n\n[solaris上应该如何监控CPU使用情况](https://www.iteye.com/blog/sunrise-king-1697486)\n\n[kernel per_cpu](https://blog.csdn.net/dayancn/article/details/51169241 )","slug":"measure-cpu-loading-by-proc-stat","published":1,"updated":"2020-04-10T09:49:56.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qx003jzkgr3t0vjb10","content":"<p>常见的测量CPU loading 的工具有:</p>\n<ul>\n<li>sar</li>\n<li>top</li>\n<li>iostat</li>\n<li>mpstat</li>\n<li>cat /proc/stat</li>\n</ul>\n<a id=\"more\"></a>\n<p>我们参看busybox 中src code，可以发现top，iostat, mpstat 都是使用到/proc/stat, 或者/proc/<pid>stat 文件并进行解析呈现。</pid></p>\n<p><code>iostat</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/iostat.png\" alt=\"iostat\"></p>\n<p><code>mpstat</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/mpstat.png\" alt=\"mpstat\"></p>\n<p><code>cat /proc/1/stat</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_pid_stat.png\" alt=\"proc_pid_stat\"></p>\n<h2 id=\"1-proc-stat\"><a href=\"#1-proc-stat\" class=\"headerlink\" title=\"1. /proc/stat\"></a>1. /proc/stat</h2><p><code>CPU time = user + nice + system + idle + iowait + irq + softirq + Steal</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">item</th>\n<th style=\"text-align:left\">remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">user time</td>\n<td style=\"text-align:left\">普通用户进程占用时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nice time</td>\n<td style=\"text-align:left\">高优先级用户进程占用时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">system time</td>\n<td style=\"text-align:left\">OS 中运行时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">idle time</td>\n<td style=\"text-align:left\">CPU 空闲时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iowait time</td>\n<td style=\"text-align:left\">I/O 等待时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">irq time</td>\n<td style=\"text-align:left\">硬中断处理时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">softirq time</td>\n<td style=\"text-align:left\">软中断处理时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">steal time</td>\n<td style=\"text-align:left\">类似于guest os 切换等未统计到的时间</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_stat.png\" alt=\"proc_stat\"></p>\n<h3 id=\"1-1-原理\"><a href=\"#1-1-原理\" class=\"headerlink\" title=\"1.1. 原理\"></a>1.1. 原理</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* kernel/fs/proc/stat.c, kernel-4.9.198 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">stat_open</span><span class=\"params\">(struct inode *inode, struct file *file)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> size = <span class=\"number\">1024</span> + <span class=\"number\">128</span> * num_online_cpus();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* minimum size to display an interrupt count : 2 bytes */</span></span><br><span class=\"line\">\tsize += <span class=\"number\">2</span> * nr_irqs;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> single_open_size(file, show_stat, <span class=\"literal\">NULL</span>, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">show_stat</span><span class=\"params\">(struct seq_file *p, <span class=\"keyword\">void</span> *v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">\tu64 user, nice, system, idle, iowait, irq, softirq, steal;</span><br><span class=\"line\">\tu64 guest, guest_nice;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuser = nice = system = idle = iowait =</span><br><span class=\"line\">\t\tirq = softirq = steal = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tguest = guest_nice = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetboottime64(&amp;boottime);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor_each_possible_cpu(i) &#123;</span><br><span class=\"line\">\t\tuser += kcpustat_cpu(i).cpustat[CPUTIME_USER];</span><br><span class=\"line\">\t\tnice += kcpustat_cpu(i).cpustat[CPUTIME_NICE];</span><br><span class=\"line\">\t\tsystem += kcpustat_cpu(i).cpustat[CPUTIME_SYSTEM];</span><br><span class=\"line\">\t\tidle += get_idle_time(i);</span><br><span class=\"line\">\t\tiowait += get_iowait_time(i);</span><br><span class=\"line\">\t\tirq += kcpustat_cpu(i).cpustat[CPUTIME_IRQ];</span><br><span class=\"line\">\t\tsoftirq += kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ];</span><br><span class=\"line\">\t\tsteal += kcpustat_cpu(i).cpustat[CPUTIME_STEAL];</span><br><span class=\"line\">\t\tguest += kcpustat_cpu(i).cpustat[CPUTIME_GUEST];</span><br><span class=\"line\">\t\tguest_nice += kcpustat_cpu(i).cpustat[CPUTIME_GUEST_NICE];</span><br><span class=\"line\">\t\tsum += kstat_cpu_irqs_sum(i);</span><br><span class=\"line\">\t\tsum += arch_irq_stat_cpu(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在show_stat() 中<font color=\"red\">kcpustat_cpu(i).cpustat[CPUTIME_USER]</font> 这个变量时一个关键全局变量。per_cpu 的用法大致是在kernel init 时拷贝CPU NUM 份变量到不同的内存空间，访问时加上CPU NUM(i) 的偏移量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kernel_cpustat</span> &#123;</span></span><br><span class=\"line\">\tu64 cpustat[NR_STATS];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> kstat_cpu(cpu) per_cpu(kstat, cpu)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> kcpustat_cpu(cpu) per_cpu(kernel_cpustat, cpu)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-何时更新\"><a href=\"#1-2-何时更新\" class=\"headerlink\" title=\"1.2. 何时更新\"></a>1.2. 何时更新</h3><p>那kernel_cpustat 是在什么时候更新的呢？答案是在Timer 的中断函数中进行更新。</p>\n<p>我们可以使用<code>dump_stack()</code>函数打印调用栈。在<code>clockevents_config_and_register()</code> 进行clock event 注册时有如下关系：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clockevents_config_and_register() -&gt;</span><br><span class=\"line\">    tick_check_new_device() -&gt; </span><br><span class=\"line\">        tick_setup_device() -&gt; </span><br><span class=\"line\">            tick_setup_periodic() -&gt; </span><br><span class=\"line\">                tick_set_periodic_handle()</span><br></pre></td></tr></table></figure>\n<p>那之后timer 将会在1/HZ 时raise 中断， 则有如下调用关系起来：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tick_handle_periodic()-&gt;</span><br><span class=\"line\">    update_process_times() -&gt;</span><br><span class=\"line\">        account_process_tick() -&gt;</span><br><span class=\"line\">            account_system_time()</span><br></pre></td></tr></table></figure>\n<p>在<code>account_system_time()</code> 函数中会进行分类统计CPU 占用时间。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* linux/kernel/sched/cputime.c, kernel-4.9.18 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">account_process_tick</span><span class=\"params\">(struct task_struct *p, <span class=\"keyword\">int</span> user_tick)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">cputime_t</span> cputime, scaled, steal;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rq</span> *<span class=\"title\">rq</span> = <span class=\"title\">this_rq</span>();</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vtime_accounting_cpu_enabled())</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sched_clock_irqtime) &#123;</span><br><span class=\"line\">\t\tirqtime_account_process_tick(p, user_tick, rq, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcputime = cputime_one_jiffy;</span><br><span class=\"line\">\tsteal = steal_account_process_time(ULONG_MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (steal &gt;= cputime)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcputime -= steal;</span><br><span class=\"line\">\tscaled = cputime_to_scaled(cputime);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (user_tick)</span><br><span class=\"line\">\t\taccount_user_time(p, cputime, scaled);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((p != rq-&gt;idle) || (irq_count() != HARDIRQ_OFFSET))</span><br><span class=\"line\">\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime, scaled);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\taccount_idle_time(cputime);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-3-怎么分类\"><a href=\"#1-3-怎么分类\" class=\"headerlink\" title=\"1.3. 怎么分类\"></a>1.3. 怎么分类</h3><p>接下来的问题是我们怎么知道何时是user, system, idle 等呢？</p>\n<h4 id=\"1-3-1-user-or-system\"><a href=\"#1-3-1-user-or-system\" class=\"headerlink\" title=\"1.3.1 user or system?\"></a>1.3.1 user or system?</h4><p>ARM CPU 可以从CPSR reg 得到当前的运行态，下面函数大概也是基于此思想：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">tick_handle_periodic() -&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    tick_periodic()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick_periodic</span><span class=\"params\">(<span class=\"keyword\">int</span> cpu)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tick_do_timer_cpu == cpu) &#123;</span><br><span class=\"line\">\t\twrite_seqlock(&amp;jiffies_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* Keep track of the next tick event */</span></span><br><span class=\"line\">\t\ttick_next_period = ktime_add(tick_next_period, tick_period);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdo_timer(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\twrite_sequnlock(&amp;jiffies_lock);</span><br><span class=\"line\">\t\tupdate_wall_time();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tupdate_process_times(user_mode(get_irq_regs()));</span><br><span class=\"line\">\tprofile_tick(CPU_PROFILING);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> user_mode(regs)\t\\</span></span><br><span class=\"line\">\t(((regs)-&gt;ARM_cpsr &amp; <span class=\"number\">0xf</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> struct pt_regs *<span class=\"title\">get_irq_regs</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __this_cpu_read(__irq_regs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-3-2-system-irq-softirq\"><a href=\"#1-3-2-system-irq-softirq\" class=\"headerlink\" title=\"1.3.2. system, irq, softirq ?\"></a>1.3.2. system, irq, softirq ?</h4><p><strong>判断idle or system</strong><br>主要通过<code>struct rq -&gt; runqueue</code> 运行队列上状态判断是否是IDLE。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">account_process_tick</span><span class=\"params\">(struct task_struct *p, <span class=\"keyword\">int</span> user_tick)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rq</span> *<span class=\"title\">rq</span> = <span class=\"title\">this_rq</span>();</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (user_tick)</span><br><span class=\"line\">\t\taccount_user_time(p, cputime, scaled);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((p != rq-&gt;idle) || (irq_count() != HARDIRQ_OFFSET))</span><br><span class=\"line\">\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime, scaled);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\taccount_idle_time(cputime);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>判断system, irq, softirq</strong></p>\n<p>kernel 判断通过thread_info 中<font color=\"red\">preempt_count</font> 进行判断。<br>在进入中断时，preempt_count 会进行设定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __irq_enter()\t\t\t\t\t\\</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;\t\t\t\t\t\t\\</span><br><span class=\"line\">\t\taccount_irq_enter_time(current);\t\\</span><br><span class=\"line\">\t\tpreempt_count_add(HARDIRQ_OFFSET);\t\\</span><br><span class=\"line\">\t\ttrace_hardirq_enter();\t\t\t\\</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> in_irq()\t\t        (hardirq_count())</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> in_softirq()\t\t    (softirq_count())</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> in_interrupt()\t\t    (irq_count())</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> in_serving_softirq()\t(softirq_count() &amp; SOFTIRQ_OFFSET)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> hardirq_count()\t(preempt_count() &amp; HARDIRQ_MASK)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> softirq_count()\t(preempt_count() &amp; SOFTIRQ_MASK)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> __<span class=\"function\">always_inline <span class=\"keyword\">int</span> <span class=\"title\">preempt_count</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> READ_ONCE(current_thread_info()-&gt;preempt_count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">account_system_time</span><span class=\"params\">(struct task_struct *p, <span class=\"keyword\">int</span> hardirq_offset,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t <span class=\"keyword\">cputime_t</span> cputime, <span class=\"keyword\">cputime_t</span> cputime_scaled)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((p-&gt;flags &amp; PF_VCPU) &amp;&amp; (irq_count() - hardirq_offset == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">\t\taccount_guest_time(p, cputime, cputime_scaled);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (hardirq_count() - hardirq_offset)</span><br><span class=\"line\">\t\tindex = CPUTIME_IRQ;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (in_serving_softirq())</span><br><span class=\"line\">\t\tindex = CPUTIME_SOFTIRQ;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tindex = CPUTIME_SYSTEM;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__account_system_time(p, cputime, cputime_scaled, index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-准确性\"><a href=\"#1-4-准确性\" class=\"headerlink\" title=\"1.4. 准确性\"></a>1.4. 准确性</h3><p>通过上面的分析，我们知道数据更新频率是1/HZ。 如果在一个timer 中断周期内有进程的调度，那么我们在timer 周期中断函数统计就可能漏掉了调度前进程占用CPU 的时间。这就最终与我们的Kernel HZ 的配置有一定的关系， 不过一般情况下kenrel 进程切换的频率并没有达到如此频繁程度。</p>\n<p>如下图所示， 在前一个Timer 周期内，Process A, Process B 在调度，那么在中断时，我们只统计到了process B， 我们就漏了Process A 占用时间。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_stat_precision.png\" alt=\"proc_stat_precision\"></p>\n<p>引起进程调度的常见原因有：</p>\n<ul>\n<li>进程调用sleep(), exit() 等函数</li>\n<li>进程时间片耗尽</li>\n<li>driver 中主动调用schedule()</li>\n<li>从中断等异常，系统调用返回用户态</li>\n</ul>\n<p>我们可以通过如下方式得到当前OS 调度程度 <code>watch -d -n 1 &#39;cat /proc/sched_debug | grep nr_switches&#39;</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/cpu_process_switch.png\" alt=\"cpu_process_switch\"></p>\n<h2 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2. 总结\"></a>2. 总结</h2><ul>\n<li>Linux CPU占用率是根据/proc/stat文件中的数据计算而来；</li>\n<li>/proc/stat中的数据精度为ticks，即1/HZ秒；</li>\n<li>内核每个ticks会更新一次CPU使用信息；</li>\n<li>CPU 占用率的精度为1/HZ秒, 数据信息单位是ticks</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.ilinuxkernel.com/files/Linux_CPU_Usage_Analysis.pdf\" target=\"_blank\" rel=\"noopener\">linux cpu usage analysis</a></p>\n<p><a href=\"https://www.jianshu.com/p/f595ee986b55?from=singlemessage\" target=\"_blank\" rel=\"noopener\">理解 CPU 利用率</a></p>\n<p><a href=\"https://blog.csdn.net/lihualoveyou/article/details/78392229\" target=\"_blank\" rel=\"noopener\">Linux系统中的CPU利用率</a></p>\n<p><a href=\"http://linuxperf.com/?p=36\" target=\"_blank\" rel=\"noopener\">借助perf工具分析CPU使用率</a></p>\n<p><a href=\"https://www.jianshu.com/p/919c75dbc420\" target=\"_blank\" rel=\"noopener\">我是如何把CPU使用率从70%降到25%的</a></p>\n<p><a href=\"https://www.iteye.com/blog/sunrise-king-1697486\" target=\"_blank\" rel=\"noopener\">solaris上应该如何监控CPU使用情况</a></p>\n<p><a href=\"https://blog.csdn.net/dayancn/article/details/51169241\" target=\"_blank\" rel=\"noopener\">kernel per_cpu</a></p>\n","site":{"data":{}},"excerpt":"<p>常见的测量CPU loading 的工具有:</p>\n<ul>\n<li>sar</li>\n<li>top</li>\n<li>iostat</li>\n<li>mpstat</li>\n<li>cat /proc/stat</li>\n</ul>","more":"<p>我们参看busybox 中src code，可以发现top，iostat, mpstat 都是使用到/proc/stat, 或者/proc/<pid>stat 文件并进行解析呈现。</pid></p>\n<p><code>iostat</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/iostat.png\" alt=\"iostat\"></p>\n<p><code>mpstat</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/mpstat.png\" alt=\"mpstat\"></p>\n<p><code>cat /proc/1/stat</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_pid_stat.png\" alt=\"proc_pid_stat\"></p>\n<h2 id=\"1-proc-stat\"><a href=\"#1-proc-stat\" class=\"headerlink\" title=\"1. /proc/stat\"></a>1. /proc/stat</h2><p><code>CPU time = user + nice + system + idle + iowait + irq + softirq + Steal</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">item</th>\n<th style=\"text-align:left\">remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">user time</td>\n<td style=\"text-align:left\">普通用户进程占用时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nice time</td>\n<td style=\"text-align:left\">高优先级用户进程占用时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">system time</td>\n<td style=\"text-align:left\">OS 中运行时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">idle time</td>\n<td style=\"text-align:left\">CPU 空闲时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iowait time</td>\n<td style=\"text-align:left\">I/O 等待时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">irq time</td>\n<td style=\"text-align:left\">硬中断处理时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">softirq time</td>\n<td style=\"text-align:left\">软中断处理时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">steal time</td>\n<td style=\"text-align:left\">类似于guest os 切换等未统计到的时间</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_stat.png\" alt=\"proc_stat\"></p>\n<h3 id=\"1-1-原理\"><a href=\"#1-1-原理\" class=\"headerlink\" title=\"1.1. 原理\"></a>1.1. 原理</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* kernel/fs/proc/stat.c, kernel-4.9.198 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">stat_open</span><span class=\"params\">(struct inode *inode, struct file *file)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> size = <span class=\"number\">1024</span> + <span class=\"number\">128</span> * num_online_cpus();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* minimum size to display an interrupt count : 2 bytes */</span></span><br><span class=\"line\">\tsize += <span class=\"number\">2</span> * nr_irqs;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> single_open_size(file, show_stat, <span class=\"literal\">NULL</span>, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">show_stat</span><span class=\"params\">(struct seq_file *p, <span class=\"keyword\">void</span> *v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">\tu64 user, nice, system, idle, iowait, irq, softirq, steal;</span><br><span class=\"line\">\tu64 guest, guest_nice;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuser = nice = system = idle = iowait =</span><br><span class=\"line\">\t\tirq = softirq = steal = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tguest = guest_nice = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetboottime64(&amp;boottime);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor_each_possible_cpu(i) &#123;</span><br><span class=\"line\">\t\tuser += kcpustat_cpu(i).cpustat[CPUTIME_USER];</span><br><span class=\"line\">\t\tnice += kcpustat_cpu(i).cpustat[CPUTIME_NICE];</span><br><span class=\"line\">\t\tsystem += kcpustat_cpu(i).cpustat[CPUTIME_SYSTEM];</span><br><span class=\"line\">\t\tidle += get_idle_time(i);</span><br><span class=\"line\">\t\tiowait += get_iowait_time(i);</span><br><span class=\"line\">\t\tirq += kcpustat_cpu(i).cpustat[CPUTIME_IRQ];</span><br><span class=\"line\">\t\tsoftirq += kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ];</span><br><span class=\"line\">\t\tsteal += kcpustat_cpu(i).cpustat[CPUTIME_STEAL];</span><br><span class=\"line\">\t\tguest += kcpustat_cpu(i).cpustat[CPUTIME_GUEST];</span><br><span class=\"line\">\t\tguest_nice += kcpustat_cpu(i).cpustat[CPUTIME_GUEST_NICE];</span><br><span class=\"line\">\t\tsum += kstat_cpu_irqs_sum(i);</span><br><span class=\"line\">\t\tsum += arch_irq_stat_cpu(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在show_stat() 中<font color=\"red\">kcpustat_cpu(i).cpustat[CPUTIME_USER]</font> 这个变量时一个关键全局变量。per_cpu 的用法大致是在kernel init 时拷贝CPU NUM 份变量到不同的内存空间，访问时加上CPU NUM(i) 的偏移量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kernel_cpustat</span> &#123;</span></span><br><span class=\"line\">\tu64 cpustat[NR_STATS];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> kstat_cpu(cpu) per_cpu(kstat, cpu)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> kcpustat_cpu(cpu) per_cpu(kernel_cpustat, cpu)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-何时更新\"><a href=\"#1-2-何时更新\" class=\"headerlink\" title=\"1.2. 何时更新\"></a>1.2. 何时更新</h3><p>那kernel_cpustat 是在什么时候更新的呢？答案是在Timer 的中断函数中进行更新。</p>\n<p>我们可以使用<code>dump_stack()</code>函数打印调用栈。在<code>clockevents_config_and_register()</code> 进行clock event 注册时有如下关系：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clockevents_config_and_register() -&gt;</span><br><span class=\"line\">    tick_check_new_device() -&gt; </span><br><span class=\"line\">        tick_setup_device() -&gt; </span><br><span class=\"line\">            tick_setup_periodic() -&gt; </span><br><span class=\"line\">                tick_set_periodic_handle()</span><br></pre></td></tr></table></figure>\n<p>那之后timer 将会在1/HZ 时raise 中断， 则有如下调用关系起来：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tick_handle_periodic()-&gt;</span><br><span class=\"line\">    update_process_times() -&gt;</span><br><span class=\"line\">        account_process_tick() -&gt;</span><br><span class=\"line\">            account_system_time()</span><br></pre></td></tr></table></figure>\n<p>在<code>account_system_time()</code> 函数中会进行分类统计CPU 占用时间。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* linux/kernel/sched/cputime.c, kernel-4.9.18 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">account_process_tick</span><span class=\"params\">(struct task_struct *p, <span class=\"keyword\">int</span> user_tick)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">cputime_t</span> cputime, scaled, steal;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rq</span> *<span class=\"title\">rq</span> = <span class=\"title\">this_rq</span>();</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vtime_accounting_cpu_enabled())</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sched_clock_irqtime) &#123;</span><br><span class=\"line\">\t\tirqtime_account_process_tick(p, user_tick, rq, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcputime = cputime_one_jiffy;</span><br><span class=\"line\">\tsteal = steal_account_process_time(ULONG_MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (steal &gt;= cputime)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcputime -= steal;</span><br><span class=\"line\">\tscaled = cputime_to_scaled(cputime);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (user_tick)</span><br><span class=\"line\">\t\taccount_user_time(p, cputime, scaled);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((p != rq-&gt;idle) || (irq_count() != HARDIRQ_OFFSET))</span><br><span class=\"line\">\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime, scaled);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\taccount_idle_time(cputime);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-3-怎么分类\"><a href=\"#1-3-怎么分类\" class=\"headerlink\" title=\"1.3. 怎么分类\"></a>1.3. 怎么分类</h3><p>接下来的问题是我们怎么知道何时是user, system, idle 等呢？</p>\n<h4 id=\"1-3-1-user-or-system\"><a href=\"#1-3-1-user-or-system\" class=\"headerlink\" title=\"1.3.1 user or system?\"></a>1.3.1 user or system?</h4><p>ARM CPU 可以从CPSR reg 得到当前的运行态，下面函数大概也是基于此思想：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">tick_handle_periodic() -&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    tick_periodic()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick_periodic</span><span class=\"params\">(<span class=\"keyword\">int</span> cpu)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tick_do_timer_cpu == cpu) &#123;</span><br><span class=\"line\">\t\twrite_seqlock(&amp;jiffies_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* Keep track of the next tick event */</span></span><br><span class=\"line\">\t\ttick_next_period = ktime_add(tick_next_period, tick_period);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdo_timer(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\twrite_sequnlock(&amp;jiffies_lock);</span><br><span class=\"line\">\t\tupdate_wall_time();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tupdate_process_times(user_mode(get_irq_regs()));</span><br><span class=\"line\">\tprofile_tick(CPU_PROFILING);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> user_mode(regs)\t\\</span></span><br><span class=\"line\">\t(((regs)-&gt;ARM_cpsr &amp; <span class=\"number\">0xf</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> struct pt_regs *<span class=\"title\">get_irq_regs</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __this_cpu_read(__irq_regs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-3-2-system-irq-softirq\"><a href=\"#1-3-2-system-irq-softirq\" class=\"headerlink\" title=\"1.3.2. system, irq, softirq ?\"></a>1.3.2. system, irq, softirq ?</h4><p><strong>判断idle or system</strong><br>主要通过<code>struct rq -&gt; runqueue</code> 运行队列上状态判断是否是IDLE。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">account_process_tick</span><span class=\"params\">(struct task_struct *p, <span class=\"keyword\">int</span> user_tick)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rq</span> *<span class=\"title\">rq</span> = <span class=\"title\">this_rq</span>();</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (user_tick)</span><br><span class=\"line\">\t\taccount_user_time(p, cputime, scaled);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((p != rq-&gt;idle) || (irq_count() != HARDIRQ_OFFSET))</span><br><span class=\"line\">\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime, scaled);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\taccount_idle_time(cputime);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>判断system, irq, softirq</strong></p>\n<p>kernel 判断通过thread_info 中<font color=\"red\">preempt_count</font> 进行判断。<br>在进入中断时，preempt_count 会进行设定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __irq_enter()\t\t\t\t\t\\</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;\t\t\t\t\t\t\\</span><br><span class=\"line\">\t\taccount_irq_enter_time(current);\t\\</span><br><span class=\"line\">\t\tpreempt_count_add(HARDIRQ_OFFSET);\t\\</span><br><span class=\"line\">\t\ttrace_hardirq_enter();\t\t\t\\</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> in_irq()\t\t        (hardirq_count())</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> in_softirq()\t\t    (softirq_count())</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> in_interrupt()\t\t    (irq_count())</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> in_serving_softirq()\t(softirq_count() &amp; SOFTIRQ_OFFSET)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> hardirq_count()\t(preempt_count() &amp; HARDIRQ_MASK)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> softirq_count()\t(preempt_count() &amp; SOFTIRQ_MASK)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> __<span class=\"function\">always_inline <span class=\"keyword\">int</span> <span class=\"title\">preempt_count</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> READ_ONCE(current_thread_info()-&gt;preempt_count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">account_system_time</span><span class=\"params\">(struct task_struct *p, <span class=\"keyword\">int</span> hardirq_offset,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t <span class=\"keyword\">cputime_t</span> cputime, <span class=\"keyword\">cputime_t</span> cputime_scaled)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((p-&gt;flags &amp; PF_VCPU) &amp;&amp; (irq_count() - hardirq_offset == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">\t\taccount_guest_time(p, cputime, cputime_scaled);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (hardirq_count() - hardirq_offset)</span><br><span class=\"line\">\t\tindex = CPUTIME_IRQ;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (in_serving_softirq())</span><br><span class=\"line\">\t\tindex = CPUTIME_SOFTIRQ;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tindex = CPUTIME_SYSTEM;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__account_system_time(p, cputime, cputime_scaled, index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-准确性\"><a href=\"#1-4-准确性\" class=\"headerlink\" title=\"1.4. 准确性\"></a>1.4. 准确性</h3><p>通过上面的分析，我们知道数据更新频率是1/HZ。 如果在一个timer 中断周期内有进程的调度，那么我们在timer 周期中断函数统计就可能漏掉了调度前进程占用CPU 的时间。这就最终与我们的Kernel HZ 的配置有一定的关系， 不过一般情况下kenrel 进程切换的频率并没有达到如此频繁程度。</p>\n<p>如下图所示， 在前一个Timer 周期内，Process A, Process B 在调度，那么在中断时，我们只统计到了process B， 我们就漏了Process A 占用时间。</p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/proc_stat_precision.png\" alt=\"proc_stat_precision\"></p>\n<p>引起进程调度的常见原因有：</p>\n<ul>\n<li>进程调用sleep(), exit() 等函数</li>\n<li>进程时间片耗尽</li>\n<li>driver 中主动调用schedule()</li>\n<li>从中断等异常，系统调用返回用户态</li>\n</ul>\n<p>我们可以通过如下方式得到当前OS 调度程度 <code>watch -d -n 1 &#39;cat /proc/sched_debug | grep nr_switches&#39;</code><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/tools/proc_stat/cpu_process_switch.png\" alt=\"cpu_process_switch\"></p>\n<h2 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2. 总结\"></a>2. 总结</h2><ul>\n<li>Linux CPU占用率是根据/proc/stat文件中的数据计算而来；</li>\n<li>/proc/stat中的数据精度为ticks，即1/HZ秒；</li>\n<li>内核每个ticks会更新一次CPU使用信息；</li>\n<li>CPU 占用率的精度为1/HZ秒, 数据信息单位是ticks</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://www.ilinuxkernel.com/files/Linux_CPU_Usage_Analysis.pdf\" target=\"_blank\" rel=\"noopener\">linux cpu usage analysis</a></p>\n<p><a href=\"https://www.jianshu.com/p/f595ee986b55?from=singlemessage\" target=\"_blank\" rel=\"noopener\">理解 CPU 利用率</a></p>\n<p><a href=\"https://blog.csdn.net/lihualoveyou/article/details/78392229\" target=\"_blank\" rel=\"noopener\">Linux系统中的CPU利用率</a></p>\n<p><a href=\"http://linuxperf.com/?p=36\" target=\"_blank\" rel=\"noopener\">借助perf工具分析CPU使用率</a></p>\n<p><a href=\"https://www.jianshu.com/p/919c75dbc420\" target=\"_blank\" rel=\"noopener\">我是如何把CPU使用率从70%降到25%的</a></p>\n<p><a href=\"https://www.iteye.com/blog/sunrise-king-1697486\" target=\"_blank\" rel=\"noopener\">solaris上应该如何监控CPU使用情况</a></p>\n<p><a href=\"https://blog.csdn.net/dayancn/article/details/51169241\" target=\"_blank\" rel=\"noopener\">kernel per_cpu</a></p>"},{"title":"more_coding_more_happy","date":"2017-12-25T11:35:34.000Z","categorise":"bookmarks","_content":"\n# 《我编程，我快乐：程序员职业规划之道》\n\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=6a709c667af0f736ccf344536b3cd87c/342ac65c103853433ae62d389113b07eca8088fa.jpg)\n\n[*我编程，我快乐 百度百科*](https://baike.baidu.com/item/%E6%88%91%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%88%91%E5%BF%AB%E4%B9%90/12445811?fr=aladdin)\n\n## 0. 序言\n\n### 0.1. 不要害怕失败\n\n不是继续保持平庸，而是要出色，要赢。就像在赛跑中，你要总想着怎么不输，那肯定不会赢得比赛。同样，总想着怎么避免糟糕的活着，那你也不可能成为生活中的赢家。**任何人都不应该时刻想着如何避免失败。**\n***(不是反对应对最坏的情况的应急措施的想法)***  \n\n一个渴望成功的人肯定要比那些只是单纯完成工作的人更有可能成功。即使我们不能成为顶级专家，但确定高目标至少可以让我们不再平凡。\n\n**TIPS：**  \n    永远对生活充满乐观与热情，即使他QJ了你无数次。\n\n<!-- more -->\n\n### 0.2. 制定自己的计划\n审视自己的职业，不要跟在别人的计划后面跑，应该按着自己的计划发展。 \n\n软件可以看做是一门生意，雇佣软件开发人员，是因为可以创造利润。要评定自身的表现，就要看你能给公司创造多少商业价值。  \n把**职业**想象成正在制作的产品的**生命周期**，你的技术成就了这个产品。在设计、生产及销售商品时，我们应注意：\n\n- 选择市场：关注技术和商业领域\n- 投资：知识和技术是商品的基础，要合理投资\n- 执行：不光有技术还有产出\n- 市场：有好的产品，也要得到行业中的认可\n\n---\n\n## 1. 市场分析\n\n### 1.1. 稳定成熟的技术还是未成熟的新技术？\n\n这与风险收益平衡概念类似。\n\n| 稳定的技术 | 未成熟的技术  |\n| -----      | ------- |\n| 投资风险低 | 高风险     |\n| 收益低     | 收益极高或极低 |\n\n选择是把双刃剑，决定权还是在自己手里。但是，无论做出哪种选择，最终的目的是**产生利润**。\n\n**TIPS：**  \n    从行业信息，招聘信息或者论坛嗅到行业的发展方向。如当前的云计算，大数据，人工智能等\n\n### 1.2. 供应和需求\n\n**Core：**  发现市场上的不平衡   \n\n供求关系可以预测商品和服务的价格，以及价格变化对购买的人数。 **当选择专注哪种技术的时候，需要仔细考虑供给增长和价格下降对职业前景的影响。**\n不要太在乎眼前，应该看得长远，不要太在意当前的小得失，**考虑时间成本与机会成本。**  \n\n**TIPS:** 研究当今市场需求，利用招聘网站找出哪些工作是高需求，哪些是低需求。与外包公司的需求做比较。\n\n## 2. 自我提升\n\n### 2.1. 学习行业是如何运转的\n\n熟悉业务领域，思考技术是如何来服务业务的。\n只有了解了一个行业后，才能**创造性**地有所建树。\n**TIPS：**\n\n- 阅读一本基础商业教程，例如《The Ten-Day MBA》\n- 公司财务部门，讲解财务状况\n\n### 2.2. 做团队中最差的\n\n时时保持一个谦卑学习的心态。你身边的人会对你产生很大的影响，明智地选择你的圈子。（*** 即使你是那个最差的，也并不意味着你就是最差的。瘦死的骆驼比马大。***）\n\n**主动性**， 需要主动问，不需等着别人来告诉你。\n\n良师或者榜样的好处：\n\n- 直到亲眼见识某人突破你所熟悉的极限时，才知道一切皆有可能\n- 学习过程形成体系，削减精力选着在哪种技术和行业领域中投资（不一定正确，但可以缩小范围）\n- 指导自己，学会自己做自己的良师\n\n还有，站在巨人到肩膀上。带有**批判视角**，从大量的现有[Good/Bad]程序中寻找模式和技巧，并以此为鉴。\n\n当然，我们需要**输出学到的东西**，这样才能加深理解与记忆。检验自己是否真的学到东西，试试向别人传授这些知识。\n\n### 2.3. 练习，练习，再练习\n\n一般分成几个阶段：\n\n1. 基础练习，例如了解各个语言的特性，go 支持高并发，python 快捷开发\n2. 练习，开源软件中可以寻找到不同的风格，不同的编程语言的软件练习\n3. 即兴编程\n\n### 2.4. 学习如何失败\n\n任何事情最开始都是不完美的，伴随着失败。\n\n***每个错误的音调离正确的音调不过一步之遥。*** 出现问题时，才是检测工匠手艺的时候。学习如何处理是非常重要的。\n\n** TIPS： **\n\n- 吸取常见的错误经验\n- 防御性的编程\n- 出现问题后，不要企图隐瞒，越早解决负面影响越小\n- 接受批评，能承担责任并提供解决方法\n\n** 充满压力的时候是赢得忠诚的最好时机。修心，亦是修行之一。顺境修力，逆境修心，缺一不可。**\n\n### 2.5.推销...不仅仅是迎合\n\n- 写作能力是必要的\n- 面对面沟通高效\n- 能用行业术语展示商业价值\n- 个人优秀与人际关系网同样重要\n- 网络日志，开源可增长写作技巧，扩大人际网（创建自己的商标--认知和尊重）\n- 恐惧感使我们无法接近专业人士\n\n### 2.6. 切忌孤注一掷\n\n切勿将自己的职业道路建立在一门特定的技术上，这是十分冒险的。\n\n在选择商业与开源项目时，我们可以将开源作为一个平台，使自己对一项技术进行深度学习。**同时，也不是致力于研究如何配置和部署一个商业应用程序服务器的细节**（ ***毕竟，任何人都可以在config中调整设置，对吗？*** ），**而是利用类似的开源，学习服务器内部是如何运作的，不要只局限于学习如何操作。**\n\n**观点转变：** 既了解实施的细节，也知道内部运作。\n\n## 3. 执行\n### 3.1. 就是现在\n\n帕金森定律：“工作会自动膨胀到占满所有可用的时间。”\n开始行动，不要总是安于现状，要做推动者。 随时记得问问自己：“** 现在我们能做些什么？”\n\n### 3.2. 读心术\n\n可以分析出潜在的功能需求--来自领导或客户。\n\n但是，这也是有风险的：  \n\n- 这是额外的任务，他的价值是否足够；\n- 可能对当前的软件架构影响，代码的模块化；\n\n*** Tips: ***\n建立自己额外分析功能的列表，查看命中率。\n\n### 3.3. 在工作中，将自己自动化\n\n想提高软件开发的效率：\n\n- 找到工作效率更高的人  \n- 找更多的人来做  \n- 自动化工作  \n\n### 3.4. 每日成绩\n问自己“今天实现自己的价值了么？”\n\n计划和跟踪工作成绩，对每个人都有益。常见步骤：\n\n1. 根据工作优先顺序，罗列计划\n2. 记录工作成绩\n3. 总结与回顾\n\n### 3.5. 8小时激情燃烧\n\n在工作上，更少的工作时间可以有更高的效率。大多数项目都是一项长期工作，人们不可能按冲刺的速度跑完整个马拉松。\n\n有限的资源更加珍贵，我们需高效的利用有限的资源，安排时间也是一样。好好规划工作时间，减少工作时间，将会收获更多。当离开工作一段时间后，才会更喜欢工作。\n\n### 3.6. 今天我能把工作做到多好？\n\n在处理最无聊烦人的工作时，如果能狂热的想要把它做好，那么能为你的工作增添多少乐趣？\n常常遇到的问题是：***我们如何挑战自己，发挥创造力来应对这些平凡的工作？***\n试试把这些无聊的工作做到100分。\n\n### 3.7. 别忘了你在为谁工作\n\n“确保你的目标和工作于你公司的目标一致。” 我们可以从小范围入手：团队。\n我们可以知道团队的问题和努力的方向。\n\n### 3.8. 安分守己\n\n比起只专注于目标上的做法，专注于现在的工作会使你离最终的目标更近。我们将会享受日常工作中的每一个小成功。\n**当有雄心，但不必路人皆知。**\n\n*** TIPS: ***\n这有点像《白日梦想家》影片。\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=61eb7902554e9258b2398ebcfdebba3d/8718367adab44aed46bb2f82b01c8701a08bfbdb.jpg)\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=1c98646b73cf3bc7fc0dc5beb069d1c4/10dfa9ec8a13632719415a55928fa0ec08fac72c.jpg)\n\n### 3.9. 一桶水中的鹅卵石\n\n不要太沉迷于自我，你的离开犹如拿起水桶中的鹅卵石并不明显。\n每个人都不是不可替代的，清楚知道这一点，与公司或同事保持良好的工作关系并努力工作，恰恰会让你与众不同，无意见创造更多的机会。\n\n越是成功，就越有可能犯下重大错误。当你得到很多肯定时，你就会很少质疑自己的决定。当使用自己的方法屡试不爽时，就可能忽视可能会有更好的方法，容易产生盲点。\n\n** TIPS：**\n不要高枕无忧，保持谦逊的心态。\n\n### 3.10. 爱上维护\n\n维护也可以成为自由和创造的沃土。<br>\n\n1. 身兼数职项目领导者、架构师、设计师和测试员，随心发挥创造力\n2. 可以设计更可见的改进\n3. 与客户直接进行交流，了解业务运行情况\n\n** TIPS： **\n在所有重要应用程序和代码中使用：评估、改进、评估。 把所有可以评估程序质量的元素列举出来。比如，响应时间，数据处理过程抛出的异常质量等，**不要直接评估程序的质量。 ** \n\n- 选取测量标准，评估、改进\n- 选取另一测量标准，评估、改进\n\n## 4.自我未来规划\n\n避免职业技术的过时。**研究、投资、执行、市场**然后重复，在任何一个环节上花费过多的时间，都会有过时的危险。\n\n### 4.1. 已经过时的技术\n\n根据摩尔定律的推断，计算机性能每隔18个月提高一倍。随着硬件的不断进步，软件技术也得到迅猛发展。必须认识到，即使你现在处于当今潮流的尖端，也极有可能已经在下一个潮流之后。**向前看，清楚地知道你的技术发展方向，是盲目和有远见的区别。**\n\n职业生涯中最重要的部分不是晋升或者加薪，而是向这些发展方向努力工作的**过程**。 \n\n*TIPS：*\n\n> 每周抽出2个小时的时间来研究新技术，学习相关技术并手动尝试，制作简单的应用程序。\n\n### 4.2.你已经失去工作了\n\n不要自己绑定到特定的工作角色上，尝试以测试员、经理、设计师架构师鞥身份来对待自己的工作。\n\n### 4.3. 要注意观察市场变化\n\n关注技术方面的新闻--不管是商业还是纯技术。并且留意技术达人，观察他们热衷于什么，我们就能大致了解到什么技术会成为热门，或者预测出两年后的热门是什么。\n\n### 4.4. 给自己做一份蓝图\n\n个人的产品路线蓝图是用来判断你是否在不断向前发展的依据，并且能帮助你纵观全局。","source":"_posts/more-coding-more-happy.md","raw":"---\n\ntitle: more_coding_more_happy\ndate: 2017-12-25 19:35:34\ntags: bookmarks reading_notes\ncategorise: bookmarks\n\n---\n\n# 《我编程，我快乐：程序员职业规划之道》\n\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=6a709c667af0f736ccf344536b3cd87c/342ac65c103853433ae62d389113b07eca8088fa.jpg)\n\n[*我编程，我快乐 百度百科*](https://baike.baidu.com/item/%E6%88%91%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%88%91%E5%BF%AB%E4%B9%90/12445811?fr=aladdin)\n\n## 0. 序言\n\n### 0.1. 不要害怕失败\n\n不是继续保持平庸，而是要出色，要赢。就像在赛跑中，你要总想着怎么不输，那肯定不会赢得比赛。同样，总想着怎么避免糟糕的活着，那你也不可能成为生活中的赢家。**任何人都不应该时刻想着如何避免失败。**\n***(不是反对应对最坏的情况的应急措施的想法)***  \n\n一个渴望成功的人肯定要比那些只是单纯完成工作的人更有可能成功。即使我们不能成为顶级专家，但确定高目标至少可以让我们不再平凡。\n\n**TIPS：**  \n    永远对生活充满乐观与热情，即使他QJ了你无数次。\n\n<!-- more -->\n\n### 0.2. 制定自己的计划\n审视自己的职业，不要跟在别人的计划后面跑，应该按着自己的计划发展。 \n\n软件可以看做是一门生意，雇佣软件开发人员，是因为可以创造利润。要评定自身的表现，就要看你能给公司创造多少商业价值。  \n把**职业**想象成正在制作的产品的**生命周期**，你的技术成就了这个产品。在设计、生产及销售商品时，我们应注意：\n\n- 选择市场：关注技术和商业领域\n- 投资：知识和技术是商品的基础，要合理投资\n- 执行：不光有技术还有产出\n- 市场：有好的产品，也要得到行业中的认可\n\n---\n\n## 1. 市场分析\n\n### 1.1. 稳定成熟的技术还是未成熟的新技术？\n\n这与风险收益平衡概念类似。\n\n| 稳定的技术 | 未成熟的技术  |\n| -----      | ------- |\n| 投资风险低 | 高风险     |\n| 收益低     | 收益极高或极低 |\n\n选择是把双刃剑，决定权还是在自己手里。但是，无论做出哪种选择，最终的目的是**产生利润**。\n\n**TIPS：**  \n    从行业信息，招聘信息或者论坛嗅到行业的发展方向。如当前的云计算，大数据，人工智能等\n\n### 1.2. 供应和需求\n\n**Core：**  发现市场上的不平衡   \n\n供求关系可以预测商品和服务的价格，以及价格变化对购买的人数。 **当选择专注哪种技术的时候，需要仔细考虑供给增长和价格下降对职业前景的影响。**\n不要太在乎眼前，应该看得长远，不要太在意当前的小得失，**考虑时间成本与机会成本。**  \n\n**TIPS:** 研究当今市场需求，利用招聘网站找出哪些工作是高需求，哪些是低需求。与外包公司的需求做比较。\n\n## 2. 自我提升\n\n### 2.1. 学习行业是如何运转的\n\n熟悉业务领域，思考技术是如何来服务业务的。\n只有了解了一个行业后，才能**创造性**地有所建树。\n**TIPS：**\n\n- 阅读一本基础商业教程，例如《The Ten-Day MBA》\n- 公司财务部门，讲解财务状况\n\n### 2.2. 做团队中最差的\n\n时时保持一个谦卑学习的心态。你身边的人会对你产生很大的影响，明智地选择你的圈子。（*** 即使你是那个最差的，也并不意味着你就是最差的。瘦死的骆驼比马大。***）\n\n**主动性**， 需要主动问，不需等着别人来告诉你。\n\n良师或者榜样的好处：\n\n- 直到亲眼见识某人突破你所熟悉的极限时，才知道一切皆有可能\n- 学习过程形成体系，削减精力选着在哪种技术和行业领域中投资（不一定正确，但可以缩小范围）\n- 指导自己，学会自己做自己的良师\n\n还有，站在巨人到肩膀上。带有**批判视角**，从大量的现有[Good/Bad]程序中寻找模式和技巧，并以此为鉴。\n\n当然，我们需要**输出学到的东西**，这样才能加深理解与记忆。检验自己是否真的学到东西，试试向别人传授这些知识。\n\n### 2.3. 练习，练习，再练习\n\n一般分成几个阶段：\n\n1. 基础练习，例如了解各个语言的特性，go 支持高并发，python 快捷开发\n2. 练习，开源软件中可以寻找到不同的风格，不同的编程语言的软件练习\n3. 即兴编程\n\n### 2.4. 学习如何失败\n\n任何事情最开始都是不完美的，伴随着失败。\n\n***每个错误的音调离正确的音调不过一步之遥。*** 出现问题时，才是检测工匠手艺的时候。学习如何处理是非常重要的。\n\n** TIPS： **\n\n- 吸取常见的错误经验\n- 防御性的编程\n- 出现问题后，不要企图隐瞒，越早解决负面影响越小\n- 接受批评，能承担责任并提供解决方法\n\n** 充满压力的时候是赢得忠诚的最好时机。修心，亦是修行之一。顺境修力，逆境修心，缺一不可。**\n\n### 2.5.推销...不仅仅是迎合\n\n- 写作能力是必要的\n- 面对面沟通高效\n- 能用行业术语展示商业价值\n- 个人优秀与人际关系网同样重要\n- 网络日志，开源可增长写作技巧，扩大人际网（创建自己的商标--认知和尊重）\n- 恐惧感使我们无法接近专业人士\n\n### 2.6. 切忌孤注一掷\n\n切勿将自己的职业道路建立在一门特定的技术上，这是十分冒险的。\n\n在选择商业与开源项目时，我们可以将开源作为一个平台，使自己对一项技术进行深度学习。**同时，也不是致力于研究如何配置和部署一个商业应用程序服务器的细节**（ ***毕竟，任何人都可以在config中调整设置，对吗？*** ），**而是利用类似的开源，学习服务器内部是如何运作的，不要只局限于学习如何操作。**\n\n**观点转变：** 既了解实施的细节，也知道内部运作。\n\n## 3. 执行\n### 3.1. 就是现在\n\n帕金森定律：“工作会自动膨胀到占满所有可用的时间。”\n开始行动，不要总是安于现状，要做推动者。 随时记得问问自己：“** 现在我们能做些什么？”\n\n### 3.2. 读心术\n\n可以分析出潜在的功能需求--来自领导或客户。\n\n但是，这也是有风险的：  \n\n- 这是额外的任务，他的价值是否足够；\n- 可能对当前的软件架构影响，代码的模块化；\n\n*** Tips: ***\n建立自己额外分析功能的列表，查看命中率。\n\n### 3.3. 在工作中，将自己自动化\n\n想提高软件开发的效率：\n\n- 找到工作效率更高的人  \n- 找更多的人来做  \n- 自动化工作  \n\n### 3.4. 每日成绩\n问自己“今天实现自己的价值了么？”\n\n计划和跟踪工作成绩，对每个人都有益。常见步骤：\n\n1. 根据工作优先顺序，罗列计划\n2. 记录工作成绩\n3. 总结与回顾\n\n### 3.5. 8小时激情燃烧\n\n在工作上，更少的工作时间可以有更高的效率。大多数项目都是一项长期工作，人们不可能按冲刺的速度跑完整个马拉松。\n\n有限的资源更加珍贵，我们需高效的利用有限的资源，安排时间也是一样。好好规划工作时间，减少工作时间，将会收获更多。当离开工作一段时间后，才会更喜欢工作。\n\n### 3.6. 今天我能把工作做到多好？\n\n在处理最无聊烦人的工作时，如果能狂热的想要把它做好，那么能为你的工作增添多少乐趣？\n常常遇到的问题是：***我们如何挑战自己，发挥创造力来应对这些平凡的工作？***\n试试把这些无聊的工作做到100分。\n\n### 3.7. 别忘了你在为谁工作\n\n“确保你的目标和工作于你公司的目标一致。” 我们可以从小范围入手：团队。\n我们可以知道团队的问题和努力的方向。\n\n### 3.8. 安分守己\n\n比起只专注于目标上的做法，专注于现在的工作会使你离最终的目标更近。我们将会享受日常工作中的每一个小成功。\n**当有雄心，但不必路人皆知。**\n\n*** TIPS: ***\n这有点像《白日梦想家》影片。\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=61eb7902554e9258b2398ebcfdebba3d/8718367adab44aed46bb2f82b01c8701a08bfbdb.jpg)\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=1c98646b73cf3bc7fc0dc5beb069d1c4/10dfa9ec8a13632719415a55928fa0ec08fac72c.jpg)\n\n### 3.9. 一桶水中的鹅卵石\n\n不要太沉迷于自我，你的离开犹如拿起水桶中的鹅卵石并不明显。\n每个人都不是不可替代的，清楚知道这一点，与公司或同事保持良好的工作关系并努力工作，恰恰会让你与众不同，无意见创造更多的机会。\n\n越是成功，就越有可能犯下重大错误。当你得到很多肯定时，你就会很少质疑自己的决定。当使用自己的方法屡试不爽时，就可能忽视可能会有更好的方法，容易产生盲点。\n\n** TIPS：**\n不要高枕无忧，保持谦逊的心态。\n\n### 3.10. 爱上维护\n\n维护也可以成为自由和创造的沃土。<br>\n\n1. 身兼数职项目领导者、架构师、设计师和测试员，随心发挥创造力\n2. 可以设计更可见的改进\n3. 与客户直接进行交流，了解业务运行情况\n\n** TIPS： **\n在所有重要应用程序和代码中使用：评估、改进、评估。 把所有可以评估程序质量的元素列举出来。比如，响应时间，数据处理过程抛出的异常质量等，**不要直接评估程序的质量。 ** \n\n- 选取测量标准，评估、改进\n- 选取另一测量标准，评估、改进\n\n## 4.自我未来规划\n\n避免职业技术的过时。**研究、投资、执行、市场**然后重复，在任何一个环节上花费过多的时间，都会有过时的危险。\n\n### 4.1. 已经过时的技术\n\n根据摩尔定律的推断，计算机性能每隔18个月提高一倍。随着硬件的不断进步，软件技术也得到迅猛发展。必须认识到，即使你现在处于当今潮流的尖端，也极有可能已经在下一个潮流之后。**向前看，清楚地知道你的技术发展方向，是盲目和有远见的区别。**\n\n职业生涯中最重要的部分不是晋升或者加薪，而是向这些发展方向努力工作的**过程**。 \n\n*TIPS：*\n\n> 每周抽出2个小时的时间来研究新技术，学习相关技术并手动尝试，制作简单的应用程序。\n\n### 4.2.你已经失去工作了\n\n不要自己绑定到特定的工作角色上，尝试以测试员、经理、设计师架构师鞥身份来对待自己的工作。\n\n### 4.3. 要注意观察市场变化\n\n关注技术方面的新闻--不管是商业还是纯技术。并且留意技术达人，观察他们热衷于什么，我们就能大致了解到什么技术会成为热门，或者预测出两年后的热门是什么。\n\n### 4.4. 给自己做一份蓝图\n\n个人的产品路线蓝图是用来判断你是否在不断向前发展的依据，并且能帮助你纵观全局。","slug":"more-coding-more-happy","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0qz003nzkgrbh1duy0v","content":"<h1 id=\"《我编程，我快乐：程序员职业规划之道》\"><a href=\"#《我编程，我快乐：程序员职业规划之道》\" class=\"headerlink\" title=\"《我编程，我快乐：程序员职业规划之道》\"></a>《我编程，我快乐：程序员职业规划之道》</h1><p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=6a709c667af0f736ccf344536b3cd87c/342ac65c103853433ae62d389113b07eca8088fa.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E6%88%91%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%88%91%E5%BF%AB%E4%B9%90/12445811?fr=aladdin\" target=\"_blank\" rel=\"noopener\"><em>我编程，我快乐 百度百科</em></a></p>\n<h2 id=\"0-序言\"><a href=\"#0-序言\" class=\"headerlink\" title=\"0. 序言\"></a>0. 序言</h2><h3 id=\"0-1-不要害怕失败\"><a href=\"#0-1-不要害怕失败\" class=\"headerlink\" title=\"0.1. 不要害怕失败\"></a>0.1. 不要害怕失败</h3><p>不是继续保持平庸，而是要出色，要赢。就像在赛跑中，你要总想着怎么不输，那肯定不会赢得比赛。同样，总想着怎么避免糟糕的活着，那你也不可能成为生活中的赢家。<strong>任何人都不应该时刻想着如何避免失败。</strong><br><strong><em>(不是反对应对最坏的情况的应急措施的想法)</em></strong>  </p>\n<p>一个渴望成功的人肯定要比那些只是单纯完成工作的人更有可能成功。即使我们不能成为顶级专家，但确定高目标至少可以让我们不再平凡。</p>\n<p><strong>TIPS：</strong><br>    永远对生活充满乐观与热情，即使他QJ了你无数次。</p>\n<a id=\"more\"></a>\n<h3 id=\"0-2-制定自己的计划\"><a href=\"#0-2-制定自己的计划\" class=\"headerlink\" title=\"0.2. 制定自己的计划\"></a>0.2. 制定自己的计划</h3><p>审视自己的职业，不要跟在别人的计划后面跑，应该按着自己的计划发展。 </p>\n<p>软件可以看做是一门生意，雇佣软件开发人员，是因为可以创造利润。要评定自身的表现，就要看你能给公司创造多少商业价值。<br>把<strong>职业</strong>想象成正在制作的产品的<strong>生命周期</strong>，你的技术成就了这个产品。在设计、生产及销售商品时，我们应注意：</p>\n<ul>\n<li>选择市场：关注技术和商业领域</li>\n<li>投资：知识和技术是商品的基础，要合理投资</li>\n<li>执行：不光有技术还有产出</li>\n<li>市场：有好的产品，也要得到行业中的认可</li>\n</ul>\n<hr>\n<h2 id=\"1-市场分析\"><a href=\"#1-市场分析\" class=\"headerlink\" title=\"1. 市场分析\"></a>1. 市场分析</h2><h3 id=\"1-1-稳定成熟的技术还是未成熟的新技术？\"><a href=\"#1-1-稳定成熟的技术还是未成熟的新技术？\" class=\"headerlink\" title=\"1.1. 稳定成熟的技术还是未成熟的新技术？\"></a>1.1. 稳定成熟的技术还是未成熟的新技术？</h3><p>这与风险收益平衡概念类似。</p>\n<table>\n<thead>\n<tr>\n<th>稳定的技术</th>\n<th>未成熟的技术</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>投资风险低</td>\n<td>高风险</td>\n</tr>\n<tr>\n<td>收益低</td>\n<td>收益极高或极低</td>\n</tr>\n</tbody>\n</table>\n<p>选择是把双刃剑，决定权还是在自己手里。但是，无论做出哪种选择，最终的目的是<strong>产生利润</strong>。</p>\n<p><strong>TIPS：</strong><br>    从行业信息，招聘信息或者论坛嗅到行业的发展方向。如当前的云计算，大数据，人工智能等</p>\n<h3 id=\"1-2-供应和需求\"><a href=\"#1-2-供应和需求\" class=\"headerlink\" title=\"1.2. 供应和需求\"></a>1.2. 供应和需求</h3><p><strong>Core：</strong>  发现市场上的不平衡   </p>\n<p>供求关系可以预测商品和服务的价格，以及价格变化对购买的人数。 <strong>当选择专注哪种技术的时候，需要仔细考虑供给增长和价格下降对职业前景的影响。</strong><br>不要太在乎眼前，应该看得长远，不要太在意当前的小得失，<strong>考虑时间成本与机会成本。</strong>  </p>\n<p><strong>TIPS:</strong> 研究当今市场需求，利用招聘网站找出哪些工作是高需求，哪些是低需求。与外包公司的需求做比较。</p>\n<h2 id=\"2-自我提升\"><a href=\"#2-自我提升\" class=\"headerlink\" title=\"2. 自我提升\"></a>2. 自我提升</h2><h3 id=\"2-1-学习行业是如何运转的\"><a href=\"#2-1-学习行业是如何运转的\" class=\"headerlink\" title=\"2.1. 学习行业是如何运转的\"></a>2.1. 学习行业是如何运转的</h3><p>熟悉业务领域，思考技术是如何来服务业务的。<br>只有了解了一个行业后，才能<strong>创造性</strong>地有所建树。<br><strong>TIPS：</strong></p>\n<ul>\n<li>阅读一本基础商业教程，例如《The Ten-Day MBA》</li>\n<li>公司财务部门，讲解财务状况</li>\n</ul>\n<h3 id=\"2-2-做团队中最差的\"><a href=\"#2-2-做团队中最差的\" class=\"headerlink\" title=\"2.2. 做团队中最差的\"></a>2.2. 做团队中最差的</h3><p>时时保持一个谦卑学习的心态。你身边的人会对你产生很大的影响，明智地选择你的圈子。（<strong><em> 即使你是那个最差的，也并不意味着你就是最差的。瘦死的骆驼比马大。</em></strong>）</p>\n<p><strong>主动性</strong>， 需要主动问，不需等着别人来告诉你。</p>\n<p>良师或者榜样的好处：</p>\n<ul>\n<li>直到亲眼见识某人突破你所熟悉的极限时，才知道一切皆有可能</li>\n<li>学习过程形成体系，削减精力选着在哪种技术和行业领域中投资（不一定正确，但可以缩小范围）</li>\n<li>指导自己，学会自己做自己的良师</li>\n</ul>\n<p>还有，站在巨人到肩膀上。带有<strong>批判视角</strong>，从大量的现有[Good/Bad]程序中寻找模式和技巧，并以此为鉴。</p>\n<p>当然，我们需要<strong>输出学到的东西</strong>，这样才能加深理解与记忆。检验自己是否真的学到东西，试试向别人传授这些知识。</p>\n<h3 id=\"2-3-练习，练习，再练习\"><a href=\"#2-3-练习，练习，再练习\" class=\"headerlink\" title=\"2.3. 练习，练习，再练习\"></a>2.3. 练习，练习，再练习</h3><p>一般分成几个阶段：</p>\n<ol>\n<li>基础练习，例如了解各个语言的特性，go 支持高并发，python 快捷开发</li>\n<li>练习，开源软件中可以寻找到不同的风格，不同的编程语言的软件练习</li>\n<li>即兴编程</li>\n</ol>\n<h3 id=\"2-4-学习如何失败\"><a href=\"#2-4-学习如何失败\" class=\"headerlink\" title=\"2.4. 学习如何失败\"></a>2.4. 学习如何失败</h3><p>任何事情最开始都是不完美的，伴随着失败。</p>\n<p><strong><em>每个错误的音调离正确的音调不过一步之遥。</em></strong> 出现问题时，才是检测工匠手艺的时候。学习如何处理是非常重要的。</p>\n<p><strong> TIPS： </strong></p>\n<ul>\n<li>吸取常见的错误经验</li>\n<li>防御性的编程</li>\n<li>出现问题后，不要企图隐瞒，越早解决负面影响越小</li>\n<li>接受批评，能承担责任并提供解决方法</li>\n</ul>\n<p><strong> 充满压力的时候是赢得忠诚的最好时机。修心，亦是修行之一。顺境修力，逆境修心，缺一不可。</strong></p>\n<h3 id=\"2-5-推销…不仅仅是迎合\"><a href=\"#2-5-推销…不仅仅是迎合\" class=\"headerlink\" title=\"2.5.推销…不仅仅是迎合\"></a>2.5.推销…不仅仅是迎合</h3><ul>\n<li>写作能力是必要的</li>\n<li>面对面沟通高效</li>\n<li>能用行业术语展示商业价值</li>\n<li>个人优秀与人际关系网同样重要</li>\n<li>网络日志，开源可增长写作技巧，扩大人际网（创建自己的商标–认知和尊重）</li>\n<li>恐惧感使我们无法接近专业人士</li>\n</ul>\n<h3 id=\"2-6-切忌孤注一掷\"><a href=\"#2-6-切忌孤注一掷\" class=\"headerlink\" title=\"2.6. 切忌孤注一掷\"></a>2.6. 切忌孤注一掷</h3><p>切勿将自己的职业道路建立在一门特定的技术上，这是十分冒险的。</p>\n<p>在选择商业与开源项目时，我们可以将开源作为一个平台，使自己对一项技术进行深度学习。<strong>同时，也不是致力于研究如何配置和部署一个商业应用程序服务器的细节</strong>（ <strong><em>毕竟，任何人都可以在config中调整设置，对吗？</em></strong> ），<strong>而是利用类似的开源，学习服务器内部是如何运作的，不要只局限于学习如何操作。</strong></p>\n<p><strong>观点转变：</strong> 既了解实施的细节，也知道内部运作。</p>\n<h2 id=\"3-执行\"><a href=\"#3-执行\" class=\"headerlink\" title=\"3. 执行\"></a>3. 执行</h2><h3 id=\"3-1-就是现在\"><a href=\"#3-1-就是现在\" class=\"headerlink\" title=\"3.1. 就是现在\"></a>3.1. 就是现在</h3><p>帕金森定律：“工作会自动膨胀到占满所有可用的时间。”<br>开始行动，不要总是安于现状，要做推动者。 随时记得问问自己：“** 现在我们能做些什么？”</p>\n<h3 id=\"3-2-读心术\"><a href=\"#3-2-读心术\" class=\"headerlink\" title=\"3.2. 读心术\"></a>3.2. 读心术</h3><p>可以分析出潜在的功能需求–来自领导或客户。</p>\n<p>但是，这也是有风险的：  </p>\n<ul>\n<li>这是额外的任务，他的价值是否足够；</li>\n<li>可能对当前的软件架构影响，代码的模块化；</li>\n</ul>\n<p><strong><em> Tips: </em></strong><br>建立自己额外分析功能的列表，查看命中率。</p>\n<h3 id=\"3-3-在工作中，将自己自动化\"><a href=\"#3-3-在工作中，将自己自动化\" class=\"headerlink\" title=\"3.3. 在工作中，将自己自动化\"></a>3.3. 在工作中，将自己自动化</h3><p>想提高软件开发的效率：</p>\n<ul>\n<li>找到工作效率更高的人  </li>\n<li>找更多的人来做  </li>\n<li>自动化工作  </li>\n</ul>\n<h3 id=\"3-4-每日成绩\"><a href=\"#3-4-每日成绩\" class=\"headerlink\" title=\"3.4. 每日成绩\"></a>3.4. 每日成绩</h3><p>问自己“今天实现自己的价值了么？”</p>\n<p>计划和跟踪工作成绩，对每个人都有益。常见步骤：</p>\n<ol>\n<li>根据工作优先顺序，罗列计划</li>\n<li>记录工作成绩</li>\n<li>总结与回顾</li>\n</ol>\n<h3 id=\"3-5-8小时激情燃烧\"><a href=\"#3-5-8小时激情燃烧\" class=\"headerlink\" title=\"3.5. 8小时激情燃烧\"></a>3.5. 8小时激情燃烧</h3><p>在工作上，更少的工作时间可以有更高的效率。大多数项目都是一项长期工作，人们不可能按冲刺的速度跑完整个马拉松。</p>\n<p>有限的资源更加珍贵，我们需高效的利用有限的资源，安排时间也是一样。好好规划工作时间，减少工作时间，将会收获更多。当离开工作一段时间后，才会更喜欢工作。</p>\n<h3 id=\"3-6-今天我能把工作做到多好？\"><a href=\"#3-6-今天我能把工作做到多好？\" class=\"headerlink\" title=\"3.6. 今天我能把工作做到多好？\"></a>3.6. 今天我能把工作做到多好？</h3><p>在处理最无聊烦人的工作时，如果能狂热的想要把它做好，那么能为你的工作增添多少乐趣？<br>常常遇到的问题是：<strong><em>我们如何挑战自己，发挥创造力来应对这些平凡的工作？</em></strong><br>试试把这些无聊的工作做到100分。</p>\n<h3 id=\"3-7-别忘了你在为谁工作\"><a href=\"#3-7-别忘了你在为谁工作\" class=\"headerlink\" title=\"3.7. 别忘了你在为谁工作\"></a>3.7. 别忘了你在为谁工作</h3><p>“确保你的目标和工作于你公司的目标一致。” 我们可以从小范围入手：团队。<br>我们可以知道团队的问题和努力的方向。</p>\n<h3 id=\"3-8-安分守己\"><a href=\"#3-8-安分守己\" class=\"headerlink\" title=\"3.8. 安分守己\"></a>3.8. 安分守己</h3><p>比起只专注于目标上的做法，专注于现在的工作会使你离最终的目标更近。我们将会享受日常工作中的每一个小成功。<br><strong>当有雄心，但不必路人皆知。</strong></p>\n<p><strong><em> TIPS: </em></strong><br>这有点像《白日梦想家》影片。<br><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=61eb7902554e9258b2398ebcfdebba3d/8718367adab44aed46bb2f82b01c8701a08bfbdb.jpg\" alt=\"\"></p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=1c98646b73cf3bc7fc0dc5beb069d1c4/10dfa9ec8a13632719415a55928fa0ec08fac72c.jpg\" alt=\"\"></p>\n<h3 id=\"3-9-一桶水中的鹅卵石\"><a href=\"#3-9-一桶水中的鹅卵石\" class=\"headerlink\" title=\"3.9. 一桶水中的鹅卵石\"></a>3.9. 一桶水中的鹅卵石</h3><p>不要太沉迷于自我，你的离开犹如拿起水桶中的鹅卵石并不明显。<br>每个人都不是不可替代的，清楚知道这一点，与公司或同事保持良好的工作关系并努力工作，恰恰会让你与众不同，无意见创造更多的机会。</p>\n<p>越是成功，就越有可能犯下重大错误。当你得到很多肯定时，你就会很少质疑自己的决定。当使用自己的方法屡试不爽时，就可能忽视可能会有更好的方法，容易产生盲点。</p>\n<p><strong> TIPS：</strong><br>不要高枕无忧，保持谦逊的心态。</p>\n<h3 id=\"3-10-爱上维护\"><a href=\"#3-10-爱上维护\" class=\"headerlink\" title=\"3.10. 爱上维护\"></a>3.10. 爱上维护</h3><p>维护也可以成为自由和创造的沃土。<br></p>\n<ol>\n<li>身兼数职项目领导者、架构师、设计师和测试员，随心发挥创造力</li>\n<li>可以设计更可见的改进</li>\n<li>与客户直接进行交流，了解业务运行情况</li>\n</ol>\n<p><strong> TIPS： </strong><br>在所有重要应用程序和代码中使用：评估、改进、评估。 把所有可以评估程序质量的元素列举出来。比如，响应时间，数据处理过程抛出的异常质量等，<strong>不要直接评估程序的质量。 </strong> </p>\n<ul>\n<li>选取测量标准，评估、改进</li>\n<li>选取另一测量标准，评估、改进</li>\n</ul>\n<h2 id=\"4-自我未来规划\"><a href=\"#4-自我未来规划\" class=\"headerlink\" title=\"4.自我未来规划\"></a>4.自我未来规划</h2><p>避免职业技术的过时。<strong>研究、投资、执行、市场</strong>然后重复，在任何一个环节上花费过多的时间，都会有过时的危险。</p>\n<h3 id=\"4-1-已经过时的技术\"><a href=\"#4-1-已经过时的技术\" class=\"headerlink\" title=\"4.1. 已经过时的技术\"></a>4.1. 已经过时的技术</h3><p>根据摩尔定律的推断，计算机性能每隔18个月提高一倍。随着硬件的不断进步，软件技术也得到迅猛发展。必须认识到，即使你现在处于当今潮流的尖端，也极有可能已经在下一个潮流之后。<strong>向前看，清楚地知道你的技术发展方向，是盲目和有远见的区别。</strong></p>\n<p>职业生涯中最重要的部分不是晋升或者加薪，而是向这些发展方向努力工作的<strong>过程</strong>。 </p>\n<p><em>TIPS：</em></p>\n<blockquote>\n<p>每周抽出2个小时的时间来研究新技术，学习相关技术并手动尝试，制作简单的应用程序。</p>\n</blockquote>\n<h3 id=\"4-2-你已经失去工作了\"><a href=\"#4-2-你已经失去工作了\" class=\"headerlink\" title=\"4.2.你已经失去工作了\"></a>4.2.你已经失去工作了</h3><p>不要自己绑定到特定的工作角色上，尝试以测试员、经理、设计师架构师鞥身份来对待自己的工作。</p>\n<h3 id=\"4-3-要注意观察市场变化\"><a href=\"#4-3-要注意观察市场变化\" class=\"headerlink\" title=\"4.3. 要注意观察市场变化\"></a>4.3. 要注意观察市场变化</h3><p>关注技术方面的新闻–不管是商业还是纯技术。并且留意技术达人，观察他们热衷于什么，我们就能大致了解到什么技术会成为热门，或者预测出两年后的热门是什么。</p>\n<h3 id=\"4-4-给自己做一份蓝图\"><a href=\"#4-4-给自己做一份蓝图\" class=\"headerlink\" title=\"4.4. 给自己做一份蓝图\"></a>4.4. 给自己做一份蓝图</h3><p>个人的产品路线蓝图是用来判断你是否在不断向前发展的依据，并且能帮助你纵观全局。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"《我编程，我快乐：程序员职业规划之道》\"><a href=\"#《我编程，我快乐：程序员职业规划之道》\" class=\"headerlink\" title=\"《我编程，我快乐：程序员职业规划之道》\"></a>《我编程，我快乐：程序员职业规划之道》</h1><p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=6a709c667af0f736ccf344536b3cd87c/342ac65c103853433ae62d389113b07eca8088fa.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E6%88%91%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%88%91%E5%BF%AB%E4%B9%90/12445811?fr=aladdin\" target=\"_blank\" rel=\"noopener\"><em>我编程，我快乐 百度百科</em></a></p>\n<h2 id=\"0-序言\"><a href=\"#0-序言\" class=\"headerlink\" title=\"0. 序言\"></a>0. 序言</h2><h3 id=\"0-1-不要害怕失败\"><a href=\"#0-1-不要害怕失败\" class=\"headerlink\" title=\"0.1. 不要害怕失败\"></a>0.1. 不要害怕失败</h3><p>不是继续保持平庸，而是要出色，要赢。就像在赛跑中，你要总想着怎么不输，那肯定不会赢得比赛。同样，总想着怎么避免糟糕的活着，那你也不可能成为生活中的赢家。<strong>任何人都不应该时刻想着如何避免失败。</strong><br><strong><em>(不是反对应对最坏的情况的应急措施的想法)</em></strong>  </p>\n<p>一个渴望成功的人肯定要比那些只是单纯完成工作的人更有可能成功。即使我们不能成为顶级专家，但确定高目标至少可以让我们不再平凡。</p>\n<p><strong>TIPS：</strong><br>    永远对生活充满乐观与热情，即使他QJ了你无数次。</p>","more":"<h3 id=\"0-2-制定自己的计划\"><a href=\"#0-2-制定自己的计划\" class=\"headerlink\" title=\"0.2. 制定自己的计划\"></a>0.2. 制定自己的计划</h3><p>审视自己的职业，不要跟在别人的计划后面跑，应该按着自己的计划发展。 </p>\n<p>软件可以看做是一门生意，雇佣软件开发人员，是因为可以创造利润。要评定自身的表现，就要看你能给公司创造多少商业价值。<br>把<strong>职业</strong>想象成正在制作的产品的<strong>生命周期</strong>，你的技术成就了这个产品。在设计、生产及销售商品时，我们应注意：</p>\n<ul>\n<li>选择市场：关注技术和商业领域</li>\n<li>投资：知识和技术是商品的基础，要合理投资</li>\n<li>执行：不光有技术还有产出</li>\n<li>市场：有好的产品，也要得到行业中的认可</li>\n</ul>\n<hr>\n<h2 id=\"1-市场分析\"><a href=\"#1-市场分析\" class=\"headerlink\" title=\"1. 市场分析\"></a>1. 市场分析</h2><h3 id=\"1-1-稳定成熟的技术还是未成熟的新技术？\"><a href=\"#1-1-稳定成熟的技术还是未成熟的新技术？\" class=\"headerlink\" title=\"1.1. 稳定成熟的技术还是未成熟的新技术？\"></a>1.1. 稳定成熟的技术还是未成熟的新技术？</h3><p>这与风险收益平衡概念类似。</p>\n<table>\n<thead>\n<tr>\n<th>稳定的技术</th>\n<th>未成熟的技术</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>投资风险低</td>\n<td>高风险</td>\n</tr>\n<tr>\n<td>收益低</td>\n<td>收益极高或极低</td>\n</tr>\n</tbody>\n</table>\n<p>选择是把双刃剑，决定权还是在自己手里。但是，无论做出哪种选择，最终的目的是<strong>产生利润</strong>。</p>\n<p><strong>TIPS：</strong><br>    从行业信息，招聘信息或者论坛嗅到行业的发展方向。如当前的云计算，大数据，人工智能等</p>\n<h3 id=\"1-2-供应和需求\"><a href=\"#1-2-供应和需求\" class=\"headerlink\" title=\"1.2. 供应和需求\"></a>1.2. 供应和需求</h3><p><strong>Core：</strong>  发现市场上的不平衡   </p>\n<p>供求关系可以预测商品和服务的价格，以及价格变化对购买的人数。 <strong>当选择专注哪种技术的时候，需要仔细考虑供给增长和价格下降对职业前景的影响。</strong><br>不要太在乎眼前，应该看得长远，不要太在意当前的小得失，<strong>考虑时间成本与机会成本。</strong>  </p>\n<p><strong>TIPS:</strong> 研究当今市场需求，利用招聘网站找出哪些工作是高需求，哪些是低需求。与外包公司的需求做比较。</p>\n<h2 id=\"2-自我提升\"><a href=\"#2-自我提升\" class=\"headerlink\" title=\"2. 自我提升\"></a>2. 自我提升</h2><h3 id=\"2-1-学习行业是如何运转的\"><a href=\"#2-1-学习行业是如何运转的\" class=\"headerlink\" title=\"2.1. 学习行业是如何运转的\"></a>2.1. 学习行业是如何运转的</h3><p>熟悉业务领域，思考技术是如何来服务业务的。<br>只有了解了一个行业后，才能<strong>创造性</strong>地有所建树。<br><strong>TIPS：</strong></p>\n<ul>\n<li>阅读一本基础商业教程，例如《The Ten-Day MBA》</li>\n<li>公司财务部门，讲解财务状况</li>\n</ul>\n<h3 id=\"2-2-做团队中最差的\"><a href=\"#2-2-做团队中最差的\" class=\"headerlink\" title=\"2.2. 做团队中最差的\"></a>2.2. 做团队中最差的</h3><p>时时保持一个谦卑学习的心态。你身边的人会对你产生很大的影响，明智地选择你的圈子。（<strong><em> 即使你是那个最差的，也并不意味着你就是最差的。瘦死的骆驼比马大。</em></strong>）</p>\n<p><strong>主动性</strong>， 需要主动问，不需等着别人来告诉你。</p>\n<p>良师或者榜样的好处：</p>\n<ul>\n<li>直到亲眼见识某人突破你所熟悉的极限时，才知道一切皆有可能</li>\n<li>学习过程形成体系，削减精力选着在哪种技术和行业领域中投资（不一定正确，但可以缩小范围）</li>\n<li>指导自己，学会自己做自己的良师</li>\n</ul>\n<p>还有，站在巨人到肩膀上。带有<strong>批判视角</strong>，从大量的现有[Good/Bad]程序中寻找模式和技巧，并以此为鉴。</p>\n<p>当然，我们需要<strong>输出学到的东西</strong>，这样才能加深理解与记忆。检验自己是否真的学到东西，试试向别人传授这些知识。</p>\n<h3 id=\"2-3-练习，练习，再练习\"><a href=\"#2-3-练习，练习，再练习\" class=\"headerlink\" title=\"2.3. 练习，练习，再练习\"></a>2.3. 练习，练习，再练习</h3><p>一般分成几个阶段：</p>\n<ol>\n<li>基础练习，例如了解各个语言的特性，go 支持高并发，python 快捷开发</li>\n<li>练习，开源软件中可以寻找到不同的风格，不同的编程语言的软件练习</li>\n<li>即兴编程</li>\n</ol>\n<h3 id=\"2-4-学习如何失败\"><a href=\"#2-4-学习如何失败\" class=\"headerlink\" title=\"2.4. 学习如何失败\"></a>2.4. 学习如何失败</h3><p>任何事情最开始都是不完美的，伴随着失败。</p>\n<p><strong><em>每个错误的音调离正确的音调不过一步之遥。</em></strong> 出现问题时，才是检测工匠手艺的时候。学习如何处理是非常重要的。</p>\n<p><strong> TIPS： </strong></p>\n<ul>\n<li>吸取常见的错误经验</li>\n<li>防御性的编程</li>\n<li>出现问题后，不要企图隐瞒，越早解决负面影响越小</li>\n<li>接受批评，能承担责任并提供解决方法</li>\n</ul>\n<p><strong> 充满压力的时候是赢得忠诚的最好时机。修心，亦是修行之一。顺境修力，逆境修心，缺一不可。</strong></p>\n<h3 id=\"2-5-推销…不仅仅是迎合\"><a href=\"#2-5-推销…不仅仅是迎合\" class=\"headerlink\" title=\"2.5.推销…不仅仅是迎合\"></a>2.5.推销…不仅仅是迎合</h3><ul>\n<li>写作能力是必要的</li>\n<li>面对面沟通高效</li>\n<li>能用行业术语展示商业价值</li>\n<li>个人优秀与人际关系网同样重要</li>\n<li>网络日志，开源可增长写作技巧，扩大人际网（创建自己的商标–认知和尊重）</li>\n<li>恐惧感使我们无法接近专业人士</li>\n</ul>\n<h3 id=\"2-6-切忌孤注一掷\"><a href=\"#2-6-切忌孤注一掷\" class=\"headerlink\" title=\"2.6. 切忌孤注一掷\"></a>2.6. 切忌孤注一掷</h3><p>切勿将自己的职业道路建立在一门特定的技术上，这是十分冒险的。</p>\n<p>在选择商业与开源项目时，我们可以将开源作为一个平台，使自己对一项技术进行深度学习。<strong>同时，也不是致力于研究如何配置和部署一个商业应用程序服务器的细节</strong>（ <strong><em>毕竟，任何人都可以在config中调整设置，对吗？</em></strong> ），<strong>而是利用类似的开源，学习服务器内部是如何运作的，不要只局限于学习如何操作。</strong></p>\n<p><strong>观点转变：</strong> 既了解实施的细节，也知道内部运作。</p>\n<h2 id=\"3-执行\"><a href=\"#3-执行\" class=\"headerlink\" title=\"3. 执行\"></a>3. 执行</h2><h3 id=\"3-1-就是现在\"><a href=\"#3-1-就是现在\" class=\"headerlink\" title=\"3.1. 就是现在\"></a>3.1. 就是现在</h3><p>帕金森定律：“工作会自动膨胀到占满所有可用的时间。”<br>开始行动，不要总是安于现状，要做推动者。 随时记得问问自己：“** 现在我们能做些什么？”</p>\n<h3 id=\"3-2-读心术\"><a href=\"#3-2-读心术\" class=\"headerlink\" title=\"3.2. 读心术\"></a>3.2. 读心术</h3><p>可以分析出潜在的功能需求–来自领导或客户。</p>\n<p>但是，这也是有风险的：  </p>\n<ul>\n<li>这是额外的任务，他的价值是否足够；</li>\n<li>可能对当前的软件架构影响，代码的模块化；</li>\n</ul>\n<p><strong><em> Tips: </em></strong><br>建立自己额外分析功能的列表，查看命中率。</p>\n<h3 id=\"3-3-在工作中，将自己自动化\"><a href=\"#3-3-在工作中，将自己自动化\" class=\"headerlink\" title=\"3.3. 在工作中，将自己自动化\"></a>3.3. 在工作中，将自己自动化</h3><p>想提高软件开发的效率：</p>\n<ul>\n<li>找到工作效率更高的人  </li>\n<li>找更多的人来做  </li>\n<li>自动化工作  </li>\n</ul>\n<h3 id=\"3-4-每日成绩\"><a href=\"#3-4-每日成绩\" class=\"headerlink\" title=\"3.4. 每日成绩\"></a>3.4. 每日成绩</h3><p>问自己“今天实现自己的价值了么？”</p>\n<p>计划和跟踪工作成绩，对每个人都有益。常见步骤：</p>\n<ol>\n<li>根据工作优先顺序，罗列计划</li>\n<li>记录工作成绩</li>\n<li>总结与回顾</li>\n</ol>\n<h3 id=\"3-5-8小时激情燃烧\"><a href=\"#3-5-8小时激情燃烧\" class=\"headerlink\" title=\"3.5. 8小时激情燃烧\"></a>3.5. 8小时激情燃烧</h3><p>在工作上，更少的工作时间可以有更高的效率。大多数项目都是一项长期工作，人们不可能按冲刺的速度跑完整个马拉松。</p>\n<p>有限的资源更加珍贵，我们需高效的利用有限的资源，安排时间也是一样。好好规划工作时间，减少工作时间，将会收获更多。当离开工作一段时间后，才会更喜欢工作。</p>\n<h3 id=\"3-6-今天我能把工作做到多好？\"><a href=\"#3-6-今天我能把工作做到多好？\" class=\"headerlink\" title=\"3.6. 今天我能把工作做到多好？\"></a>3.6. 今天我能把工作做到多好？</h3><p>在处理最无聊烦人的工作时，如果能狂热的想要把它做好，那么能为你的工作增添多少乐趣？<br>常常遇到的问题是：<strong><em>我们如何挑战自己，发挥创造力来应对这些平凡的工作？</em></strong><br>试试把这些无聊的工作做到100分。</p>\n<h3 id=\"3-7-别忘了你在为谁工作\"><a href=\"#3-7-别忘了你在为谁工作\" class=\"headerlink\" title=\"3.7. 别忘了你在为谁工作\"></a>3.7. 别忘了你在为谁工作</h3><p>“确保你的目标和工作于你公司的目标一致。” 我们可以从小范围入手：团队。<br>我们可以知道团队的问题和努力的方向。</p>\n<h3 id=\"3-8-安分守己\"><a href=\"#3-8-安分守己\" class=\"headerlink\" title=\"3.8. 安分守己\"></a>3.8. 安分守己</h3><p>比起只专注于目标上的做法，专注于现在的工作会使你离最终的目标更近。我们将会享受日常工作中的每一个小成功。<br><strong>当有雄心，但不必路人皆知。</strong></p>\n<p><strong><em> TIPS: </em></strong><br>这有点像《白日梦想家》影片。<br><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=61eb7902554e9258b2398ebcfdebba3d/8718367adab44aed46bb2f82b01c8701a08bfbdb.jpg\" alt=\"\"></p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=1c98646b73cf3bc7fc0dc5beb069d1c4/10dfa9ec8a13632719415a55928fa0ec08fac72c.jpg\" alt=\"\"></p>\n<h3 id=\"3-9-一桶水中的鹅卵石\"><a href=\"#3-9-一桶水中的鹅卵石\" class=\"headerlink\" title=\"3.9. 一桶水中的鹅卵石\"></a>3.9. 一桶水中的鹅卵石</h3><p>不要太沉迷于自我，你的离开犹如拿起水桶中的鹅卵石并不明显。<br>每个人都不是不可替代的，清楚知道这一点，与公司或同事保持良好的工作关系并努力工作，恰恰会让你与众不同，无意见创造更多的机会。</p>\n<p>越是成功，就越有可能犯下重大错误。当你得到很多肯定时，你就会很少质疑自己的决定。当使用自己的方法屡试不爽时，就可能忽视可能会有更好的方法，容易产生盲点。</p>\n<p><strong> TIPS：</strong><br>不要高枕无忧，保持谦逊的心态。</p>\n<h3 id=\"3-10-爱上维护\"><a href=\"#3-10-爱上维护\" class=\"headerlink\" title=\"3.10. 爱上维护\"></a>3.10. 爱上维护</h3><p>维护也可以成为自由和创造的沃土。<br></p>\n<ol>\n<li>身兼数职项目领导者、架构师、设计师和测试员，随心发挥创造力</li>\n<li>可以设计更可见的改进</li>\n<li>与客户直接进行交流，了解业务运行情况</li>\n</ol>\n<p><strong> TIPS： </strong><br>在所有重要应用程序和代码中使用：评估、改进、评估。 把所有可以评估程序质量的元素列举出来。比如，响应时间，数据处理过程抛出的异常质量等，<strong>不要直接评估程序的质量。 </strong> </p>\n<ul>\n<li>选取测量标准，评估、改进</li>\n<li>选取另一测量标准，评估、改进</li>\n</ul>\n<h2 id=\"4-自我未来规划\"><a href=\"#4-自我未来规划\" class=\"headerlink\" title=\"4.自我未来规划\"></a>4.自我未来规划</h2><p>避免职业技术的过时。<strong>研究、投资、执行、市场</strong>然后重复，在任何一个环节上花费过多的时间，都会有过时的危险。</p>\n<h3 id=\"4-1-已经过时的技术\"><a href=\"#4-1-已经过时的技术\" class=\"headerlink\" title=\"4.1. 已经过时的技术\"></a>4.1. 已经过时的技术</h3><p>根据摩尔定律的推断，计算机性能每隔18个月提高一倍。随着硬件的不断进步，软件技术也得到迅猛发展。必须认识到，即使你现在处于当今潮流的尖端，也极有可能已经在下一个潮流之后。<strong>向前看，清楚地知道你的技术发展方向，是盲目和有远见的区别。</strong></p>\n<p>职业生涯中最重要的部分不是晋升或者加薪，而是向这些发展方向努力工作的<strong>过程</strong>。 </p>\n<p><em>TIPS：</em></p>\n<blockquote>\n<p>每周抽出2个小时的时间来研究新技术，学习相关技术并手动尝试，制作简单的应用程序。</p>\n</blockquote>\n<h3 id=\"4-2-你已经失去工作了\"><a href=\"#4-2-你已经失去工作了\" class=\"headerlink\" title=\"4.2.你已经失去工作了\"></a>4.2.你已经失去工作了</h3><p>不要自己绑定到特定的工作角色上，尝试以测试员、经理、设计师架构师鞥身份来对待自己的工作。</p>\n<h3 id=\"4-3-要注意观察市场变化\"><a href=\"#4-3-要注意观察市场变化\" class=\"headerlink\" title=\"4.3. 要注意观察市场变化\"></a>4.3. 要注意观察市场变化</h3><p>关注技术方面的新闻–不管是商业还是纯技术。并且留意技术达人，观察他们热衷于什么，我们就能大致了解到什么技术会成为热门，或者预测出两年后的热门是什么。</p>\n<h3 id=\"4-4-给自己做一份蓝图\"><a href=\"#4-4-给自己做一份蓝图\" class=\"headerlink\" title=\"4.4. 给自己做一份蓝图\"></a>4.4. 给自己做一份蓝图</h3><p>个人的产品路线蓝图是用来判断你是否在不断向前发展的依据，并且能帮助你纵观全局。</p>"},{"title":"openwrt-ssh 跳过密码验证","date":"2017-09-04T15:29:54.000Z","_content":"\nopenwrt 一般采用dropbear 作为ssh 客户端/服务端。 但一般都是使用password  的形式登录ssh. 我们使用public/private key 的形式来跳过需要password的验证。\n\n# 1. 客户端\n使用如下命令，生成public keys\n``` bash\ndropbearkey  -y -f /etc/dropbear/dropbear_rsa_host_key\n```\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/public_key.png)\n将图中pulibc key 复制到服务端。\n<!-- more -->\n# 2. 服务端\ndropbear 与openssh 有点区别在于，**authorized_keys 文件并不在~/.ssh/authorized_keys 文件中, 而是在/etc/dropbear/authorized_keys**\n\n之后重启服务端dropbear service\n``` bash\n/etc/init.d/dropbear restart\n```\ndropbear 的配置如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/dropbear_config.png)\n\n# 3. 使用\n在客服端使用如下命令登陆服务端\n``` bash\nssh -i /etc/dropbear/dropbear_rsa_host_key root@172.28.52.151 -p 6350\n```\n需要使用 \"-i\"选项指明identify 文件， \"-p 6350\" 是指明端口号\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/ssh_help.png)\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/login_ssh_without_password.png)\n当然我们可以不指明**-i** option 指定文件，直接登录。\n\n作如下步骤：\n``` bash\ncp /etc/dropbear/dropbear_rsa_host_key ~/.ssh/id_dropbear\n```\n\n使用如下命令直接登陆：\n``` bash\nssh 172.28.52.151 -l root -p 6350 \n```\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/simple_ssh_login.png)\n\n","source":"_posts/openwrt-ssh.md","raw":"---\ntitle: openwrt-ssh 跳过密码验证\ndate: 2017-09-04 23:29:54\ntags: \n\t- ssh\n\t- dropbear\ncategories: openwrt\n---\n\nopenwrt 一般采用dropbear 作为ssh 客户端/服务端。 但一般都是使用password  的形式登录ssh. 我们使用public/private key 的形式来跳过需要password的验证。\n\n# 1. 客户端\n使用如下命令，生成public keys\n``` bash\ndropbearkey  -y -f /etc/dropbear/dropbear_rsa_host_key\n```\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/public_key.png)\n将图中pulibc key 复制到服务端。\n<!-- more -->\n# 2. 服务端\ndropbear 与openssh 有点区别在于，**authorized_keys 文件并不在~/.ssh/authorized_keys 文件中, 而是在/etc/dropbear/authorized_keys**\n\n之后重启服务端dropbear service\n``` bash\n/etc/init.d/dropbear restart\n```\ndropbear 的配置如下：\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/dropbear_config.png)\n\n# 3. 使用\n在客服端使用如下命令登陆服务端\n``` bash\nssh -i /etc/dropbear/dropbear_rsa_host_key root@172.28.52.151 -p 6350\n```\n需要使用 \"-i\"选项指明identify 文件， \"-p 6350\" 是指明端口号\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/ssh_help.png)\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/login_ssh_without_password.png)\n当然我们可以不指明**-i** option 指定文件，直接登录。\n\n作如下步骤：\n``` bash\ncp /etc/dropbear/dropbear_rsa_host_key ~/.ssh/id_dropbear\n```\n\n使用如下命令直接登陆：\n``` bash\nssh 172.28.52.151 -l root -p 6350 \n```\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/simple_ssh_login.png)\n\n","slug":"openwrt-ssh","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0r0003pzkgryqjneh3a","content":"<p>openwrt 一般采用dropbear 作为ssh 客户端/服务端。 但一般都是使用password  的形式登录ssh. 我们使用public/private key 的形式来跳过需要password的验证。</p>\n<h1 id=\"1-客户端\"><a href=\"#1-客户端\" class=\"headerlink\" title=\"1. 客户端\"></a>1. 客户端</h1><p>使用如下命令，生成public keys<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dropbearkey  -y -f /etc/dropbear/dropbear_rsa_host_key</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/public_key.png\" alt=\"\"><br>将图中pulibc key 复制到服务端。<br><a id=\"more\"></a></p>\n<h1 id=\"2-服务端\"><a href=\"#2-服务端\" class=\"headerlink\" title=\"2. 服务端\"></a>2. 服务端</h1><p>dropbear 与openssh 有点区别在于，<strong>authorized_keys 文件并不在~/.ssh/authorized_keys 文件中, 而是在/etc/dropbear/authorized_keys</strong></p>\n<p>之后重启服务端dropbear service<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/dropbear restart</span><br></pre></td></tr></table></figure></p>\n<p>dropbear 的配置如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/dropbear_config.png\" alt=\"\"></p>\n<h1 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h1><p>在客服端使用如下命令登陆服务端<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i /etc/dropbear/dropbear_rsa_host_key root@172.28.52.151 -p 6350</span><br></pre></td></tr></table></figure></p>\n<p>需要使用 “-i”选项指明identify 文件， “-p 6350” 是指明端口号<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/ssh_help.png\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/login_ssh_without_password.png\" alt=\"\"><br>当然我们可以不指明<strong>-i</strong> option 指定文件，直接登录。</p>\n<p>作如下步骤：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /etc/dropbear/dropbear_rsa_host_key ~/.ssh/id_dropbear</span><br></pre></td></tr></table></figure></p>\n<p>使用如下命令直接登陆：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh 172.28.52.151 -l root -p 6350</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/simple_ssh_login.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>openwrt 一般采用dropbear 作为ssh 客户端/服务端。 但一般都是使用password  的形式登录ssh. 我们使用public/private key 的形式来跳过需要password的验证。</p>\n<h1 id=\"1-客户端\"><a href=\"#1-客户端\" class=\"headerlink\" title=\"1. 客户端\"></a>1. 客户端</h1><p>使用如下命令，生成public keys<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dropbearkey  -y -f /etc/dropbear/dropbear_rsa_host_key</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/public_key.png\" alt=\"\"><br>将图中pulibc key 复制到服务端。<br>","more":"</p>\n<h1 id=\"2-服务端\"><a href=\"#2-服务端\" class=\"headerlink\" title=\"2. 服务端\"></a>2. 服务端</h1><p>dropbear 与openssh 有点区别在于，<strong>authorized_keys 文件并不在~/.ssh/authorized_keys 文件中, 而是在/etc/dropbear/authorized_keys</strong></p>\n<p>之后重启服务端dropbear service<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/dropbear restart</span><br></pre></td></tr></table></figure></p>\n<p>dropbear 的配置如下：<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/dropbear_config.png\" alt=\"\"></p>\n<h1 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h1><p>在客服端使用如下命令登陆服务端<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i /etc/dropbear/dropbear_rsa_host_key root@172.28.52.151 -p 6350</span><br></pre></td></tr></table></figure></p>\n<p>需要使用 “-i”选项指明identify 文件， “-p 6350” 是指明端口号<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/ssh_help.png\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/login_ssh_without_password.png\" alt=\"\"><br>当然我们可以不指明<strong>-i</strong> option 指定文件，直接登录。</p>\n<p>作如下步骤：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /etc/dropbear/dropbear_rsa_host_key ~/.ssh/id_dropbear</span><br></pre></td></tr></table></figure></p>\n<p>使用如下命令直接登陆：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh 172.28.52.151 -l root -p 6350</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/openwrt-ssh/simple_ssh_login.png\" alt=\"\"></p>"},{"title":"ssh_of_openwrt","date":"2017-09-04T12:10:09.000Z","_content":"\nopenwrt 一般采用dropbear 作为ssh 客户端/服务端。\n\n# 客户端\n使用如下命令，生成public keys\n``` bash\ndropbearkey  -y -f /etc/dropbear/dropbear_rsa_host_key\n```\n\n将图中pulibc key 复制到服务端。\n<!-- more -->\n# 服务端\ndropbear 与openssh 有点区别在于，**authorized\\_keys 文件并不在~/.ssh/authorized_keys 文件中**，如下图：\n\n之后重启服务端dropbear service\n\n\ndropbear 的配置如下：\n\n\n# 使用\n在客服端使用如下命令登陆服务端\n``` bash\nssh -i /etc/dropbear/dropbear_rsa_host_key root@172.28.52.151 -p 6350\n```\n\n需要使用 \"-i\"选项指明identify 文件， \"-p 6350\" 是指明端口号\n\n\n或者可以不指明-i  文件\n``` bash\ncp /etc/dropbear/dropbear_rsa_host_key ~/.ssh/id_dropbear\n```\n\n之后使用如下命令直接登陆：\n``` bash\nssh 172.28.52.151 -l root -p 6350 \n```\n\n","source":"_posts/ssh-of-openwrt.md","raw":"---\ntitle: ssh_of_openwrt\ndate: 2017-09-04 20:10:09\ntags:\n\t- openwrt\ncategories: openwrt\n---\n\nopenwrt 一般采用dropbear 作为ssh 客户端/服务端。\n\n# 客户端\n使用如下命令，生成public keys\n``` bash\ndropbearkey  -y -f /etc/dropbear/dropbear_rsa_host_key\n```\n\n将图中pulibc key 复制到服务端。\n<!-- more -->\n# 服务端\ndropbear 与openssh 有点区别在于，**authorized\\_keys 文件并不在~/.ssh/authorized_keys 文件中**，如下图：\n\n之后重启服务端dropbear service\n\n\ndropbear 的配置如下：\n\n\n# 使用\n在客服端使用如下命令登陆服务端\n``` bash\nssh -i /etc/dropbear/dropbear_rsa_host_key root@172.28.52.151 -p 6350\n```\n\n需要使用 \"-i\"选项指明identify 文件， \"-p 6350\" 是指明端口号\n\n\n或者可以不指明-i  文件\n``` bash\ncp /etc/dropbear/dropbear_rsa_host_key ~/.ssh/id_dropbear\n```\n\n之后使用如下命令直接登陆：\n``` bash\nssh 172.28.52.151 -l root -p 6350 \n```\n\n","slug":"ssh-of-openwrt","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0r2003tzkgrmwha9b34","content":"<p>openwrt 一般采用dropbear 作为ssh 客户端/服务端。</p>\n<h1 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h1><p>使用如下命令，生成public keys<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dropbearkey  -y -f /etc/dropbear/dropbear_rsa_host_key</span><br></pre></td></tr></table></figure></p>\n<p>将图中pulibc key 复制到服务端。<br><a id=\"more\"></a></p>\n<h1 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h1><p>dropbear 与openssh 有点区别在于，<strong>authorized_keys 文件并不在~/.ssh/authorized_keys 文件中</strong>，如下图：</p>\n<p>之后重启服务端dropbear service</p>\n<p>dropbear 的配置如下：</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>在客服端使用如下命令登陆服务端<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i /etc/dropbear/dropbear_rsa_host_key root@172.28.52.151 -p 6350</span><br></pre></td></tr></table></figure></p>\n<p>需要使用 “-i”选项指明identify 文件， “-p 6350” 是指明端口号</p>\n<p>或者可以不指明-i  文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /etc/dropbear/dropbear_rsa_host_key ~/.ssh/id_dropbear</span><br></pre></td></tr></table></figure></p>\n<p>之后使用如下命令直接登陆：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh 172.28.52.151 -l root -p 6350</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>openwrt 一般采用dropbear 作为ssh 客户端/服务端。</p>\n<h1 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h1><p>使用如下命令，生成public keys<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dropbearkey  -y -f /etc/dropbear/dropbear_rsa_host_key</span><br></pre></td></tr></table></figure></p>\n<p>将图中pulibc key 复制到服务端。<br>","more":"</p>\n<h1 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h1><p>dropbear 与openssh 有点区别在于，<strong>authorized_keys 文件并不在~/.ssh/authorized_keys 文件中</strong>，如下图：</p>\n<p>之后重启服务端dropbear service</p>\n<p>dropbear 的配置如下：</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>在客服端使用如下命令登陆服务端<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i /etc/dropbear/dropbear_rsa_host_key root@172.28.52.151 -p 6350</span><br></pre></td></tr></table></figure></p>\n<p>需要使用 “-i”选项指明identify 文件， “-p 6350” 是指明端口号</p>\n<p>或者可以不指明-i  文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /etc/dropbear/dropbear_rsa_host_key ~/.ssh/id_dropbear</span><br></pre></td></tr></table></figure></p>\n<p>之后使用如下命令直接登陆：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh 172.28.52.151 -l root -p 6350</span><br></pre></td></tr></table></figure></p>"},{"title":"webrtc_directory_analyze","date":"2017-12-11T09:06:12.000Z","_content":"\n# 1. Structure\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/webrtc_call_flow.png)\n\n<!-- more -->\n# 2. Directory Analyze\nDirectory | Remarks\n-         | :-\napi       | native api, support for app or web browser. Note **medianinterface.h** and **peerconnectioninterface.h**\n**pc**    | 1.hannel manager; <br>2.**peerconnecction**, **mediastream** manage; <br>3.RTP receive/send\n**audio** | audio receive/send\n**video** | 1.video receive/send; <br>2.video encoder;  <br>3.handle synchronize, quality\ncommon audio | 1.audio converter; <br>2.channel buffer; <br>3.smoothing filter; <br>4.handle wav file\ncommon video | 1.**h264**, **libyuv**; <br>2.bitrate control; <br>3.video frame, video render frame\ncall      | provide base class for audio and video\n**media** | Audio and Video will be AddStreams as track. <br>1.webrtc general video handle; <br>2.sctp.(Session Description Transport Protocol)\nstats     | reference counter\n**modules** | 1.audio (coding, device, mixer, processing); <br>2.bitrate controller; <br>3.video(capture, coding)\np2p       | 1.port, session, stun(server, port); <br>2.stunprober\nrtc_base  | base class. <br>1.bind, network, socket; <br>2.crc32, md5, openssl; <br>3.(bit, byte)buffer, memory; <br>4.task, thread\nsysterm_wrapper | 1.clock; <br>2.event; <br>3.rw_lock","source":"_posts/webrtc-directory-analyze.md","raw":"---\ntitle: webrtc_directory_analyze\ndate: 2017-12-11 17:06:12\ntags:\n\t- WebRTC\ncategories: WebRTC\n---\n\n# 1. Structure\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/webrtc_call_flow.png)\n\n<!-- more -->\n# 2. Directory Analyze\nDirectory | Remarks\n-         | :-\napi       | native api, support for app or web browser. Note **medianinterface.h** and **peerconnectioninterface.h**\n**pc**    | 1.hannel manager; <br>2.**peerconnecction**, **mediastream** manage; <br>3.RTP receive/send\n**audio** | audio receive/send\n**video** | 1.video receive/send; <br>2.video encoder;  <br>3.handle synchronize, quality\ncommon audio | 1.audio converter; <br>2.channel buffer; <br>3.smoothing filter; <br>4.handle wav file\ncommon video | 1.**h264**, **libyuv**; <br>2.bitrate control; <br>3.video frame, video render frame\ncall      | provide base class for audio and video\n**media** | Audio and Video will be AddStreams as track. <br>1.webrtc general video handle; <br>2.sctp.(Session Description Transport Protocol)\nstats     | reference counter\n**modules** | 1.audio (coding, device, mixer, processing); <br>2.bitrate controller; <br>3.video(capture, coding)\np2p       | 1.port, session, stun(server, port); <br>2.stunprober\nrtc_base  | base class. <br>1.bind, network, socket; <br>2.crc32, md5, openssl; <br>3.(bit, byte)buffer, memory; <br>4.task, thread\nsysterm_wrapper | 1.clock; <br>2.event; <br>3.rw_lock","slug":"webrtc-directory-analyze","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0r3003vzkgr9jp4xfwl","content":"<h1 id=\"1-Structure\"><a href=\"#1-Structure\" class=\"headerlink\" title=\"1. Structure\"></a>1. Structure</h1><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/webrtc_call_flow.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h1 id=\"2-Directory-Analyze\"><a href=\"#2-Directory-Analyze\" class=\"headerlink\" title=\"2. Directory Analyze\"></a>2. Directory Analyze</h1><table>\n<thead>\n<tr>\n<th>Directory</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>api</td>\n<td style=\"text-align:left\">native api, support for app or web browser. Note <strong>medianinterface.h</strong> and <strong>peerconnectioninterface.h</strong></td>\n</tr>\n<tr>\n<td><strong>pc</strong></td>\n<td style=\"text-align:left\">1.hannel manager; <br>2.<strong>peerconnecction</strong>, <strong>mediastream</strong> manage; <br>3.RTP receive/send</td>\n</tr>\n<tr>\n<td><strong>audio</strong></td>\n<td style=\"text-align:left\">audio receive/send</td>\n</tr>\n<tr>\n<td><strong>video</strong></td>\n<td style=\"text-align:left\">1.video receive/send; <br>2.video encoder;  <br>3.handle synchronize, quality</td>\n</tr>\n<tr>\n<td>common audio</td>\n<td style=\"text-align:left\">1.audio converter; <br>2.channel buffer; <br>3.smoothing filter; <br>4.handle wav file</td>\n</tr>\n<tr>\n<td>common video</td>\n<td style=\"text-align:left\">1.<strong>h264</strong>, <strong>libyuv</strong>; <br>2.bitrate control; <br>3.video frame, video render frame</td>\n</tr>\n<tr>\n<td>call</td>\n<td style=\"text-align:left\">provide base class for audio and video</td>\n</tr>\n<tr>\n<td><strong>media</strong></td>\n<td style=\"text-align:left\">Audio and Video will be AddStreams as track. <br>1.webrtc general video handle; <br>2.sctp.(Session Description Transport Protocol)</td>\n</tr>\n<tr>\n<td>stats</td>\n<td style=\"text-align:left\">reference counter</td>\n</tr>\n<tr>\n<td><strong>modules</strong></td>\n<td style=\"text-align:left\">1.audio (coding, device, mixer, processing); <br>2.bitrate controller; <br>3.video(capture, coding)</td>\n</tr>\n<tr>\n<td>p2p</td>\n<td style=\"text-align:left\">1.port, session, stun(server, port); <br>2.stunprober</td>\n</tr>\n<tr>\n<td>rtc_base</td>\n<td style=\"text-align:left\">base class. <br>1.bind, network, socket; <br>2.crc32, md5, openssl; <br>3.(bit, byte)buffer, memory; <br>4.task, thread</td>\n</tr>\n<tr>\n<td>systerm_wrapper</td>\n<td style=\"text-align:left\">1.clock; <br>2.event; <br>3.rw_lock</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Structure\"><a href=\"#1-Structure\" class=\"headerlink\" title=\"1. Structure\"></a>1. Structure</h1><p><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/webrtc_call_flow.png\" alt=\"\"></p>","more":"<h1 id=\"2-Directory-Analyze\"><a href=\"#2-Directory-Analyze\" class=\"headerlink\" title=\"2. Directory Analyze\"></a>2. Directory Analyze</h1><table>\n<thead>\n<tr>\n<th>Directory</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>api</td>\n<td style=\"text-align:left\">native api, support for app or web browser. Note <strong>medianinterface.h</strong> and <strong>peerconnectioninterface.h</strong></td>\n</tr>\n<tr>\n<td><strong>pc</strong></td>\n<td style=\"text-align:left\">1.hannel manager; <br>2.<strong>peerconnecction</strong>, <strong>mediastream</strong> manage; <br>3.RTP receive/send</td>\n</tr>\n<tr>\n<td><strong>audio</strong></td>\n<td style=\"text-align:left\">audio receive/send</td>\n</tr>\n<tr>\n<td><strong>video</strong></td>\n<td style=\"text-align:left\">1.video receive/send; <br>2.video encoder;  <br>3.handle synchronize, quality</td>\n</tr>\n<tr>\n<td>common audio</td>\n<td style=\"text-align:left\">1.audio converter; <br>2.channel buffer; <br>3.smoothing filter; <br>4.handle wav file</td>\n</tr>\n<tr>\n<td>common video</td>\n<td style=\"text-align:left\">1.<strong>h264</strong>, <strong>libyuv</strong>; <br>2.bitrate control; <br>3.video frame, video render frame</td>\n</tr>\n<tr>\n<td>call</td>\n<td style=\"text-align:left\">provide base class for audio and video</td>\n</tr>\n<tr>\n<td><strong>media</strong></td>\n<td style=\"text-align:left\">Audio and Video will be AddStreams as track. <br>1.webrtc general video handle; <br>2.sctp.(Session Description Transport Protocol)</td>\n</tr>\n<tr>\n<td>stats</td>\n<td style=\"text-align:left\">reference counter</td>\n</tr>\n<tr>\n<td><strong>modules</strong></td>\n<td style=\"text-align:left\">1.audio (coding, device, mixer, processing); <br>2.bitrate controller; <br>3.video(capture, coding)</td>\n</tr>\n<tr>\n<td>p2p</td>\n<td style=\"text-align:left\">1.port, session, stun(server, port); <br>2.stunprober</td>\n</tr>\n<tr>\n<td>rtc_base</td>\n<td style=\"text-align:left\">base class. <br>1.bind, network, socket; <br>2.crc32, md5, openssl; <br>3.(bit, byte)buffer, memory; <br>4.task, thread</td>\n</tr>\n<tr>\n<td>systerm_wrapper</td>\n<td style=\"text-align:left\">1.clock; <br>2.event; <br>3.rw_lock</td>\n</tr>\n</tbody>\n</table>"},{"title":"the Siege webserver performance test tool","date":"2017-06-22T02:56:27.000Z","_content":"\n# 1. Backgroud\n>Siege is an open source regression test and benchmark utility. It can stress test a single URL with a user defined number of simulated users, or it can read many URLs into memory and stress them simultaneously. The program reports the total number of hits recorded, bytes transferred, response time, concurrency, and return status. Siege supports HTTP/1.0 and 1.1 protocols, the GET and POST directives, cookies, transaction logging, and basic authentication. Its features are configurable on a per user basis.\n\nDetail see  <https://github.com/JoeDog/siege>\n\n# 2. Compile\nDecompressing Siege source code archive, and run  \n``` bash\n./utils/bootstrap\n./configure\nmake && make install\n```\n**Note:**  If we have ssl or zlib support, please point out when we make the configuration.   \n```bash\n--with-ssl=$(SSL_include_dir) \\\n--with-zlib=$(ZLIB_include_dir)\n```\n<!-- more -->\n# 3. Run\nUse \"siege -C ' command to see current configuration.   \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_config.png)\n\nModify /etc/url.txt file to test accessing url.  \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_test_url.png)\n\nThen we use siege command to test, and press \"Ctrl + C\" to stop.  \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_run.png)\n\n# 4. Result\nAfter we stop Siege with \"Ctrl + C\", we will get result:  \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_result.png)\n","source":"_posts/the Siege webserver test tool.md","raw":"---\ntitle: the Siege webserver performance test tool\ndate: 2017-06-22 10:56:27\ntags: \n\t- Siege\n\t- webserver\ncategories: tools\n---\n\n# 1. Backgroud\n>Siege is an open source regression test and benchmark utility. It can stress test a single URL with a user defined number of simulated users, or it can read many URLs into memory and stress them simultaneously. The program reports the total number of hits recorded, bytes transferred, response time, concurrency, and return status. Siege supports HTTP/1.0 and 1.1 protocols, the GET and POST directives, cookies, transaction logging, and basic authentication. Its features are configurable on a per user basis.\n\nDetail see  <https://github.com/JoeDog/siege>\n\n# 2. Compile\nDecompressing Siege source code archive, and run  \n``` bash\n./utils/bootstrap\n./configure\nmake && make install\n```\n**Note:**  If we have ssl or zlib support, please point out when we make the configuration.   \n```bash\n--with-ssl=$(SSL_include_dir) \\\n--with-zlib=$(ZLIB_include_dir)\n```\n<!-- more -->\n# 3. Run\nUse \"siege -C ' command to see current configuration.   \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_config.png)\n\nModify /etc/url.txt file to test accessing url.  \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_test_url.png)\n\nThen we use siege command to test, and press \"Ctrl + C\" to stop.  \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_run.png)\n\n# 4. Result\nAfter we stop Siege with \"Ctrl + C\", we will get result:  \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_result.png)\n","slug":"the Siege webserver test tool","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0r6003xzkgrljf5syww","content":"<h1 id=\"1-Backgroud\"><a href=\"#1-Backgroud\" class=\"headerlink\" title=\"1. Backgroud\"></a>1. Backgroud</h1><blockquote>\n<p>Siege is an open source regression test and benchmark utility. It can stress test a single URL with a user defined number of simulated users, or it can read many URLs into memory and stress them simultaneously. The program reports the total number of hits recorded, bytes transferred, response time, concurrency, and return status. Siege supports HTTP/1.0 and 1.1 protocols, the GET and POST directives, cookies, transaction logging, and basic authentication. Its features are configurable on a per user basis.</p>\n</blockquote>\n<p>Detail see  <a href=\"https://github.com/JoeDog/siege\" target=\"_blank\" rel=\"noopener\">https://github.com/JoeDog/siege</a></p>\n<h1 id=\"2-Compile\"><a href=\"#2-Compile\" class=\"headerlink\" title=\"2. Compile\"></a>2. Compile</h1><p>Decompressing Siege source code archive, and run<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./utils/bootstrap</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>\n<p><strong>Note:</strong>  If we have ssl or zlib support, please point out when we make the configuration.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--with-ssl=$(SSL_include_dir) \\</span><br><span class=\"line\">--with-zlib=$(ZLIB_include_dir)</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h1 id=\"3-Run\"><a href=\"#3-Run\" class=\"headerlink\" title=\"3. Run\"></a>3. Run</h1><p>Use “siege -C ‘ command to see current configuration.<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_config.png\" alt=\"\"></p>\n<p>Modify /etc/url.txt file to test accessing url.<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_test_url.png\" alt=\"\"></p>\n<p>Then we use siege command to test, and press “Ctrl + C” to stop.<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_run.png\" alt=\"\"></p>\n<h1 id=\"4-Result\"><a href=\"#4-Result\" class=\"headerlink\" title=\"4. Result\"></a>4. Result</h1><p>After we stop Siege with “Ctrl + C”, we will get result:<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_result.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Backgroud\"><a href=\"#1-Backgroud\" class=\"headerlink\" title=\"1. Backgroud\"></a>1. Backgroud</h1><blockquote>\n<p>Siege is an open source regression test and benchmark utility. It can stress test a single URL with a user defined number of simulated users, or it can read many URLs into memory and stress them simultaneously. The program reports the total number of hits recorded, bytes transferred, response time, concurrency, and return status. Siege supports HTTP/1.0 and 1.1 protocols, the GET and POST directives, cookies, transaction logging, and basic authentication. Its features are configurable on a per user basis.</p>\n</blockquote>\n<p>Detail see  <a href=\"https://github.com/JoeDog/siege\" target=\"_blank\" rel=\"noopener\">https://github.com/JoeDog/siege</a></p>\n<h1 id=\"2-Compile\"><a href=\"#2-Compile\" class=\"headerlink\" title=\"2. Compile\"></a>2. Compile</h1><p>Decompressing Siege source code archive, and run<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./utils/bootstrap</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>\n<p><strong>Note:</strong>  If we have ssl or zlib support, please point out when we make the configuration.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--with-ssl=$(SSL_include_dir) \\</span><br><span class=\"line\">--with-zlib=$(ZLIB_include_dir)</span><br></pre></td></tr></table></figure></p>","more":"<h1 id=\"3-Run\"><a href=\"#3-Run\" class=\"headerlink\" title=\"3. Run\"></a>3. Run</h1><p>Use “siege -C ‘ command to see current configuration.<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_config.png\" alt=\"\"></p>\n<p>Modify /etc/url.txt file to test accessing url.<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_test_url.png\" alt=\"\"></p>\n<p>Then we use siege command to test, and press “Ctrl + C” to stop.<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_run.png\" alt=\"\"></p>\n<h1 id=\"4-Result\"><a href=\"#4-Result\" class=\"headerlink\" title=\"4. Result\"></a>4. Result</h1><p>After we stop Siege with “Ctrl + C”, we will get result:<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/siege/siege_result.png\" alt=\"\"></p>"},{"title":"webRTC_Directory","date":"2017-11-28T12:03:36.000Z","_content":"\n# 1.Backgroud\nWebRTC is a free, open project that enables web browsers with Real-Time Communications (RTC) capabilities via simple JavaScript APIs. The WebRTC components have been optimized to best serve this purpose.  \n\nThe WebRTC initiative is a project supported by Google, Mozilla and Opera, amongst others. This page is maintained by the Google Chrome team.\n\nAnd it's source code structure like this:  \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/webRTC_Structure.png)  \nMore detail see <https://webrtc.org>  \n\n<!-- more -->\n# 2.Source code Directory\nDir. | Remarks\n-    | :-\napi | WebRTC 接口层。包括 DataChannel, MediaStream SDP相关的接口。各浏览器都是通过该接口层调用的 WebRTC。\ncall | 存放的是 WebRTC “呼叫（Call）” 相关逻辑层的代码。\naudio | 存放音频网络逻辑层相关的代码。音频数据逻辑上的发送，接收等代码。\nvideo | 存放视频逻辑层及视频引擎层的相关的代码。视频数据逻辑上的发送，接收等代码。视频引擎层就是指如何控制视频采集，处理和编解码操作的逻辑。\nvoice_engine | 存放音频引擎代码。主要是控制音频的采集，处理，编解码的操作。*这个目录后面可能也会被拿掉。*\nsdk | 存放了 Android 和 IOS 层代码。如视频的采集，渲染代码都在这里。\npc | 存放一些业务逻辑层的代码。如 channel, session等。\ncommon_audio | 放一些音频的基本算法。包括环形队列，博利叶算法，滤波器等。\ncommon_video |存放了视频算法相关的常用工具，如libyuv, sps/pps分析器，I420缓冲器等。\nmodules | ** 后面单独列举 **\nmedia | 存放媒体相关的代码。\np2p |  \nrtc_base | 存放了一些基础代码。如线程，事件，socket等相关的代码。\nrtc_tools | 存放了一些工具代码。如视频帧比较，I420转RGB，视频帧分析。\nstats | 存放各种数据统计相关的类。\nlibjingle | 网络库。\nsystem_wrapper | 与操作系统相关的代码，如 CPU特性，原子操作，读写锁，时钟等。\n\n*** Modules: ***  \n\nDir. | Remarks\n-    | :-\naudio_coding | 音频编解码相关代码。\naudio_conference_mixer | 会议混音相关代码。\naudio_device | 音频采集与音频播放相关代码。\naudio_mixer | 混音相关代码，这部分是后加的。\naudio_processing | 音频前后处理的相关代码。\nbitrate_controller | 码率控制相关代码。\ncongestion_controller | 流控相关的代码。\ndesktop_capture | 桌面采集相关的代码。\nmedia_file | 播放媒体文件相关的代码。\npacing | 码率探测相关的代码。\nremote_bitrate_estimator | 远端码率估算相关的代码。\nrtp_rtcp | rtp/rtcp协议相关代码。\nvideo_capture | 视频采集相关的代码。\nvideo_coding | 视频编解码相关的代码。\nvideo_processing | 视频前后处理相关的代码。\n\n","source":"_posts/webRTCDirectory.md","raw":"---\ntitle: webRTC_Directory\ndate: 2017-11-28 20:03:36\ntags:\n\t- WebRTC\n\t- Streaming\ncategories: WebRTC\n---\n\n# 1.Backgroud\nWebRTC is a free, open project that enables web browsers with Real-Time Communications (RTC) capabilities via simple JavaScript APIs. The WebRTC components have been optimized to best serve this purpose.  \n\nThe WebRTC initiative is a project supported by Google, Mozilla and Opera, amongst others. This page is maintained by the Google Chrome team.\n\nAnd it's source code structure like this:  \n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/webRTC_Structure.png)  \nMore detail see <https://webrtc.org>  \n\n<!-- more -->\n# 2.Source code Directory\nDir. | Remarks\n-    | :-\napi | WebRTC 接口层。包括 DataChannel, MediaStream SDP相关的接口。各浏览器都是通过该接口层调用的 WebRTC。\ncall | 存放的是 WebRTC “呼叫（Call）” 相关逻辑层的代码。\naudio | 存放音频网络逻辑层相关的代码。音频数据逻辑上的发送，接收等代码。\nvideo | 存放视频逻辑层及视频引擎层的相关的代码。视频数据逻辑上的发送，接收等代码。视频引擎层就是指如何控制视频采集，处理和编解码操作的逻辑。\nvoice_engine | 存放音频引擎代码。主要是控制音频的采集，处理，编解码的操作。*这个目录后面可能也会被拿掉。*\nsdk | 存放了 Android 和 IOS 层代码。如视频的采集，渲染代码都在这里。\npc | 存放一些业务逻辑层的代码。如 channel, session等。\ncommon_audio | 放一些音频的基本算法。包括环形队列，博利叶算法，滤波器等。\ncommon_video |存放了视频算法相关的常用工具，如libyuv, sps/pps分析器，I420缓冲器等。\nmodules | ** 后面单独列举 **\nmedia | 存放媒体相关的代码。\np2p |  \nrtc_base | 存放了一些基础代码。如线程，事件，socket等相关的代码。\nrtc_tools | 存放了一些工具代码。如视频帧比较，I420转RGB，视频帧分析。\nstats | 存放各种数据统计相关的类。\nlibjingle | 网络库。\nsystem_wrapper | 与操作系统相关的代码，如 CPU特性，原子操作，读写锁，时钟等。\n\n*** Modules: ***  \n\nDir. | Remarks\n-    | :-\naudio_coding | 音频编解码相关代码。\naudio_conference_mixer | 会议混音相关代码。\naudio_device | 音频采集与音频播放相关代码。\naudio_mixer | 混音相关代码，这部分是后加的。\naudio_processing | 音频前后处理的相关代码。\nbitrate_controller | 码率控制相关代码。\ncongestion_controller | 流控相关的代码。\ndesktop_capture | 桌面采集相关的代码。\nmedia_file | 播放媒体文件相关的代码。\npacing | 码率探测相关的代码。\nremote_bitrate_estimator | 远端码率估算相关的代码。\nrtp_rtcp | rtp/rtcp协议相关代码。\nvideo_capture | 视频采集相关的代码。\nvideo_coding | 视频编解码相关的代码。\nvideo_processing | 视频前后处理相关的代码。\n\n","slug":"webRTCDirectory","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0r80042zkgrlt1ll3tk","content":"<h1 id=\"1-Backgroud\"><a href=\"#1-Backgroud\" class=\"headerlink\" title=\"1.Backgroud\"></a>1.Backgroud</h1><p>WebRTC is a free, open project that enables web browsers with Real-Time Communications (RTC) capabilities via simple JavaScript APIs. The WebRTC components have been optimized to best serve this purpose.  </p>\n<p>The WebRTC initiative is a project supported by Google, Mozilla and Opera, amongst others. This page is maintained by the Google Chrome team.</p>\n<p>And it’s source code structure like this:<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/webRTC_Structure.png\" alt=\"\"><br>More detail see <a href=\"https://webrtc.org\" target=\"_blank\" rel=\"noopener\">https://webrtc.org</a>  </p>\n<a id=\"more\"></a>\n<h1 id=\"2-Source-code-Directory\"><a href=\"#2-Source-code-Directory\" class=\"headerlink\" title=\"2.Source code Directory\"></a>2.Source code Directory</h1><table>\n<thead>\n<tr>\n<th>Dir.</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>api</td>\n<td style=\"text-align:left\">WebRTC 接口层。包括 DataChannel, MediaStream SDP相关的接口。各浏览器都是通过该接口层调用的 WebRTC。</td>\n</tr>\n<tr>\n<td>call</td>\n<td style=\"text-align:left\">存放的是 WebRTC “呼叫（Call）” 相关逻辑层的代码。</td>\n</tr>\n<tr>\n<td>audio</td>\n<td style=\"text-align:left\">存放音频网络逻辑层相关的代码。音频数据逻辑上的发送，接收等代码。</td>\n</tr>\n<tr>\n<td>video</td>\n<td style=\"text-align:left\">存放视频逻辑层及视频引擎层的相关的代码。视频数据逻辑上的发送，接收等代码。视频引擎层就是指如何控制视频采集，处理和编解码操作的逻辑。</td>\n</tr>\n<tr>\n<td>voice_engine</td>\n<td style=\"text-align:left\">存放音频引擎代码。主要是控制音频的采集，处理，编解码的操作。<em>这个目录后面可能也会被拿掉。</em></td>\n</tr>\n<tr>\n<td>sdk</td>\n<td style=\"text-align:left\">存放了 Android 和 IOS 层代码。如视频的采集，渲染代码都在这里。</td>\n</tr>\n<tr>\n<td>pc</td>\n<td style=\"text-align:left\">存放一些业务逻辑层的代码。如 channel, session等。</td>\n</tr>\n<tr>\n<td>common_audio</td>\n<td style=\"text-align:left\">放一些音频的基本算法。包括环形队列，博利叶算法，滤波器等。</td>\n</tr>\n<tr>\n<td>common_video</td>\n<td style=\"text-align:left\">存放了视频算法相关的常用工具，如libyuv, sps/pps分析器，I420缓冲器等。</td>\n</tr>\n<tr>\n<td>modules</td>\n<td style=\"text-align:left\"><strong> 后面单独列举 </strong></td>\n</tr>\n<tr>\n<td>media</td>\n<td style=\"text-align:left\">存放媒体相关的代码。</td>\n</tr>\n<tr>\n<td>p2p</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td>rtc_base</td>\n<td style=\"text-align:left\">存放了一些基础代码。如线程，事件，socket等相关的代码。</td>\n</tr>\n<tr>\n<td>rtc_tools</td>\n<td style=\"text-align:left\">存放了一些工具代码。如视频帧比较，I420转RGB，视频帧分析。</td>\n</tr>\n<tr>\n<td>stats</td>\n<td style=\"text-align:left\">存放各种数据统计相关的类。</td>\n</tr>\n<tr>\n<td>libjingle</td>\n<td style=\"text-align:left\">网络库。</td>\n</tr>\n<tr>\n<td>system_wrapper</td>\n<td style=\"text-align:left\">与操作系统相关的代码，如 CPU特性，原子操作，读写锁，时钟等。</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em> Modules: </em></strong>  </p>\n<table>\n<thead>\n<tr>\n<th>Dir.</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>audio_coding</td>\n<td style=\"text-align:left\">音频编解码相关代码。</td>\n</tr>\n<tr>\n<td>audio_conference_mixer</td>\n<td style=\"text-align:left\">会议混音相关代码。</td>\n</tr>\n<tr>\n<td>audio_device</td>\n<td style=\"text-align:left\">音频采集与音频播放相关代码。</td>\n</tr>\n<tr>\n<td>audio_mixer</td>\n<td style=\"text-align:left\">混音相关代码，这部分是后加的。</td>\n</tr>\n<tr>\n<td>audio_processing</td>\n<td style=\"text-align:left\">音频前后处理的相关代码。</td>\n</tr>\n<tr>\n<td>bitrate_controller</td>\n<td style=\"text-align:left\">码率控制相关代码。</td>\n</tr>\n<tr>\n<td>congestion_controller</td>\n<td style=\"text-align:left\">流控相关的代码。</td>\n</tr>\n<tr>\n<td>desktop_capture</td>\n<td style=\"text-align:left\">桌面采集相关的代码。</td>\n</tr>\n<tr>\n<td>media_file</td>\n<td style=\"text-align:left\">播放媒体文件相关的代码。</td>\n</tr>\n<tr>\n<td>pacing</td>\n<td style=\"text-align:left\">码率探测相关的代码。</td>\n</tr>\n<tr>\n<td>remote_bitrate_estimator</td>\n<td style=\"text-align:left\">远端码率估算相关的代码。</td>\n</tr>\n<tr>\n<td>rtp_rtcp</td>\n<td style=\"text-align:left\">rtp/rtcp协议相关代码。</td>\n</tr>\n<tr>\n<td>video_capture</td>\n<td style=\"text-align:left\">视频采集相关的代码。</td>\n</tr>\n<tr>\n<td>video_coding</td>\n<td style=\"text-align:left\">视频编解码相关的代码。</td>\n</tr>\n<tr>\n<td>video_processing</td>\n<td style=\"text-align:left\">视频前后处理相关的代码。</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Backgroud\"><a href=\"#1-Backgroud\" class=\"headerlink\" title=\"1.Backgroud\"></a>1.Backgroud</h1><p>WebRTC is a free, open project that enables web browsers with Real-Time Communications (RTC) capabilities via simple JavaScript APIs. The WebRTC components have been optimized to best serve this purpose.  </p>\n<p>The WebRTC initiative is a project supported by Google, Mozilla and Opera, amongst others. This page is maintained by the Google Chrome team.</p>\n<p>And it’s source code structure like this:<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/webRTC/webRTC_Structure.png\" alt=\"\"><br>More detail see <a href=\"https://webrtc.org\" target=\"_blank\" rel=\"noopener\">https://webrtc.org</a>  </p>","more":"<h1 id=\"2-Source-code-Directory\"><a href=\"#2-Source-code-Directory\" class=\"headerlink\" title=\"2.Source code Directory\"></a>2.Source code Directory</h1><table>\n<thead>\n<tr>\n<th>Dir.</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>api</td>\n<td style=\"text-align:left\">WebRTC 接口层。包括 DataChannel, MediaStream SDP相关的接口。各浏览器都是通过该接口层调用的 WebRTC。</td>\n</tr>\n<tr>\n<td>call</td>\n<td style=\"text-align:left\">存放的是 WebRTC “呼叫（Call）” 相关逻辑层的代码。</td>\n</tr>\n<tr>\n<td>audio</td>\n<td style=\"text-align:left\">存放音频网络逻辑层相关的代码。音频数据逻辑上的发送，接收等代码。</td>\n</tr>\n<tr>\n<td>video</td>\n<td style=\"text-align:left\">存放视频逻辑层及视频引擎层的相关的代码。视频数据逻辑上的发送，接收等代码。视频引擎层就是指如何控制视频采集，处理和编解码操作的逻辑。</td>\n</tr>\n<tr>\n<td>voice_engine</td>\n<td style=\"text-align:left\">存放音频引擎代码。主要是控制音频的采集，处理，编解码的操作。<em>这个目录后面可能也会被拿掉。</em></td>\n</tr>\n<tr>\n<td>sdk</td>\n<td style=\"text-align:left\">存放了 Android 和 IOS 层代码。如视频的采集，渲染代码都在这里。</td>\n</tr>\n<tr>\n<td>pc</td>\n<td style=\"text-align:left\">存放一些业务逻辑层的代码。如 channel, session等。</td>\n</tr>\n<tr>\n<td>common_audio</td>\n<td style=\"text-align:left\">放一些音频的基本算法。包括环形队列，博利叶算法，滤波器等。</td>\n</tr>\n<tr>\n<td>common_video</td>\n<td style=\"text-align:left\">存放了视频算法相关的常用工具，如libyuv, sps/pps分析器，I420缓冲器等。</td>\n</tr>\n<tr>\n<td>modules</td>\n<td style=\"text-align:left\"><strong> 后面单独列举 </strong></td>\n</tr>\n<tr>\n<td>media</td>\n<td style=\"text-align:left\">存放媒体相关的代码。</td>\n</tr>\n<tr>\n<td>p2p</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td>rtc_base</td>\n<td style=\"text-align:left\">存放了一些基础代码。如线程，事件，socket等相关的代码。</td>\n</tr>\n<tr>\n<td>rtc_tools</td>\n<td style=\"text-align:left\">存放了一些工具代码。如视频帧比较，I420转RGB，视频帧分析。</td>\n</tr>\n<tr>\n<td>stats</td>\n<td style=\"text-align:left\">存放各种数据统计相关的类。</td>\n</tr>\n<tr>\n<td>libjingle</td>\n<td style=\"text-align:left\">网络库。</td>\n</tr>\n<tr>\n<td>system_wrapper</td>\n<td style=\"text-align:left\">与操作系统相关的代码，如 CPU特性，原子操作，读写锁，时钟等。</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em> Modules: </em></strong>  </p>\n<table>\n<thead>\n<tr>\n<th>Dir.</th>\n<th style=\"text-align:left\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>audio_coding</td>\n<td style=\"text-align:left\">音频编解码相关代码。</td>\n</tr>\n<tr>\n<td>audio_conference_mixer</td>\n<td style=\"text-align:left\">会议混音相关代码。</td>\n</tr>\n<tr>\n<td>audio_device</td>\n<td style=\"text-align:left\">音频采集与音频播放相关代码。</td>\n</tr>\n<tr>\n<td>audio_mixer</td>\n<td style=\"text-align:left\">混音相关代码，这部分是后加的。</td>\n</tr>\n<tr>\n<td>audio_processing</td>\n<td style=\"text-align:left\">音频前后处理的相关代码。</td>\n</tr>\n<tr>\n<td>bitrate_controller</td>\n<td style=\"text-align:left\">码率控制相关代码。</td>\n</tr>\n<tr>\n<td>congestion_controller</td>\n<td style=\"text-align:left\">流控相关的代码。</td>\n</tr>\n<tr>\n<td>desktop_capture</td>\n<td style=\"text-align:left\">桌面采集相关的代码。</td>\n</tr>\n<tr>\n<td>media_file</td>\n<td style=\"text-align:left\">播放媒体文件相关的代码。</td>\n</tr>\n<tr>\n<td>pacing</td>\n<td style=\"text-align:left\">码率探测相关的代码。</td>\n</tr>\n<tr>\n<td>remote_bitrate_estimator</td>\n<td style=\"text-align:left\">远端码率估算相关的代码。</td>\n</tr>\n<tr>\n<td>rtp_rtcp</td>\n<td style=\"text-align:left\">rtp/rtcp协议相关代码。</td>\n</tr>\n<tr>\n<td>video_capture</td>\n<td style=\"text-align:left\">视频采集相关的代码。</td>\n</tr>\n<tr>\n<td>video_coding</td>\n<td style=\"text-align:left\">视频编解码相关的代码。</td>\n</tr>\n<tr>\n<td>video_processing</td>\n<td style=\"text-align:left\">视频前后处理相关的代码。</td>\n</tr>\n</tbody>\n</table>"},{"title":"人性的弱点","date":"2019-09-05T12:03:35.000Z","_content":"\n来源于美国著名人际关系学大师，美国现代成人教育之父，西方现代人际关系教育的奠基人，被誉为是20世纪最伟大的心灵导师和成功学大师--[戴尔·卡耐基](https://baike.baidu.com/item/%E6%88%B4%E5%B0%94%C2%B7%E5%8D%A1%E8%80%90%E5%9F%BA/6896000?fromtitle=%E5%8D%A1%E8%80%90%E5%9F%BA&fromid=973060)\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D0%2C163%2C600%2C395%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=40cd7eaeb099a9012f7a017620a5264a/b219ebc4b74543a9dddb587616178a82b8011443.jpg)\n\n<!--more-->\n\n## 1. 与人相处\n\n### 1.1. 待人接物\n>我们面对的不是理性动物，而是情感动物，他们充满执念并为自尊和虚荣所驱动。\n\n让我们理解他人，而不是指责对方。努力弄清他们为什么这么做，这比批评更叫有益和诱人得多。\n\n__理解了一切，就能原谅一切。__\n\n本杰明.富兰克林：\n>成功秘诀何在？我只说自己知道每个人的优点!\n\n### 1.2. 说话方式\n\n我总是急于称赞，迟于挑刺儿。当我喜欢一点，就会给予<font color=red>真诚的嘉许</font>，我对赞扬从不吝啬。\n\n激发大伙儿的热情的能力，是我拥有最大的资源，我激活每个人的潜能的方式，就是 __欣赏和鼓励。__\n \n给予真诚的认可，毫不吝啬自己的赞扬。\n\n弗洛伊德:\n>每个人都渴望感觉自己很重要，对伟大的渴望。\n\n所以世界上唯一能影响他人的方法，就是谈论他们想要的东西，并告诉他们如何获得。\n\n人们不在意你，也不在意我。人们在意他们自己，早上在意，中午在意，晚饭后在意。和人们聊他们自己，他们会听几个小时都不烦。\n\n每个人都喜欢称赞，但表扬必须具体，否则就特别假，成了说好话哄骗人。\n\n<font color=red>没有人喜欢虚假，所有人都讨厌奉承</font>\n\n#### 1.2.1. 尊重对方观点\n尊重对方的观点，永远别说“你不对”。\n>很少有人特别理性，大部分人都带着偏见和成见，被先入为主的观念、猜疑、嫉妒和骄傲染色。\n\n#### 1.2.2. 出现争辩时\n- 主动承认自己的错误\n- 先说友善的话，在说其他的（改变氛围）\n- 关注双方重合的地方，避免说意见相左的部分（强调追求的是统一个目标，不同的是方法而不是目的）\n- 给建议，让对方自己得出结论（这比强制传递想法給他更让人深信不疑）\n\n能让对方说很多个“对”，开启了一个心理过程，导向正确的方向。\n\n回应一个“不”字，就增加了一堵难克服的墙。\n\n### 1.3. 交友\n不走心交不到朋友，要为别人做些需要时间和精力的、无私的、体贴的事。\n\n__一个人脸上的表情，比她背上的皮革要值钱得多。__ -- 一笑值千金\n\n以热情和高兴待人。\n\n如果你想让别人喜欢你，如果你想获得真的朋友：__真的喜欢别人,真诚。__\n\n#### 1.3.1 让人乐意服\n诉诸高尚的情操，假设他就是真诚的好人。可以改变人的意志。（这其实给予了他心理暗示，大部分情况下做出对你有利的反应）\n\n批评他人之前，不妨说说自己犯过的错，间接让他们注意到自己的错误。（拉近他人的距离，不招人狠。少用“但是/但”，用“而”，给予别人尊重）\n\n总是用建议，而不是命令（给人留够自由做事的空间，让他们自己去做，让他们从错误中学习）\n\n#### 1.3.2. 期望朋友帮忙\n给人一个无法抗拒、无法辜负的好评。\n“你也可以假定对方已经拥有了你想要激活的美德，并公开宣布，让他不要辜负自己的美名。”\n\n## 2. 自我内在\n### 2.1. 主动承认错误\n赢得争论的唯一方法就是避免争论。愚蠢的人则会努力寻找辩解的理由。\n\n承认自己错了，你就绝对不会遇到麻烦。这能熄灭争论，启发对手像你一样公平、开放、有气量。这会让他想承认，其实自己也难免犯错。\n\n### 2.2. 换角度思考\n努力从对方的视角看问题，要诚实。\n\n不要指责，试着理解他们。找到他的道理，明白他的行为甚至人格。","source":"_posts/人性的弱点.md","raw":"---\ntitle: 人性的弱点\ndate: 2019-09-05 20:03:35\ntags: bookmarks\ncategories: bookmarks\n---\n\n来源于美国著名人际关系学大师，美国现代成人教育之父，西方现代人际关系教育的奠基人，被誉为是20世纪最伟大的心灵导师和成功学大师--[戴尔·卡耐基](https://baike.baidu.com/item/%E6%88%B4%E5%B0%94%C2%B7%E5%8D%A1%E8%80%90%E5%9F%BA/6896000?fromtitle=%E5%8D%A1%E8%80%90%E5%9F%BA&fromid=973060)\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D0%2C163%2C600%2C395%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=40cd7eaeb099a9012f7a017620a5264a/b219ebc4b74543a9dddb587616178a82b8011443.jpg)\n\n<!--more-->\n\n## 1. 与人相处\n\n### 1.1. 待人接物\n>我们面对的不是理性动物，而是情感动物，他们充满执念并为自尊和虚荣所驱动。\n\n让我们理解他人，而不是指责对方。努力弄清他们为什么这么做，这比批评更叫有益和诱人得多。\n\n__理解了一切，就能原谅一切。__\n\n本杰明.富兰克林：\n>成功秘诀何在？我只说自己知道每个人的优点!\n\n### 1.2. 说话方式\n\n我总是急于称赞，迟于挑刺儿。当我喜欢一点，就会给予<font color=red>真诚的嘉许</font>，我对赞扬从不吝啬。\n\n激发大伙儿的热情的能力，是我拥有最大的资源，我激活每个人的潜能的方式，就是 __欣赏和鼓励。__\n \n给予真诚的认可，毫不吝啬自己的赞扬。\n\n弗洛伊德:\n>每个人都渴望感觉自己很重要，对伟大的渴望。\n\n所以世界上唯一能影响他人的方法，就是谈论他们想要的东西，并告诉他们如何获得。\n\n人们不在意你，也不在意我。人们在意他们自己，早上在意，中午在意，晚饭后在意。和人们聊他们自己，他们会听几个小时都不烦。\n\n每个人都喜欢称赞，但表扬必须具体，否则就特别假，成了说好话哄骗人。\n\n<font color=red>没有人喜欢虚假，所有人都讨厌奉承</font>\n\n#### 1.2.1. 尊重对方观点\n尊重对方的观点，永远别说“你不对”。\n>很少有人特别理性，大部分人都带着偏见和成见，被先入为主的观念、猜疑、嫉妒和骄傲染色。\n\n#### 1.2.2. 出现争辩时\n- 主动承认自己的错误\n- 先说友善的话，在说其他的（改变氛围）\n- 关注双方重合的地方，避免说意见相左的部分（强调追求的是统一个目标，不同的是方法而不是目的）\n- 给建议，让对方自己得出结论（这比强制传递想法給他更让人深信不疑）\n\n能让对方说很多个“对”，开启了一个心理过程，导向正确的方向。\n\n回应一个“不”字，就增加了一堵难克服的墙。\n\n### 1.3. 交友\n不走心交不到朋友，要为别人做些需要时间和精力的、无私的、体贴的事。\n\n__一个人脸上的表情，比她背上的皮革要值钱得多。__ -- 一笑值千金\n\n以热情和高兴待人。\n\n如果你想让别人喜欢你，如果你想获得真的朋友：__真的喜欢别人,真诚。__\n\n#### 1.3.1 让人乐意服\n诉诸高尚的情操，假设他就是真诚的好人。可以改变人的意志。（这其实给予了他心理暗示，大部分情况下做出对你有利的反应）\n\n批评他人之前，不妨说说自己犯过的错，间接让他们注意到自己的错误。（拉近他人的距离，不招人狠。少用“但是/但”，用“而”，给予别人尊重）\n\n总是用建议，而不是命令（给人留够自由做事的空间，让他们自己去做，让他们从错误中学习）\n\n#### 1.3.2. 期望朋友帮忙\n给人一个无法抗拒、无法辜负的好评。\n“你也可以假定对方已经拥有了你想要激活的美德，并公开宣布，让他不要辜负自己的美名。”\n\n## 2. 自我内在\n### 2.1. 主动承认错误\n赢得争论的唯一方法就是避免争论。愚蠢的人则会努力寻找辩解的理由。\n\n承认自己错了，你就绝对不会遇到麻烦。这能熄灭争论，启发对手像你一样公平、开放、有气量。这会让他想承认，其实自己也难免犯错。\n\n### 2.2. 换角度思考\n努力从对方的视角看问题，要诚实。\n\n不要指责，试着理解他们。找到他的道理，明白他的行为甚至人格。","slug":"人性的弱点","published":1,"updated":"2019-09-10T12:03:55.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0rb0045zkgr6u5l4k9m","content":"<p>来源于美国著名人际关系学大师，美国现代成人教育之父，西方现代人际关系教育的奠基人，被誉为是20世纪最伟大的心灵导师和成功学大师–<a href=\"https://baike.baidu.com/item/%E6%88%B4%E5%B0%94%C2%B7%E5%8D%A1%E8%80%90%E5%9F%BA/6896000?fromtitle=%E5%8D%A1%E8%80%90%E5%9F%BA&amp;fromid=973060\" target=\"_blank\" rel=\"noopener\">戴尔·卡耐基</a></p>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D0%2C163%2C600%2C395%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=40cd7eaeb099a9012f7a017620a5264a/b219ebc4b74543a9dddb587616178a82b8011443.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"1-与人相处\"><a href=\"#1-与人相处\" class=\"headerlink\" title=\"1. 与人相处\"></a>1. 与人相处</h2><h3 id=\"1-1-待人接物\"><a href=\"#1-1-待人接物\" class=\"headerlink\" title=\"1.1. 待人接物\"></a>1.1. 待人接物</h3><blockquote>\n<p>我们面对的不是理性动物，而是情感动物，他们充满执念并为自尊和虚荣所驱动。</p>\n</blockquote>\n<p>让我们理解他人，而不是指责对方。努力弄清他们为什么这么做，这比批评更叫有益和诱人得多。</p>\n<p><strong>理解了一切，就能原谅一切。</strong></p>\n<p>本杰明.富兰克林：</p>\n<blockquote>\n<p>成功秘诀何在？我只说自己知道每个人的优点!</p>\n</blockquote>\n<h3 id=\"1-2-说话方式\"><a href=\"#1-2-说话方式\" class=\"headerlink\" title=\"1.2. 说话方式\"></a>1.2. 说话方式</h3><p>我总是急于称赞，迟于挑刺儿。当我喜欢一点，就会给予<font color=\"red\">真诚的嘉许</font>，我对赞扬从不吝啬。</p>\n<p>激发大伙儿的热情的能力，是我拥有最大的资源，我激活每个人的潜能的方式，就是 <strong>欣赏和鼓励。</strong></p>\n<p>给予真诚的认可，毫不吝啬自己的赞扬。</p>\n<p>弗洛伊德:</p>\n<blockquote>\n<p>每个人都渴望感觉自己很重要，对伟大的渴望。</p>\n</blockquote>\n<p>所以世界上唯一能影响他人的方法，就是谈论他们想要的东西，并告诉他们如何获得。</p>\n<p>人们不在意你，也不在意我。人们在意他们自己，早上在意，中午在意，晚饭后在意。和人们聊他们自己，他们会听几个小时都不烦。</p>\n<p>每个人都喜欢称赞，但表扬必须具体，否则就特别假，成了说好话哄骗人。</p>\n<font color=\"red\">没有人喜欢虚假，所有人都讨厌奉承</font>\n\n<h4 id=\"1-2-1-尊重对方观点\"><a href=\"#1-2-1-尊重对方观点\" class=\"headerlink\" title=\"1.2.1. 尊重对方观点\"></a>1.2.1. 尊重对方观点</h4><p>尊重对方的观点，永远别说“你不对”。</p>\n<blockquote>\n<p>很少有人特别理性，大部分人都带着偏见和成见，被先入为主的观念、猜疑、嫉妒和骄傲染色。</p>\n</blockquote>\n<h4 id=\"1-2-2-出现争辩时\"><a href=\"#1-2-2-出现争辩时\" class=\"headerlink\" title=\"1.2.2. 出现争辩时\"></a>1.2.2. 出现争辩时</h4><ul>\n<li>主动承认自己的错误</li>\n<li>先说友善的话，在说其他的（改变氛围）</li>\n<li>关注双方重合的地方，避免说意见相左的部分（强调追求的是统一个目标，不同的是方法而不是目的）</li>\n<li>给建议，让对方自己得出结论（这比强制传递想法給他更让人深信不疑）</li>\n</ul>\n<p>能让对方说很多个“对”，开启了一个心理过程，导向正确的方向。</p>\n<p>回应一个“不”字，就增加了一堵难克服的墙。</p>\n<h3 id=\"1-3-交友\"><a href=\"#1-3-交友\" class=\"headerlink\" title=\"1.3. 交友\"></a>1.3. 交友</h3><p>不走心交不到朋友，要为别人做些需要时间和精力的、无私的、体贴的事。</p>\n<p><strong>一个人脸上的表情，比她背上的皮革要值钱得多。</strong> – 一笑值千金</p>\n<p>以热情和高兴待人。</p>\n<p>如果你想让别人喜欢你，如果你想获得真的朋友：<strong>真的喜欢别人,真诚。</strong></p>\n<h4 id=\"1-3-1-让人乐意服\"><a href=\"#1-3-1-让人乐意服\" class=\"headerlink\" title=\"1.3.1 让人乐意服\"></a>1.3.1 让人乐意服</h4><p>诉诸高尚的情操，假设他就是真诚的好人。可以改变人的意志。（这其实给予了他心理暗示，大部分情况下做出对你有利的反应）</p>\n<p>批评他人之前，不妨说说自己犯过的错，间接让他们注意到自己的错误。（拉近他人的距离，不招人狠。少用“但是/但”，用“而”，给予别人尊重）</p>\n<p>总是用建议，而不是命令（给人留够自由做事的空间，让他们自己去做，让他们从错误中学习）</p>\n<h4 id=\"1-3-2-期望朋友帮忙\"><a href=\"#1-3-2-期望朋友帮忙\" class=\"headerlink\" title=\"1.3.2. 期望朋友帮忙\"></a>1.3.2. 期望朋友帮忙</h4><p>给人一个无法抗拒、无法辜负的好评。<br>“你也可以假定对方已经拥有了你想要激活的美德，并公开宣布，让他不要辜负自己的美名。”</p>\n<h2 id=\"2-自我内在\"><a href=\"#2-自我内在\" class=\"headerlink\" title=\"2. 自我内在\"></a>2. 自我内在</h2><h3 id=\"2-1-主动承认错误\"><a href=\"#2-1-主动承认错误\" class=\"headerlink\" title=\"2.1. 主动承认错误\"></a>2.1. 主动承认错误</h3><p>赢得争论的唯一方法就是避免争论。愚蠢的人则会努力寻找辩解的理由。</p>\n<p>承认自己错了，你就绝对不会遇到麻烦。这能熄灭争论，启发对手像你一样公平、开放、有气量。这会让他想承认，其实自己也难免犯错。</p>\n<h3 id=\"2-2-换角度思考\"><a href=\"#2-2-换角度思考\" class=\"headerlink\" title=\"2.2. 换角度思考\"></a>2.2. 换角度思考</h3><p>努力从对方的视角看问题，要诚实。</p>\n<p>不要指责，试着理解他们。找到他的道理，明白他的行为甚至人格。</p>\n","site":{"data":{}},"excerpt":"<p>来源于美国著名人际关系学大师，美国现代成人教育之父，西方现代人际关系教育的奠基人，被誉为是20世纪最伟大的心灵导师和成功学大师–<a href=\"https://baike.baidu.com/item/%E6%88%B4%E5%B0%94%C2%B7%E5%8D%A1%E8%80%90%E5%9F%BA/6896000?fromtitle=%E5%8D%A1%E8%80%90%E5%9F%BA&amp;fromid=973060\" target=\"_blank\" rel=\"noopener\">戴尔·卡耐基</a></p>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D0%2C163%2C600%2C395%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=40cd7eaeb099a9012f7a017620a5264a/b219ebc4b74543a9dddb587616178a82b8011443.jpg\" alt=\"\"></p>","more":"<h2 id=\"1-与人相处\"><a href=\"#1-与人相处\" class=\"headerlink\" title=\"1. 与人相处\"></a>1. 与人相处</h2><h3 id=\"1-1-待人接物\"><a href=\"#1-1-待人接物\" class=\"headerlink\" title=\"1.1. 待人接物\"></a>1.1. 待人接物</h3><blockquote>\n<p>我们面对的不是理性动物，而是情感动物，他们充满执念并为自尊和虚荣所驱动。</p>\n</blockquote>\n<p>让我们理解他人，而不是指责对方。努力弄清他们为什么这么做，这比批评更叫有益和诱人得多。</p>\n<p><strong>理解了一切，就能原谅一切。</strong></p>\n<p>本杰明.富兰克林：</p>\n<blockquote>\n<p>成功秘诀何在？我只说自己知道每个人的优点!</p>\n</blockquote>\n<h3 id=\"1-2-说话方式\"><a href=\"#1-2-说话方式\" class=\"headerlink\" title=\"1.2. 说话方式\"></a>1.2. 说话方式</h3><p>我总是急于称赞，迟于挑刺儿。当我喜欢一点，就会给予<font color=\"red\">真诚的嘉许</font>，我对赞扬从不吝啬。</p>\n<p>激发大伙儿的热情的能力，是我拥有最大的资源，我激活每个人的潜能的方式，就是 <strong>欣赏和鼓励。</strong></p>\n<p>给予真诚的认可，毫不吝啬自己的赞扬。</p>\n<p>弗洛伊德:</p>\n<blockquote>\n<p>每个人都渴望感觉自己很重要，对伟大的渴望。</p>\n</blockquote>\n<p>所以世界上唯一能影响他人的方法，就是谈论他们想要的东西，并告诉他们如何获得。</p>\n<p>人们不在意你，也不在意我。人们在意他们自己，早上在意，中午在意，晚饭后在意。和人们聊他们自己，他们会听几个小时都不烦。</p>\n<p>每个人都喜欢称赞，但表扬必须具体，否则就特别假，成了说好话哄骗人。</p>\n<font color=\"red\">没有人喜欢虚假，所有人都讨厌奉承</font>\n\n<h4 id=\"1-2-1-尊重对方观点\"><a href=\"#1-2-1-尊重对方观点\" class=\"headerlink\" title=\"1.2.1. 尊重对方观点\"></a>1.2.1. 尊重对方观点</h4><p>尊重对方的观点，永远别说“你不对”。</p>\n<blockquote>\n<p>很少有人特别理性，大部分人都带着偏见和成见，被先入为主的观念、猜疑、嫉妒和骄傲染色。</p>\n</blockquote>\n<h4 id=\"1-2-2-出现争辩时\"><a href=\"#1-2-2-出现争辩时\" class=\"headerlink\" title=\"1.2.2. 出现争辩时\"></a>1.2.2. 出现争辩时</h4><ul>\n<li>主动承认自己的错误</li>\n<li>先说友善的话，在说其他的（改变氛围）</li>\n<li>关注双方重合的地方，避免说意见相左的部分（强调追求的是统一个目标，不同的是方法而不是目的）</li>\n<li>给建议，让对方自己得出结论（这比强制传递想法給他更让人深信不疑）</li>\n</ul>\n<p>能让对方说很多个“对”，开启了一个心理过程，导向正确的方向。</p>\n<p>回应一个“不”字，就增加了一堵难克服的墙。</p>\n<h3 id=\"1-3-交友\"><a href=\"#1-3-交友\" class=\"headerlink\" title=\"1.3. 交友\"></a>1.3. 交友</h3><p>不走心交不到朋友，要为别人做些需要时间和精力的、无私的、体贴的事。</p>\n<p><strong>一个人脸上的表情，比她背上的皮革要值钱得多。</strong> – 一笑值千金</p>\n<p>以热情和高兴待人。</p>\n<p>如果你想让别人喜欢你，如果你想获得真的朋友：<strong>真的喜欢别人,真诚。</strong></p>\n<h4 id=\"1-3-1-让人乐意服\"><a href=\"#1-3-1-让人乐意服\" class=\"headerlink\" title=\"1.3.1 让人乐意服\"></a>1.3.1 让人乐意服</h4><p>诉诸高尚的情操，假设他就是真诚的好人。可以改变人的意志。（这其实给予了他心理暗示，大部分情况下做出对你有利的反应）</p>\n<p>批评他人之前，不妨说说自己犯过的错，间接让他们注意到自己的错误。（拉近他人的距离，不招人狠。少用“但是/但”，用“而”，给予别人尊重）</p>\n<p>总是用建议，而不是命令（给人留够自由做事的空间，让他们自己去做，让他们从错误中学习）</p>\n<h4 id=\"1-3-2-期望朋友帮忙\"><a href=\"#1-3-2-期望朋友帮忙\" class=\"headerlink\" title=\"1.3.2. 期望朋友帮忙\"></a>1.3.2. 期望朋友帮忙</h4><p>给人一个无法抗拒、无法辜负的好评。<br>“你也可以假定对方已经拥有了你想要激活的美德，并公开宣布，让他不要辜负自己的美名。”</p>\n<h2 id=\"2-自我内在\"><a href=\"#2-自我内在\" class=\"headerlink\" title=\"2. 自我内在\"></a>2. 自我内在</h2><h3 id=\"2-1-主动承认错误\"><a href=\"#2-1-主动承认错误\" class=\"headerlink\" title=\"2.1. 主动承认错误\"></a>2.1. 主动承认错误</h3><p>赢得争论的唯一方法就是避免争论。愚蠢的人则会努力寻找辩解的理由。</p>\n<p>承认自己错了，你就绝对不会遇到麻烦。这能熄灭争论，启发对手像你一样公平、开放、有气量。这会让他想承认，其实自己也难免犯错。</p>\n<h3 id=\"2-2-换角度思考\"><a href=\"#2-2-换角度思考\" class=\"headerlink\" title=\"2.2. 换角度思考\"></a>2.2. 换角度思考</h3><p>努力从对方的视角看问题，要诚实。</p>\n<p>不要指责，试着理解他们。找到他的道理，明白他的行为甚至人格。</p>"},{"title":"买车记录","date":"2018-05-08T14:55:25.000Z","_content":"\n# 买车过程记录\n\n### 1. 选车\n\n**观念** \n\n不尽信，论坛与个人等，参数为王。\n\n**目的** \n\n不同车系，或者不同的车辆都有各自的定位与特定。常见的有：\n\n- 性能性： 讲究操作性，动力\n- 家居性：空间，省油与保养方面\n- 商务性：big, bigger and bigger\n- 土豪性：暂不谈~~\n\n个人的考虑主要是家用，偏向于考虑空间与保养，省油方面，当然还要有必要的安全性。另外，考虑在城市中行驶和之后另一半使用车辆，尽量考虑自动挡车辆。\n\n<!-- more -->\n\n**选车**\n\n货比三家，多跑几家4s店，试驾不同车系（美系，韩系，日系，德系等），以及同一车系中同价位的车辆，如朗逸与宝来，卡罗拉与雷凌等。\n\n来自38号车评中心的视频：\n\n[购车诉求概念一](http://v.youku.com/v_show/id_XNzE5MjQ0Mzgw.html?spm=a2hzp.8249370.0.0)\n\n[购车诉求概念二](http://v.youku.com/v_show/id_XNzI3Njc5Mzky.html?spm=a2hzp.8249370.0.0)\n\n[选车如何看品牌](http://v.youku.com/v_show/id_XNzIxMTYzODY4.html?spm=a2hzp.8249370.0.0)\n\n[选车试车购车正确流程](http://v.youku.com/v_show/id_XNzMzODA2NTQw.html?spm=a2hzp.8249370.0.0)\n\n---\n\n### 2. 试车\n\n**空间**\n\n试驾不同车辆时，将前排调整为自己适合的开车习惯再看后排的空间表现。这是避免对比不统一。另外，空间包括：\n\n- 前排的左右及头部空间，储物格等\n\n- 后排的腿部空间，特别是头部空间，有很多车辆使用溜背造型\n\n- 后备箱的平整度，后排能否放倒（虽然用的不多，可以放倒总是更好些）\n\n**舒适度**\n\n座椅的舒适度，包裹性，这些决定了在开长途时的疲劳程度。\n\n试驾时，建议先试坐后排，试驾再前排，车辆的前后排的悬架可能不同。悬架可以通过减速带与凹凸路面，或者急刹车与转弯时能体现。\n\n**试驾关注点**\n\n`档位`\n\n换挡的平顺性，主要是加速与收油时的表现。总结为：\n\n- 稳：加速，收油低速平顺性\n\n- 准：加减，转速准确，没有动力粘滞\n\n- 狠：换挡快，没有空转\n\n`转向`\n\n主要是悬架的调校，以及回正度（助力）\n\n`油门，刹车`\n\n行程是否都有用（深踩），有些车辆的油门与刹车都只是前半段比较灵敏，后半段效果不同。例如，有些小排量油门前半段都有点窜，他是为了营造一种有动力的假象。\n\n`转速表`\n\n转速表不一定准，需要自己感受。另外，车辆的油耗显示也不一定准确，自己使用油枪或者APP计算。\n\n![](http://cdn.xiaoxiongyouhao.com/assets/images/logo.png)\n\n[小熊油耗排行](https://www.xiaoxiongyouhao.com/page_rank_chexi.php)\n\n---\n\n### 3. 砍价技巧与购买时间\n\n** 购买时间 **\n\n根据我们的初步参数比较，试驾对比，我们基本能确定2~3辆想买的。接下来，就看每个车最终的落地价了。\n\n购买时间，参考网上的说法是：3-5月，7-9月。当然还有车展期间优惠幅度也比较大。2018年4月，韩系受萨德的影响，车辆的最终优惠大致可以达到2.3万，并没有优惠很多，只是厂家回访了2次，服务态度比较好，并不好抄底啊^_^!。\n\n> 购买车辆，千万不要着急与冲动，能稳得住，汽拖之家的车系论坛还是真有些拖存在。\n\n** 砍价 **\n\n`落地价 = 裸车价 + 购置税 + 保险`\n\n注意：\n\n- 裸车价越便宜，购置税与保险也要重新计算，要尽量杀裸车价\n\n- 不要在4S 店加装，尽量要求赠送，加装的东西如皮座4S 店都会外包给外面的装饰店搞定 \n\n| **序号** | **步骤** | **说明**                                                                                       |\n| ------ | ------ | -------------------------------------------------------------------------------------------- |\n| 1      | 诚意     | 更能表现出**购买欲**，销售才会透露低价给你。<br> **提醒**：关于寻找谈判的销售人员，请选择男性，男人一般容易冲动，爽快                            |\n| 2      | 销售底价   | 不要暴露自己的低价。4S店组织一般为三级：`销售、科长（主管）、经理`。                                                         |\n| 3      | 上级底价   | 谈价时销售员问你是不是今天就买或者能付定金，要是可以的话他去请示下领导，给你个最低价。<br>这个时候你还是不要说出你的心理价，但你可以告诉他，要是价格合适可以交定金，让他去请示领导。 |\n| 4      | 同伴作用   | 销售请示的低价还是有所保留的，同伴红黑脸作用得到上级真正底价                                                               |\n| 5      | 赠送     | 千万不要将砍价也要赠品混在一起谈，这要肯定会分散注意力。一个字：磨。<br>磨赠品的时候，需要注意的就是别光看数量，要注重质量。                             |\n| 6      | 心态     | 买卖交易，讲究个缘分，实在谈不拢也别争个脸红脖子粗的，要保持风度                                                             |\n\n[经典砍价--百度知道](https://zhidao.baidu.com/question/524012738221021205.html?qbl=relate_question_0&word=%B3%C9%B6%BC%20%B9%BA%B3%B5%CA%B1%BC%E4%20%D3%C5%BB%DD)\n\n*TIPS:*\n\n> 在汽车之家与论坛上，我们往往能找到某一款车的最低价格，我们可以参考得出自己心里的价格。\n\n---\n\n### 4. 自己试驾记录表格\n\n下表是我试驾过或者看过的车辆\n\n| 车系  | 车款                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 空间           | 操作  | 底盘   | 变速箱         | 动力         | 其他                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------ | --- | ---- | ----------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 德系  | 朗逸（2017款1.6自舒）                                                                                                                                                                                                                                                                                                                                                                                                        | 中上           | 好   | 完整度高 | 有滞缓         | 1.6 动力弱    | 中配就已经11.8万多了                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| 韩系  | 领动（2016款1.6自精）                                                                                                                                                                                                                                                                                                                                                                                                        | 后排溜背导致头部空间不行 | 好   | 悬架偏硬 | 好，有点迟滞不会很明显 | 动力够        | 1.6L的发动机是2014 沃德十佳，变速箱也是自家的摩比斯，油耗表现优异。<br>后防撞梁居然是玻璃钢！[百度 领动 后防撞梁](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=monline_4_dg&wd=%E9%A2%86%E5%8A%A8%20%E5%90%8E%E9%98%B2%E6%92%9E%E6%A2%81%20%E7%8E%BB%E7%92%83&oq=%25E9%25A2%2586%25E5%258A%25A8%2520%25E5%2590%258E%25E9%2598%25B2%25E6%2592%259E%25E6%25A2%2581&rsv_pq=9ac8441b0004242a&rsv_t=4beaP6FxpPEI26yNqP48zmG5vR635nlh4%2BodmhhLFiBzPFLDPWF%2Fd6VLY9A3cnuGCjC0&rqlang=cn&rsv_enter=1&rsv_sug3=10&rsv_sug1=12&rsv_sug7=100&rsv_sug2=0&inputT=3636&rsv_sug4=4074) |\n| 法系  | 标致308（2018款1.6自豪） <br>C4世嘉（2018款1.6自豪）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 小            | 未注意 | 好    | 感觉比朗逸好      | 不连顺        | 试驾了1.2T 的C4世嘉，动力严重不连贯。<br> 308 从16款到18款直接简配                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| 日系  | 昂克赛拉（2017款1.5自舒） <br> 轩逸<br> 卡罗拉 <br>  雷凌（2017改款1.2T） | 优秀           | 一般  | 一般   | 顺畅CVT 缘故    | 1.2T动力还是有劲 | 只试驾了雷凌。昂克赛拉后排空间小点，优惠只有8千，不要装饰1.2万。<br> 轩逸感觉价格对标雷凌有点小贵，动力偏弱一点（自吸），但是座椅绝对是最舒服的。<br> 卡罗拉优惠也只有1.2万样子，销售太傲气不想多讲。                                                                                                                                                                                                                                                                                                                                                                                                                  |\n\n### 5. SSSS常见销售技巧\n\n**增加配置**\n\n厂家并没有此配置，4S自己加装。自己遇到的情况是：雷凌17款自精，增加倒车影像、右侧转向影像、胎压、日间行车灯、座椅仿皮。原厂自精指导价12.68万，但是增配的版本价格就提升到13.38万。这中间贵了7K去买这些东西，销售说是优惠2万\n\n\n**巧设收费名目**\n\n这在询问C4世嘉时遇到，当时报的裸车价比较低，优惠比较大。但是，....\n他GRD 有：出库费2K，贷款手续费要3~4K，检测费等，简直就是LG。\n\n---\n\n### 6. 结果\n最终购买了雷凌（2017改款185T）\n![](https://car2.autoimg.cn/cardfs/product/g15/M0E/BF/3F/1024x0_1_q87_autohomecar__wKgH1lkxHnyAZO_-AAg2uaPgZ6M981.jpg)\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=46311ef712d8bc3ed2050e98e3e2cd7b/8694a4c27d1ed21b24448528a66eddc450da3f69.jpg)\n\n| 项目 | 说明 |\n| --- | --- |\n| 价格 | 大约12.2万 |\n| 裸车价 | 10.58万（指导价12.68万，优惠2.1万）|\n| 购置税 | 9.6K左右 |\n| 赠送 | 脚垫、车窗膜、倒车影像、右车转弯影像、胎压 |\n| 其他 | 在途虎养车上买了坐垫与360行车记录仪大概花了750块 |\n\n---\n### 参考\n\n[38号车评中心](http://i.youku.com/i/UMTUxMTg3NjU0MA==/navcustom?spm=a2hzp.8249370.0.0&id=760665&order=2&page=6&last_item=&last_pn=1&last_vid=404420941)\n\n[车评人郑刚](http://i.youku.com/i/UMTQ2NTYxNDI4OA==?spm=a2h0j.11185381.module_basic_dayu_sub.DL~DD~H2~A)\n","source":"_posts/买车记录.md","raw":"---\ntitle: 买车记录\ndate: 2018-05-08 22:55:25\ntags: life\ncategories: life\n---\n\n# 买车过程记录\n\n### 1. 选车\n\n**观念** \n\n不尽信，论坛与个人等，参数为王。\n\n**目的** \n\n不同车系，或者不同的车辆都有各自的定位与特定。常见的有：\n\n- 性能性： 讲究操作性，动力\n- 家居性：空间，省油与保养方面\n- 商务性：big, bigger and bigger\n- 土豪性：暂不谈~~\n\n个人的考虑主要是家用，偏向于考虑空间与保养，省油方面，当然还要有必要的安全性。另外，考虑在城市中行驶和之后另一半使用车辆，尽量考虑自动挡车辆。\n\n<!-- more -->\n\n**选车**\n\n货比三家，多跑几家4s店，试驾不同车系（美系，韩系，日系，德系等），以及同一车系中同价位的车辆，如朗逸与宝来，卡罗拉与雷凌等。\n\n来自38号车评中心的视频：\n\n[购车诉求概念一](http://v.youku.com/v_show/id_XNzE5MjQ0Mzgw.html?spm=a2hzp.8249370.0.0)\n\n[购车诉求概念二](http://v.youku.com/v_show/id_XNzI3Njc5Mzky.html?spm=a2hzp.8249370.0.0)\n\n[选车如何看品牌](http://v.youku.com/v_show/id_XNzIxMTYzODY4.html?spm=a2hzp.8249370.0.0)\n\n[选车试车购车正确流程](http://v.youku.com/v_show/id_XNzMzODA2NTQw.html?spm=a2hzp.8249370.0.0)\n\n---\n\n### 2. 试车\n\n**空间**\n\n试驾不同车辆时，将前排调整为自己适合的开车习惯再看后排的空间表现。这是避免对比不统一。另外，空间包括：\n\n- 前排的左右及头部空间，储物格等\n\n- 后排的腿部空间，特别是头部空间，有很多车辆使用溜背造型\n\n- 后备箱的平整度，后排能否放倒（虽然用的不多，可以放倒总是更好些）\n\n**舒适度**\n\n座椅的舒适度，包裹性，这些决定了在开长途时的疲劳程度。\n\n试驾时，建议先试坐后排，试驾再前排，车辆的前后排的悬架可能不同。悬架可以通过减速带与凹凸路面，或者急刹车与转弯时能体现。\n\n**试驾关注点**\n\n`档位`\n\n换挡的平顺性，主要是加速与收油时的表现。总结为：\n\n- 稳：加速，收油低速平顺性\n\n- 准：加减，转速准确，没有动力粘滞\n\n- 狠：换挡快，没有空转\n\n`转向`\n\n主要是悬架的调校，以及回正度（助力）\n\n`油门，刹车`\n\n行程是否都有用（深踩），有些车辆的油门与刹车都只是前半段比较灵敏，后半段效果不同。例如，有些小排量油门前半段都有点窜，他是为了营造一种有动力的假象。\n\n`转速表`\n\n转速表不一定准，需要自己感受。另外，车辆的油耗显示也不一定准确，自己使用油枪或者APP计算。\n\n![](http://cdn.xiaoxiongyouhao.com/assets/images/logo.png)\n\n[小熊油耗排行](https://www.xiaoxiongyouhao.com/page_rank_chexi.php)\n\n---\n\n### 3. 砍价技巧与购买时间\n\n** 购买时间 **\n\n根据我们的初步参数比较，试驾对比，我们基本能确定2~3辆想买的。接下来，就看每个车最终的落地价了。\n\n购买时间，参考网上的说法是：3-5月，7-9月。当然还有车展期间优惠幅度也比较大。2018年4月，韩系受萨德的影响，车辆的最终优惠大致可以达到2.3万，并没有优惠很多，只是厂家回访了2次，服务态度比较好，并不好抄底啊^_^!。\n\n> 购买车辆，千万不要着急与冲动，能稳得住，汽拖之家的车系论坛还是真有些拖存在。\n\n** 砍价 **\n\n`落地价 = 裸车价 + 购置税 + 保险`\n\n注意：\n\n- 裸车价越便宜，购置税与保险也要重新计算，要尽量杀裸车价\n\n- 不要在4S 店加装，尽量要求赠送，加装的东西如皮座4S 店都会外包给外面的装饰店搞定 \n\n| **序号** | **步骤** | **说明**                                                                                       |\n| ------ | ------ | -------------------------------------------------------------------------------------------- |\n| 1      | 诚意     | 更能表现出**购买欲**，销售才会透露低价给你。<br> **提醒**：关于寻找谈判的销售人员，请选择男性，男人一般容易冲动，爽快                            |\n| 2      | 销售底价   | 不要暴露自己的低价。4S店组织一般为三级：`销售、科长（主管）、经理`。                                                         |\n| 3      | 上级底价   | 谈价时销售员问你是不是今天就买或者能付定金，要是可以的话他去请示下领导，给你个最低价。<br>这个时候你还是不要说出你的心理价，但你可以告诉他，要是价格合适可以交定金，让他去请示领导。 |\n| 4      | 同伴作用   | 销售请示的低价还是有所保留的，同伴红黑脸作用得到上级真正底价                                                               |\n| 5      | 赠送     | 千万不要将砍价也要赠品混在一起谈，这要肯定会分散注意力。一个字：磨。<br>磨赠品的时候，需要注意的就是别光看数量，要注重质量。                             |\n| 6      | 心态     | 买卖交易，讲究个缘分，实在谈不拢也别争个脸红脖子粗的，要保持风度                                                             |\n\n[经典砍价--百度知道](https://zhidao.baidu.com/question/524012738221021205.html?qbl=relate_question_0&word=%B3%C9%B6%BC%20%B9%BA%B3%B5%CA%B1%BC%E4%20%D3%C5%BB%DD)\n\n*TIPS:*\n\n> 在汽车之家与论坛上，我们往往能找到某一款车的最低价格，我们可以参考得出自己心里的价格。\n\n---\n\n### 4. 自己试驾记录表格\n\n下表是我试驾过或者看过的车辆\n\n| 车系  | 车款                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 空间           | 操作  | 底盘   | 变速箱         | 动力         | 其他                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------ | --- | ---- | ----------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 德系  | 朗逸（2017款1.6自舒）                                                                                                                                                                                                                                                                                                                                                                                                        | 中上           | 好   | 完整度高 | 有滞缓         | 1.6 动力弱    | 中配就已经11.8万多了                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| 韩系  | 领动（2016款1.6自精）                                                                                                                                                                                                                                                                                                                                                                                                        | 后排溜背导致头部空间不行 | 好   | 悬架偏硬 | 好，有点迟滞不会很明显 | 动力够        | 1.6L的发动机是2014 沃德十佳，变速箱也是自家的摩比斯，油耗表现优异。<br>后防撞梁居然是玻璃钢！[百度 领动 后防撞梁](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=monline_4_dg&wd=%E9%A2%86%E5%8A%A8%20%E5%90%8E%E9%98%B2%E6%92%9E%E6%A2%81%20%E7%8E%BB%E7%92%83&oq=%25E9%25A2%2586%25E5%258A%25A8%2520%25E5%2590%258E%25E9%2598%25B2%25E6%2592%259E%25E6%25A2%2581&rsv_pq=9ac8441b0004242a&rsv_t=4beaP6FxpPEI26yNqP48zmG5vR635nlh4%2BodmhhLFiBzPFLDPWF%2Fd6VLY9A3cnuGCjC0&rqlang=cn&rsv_enter=1&rsv_sug3=10&rsv_sug1=12&rsv_sug7=100&rsv_sug2=0&inputT=3636&rsv_sug4=4074) |\n| 法系  | 标致308（2018款1.6自豪） <br>C4世嘉（2018款1.6自豪）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 小            | 未注意 | 好    | 感觉比朗逸好      | 不连顺        | 试驾了1.2T 的C4世嘉，动力严重不连贯。<br> 308 从16款到18款直接简配                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| 日系  | 昂克赛拉（2017款1.5自舒） <br> 轩逸<br> 卡罗拉 <br>  雷凌（2017改款1.2T） | 优秀           | 一般  | 一般   | 顺畅CVT 缘故    | 1.2T动力还是有劲 | 只试驾了雷凌。昂克赛拉后排空间小点，优惠只有8千，不要装饰1.2万。<br> 轩逸感觉价格对标雷凌有点小贵，动力偏弱一点（自吸），但是座椅绝对是最舒服的。<br> 卡罗拉优惠也只有1.2万样子，销售太傲气不想多讲。                                                                                                                                                                                                                                                                                                                                                                                                                  |\n\n### 5. SSSS常见销售技巧\n\n**增加配置**\n\n厂家并没有此配置，4S自己加装。自己遇到的情况是：雷凌17款自精，增加倒车影像、右侧转向影像、胎压、日间行车灯、座椅仿皮。原厂自精指导价12.68万，但是增配的版本价格就提升到13.38万。这中间贵了7K去买这些东西，销售说是优惠2万\n\n\n**巧设收费名目**\n\n这在询问C4世嘉时遇到，当时报的裸车价比较低，优惠比较大。但是，....\n他GRD 有：出库费2K，贷款手续费要3~4K，检测费等，简直就是LG。\n\n---\n\n### 6. 结果\n最终购买了雷凌（2017改款185T）\n![](https://car2.autoimg.cn/cardfs/product/g15/M0E/BF/3F/1024x0_1_q87_autohomecar__wKgH1lkxHnyAZO_-AAg2uaPgZ6M981.jpg)\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=46311ef712d8bc3ed2050e98e3e2cd7b/8694a4c27d1ed21b24448528a66eddc450da3f69.jpg)\n\n| 项目 | 说明 |\n| --- | --- |\n| 价格 | 大约12.2万 |\n| 裸车价 | 10.58万（指导价12.68万，优惠2.1万）|\n| 购置税 | 9.6K左右 |\n| 赠送 | 脚垫、车窗膜、倒车影像、右车转弯影像、胎压 |\n| 其他 | 在途虎养车上买了坐垫与360行车记录仪大概花了750块 |\n\n---\n### 参考\n\n[38号车评中心](http://i.youku.com/i/UMTUxMTg3NjU0MA==/navcustom?spm=a2hzp.8249370.0.0&id=760665&order=2&page=6&last_item=&last_pn=1&last_vid=404420941)\n\n[车评人郑刚](http://i.youku.com/i/UMTQ2NTYxNDI4OA==?spm=a2h0j.11185381.module_basic_dayu_sub.DL~DD~H2~A)\n","slug":"买车记录","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0rd004azkgra5v900he","content":"<h1 id=\"买车过程记录\"><a href=\"#买车过程记录\" class=\"headerlink\" title=\"买车过程记录\"></a>买车过程记录</h1><h3 id=\"1-选车\"><a href=\"#1-选车\" class=\"headerlink\" title=\"1. 选车\"></a>1. 选车</h3><p><strong>观念</strong> </p>\n<p>不尽信，论坛与个人等，参数为王。</p>\n<p><strong>目的</strong> </p>\n<p>不同车系，或者不同的车辆都有各自的定位与特定。常见的有：</p>\n<ul>\n<li>性能性： 讲究操作性，动力</li>\n<li>家居性：空间，省油与保养方面</li>\n<li>商务性：big, bigger and bigger</li>\n<li>土豪性：暂不谈~~</li>\n</ul>\n<p>个人的考虑主要是家用，偏向于考虑空间与保养，省油方面，当然还要有必要的安全性。另外，考虑在城市中行驶和之后另一半使用车辆，尽量考虑自动挡车辆。</p>\n<a id=\"more\"></a>\n<p><strong>选车</strong></p>\n<p>货比三家，多跑几家4s店，试驾不同车系（美系，韩系，日系，德系等），以及同一车系中同价位的车辆，如朗逸与宝来，卡罗拉与雷凌等。</p>\n<p>来自38号车评中心的视频：</p>\n<p><a href=\"http://v.youku.com/v_show/id_XNzE5MjQ0Mzgw.html?spm=a2hzp.8249370.0.0\" target=\"_blank\" rel=\"noopener\">购车诉求概念一</a></p>\n<p><a href=\"http://v.youku.com/v_show/id_XNzI3Njc5Mzky.html?spm=a2hzp.8249370.0.0\" target=\"_blank\" rel=\"noopener\">购车诉求概念二</a></p>\n<p><a href=\"http://v.youku.com/v_show/id_XNzIxMTYzODY4.html?spm=a2hzp.8249370.0.0\" target=\"_blank\" rel=\"noopener\">选车如何看品牌</a></p>\n<p><a href=\"http://v.youku.com/v_show/id_XNzMzODA2NTQw.html?spm=a2hzp.8249370.0.0\" target=\"_blank\" rel=\"noopener\">选车试车购车正确流程</a></p>\n<hr>\n<h3 id=\"2-试车\"><a href=\"#2-试车\" class=\"headerlink\" title=\"2. 试车\"></a>2. 试车</h3><p><strong>空间</strong></p>\n<p>试驾不同车辆时，将前排调整为自己适合的开车习惯再看后排的空间表现。这是避免对比不统一。另外，空间包括：</p>\n<ul>\n<li><p>前排的左右及头部空间，储物格等</p>\n</li>\n<li><p>后排的腿部空间，特别是头部空间，有很多车辆使用溜背造型</p>\n</li>\n<li><p>后备箱的平整度，后排能否放倒（虽然用的不多，可以放倒总是更好些）</p>\n</li>\n</ul>\n<p><strong>舒适度</strong></p>\n<p>座椅的舒适度，包裹性，这些决定了在开长途时的疲劳程度。</p>\n<p>试驾时，建议先试坐后排，试驾再前排，车辆的前后排的悬架可能不同。悬架可以通过减速带与凹凸路面，或者急刹车与转弯时能体现。</p>\n<p><strong>试驾关注点</strong></p>\n<p><code>档位</code></p>\n<p>换挡的平顺性，主要是加速与收油时的表现。总结为：</p>\n<ul>\n<li><p>稳：加速，收油低速平顺性</p>\n</li>\n<li><p>准：加减，转速准确，没有动力粘滞</p>\n</li>\n<li><p>狠：换挡快，没有空转</p>\n</li>\n</ul>\n<p><code>转向</code></p>\n<p>主要是悬架的调校，以及回正度（助力）</p>\n<p><code>油门，刹车</code></p>\n<p>行程是否都有用（深踩），有些车辆的油门与刹车都只是前半段比较灵敏，后半段效果不同。例如，有些小排量油门前半段都有点窜，他是为了营造一种有动力的假象。</p>\n<p><code>转速表</code></p>\n<p>转速表不一定准，需要自己感受。另外，车辆的油耗显示也不一定准确，自己使用油枪或者APP计算。</p>\n<p><img src=\"http://cdn.xiaoxiongyouhao.com/assets/images/logo.png\" alt=\"\"></p>\n<p><a href=\"https://www.xiaoxiongyouhao.com/page_rank_chexi.php\" target=\"_blank\" rel=\"noopener\">小熊油耗排行</a></p>\n<hr>\n<h3 id=\"3-砍价技巧与购买时间\"><a href=\"#3-砍价技巧与购买时间\" class=\"headerlink\" title=\"3. 砍价技巧与购买时间\"></a>3. 砍价技巧与购买时间</h3><p><strong> 购买时间 </strong></p>\n<p>根据我们的初步参数比较，试驾对比，我们基本能确定2~3辆想买的。接下来，就看每个车最终的落地价了。</p>\n<p>购买时间，参考网上的说法是：3-5月，7-9月。当然还有车展期间优惠幅度也比较大。2018年4月，韩系受萨德的影响，车辆的最终优惠大致可以达到2.3万，并没有优惠很多，只是厂家回访了2次，服务态度比较好，并不好抄底啊^_^!。</p>\n<blockquote>\n<p>购买车辆，千万不要着急与冲动，能稳得住，汽拖之家的车系论坛还是真有些拖存在。</p>\n</blockquote>\n<p><strong> 砍价 </strong></p>\n<p><code>落地价 = 裸车价 + 购置税 + 保险</code></p>\n<p>注意：</p>\n<ul>\n<li><p>裸车价越便宜，购置税与保险也要重新计算，要尽量杀裸车价</p>\n</li>\n<li><p>不要在4S 店加装，尽量要求赠送，加装的东西如皮座4S 店都会外包给外面的装饰店搞定 </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>序号</strong></th>\n<th><strong>步骤</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>诚意</td>\n<td>更能表现出<strong>购买欲</strong>，销售才会透露低价给你。<br> <strong>提醒</strong>：关于寻找谈判的销售人员，请选择男性，男人一般容易冲动，爽快</td>\n</tr>\n<tr>\n<td>2</td>\n<td>销售底价</td>\n<td>不要暴露自己的低价。4S店组织一般为三级：<code>销售、科长（主管）、经理</code>。</td>\n</tr>\n<tr>\n<td>3</td>\n<td>上级底价</td>\n<td>谈价时销售员问你是不是今天就买或者能付定金，要是可以的话他去请示下领导，给你个最低价。<br>这个时候你还是不要说出你的心理价，但你可以告诉他，要是价格合适可以交定金，让他去请示领导。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>同伴作用</td>\n<td>销售请示的低价还是有所保留的，同伴红黑脸作用得到上级真正底价</td>\n</tr>\n<tr>\n<td>5</td>\n<td>赠送</td>\n<td>千万不要将砍价也要赠品混在一起谈，这要肯定会分散注意力。一个字：磨。<br>磨赠品的时候，需要注意的就是别光看数量，要注重质量。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>心态</td>\n<td>买卖交易，讲究个缘分，实在谈不拢也别争个脸红脖子粗的，要保持风度</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://zhidao.baidu.com/question/524012738221021205.html?qbl=relate_question_0&amp;word=%B3%C9%B6%BC%20%B9%BA%B3%B5%CA%B1%BC%E4%20%D3%C5%BB%DD\" target=\"_blank\" rel=\"noopener\">经典砍价–百度知道</a></p>\n<p><em>TIPS:</em></p>\n<blockquote>\n<p>在汽车之家与论坛上，我们往往能找到某一款车的最低价格，我们可以参考得出自己心里的价格。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-自己试驾记录表格\"><a href=\"#4-自己试驾记录表格\" class=\"headerlink\" title=\"4. 自己试驾记录表格\"></a>4. 自己试驾记录表格</h3><p>下表是我试驾过或者看过的车辆</p>\n<table>\n<thead>\n<tr>\n<th>车系</th>\n<th>车款</th>\n<th>空间</th>\n<th>操作</th>\n<th>底盘</th>\n<th>变速箱</th>\n<th>动力</th>\n<th>其他</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>德系</td>\n<td>朗逸（2017款1.6自舒）</td>\n<td>中上</td>\n<td>好</td>\n<td>完整度高</td>\n<td>有滞缓</td>\n<td>1.6 动力弱</td>\n<td>中配就已经11.8万多了</td>\n</tr>\n<tr>\n<td>韩系</td>\n<td>领动（2016款1.6自精）</td>\n<td>后排溜背导致头部空间不行</td>\n<td>好</td>\n<td>悬架偏硬</td>\n<td>好，有点迟滞不会很明显</td>\n<td>动力够</td>\n<td>1.6L的发动机是2014 沃德十佳，变速箱也是自家的摩比斯，油耗表现优异。<br>后防撞梁居然是玻璃钢！<a href=\"https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=monline_4_dg&amp;wd=%E9%A2%86%E5%8A%A8%20%E5%90%8E%E9%98%B2%E6%92%9E%E6%A2%81%20%E7%8E%BB%E7%92%83&amp;oq=%25E9%25A2%2586%25E5%258A%25A8%2520%25E5%2590%258E%25E9%2598%25B2%25E6%2592%259E%25E6%25A2%2581&amp;rsv_pq=9ac8441b0004242a&amp;rsv_t=4beaP6FxpPEI26yNqP48zmG5vR635nlh4%2BodmhhLFiBzPFLDPWF%2Fd6VLY9A3cnuGCjC0&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=10&amp;rsv_sug1=12&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=3636&amp;rsv_sug4=4074\" target=\"_blank\" rel=\"noopener\">百度 领动 后防撞梁</a></td>\n</tr>\n<tr>\n<td>法系</td>\n<td>标致308（2018款1.6自豪） <br>C4世嘉（2018款1.6自豪）</td>\n<td>小</td>\n<td>未注意</td>\n<td>好</td>\n<td>感觉比朗逸好</td>\n<td>不连顺</td>\n<td>试驾了1.2T 的C4世嘉，动力严重不连贯。<br> 308 从16款到18款直接简配</td>\n</tr>\n<tr>\n<td>日系</td>\n<td>昂克赛拉（2017款1.5自舒） <br> 轩逸<br> 卡罗拉 <br>  雷凌（2017改款1.2T）</td>\n<td>优秀</td>\n<td>一般</td>\n<td>一般</td>\n<td>顺畅CVT 缘故</td>\n<td>1.2T动力还是有劲</td>\n<td>只试驾了雷凌。昂克赛拉后排空间小点，优惠只有8千，不要装饰1.2万。<br> 轩逸感觉价格对标雷凌有点小贵，动力偏弱一点（自吸），但是座椅绝对是最舒服的。<br> 卡罗拉优惠也只有1.2万样子，销售太傲气不想多讲。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"5-SSSS常见销售技巧\"><a href=\"#5-SSSS常见销售技巧\" class=\"headerlink\" title=\"5. SSSS常见销售技巧\"></a>5. SSSS常见销售技巧</h3><p><strong>增加配置</strong></p>\n<p>厂家并没有此配置，4S自己加装。自己遇到的情况是：雷凌17款自精，增加倒车影像、右侧转向影像、胎压、日间行车灯、座椅仿皮。原厂自精指导价12.68万，但是增配的版本价格就提升到13.38万。这中间贵了7K去买这些东西，销售说是优惠2万</p>\n<p><strong>巧设收费名目</strong></p>\n<p>这在询问C4世嘉时遇到，当时报的裸车价比较低，优惠比较大。但是，….<br>他GRD 有：出库费2K，贷款手续费要3~4K，检测费等，简直就是LG。</p>\n<hr>\n<h3 id=\"6-结果\"><a href=\"#6-结果\" class=\"headerlink\" title=\"6. 结果\"></a>6. 结果</h3><p>最终购买了雷凌（2017改款185T）<br><img src=\"https://car2.autoimg.cn/cardfs/product/g15/M0E/BF/3F/1024x0_1_q87_autohomecar__wKgH1lkxHnyAZO_-AAg2uaPgZ6M981.jpg\" alt=\"\"><br><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=46311ef712d8bc3ed2050e98e3e2cd7b/8694a4c27d1ed21b24448528a66eddc450da3f69.jpg\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>价格</td>\n<td>大约12.2万</td>\n</tr>\n<tr>\n<td>裸车价</td>\n<td>10.58万（指导价12.68万，优惠2.1万）</td>\n</tr>\n<tr>\n<td>购置税</td>\n<td>9.6K左右</td>\n</tr>\n<tr>\n<td>赠送</td>\n<td>脚垫、车窗膜、倒车影像、右车转弯影像、胎压</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>在途虎养车上买了坐垫与360行车记录仪大概花了750块</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://i.youku.com/i/UMTUxMTg3NjU0MA==/navcustom?spm=a2hzp.8249370.0.0&amp;id=760665&amp;order=2&amp;page=6&amp;last_item=&amp;last_pn=1&amp;last_vid=404420941\" target=\"_blank\" rel=\"noopener\">38号车评中心</a></p>\n<p><a href=\"http://i.youku.com/i/UMTQ2NTYxNDI4OA==?spm=a2h0j.11185381.module_basic_dayu_sub.DL~DD~H2~A\" target=\"_blank\" rel=\"noopener\">车评人郑刚</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"买车过程记录\"><a href=\"#买车过程记录\" class=\"headerlink\" title=\"买车过程记录\"></a>买车过程记录</h1><h3 id=\"1-选车\"><a href=\"#1-选车\" class=\"headerlink\" title=\"1. 选车\"></a>1. 选车</h3><p><strong>观念</strong> </p>\n<p>不尽信，论坛与个人等，参数为王。</p>\n<p><strong>目的</strong> </p>\n<p>不同车系，或者不同的车辆都有各自的定位与特定。常见的有：</p>\n<ul>\n<li>性能性： 讲究操作性，动力</li>\n<li>家居性：空间，省油与保养方面</li>\n<li>商务性：big, bigger and bigger</li>\n<li>土豪性：暂不谈~~</li>\n</ul>\n<p>个人的考虑主要是家用，偏向于考虑空间与保养，省油方面，当然还要有必要的安全性。另外，考虑在城市中行驶和之后另一半使用车辆，尽量考虑自动挡车辆。</p>","more":"<p><strong>选车</strong></p>\n<p>货比三家，多跑几家4s店，试驾不同车系（美系，韩系，日系，德系等），以及同一车系中同价位的车辆，如朗逸与宝来，卡罗拉与雷凌等。</p>\n<p>来自38号车评中心的视频：</p>\n<p><a href=\"http://v.youku.com/v_show/id_XNzE5MjQ0Mzgw.html?spm=a2hzp.8249370.0.0\" target=\"_blank\" rel=\"noopener\">购车诉求概念一</a></p>\n<p><a href=\"http://v.youku.com/v_show/id_XNzI3Njc5Mzky.html?spm=a2hzp.8249370.0.0\" target=\"_blank\" rel=\"noopener\">购车诉求概念二</a></p>\n<p><a href=\"http://v.youku.com/v_show/id_XNzIxMTYzODY4.html?spm=a2hzp.8249370.0.0\" target=\"_blank\" rel=\"noopener\">选车如何看品牌</a></p>\n<p><a href=\"http://v.youku.com/v_show/id_XNzMzODA2NTQw.html?spm=a2hzp.8249370.0.0\" target=\"_blank\" rel=\"noopener\">选车试车购车正确流程</a></p>\n<hr>\n<h3 id=\"2-试车\"><a href=\"#2-试车\" class=\"headerlink\" title=\"2. 试车\"></a>2. 试车</h3><p><strong>空间</strong></p>\n<p>试驾不同车辆时，将前排调整为自己适合的开车习惯再看后排的空间表现。这是避免对比不统一。另外，空间包括：</p>\n<ul>\n<li><p>前排的左右及头部空间，储物格等</p>\n</li>\n<li><p>后排的腿部空间，特别是头部空间，有很多车辆使用溜背造型</p>\n</li>\n<li><p>后备箱的平整度，后排能否放倒（虽然用的不多，可以放倒总是更好些）</p>\n</li>\n</ul>\n<p><strong>舒适度</strong></p>\n<p>座椅的舒适度，包裹性，这些决定了在开长途时的疲劳程度。</p>\n<p>试驾时，建议先试坐后排，试驾再前排，车辆的前后排的悬架可能不同。悬架可以通过减速带与凹凸路面，或者急刹车与转弯时能体现。</p>\n<p><strong>试驾关注点</strong></p>\n<p><code>档位</code></p>\n<p>换挡的平顺性，主要是加速与收油时的表现。总结为：</p>\n<ul>\n<li><p>稳：加速，收油低速平顺性</p>\n</li>\n<li><p>准：加减，转速准确，没有动力粘滞</p>\n</li>\n<li><p>狠：换挡快，没有空转</p>\n</li>\n</ul>\n<p><code>转向</code></p>\n<p>主要是悬架的调校，以及回正度（助力）</p>\n<p><code>油门，刹车</code></p>\n<p>行程是否都有用（深踩），有些车辆的油门与刹车都只是前半段比较灵敏，后半段效果不同。例如，有些小排量油门前半段都有点窜，他是为了营造一种有动力的假象。</p>\n<p><code>转速表</code></p>\n<p>转速表不一定准，需要自己感受。另外，车辆的油耗显示也不一定准确，自己使用油枪或者APP计算。</p>\n<p><img src=\"http://cdn.xiaoxiongyouhao.com/assets/images/logo.png\" alt=\"\"></p>\n<p><a href=\"https://www.xiaoxiongyouhao.com/page_rank_chexi.php\" target=\"_blank\" rel=\"noopener\">小熊油耗排行</a></p>\n<hr>\n<h3 id=\"3-砍价技巧与购买时间\"><a href=\"#3-砍价技巧与购买时间\" class=\"headerlink\" title=\"3. 砍价技巧与购买时间\"></a>3. 砍价技巧与购买时间</h3><p><strong> 购买时间 </strong></p>\n<p>根据我们的初步参数比较，试驾对比，我们基本能确定2~3辆想买的。接下来，就看每个车最终的落地价了。</p>\n<p>购买时间，参考网上的说法是：3-5月，7-9月。当然还有车展期间优惠幅度也比较大。2018年4月，韩系受萨德的影响，车辆的最终优惠大致可以达到2.3万，并没有优惠很多，只是厂家回访了2次，服务态度比较好，并不好抄底啊^_^!。</p>\n<blockquote>\n<p>购买车辆，千万不要着急与冲动，能稳得住，汽拖之家的车系论坛还是真有些拖存在。</p>\n</blockquote>\n<p><strong> 砍价 </strong></p>\n<p><code>落地价 = 裸车价 + 购置税 + 保险</code></p>\n<p>注意：</p>\n<ul>\n<li><p>裸车价越便宜，购置税与保险也要重新计算，要尽量杀裸车价</p>\n</li>\n<li><p>不要在4S 店加装，尽量要求赠送，加装的东西如皮座4S 店都会外包给外面的装饰店搞定 </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>序号</strong></th>\n<th><strong>步骤</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>诚意</td>\n<td>更能表现出<strong>购买欲</strong>，销售才会透露低价给你。<br> <strong>提醒</strong>：关于寻找谈判的销售人员，请选择男性，男人一般容易冲动，爽快</td>\n</tr>\n<tr>\n<td>2</td>\n<td>销售底价</td>\n<td>不要暴露自己的低价。4S店组织一般为三级：<code>销售、科长（主管）、经理</code>。</td>\n</tr>\n<tr>\n<td>3</td>\n<td>上级底价</td>\n<td>谈价时销售员问你是不是今天就买或者能付定金，要是可以的话他去请示下领导，给你个最低价。<br>这个时候你还是不要说出你的心理价，但你可以告诉他，要是价格合适可以交定金，让他去请示领导。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>同伴作用</td>\n<td>销售请示的低价还是有所保留的，同伴红黑脸作用得到上级真正底价</td>\n</tr>\n<tr>\n<td>5</td>\n<td>赠送</td>\n<td>千万不要将砍价也要赠品混在一起谈，这要肯定会分散注意力。一个字：磨。<br>磨赠品的时候，需要注意的就是别光看数量，要注重质量。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>心态</td>\n<td>买卖交易，讲究个缘分，实在谈不拢也别争个脸红脖子粗的，要保持风度</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://zhidao.baidu.com/question/524012738221021205.html?qbl=relate_question_0&amp;word=%B3%C9%B6%BC%20%B9%BA%B3%B5%CA%B1%BC%E4%20%D3%C5%BB%DD\" target=\"_blank\" rel=\"noopener\">经典砍价–百度知道</a></p>\n<p><em>TIPS:</em></p>\n<blockquote>\n<p>在汽车之家与论坛上，我们往往能找到某一款车的最低价格，我们可以参考得出自己心里的价格。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-自己试驾记录表格\"><a href=\"#4-自己试驾记录表格\" class=\"headerlink\" title=\"4. 自己试驾记录表格\"></a>4. 自己试驾记录表格</h3><p>下表是我试驾过或者看过的车辆</p>\n<table>\n<thead>\n<tr>\n<th>车系</th>\n<th>车款</th>\n<th>空间</th>\n<th>操作</th>\n<th>底盘</th>\n<th>变速箱</th>\n<th>动力</th>\n<th>其他</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>德系</td>\n<td>朗逸（2017款1.6自舒）</td>\n<td>中上</td>\n<td>好</td>\n<td>完整度高</td>\n<td>有滞缓</td>\n<td>1.6 动力弱</td>\n<td>中配就已经11.8万多了</td>\n</tr>\n<tr>\n<td>韩系</td>\n<td>领动（2016款1.6自精）</td>\n<td>后排溜背导致头部空间不行</td>\n<td>好</td>\n<td>悬架偏硬</td>\n<td>好，有点迟滞不会很明显</td>\n<td>动力够</td>\n<td>1.6L的发动机是2014 沃德十佳，变速箱也是自家的摩比斯，油耗表现优异。<br>后防撞梁居然是玻璃钢！<a href=\"https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=monline_4_dg&amp;wd=%E9%A2%86%E5%8A%A8%20%E5%90%8E%E9%98%B2%E6%92%9E%E6%A2%81%20%E7%8E%BB%E7%92%83&amp;oq=%25E9%25A2%2586%25E5%258A%25A8%2520%25E5%2590%258E%25E9%2598%25B2%25E6%2592%259E%25E6%25A2%2581&amp;rsv_pq=9ac8441b0004242a&amp;rsv_t=4beaP6FxpPEI26yNqP48zmG5vR635nlh4%2BodmhhLFiBzPFLDPWF%2Fd6VLY9A3cnuGCjC0&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=10&amp;rsv_sug1=12&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=3636&amp;rsv_sug4=4074\" target=\"_blank\" rel=\"noopener\">百度 领动 后防撞梁</a></td>\n</tr>\n<tr>\n<td>法系</td>\n<td>标致308（2018款1.6自豪） <br>C4世嘉（2018款1.6自豪）</td>\n<td>小</td>\n<td>未注意</td>\n<td>好</td>\n<td>感觉比朗逸好</td>\n<td>不连顺</td>\n<td>试驾了1.2T 的C4世嘉，动力严重不连贯。<br> 308 从16款到18款直接简配</td>\n</tr>\n<tr>\n<td>日系</td>\n<td>昂克赛拉（2017款1.5自舒） <br> 轩逸<br> 卡罗拉 <br>  雷凌（2017改款1.2T）</td>\n<td>优秀</td>\n<td>一般</td>\n<td>一般</td>\n<td>顺畅CVT 缘故</td>\n<td>1.2T动力还是有劲</td>\n<td>只试驾了雷凌。昂克赛拉后排空间小点，优惠只有8千，不要装饰1.2万。<br> 轩逸感觉价格对标雷凌有点小贵，动力偏弱一点（自吸），但是座椅绝对是最舒服的。<br> 卡罗拉优惠也只有1.2万样子，销售太傲气不想多讲。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"5-SSSS常见销售技巧\"><a href=\"#5-SSSS常见销售技巧\" class=\"headerlink\" title=\"5. SSSS常见销售技巧\"></a>5. SSSS常见销售技巧</h3><p><strong>增加配置</strong></p>\n<p>厂家并没有此配置，4S自己加装。自己遇到的情况是：雷凌17款自精，增加倒车影像、右侧转向影像、胎压、日间行车灯、座椅仿皮。原厂自精指导价12.68万，但是增配的版本价格就提升到13.38万。这中间贵了7K去买这些东西，销售说是优惠2万</p>\n<p><strong>巧设收费名目</strong></p>\n<p>这在询问C4世嘉时遇到，当时报的裸车价比较低，优惠比较大。但是，….<br>他GRD 有：出库费2K，贷款手续费要3~4K，检测费等，简直就是LG。</p>\n<hr>\n<h3 id=\"6-结果\"><a href=\"#6-结果\" class=\"headerlink\" title=\"6. 结果\"></a>6. 结果</h3><p>最终购买了雷凌（2017改款185T）<br><img src=\"https://car2.autoimg.cn/cardfs/product/g15/M0E/BF/3F/1024x0_1_q87_autohomecar__wKgH1lkxHnyAZO_-AAg2uaPgZ6M981.jpg\" alt=\"\"><br><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=46311ef712d8bc3ed2050e98e3e2cd7b/8694a4c27d1ed21b24448528a66eddc450da3f69.jpg\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>价格</td>\n<td>大约12.2万</td>\n</tr>\n<tr>\n<td>裸车价</td>\n<td>10.58万（指导价12.68万，优惠2.1万）</td>\n</tr>\n<tr>\n<td>购置税</td>\n<td>9.6K左右</td>\n</tr>\n<tr>\n<td>赠送</td>\n<td>脚垫、车窗膜、倒车影像、右车转弯影像、胎压</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>在途虎养车上买了坐垫与360行车记录仪大概花了750块</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://i.youku.com/i/UMTUxMTg3NjU0MA==/navcustom?spm=a2hzp.8249370.0.0&amp;id=760665&amp;order=2&amp;page=6&amp;last_item=&amp;last_pn=1&amp;last_vid=404420941\" target=\"_blank\" rel=\"noopener\">38号车评中心</a></p>\n<p><a href=\"http://i.youku.com/i/UMTQ2NTYxNDI4OA==?spm=a2h0j.11185381.module_basic_dayu_sub.DL~DD~H2~A\" target=\"_blank\" rel=\"noopener\">车评人郑刚</a></p>"},{"title":"大脑整理术","date":"2018-11-26T10:56:49.000Z","_content":"\n![](https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/doc/pic/item/5fdf8db1cb134954fec540815a4e9258d0094a78.jpg)\n\n<!--more-->\n\n## 1. 大脑重塑操作指南\n本书的主要是可以让我们具备：**保持镇定和积极的心态的能力。**\n\n定期训练思考、感知和采取行动的能力，将会重塑你的大脑，并且使你感到内心平静和精神集中。\n\n由于你的大脑不是“硬连接”，而是真真正正的“软连接”，所以你的人生经历在如何培养你的天性方面发挥了重要的作用。\n\n### 1.1. 大脑工作原理概述\n人类的[大脑](https://baike.baidu.com/item/%E5%A4%A7%E8%84%91/791360?fr=aladdin)大致结构可参见下图：\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f45ccc0a8618367ab984778f4f1ae0b1/4a36acaf2edda3cc38d4b90301e93901213f92e4.jpg)\n\n神经元在名为模块的大脑区域中聚集在一起，这些模块有：皮层（外层，包含两个半球(每个半球都有外侧裂以上的额叶、外侧裂以下的颞叶、顶枕裂后方的枕叶)）、4个叶和皮层下模块。大脑中名为[胼胝体(\npián zhī tǐ)](https://baike.baidu.com/item/%E8%83%BC%E8%83%9D%E4%BD%93)的纤维束将这个半球连接在一起，同时激发两个神经元联系起来。\n\n### 1.2. 神经元和神经递质简介\n神经元的功能部分依赖于化学作用，部分依赖于时短时续的脉冲放电激活。神经元相互之间通过发送神经递质这种化学信号，跨越突触间的间隙交流。\n\n### 1.3. 神经可塑性的功能\n大量的证据表明突触突不是硬连接的，而是在变动之中，这就是突触可塑性或叫神经可塑性的含义。同时，他也证明了**用进废退**的道理，当你连接上体现某想技能的突触时，就是在强化这项技能。\n\n**不仅行为可以借助神经可塑性改变大脑结构，就算只是思考或想象某种行为也能改变大脑结构。**\n\n“__给予就是获得__”是脑神经的一条真理。感觉迟钝和自私自利对大脑和心里健康都是有害的，相反，同情和关爱更有益。\n\n**通过冥想和祈祷的平静和精神集中的练习将使大脑线路连接起来，有益于健康。**\n\n### 1.4.重塑大脑的4个步骤\n\n简称为FEED\n- 聚精会神(Focus)\n- 努力练习(Effort)\n- 轻松自如(Effortlessness)\n- 坚持不懈(Determination)\n\n注意力和额叶在神经可塑性方面扮演着重要角色， 前额叶皮层相当于大脑的大脑。\n\n努力练习将使注意力从感知转移到行动上，尽量使你的大脑活跃起来，从而产生新的突触连接（刻意练习，使得它变成一个新习惯）。为达到重塑大脑的目的，你必须使新行为保持足够长的时间，直到新行为变成你下意识的动作。\n\n\n## 2. 如何赶走焦虑情绪？\n\n一般遇到警报，杏仁核给下丘脑（负责许多新陈代谢过程并涉及自主神经系统）发出信号，它又给脑垂体发出信号，脑垂体又给肾上腺发出信号，释放出肾上腺素和皮质醇（它是比肾上腺素更能让你保持长久兴奋的应激激素），这一系列使得身体系统发生波动，造成呼吸加快，心跳加速，血压升高，这就是“战或逃反应”。__杏仁核，本能的天使，现实的魔鬼。__\n\n__适度的焦虑有益于神经可塑性__。在过度焦虑和不焦虑之间保持平衡对于学习和记忆是最好的选择，这种平衡关系呈“倒U形”曲线，也叫作\"[耶克斯-多德深曲线](https://baike.baidu.com/item/%E8%80%B6%E5%85%8B%E6%96%AF-%E5%A4%9A%E5%BE%B7%E6%A3%AE%E5%AE%9A%E5%BE%8B/5723839?fr=aladdin)\"。\n\n**深度呼吸**\n吸吸入更多氧气，降低血液中二氧化碳的含量（它有维持血液中PH值，PH值越低，你的神经元越兴奋，就会越感到紧张）。\n\n**不逃避**\n从长远看，**不逃避并尽可能面对事情可以减轻焦虑**。 用\"暴露法\"取代逃避，即直面让你感到焦虑的事情，不断地将自己暴露在宁你焦虑达的情境下，让自己习以为常，最终减弱焦虑。\n\n## 3.如何摆脱负面情绪\n左额叶增进积极乐观的心态并促使你采取行动，而右额叶则会使你逆来顺受，加重消极的情绪。\n\n常用促使积极心态的产生：\n- 激发积极的情绪  \n- 多晒太阳  \n- 运动改变心情 \n- 以乐观的方式解读生活  \n- 打造积极思维  \n- 社交疗法  \n- 采取行动 \n\n常常微笑确实有帮助，它是这样发挥作用的：神经通路连接着面部肌肉、脑神经、皮层下区域和皮层。信息从大脑传向面部，也会传回大脑。例如，如果你收缩右脸的肌肉让你的左脑活跃起来，极可能产生积极的情绪。\n\n运动可以促进血液的氧合作用，也会降低体内的酸性水平。\n\n右脑更具全局性，也更情绪化，对主体本质和自传体记忆具有意义。但他也需要左脑，它是你生活经历的解读器，输入细节和积极的心态，帮助理解你理解你的体验。\n\n当你被另外一个人吸引时，神经递质多巴胺被激活，产生愉悦感。积极的人际关系引发积极的情绪。\n\n__积极的情绪模式不仅代表着更多快乐，它也需要更多的实践。如果情绪是积极的，你将更倾向于思考可能性和潜在性，把迎接生活中的挑战视为活力的释放。__\n\n## 4. 如何增强记忆力\n工作记忆通常被称作短时记忆。工作记忆是一条通向长时记忆的必经之路。它想长时记忆\"供给\"记忆，长时记忆需要将工作记忆进行编码整理。\n\n身体的脂肪的增加与记忆力的减退有关。\n\n- 提升注意力  \n- 学会运用不用类型的记忆技巧（视觉系，听觉系）  \n- __利用联系法__\n\n>使用联系法是一个特别有效的方式，就是将你想记住的东西与一个视觉影像联系起来。视觉联系之所以有效，是因为人们石峰擅长记忆非同寻常的视觉影像。\n\n随着你开始描述事件，你会想起围绕该事件的相关记忆，激活一个完整的联想链，并重新激发了一个更叫宽广的记忆范围，这是因为记忆就是在大的神经元群之间建立突触连接。\n\n__不管你处于什么年龄段，都应该不断挑战自我。__ 树突分枝会刺激神经元产生更多的连接。\n- 阅读费小说类的书籍  \n- 选修其他课程  \n- 旅游  \n- 参加由启发性的对话和辩论\n\n>练习专注于一项活动，而且时间要越来越久。不要同时做好几件事，也不要从一件事情快速跳转到另一件事上。要让自己沉寂到感兴趣的某项活动之中，而且要全身心地投入。\n\n## 5.合理安排饮食\n\n氨基酸是神经递质的关键构成要素。 维生素C,E 是主要的抗氧化物。\n\n## 6.改善睡眠\n电脑，手机的使用，会让视网膜感受光信号，大脑误认这是白天而不是夜晚，从而抑制了睡眠激素褪黑素的生成。\n\n运动是一剂良药。运动向大脑输送了更多的氧，改善了毛细血管的健康状况。通过提高心血系统的效率，运动使血压下降。\n\n## 7. 坚毅的心态\n**心态点亮你的未来**\n心理韧性面对逆境心存希望，竭尽所能促使转机出现，逆境变成顺境。\n\n通过冥想来培养积极心态和乐观情绪的人，其心理韧性更强。\n\n你培养的幽默感应当是积极向上的。\n\n## 8. 提升注意力\n大脑需要稳定的血流，体操等伸展运动能促使健康的血液流向大脑，让人注意力更集中、精神更放松。\n\n__源于佛教的冥想被称作正念、内观或者内观禅修。__\n\n正念曾用于治疗焦虑症、抑郁。关注的是呼吸、旁观者的视角、接纳和不做批判的态度。\n\n>通过保持旁观者的视角，养成不做评判的态度。如果你在任何时间只是旁观而不是对正在发生的事情做出反应，你就会延迟对情景的反应，移植到所有的信息都被正确的看待。\n\n\n\n\n","source":"_posts/大脑整理术.md","raw":"---\ntitle: 大脑整理术\ndate: 2018-11-26 18:56:49\ntags: bookmarks\ncategories: bookmarks\n---\n\n![](https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/doc/pic/item/5fdf8db1cb134954fec540815a4e9258d0094a78.jpg)\n\n<!--more-->\n\n## 1. 大脑重塑操作指南\n本书的主要是可以让我们具备：**保持镇定和积极的心态的能力。**\n\n定期训练思考、感知和采取行动的能力，将会重塑你的大脑，并且使你感到内心平静和精神集中。\n\n由于你的大脑不是“硬连接”，而是真真正正的“软连接”，所以你的人生经历在如何培养你的天性方面发挥了重要的作用。\n\n### 1.1. 大脑工作原理概述\n人类的[大脑](https://baike.baidu.com/item/%E5%A4%A7%E8%84%91/791360?fr=aladdin)大致结构可参见下图：\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f45ccc0a8618367ab984778f4f1ae0b1/4a36acaf2edda3cc38d4b90301e93901213f92e4.jpg)\n\n神经元在名为模块的大脑区域中聚集在一起，这些模块有：皮层（外层，包含两个半球(每个半球都有外侧裂以上的额叶、外侧裂以下的颞叶、顶枕裂后方的枕叶)）、4个叶和皮层下模块。大脑中名为[胼胝体(\npián zhī tǐ)](https://baike.baidu.com/item/%E8%83%BC%E8%83%9D%E4%BD%93)的纤维束将这个半球连接在一起，同时激发两个神经元联系起来。\n\n### 1.2. 神经元和神经递质简介\n神经元的功能部分依赖于化学作用，部分依赖于时短时续的脉冲放电激活。神经元相互之间通过发送神经递质这种化学信号，跨越突触间的间隙交流。\n\n### 1.3. 神经可塑性的功能\n大量的证据表明突触突不是硬连接的，而是在变动之中，这就是突触可塑性或叫神经可塑性的含义。同时，他也证明了**用进废退**的道理，当你连接上体现某想技能的突触时，就是在强化这项技能。\n\n**不仅行为可以借助神经可塑性改变大脑结构，就算只是思考或想象某种行为也能改变大脑结构。**\n\n“__给予就是获得__”是脑神经的一条真理。感觉迟钝和自私自利对大脑和心里健康都是有害的，相反，同情和关爱更有益。\n\n**通过冥想和祈祷的平静和精神集中的练习将使大脑线路连接起来，有益于健康。**\n\n### 1.4.重塑大脑的4个步骤\n\n简称为FEED\n- 聚精会神(Focus)\n- 努力练习(Effort)\n- 轻松自如(Effortlessness)\n- 坚持不懈(Determination)\n\n注意力和额叶在神经可塑性方面扮演着重要角色， 前额叶皮层相当于大脑的大脑。\n\n努力练习将使注意力从感知转移到行动上，尽量使你的大脑活跃起来，从而产生新的突触连接（刻意练习，使得它变成一个新习惯）。为达到重塑大脑的目的，你必须使新行为保持足够长的时间，直到新行为变成你下意识的动作。\n\n\n## 2. 如何赶走焦虑情绪？\n\n一般遇到警报，杏仁核给下丘脑（负责许多新陈代谢过程并涉及自主神经系统）发出信号，它又给脑垂体发出信号，脑垂体又给肾上腺发出信号，释放出肾上腺素和皮质醇（它是比肾上腺素更能让你保持长久兴奋的应激激素），这一系列使得身体系统发生波动，造成呼吸加快，心跳加速，血压升高，这就是“战或逃反应”。__杏仁核，本能的天使，现实的魔鬼。__\n\n__适度的焦虑有益于神经可塑性__。在过度焦虑和不焦虑之间保持平衡对于学习和记忆是最好的选择，这种平衡关系呈“倒U形”曲线，也叫作\"[耶克斯-多德深曲线](https://baike.baidu.com/item/%E8%80%B6%E5%85%8B%E6%96%AF-%E5%A4%9A%E5%BE%B7%E6%A3%AE%E5%AE%9A%E5%BE%8B/5723839?fr=aladdin)\"。\n\n**深度呼吸**\n吸吸入更多氧气，降低血液中二氧化碳的含量（它有维持血液中PH值，PH值越低，你的神经元越兴奋，就会越感到紧张）。\n\n**不逃避**\n从长远看，**不逃避并尽可能面对事情可以减轻焦虑**。 用\"暴露法\"取代逃避，即直面让你感到焦虑的事情，不断地将自己暴露在宁你焦虑达的情境下，让自己习以为常，最终减弱焦虑。\n\n## 3.如何摆脱负面情绪\n左额叶增进积极乐观的心态并促使你采取行动，而右额叶则会使你逆来顺受，加重消极的情绪。\n\n常用促使积极心态的产生：\n- 激发积极的情绪  \n- 多晒太阳  \n- 运动改变心情 \n- 以乐观的方式解读生活  \n- 打造积极思维  \n- 社交疗法  \n- 采取行动 \n\n常常微笑确实有帮助，它是这样发挥作用的：神经通路连接着面部肌肉、脑神经、皮层下区域和皮层。信息从大脑传向面部，也会传回大脑。例如，如果你收缩右脸的肌肉让你的左脑活跃起来，极可能产生积极的情绪。\n\n运动可以促进血液的氧合作用，也会降低体内的酸性水平。\n\n右脑更具全局性，也更情绪化，对主体本质和自传体记忆具有意义。但他也需要左脑，它是你生活经历的解读器，输入细节和积极的心态，帮助理解你理解你的体验。\n\n当你被另外一个人吸引时，神经递质多巴胺被激活，产生愉悦感。积极的人际关系引发积极的情绪。\n\n__积极的情绪模式不仅代表着更多快乐，它也需要更多的实践。如果情绪是积极的，你将更倾向于思考可能性和潜在性，把迎接生活中的挑战视为活力的释放。__\n\n## 4. 如何增强记忆力\n工作记忆通常被称作短时记忆。工作记忆是一条通向长时记忆的必经之路。它想长时记忆\"供给\"记忆，长时记忆需要将工作记忆进行编码整理。\n\n身体的脂肪的增加与记忆力的减退有关。\n\n- 提升注意力  \n- 学会运用不用类型的记忆技巧（视觉系，听觉系）  \n- __利用联系法__\n\n>使用联系法是一个特别有效的方式，就是将你想记住的东西与一个视觉影像联系起来。视觉联系之所以有效，是因为人们石峰擅长记忆非同寻常的视觉影像。\n\n随着你开始描述事件，你会想起围绕该事件的相关记忆，激活一个完整的联想链，并重新激发了一个更叫宽广的记忆范围，这是因为记忆就是在大的神经元群之间建立突触连接。\n\n__不管你处于什么年龄段，都应该不断挑战自我。__ 树突分枝会刺激神经元产生更多的连接。\n- 阅读费小说类的书籍  \n- 选修其他课程  \n- 旅游  \n- 参加由启发性的对话和辩论\n\n>练习专注于一项活动，而且时间要越来越久。不要同时做好几件事，也不要从一件事情快速跳转到另一件事上。要让自己沉寂到感兴趣的某项活动之中，而且要全身心地投入。\n\n## 5.合理安排饮食\n\n氨基酸是神经递质的关键构成要素。 维生素C,E 是主要的抗氧化物。\n\n## 6.改善睡眠\n电脑，手机的使用，会让视网膜感受光信号，大脑误认这是白天而不是夜晚，从而抑制了睡眠激素褪黑素的生成。\n\n运动是一剂良药。运动向大脑输送了更多的氧，改善了毛细血管的健康状况。通过提高心血系统的效率，运动使血压下降。\n\n## 7. 坚毅的心态\n**心态点亮你的未来**\n心理韧性面对逆境心存希望，竭尽所能促使转机出现，逆境变成顺境。\n\n通过冥想来培养积极心态和乐观情绪的人，其心理韧性更强。\n\n你培养的幽默感应当是积极向上的。\n\n## 8. 提升注意力\n大脑需要稳定的血流，体操等伸展运动能促使健康的血液流向大脑，让人注意力更集中、精神更放松。\n\n__源于佛教的冥想被称作正念、内观或者内观禅修。__\n\n正念曾用于治疗焦虑症、抑郁。关注的是呼吸、旁观者的视角、接纳和不做批判的态度。\n\n>通过保持旁观者的视角，养成不做评判的态度。如果你在任何时间只是旁观而不是对正在发生的事情做出反应，你就会延迟对情景的反应，移植到所有的信息都被正确的看待。\n\n\n\n\n","slug":"大脑整理术","published":1,"updated":"2020-02-17T13:56:53.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0rf004dzkgrvhlmsio5","content":"<p><img src=\"https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/doc/pic/item/5fdf8db1cb134954fec540815a4e9258d0094a78.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"1-大脑重塑操作指南\"><a href=\"#1-大脑重塑操作指南\" class=\"headerlink\" title=\"1. 大脑重塑操作指南\"></a>1. 大脑重塑操作指南</h2><p>本书的主要是可以让我们具备：<strong>保持镇定和积极的心态的能力。</strong></p>\n<p>定期训练思考、感知和采取行动的能力，将会重塑你的大脑，并且使你感到内心平静和精神集中。</p>\n<p>由于你的大脑不是“硬连接”，而是真真正正的“软连接”，所以你的人生经历在如何培养你的天性方面发挥了重要的作用。</p>\n<h3 id=\"1-1-大脑工作原理概述\"><a href=\"#1-1-大脑工作原理概述\" class=\"headerlink\" title=\"1.1. 大脑工作原理概述\"></a>1.1. 大脑工作原理概述</h3><p>人类的<a href=\"https://baike.baidu.com/item/%E5%A4%A7%E8%84%91/791360?fr=aladdin\" target=\"_blank\" rel=\"noopener\">大脑</a>大致结构可参见下图：<br><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f45ccc0a8618367ab984778f4f1ae0b1/4a36acaf2edda3cc38d4b90301e93901213f92e4.jpg\" alt=\"\"></p>\n<p>神经元在名为模块的大脑区域中聚集在一起，这些模块有：皮层（外层，包含两个半球(每个半球都有外侧裂以上的额叶、外侧裂以下的颞叶、顶枕裂后方的枕叶)）、4个叶和皮层下模块。大脑中名为<a href=\"https://baike.baidu.com/item/%E8%83%BC%E8%83%9D%E4%BD%93\" target=\"_blank\" rel=\"noopener\">胼胝体(<br>pián zhī tǐ)</a>的纤维束将这个半球连接在一起，同时激发两个神经元联系起来。</p>\n<h3 id=\"1-2-神经元和神经递质简介\"><a href=\"#1-2-神经元和神经递质简介\" class=\"headerlink\" title=\"1.2. 神经元和神经递质简介\"></a>1.2. 神经元和神经递质简介</h3><p>神经元的功能部分依赖于化学作用，部分依赖于时短时续的脉冲放电激活。神经元相互之间通过发送神经递质这种化学信号，跨越突触间的间隙交流。</p>\n<h3 id=\"1-3-神经可塑性的功能\"><a href=\"#1-3-神经可塑性的功能\" class=\"headerlink\" title=\"1.3. 神经可塑性的功能\"></a>1.3. 神经可塑性的功能</h3><p>大量的证据表明突触突不是硬连接的，而是在变动之中，这就是突触可塑性或叫神经可塑性的含义。同时，他也证明了<strong>用进废退</strong>的道理，当你连接上体现某想技能的突触时，就是在强化这项技能。</p>\n<p><strong>不仅行为可以借助神经可塑性改变大脑结构，就算只是思考或想象某种行为也能改变大脑结构。</strong></p>\n<p>“<strong>给予就是获得</strong>”是脑神经的一条真理。感觉迟钝和自私自利对大脑和心里健康都是有害的，相反，同情和关爱更有益。</p>\n<p><strong>通过冥想和祈祷的平静和精神集中的练习将使大脑线路连接起来，有益于健康。</strong></p>\n<h3 id=\"1-4-重塑大脑的4个步骤\"><a href=\"#1-4-重塑大脑的4个步骤\" class=\"headerlink\" title=\"1.4.重塑大脑的4个步骤\"></a>1.4.重塑大脑的4个步骤</h3><p>简称为FEED</p>\n<ul>\n<li>聚精会神(Focus)</li>\n<li>努力练习(Effort)</li>\n<li>轻松自如(Effortlessness)</li>\n<li>坚持不懈(Determination)</li>\n</ul>\n<p>注意力和额叶在神经可塑性方面扮演着重要角色， 前额叶皮层相当于大脑的大脑。</p>\n<p>努力练习将使注意力从感知转移到行动上，尽量使你的大脑活跃起来，从而产生新的突触连接（刻意练习，使得它变成一个新习惯）。为达到重塑大脑的目的，你必须使新行为保持足够长的时间，直到新行为变成你下意识的动作。</p>\n<h2 id=\"2-如何赶走焦虑情绪？\"><a href=\"#2-如何赶走焦虑情绪？\" class=\"headerlink\" title=\"2. 如何赶走焦虑情绪？\"></a>2. 如何赶走焦虑情绪？</h2><p>一般遇到警报，杏仁核给下丘脑（负责许多新陈代谢过程并涉及自主神经系统）发出信号，它又给脑垂体发出信号，脑垂体又给肾上腺发出信号，释放出肾上腺素和皮质醇（它是比肾上腺素更能让你保持长久兴奋的应激激素），这一系列使得身体系统发生波动，造成呼吸加快，心跳加速，血压升高，这就是“战或逃反应”。<strong>杏仁核，本能的天使，现实的魔鬼。</strong></p>\n<p><strong>适度的焦虑有益于神经可塑性</strong>。在过度焦虑和不焦虑之间保持平衡对于学习和记忆是最好的选择，这种平衡关系呈“倒U形”曲线，也叫作”<a href=\"https://baike.baidu.com/item/%E8%80%B6%E5%85%8B%E6%96%AF-%E5%A4%9A%E5%BE%B7%E6%A3%AE%E5%AE%9A%E5%BE%8B/5723839?fr=aladdin\" target=\"_blank\" rel=\"noopener\">耶克斯-多德深曲线</a>“。</p>\n<p><strong>深度呼吸</strong><br>吸吸入更多氧气，降低血液中二氧化碳的含量（它有维持血液中PH值，PH值越低，你的神经元越兴奋，就会越感到紧张）。</p>\n<p><strong>不逃避</strong><br>从长远看，<strong>不逃避并尽可能面对事情可以减轻焦虑</strong>。 用”暴露法”取代逃避，即直面让你感到焦虑的事情，不断地将自己暴露在宁你焦虑达的情境下，让自己习以为常，最终减弱焦虑。</p>\n<h2 id=\"3-如何摆脱负面情绪\"><a href=\"#3-如何摆脱负面情绪\" class=\"headerlink\" title=\"3.如何摆脱负面情绪\"></a>3.如何摆脱负面情绪</h2><p>左额叶增进积极乐观的心态并促使你采取行动，而右额叶则会使你逆来顺受，加重消极的情绪。</p>\n<p>常用促使积极心态的产生：</p>\n<ul>\n<li>激发积极的情绪  </li>\n<li>多晒太阳  </li>\n<li>运动改变心情 </li>\n<li>以乐观的方式解读生活  </li>\n<li>打造积极思维  </li>\n<li>社交疗法  </li>\n<li>采取行动 </li>\n</ul>\n<p>常常微笑确实有帮助，它是这样发挥作用的：神经通路连接着面部肌肉、脑神经、皮层下区域和皮层。信息从大脑传向面部，也会传回大脑。例如，如果你收缩右脸的肌肉让你的左脑活跃起来，极可能产生积极的情绪。</p>\n<p>运动可以促进血液的氧合作用，也会降低体内的酸性水平。</p>\n<p>右脑更具全局性，也更情绪化，对主体本质和自传体记忆具有意义。但他也需要左脑，它是你生活经历的解读器，输入细节和积极的心态，帮助理解你理解你的体验。</p>\n<p>当你被另外一个人吸引时，神经递质多巴胺被激活，产生愉悦感。积极的人际关系引发积极的情绪。</p>\n<p><strong>积极的情绪模式不仅代表着更多快乐，它也需要更多的实践。如果情绪是积极的，你将更倾向于思考可能性和潜在性，把迎接生活中的挑战视为活力的释放。</strong></p>\n<h2 id=\"4-如何增强记忆力\"><a href=\"#4-如何增强记忆力\" class=\"headerlink\" title=\"4. 如何增强记忆力\"></a>4. 如何增强记忆力</h2><p>工作记忆通常被称作短时记忆。工作记忆是一条通向长时记忆的必经之路。它想长时记忆”供给”记忆，长时记忆需要将工作记忆进行编码整理。</p>\n<p>身体的脂肪的增加与记忆力的减退有关。</p>\n<ul>\n<li>提升注意力  </li>\n<li>学会运用不用类型的记忆技巧（视觉系，听觉系）  </li>\n<li><strong>利用联系法</strong></li>\n</ul>\n<blockquote>\n<p>使用联系法是一个特别有效的方式，就是将你想记住的东西与一个视觉影像联系起来。视觉联系之所以有效，是因为人们石峰擅长记忆非同寻常的视觉影像。</p>\n</blockquote>\n<p>随着你开始描述事件，你会想起围绕该事件的相关记忆，激活一个完整的联想链，并重新激发了一个更叫宽广的记忆范围，这是因为记忆就是在大的神经元群之间建立突触连接。</p>\n<p><strong>不管你处于什么年龄段，都应该不断挑战自我。</strong> 树突分枝会刺激神经元产生更多的连接。</p>\n<ul>\n<li>阅读费小说类的书籍  </li>\n<li>选修其他课程  </li>\n<li>旅游  </li>\n<li>参加由启发性的对话和辩论</li>\n</ul>\n<blockquote>\n<p>练习专注于一项活动，而且时间要越来越久。不要同时做好几件事，也不要从一件事情快速跳转到另一件事上。要让自己沉寂到感兴趣的某项活动之中，而且要全身心地投入。</p>\n</blockquote>\n<h2 id=\"5-合理安排饮食\"><a href=\"#5-合理安排饮食\" class=\"headerlink\" title=\"5.合理安排饮食\"></a>5.合理安排饮食</h2><p>氨基酸是神经递质的关键构成要素。 维生素C,E 是主要的抗氧化物。</p>\n<h2 id=\"6-改善睡眠\"><a href=\"#6-改善睡眠\" class=\"headerlink\" title=\"6.改善睡眠\"></a>6.改善睡眠</h2><p>电脑，手机的使用，会让视网膜感受光信号，大脑误认这是白天而不是夜晚，从而抑制了睡眠激素褪黑素的生成。</p>\n<p>运动是一剂良药。运动向大脑输送了更多的氧，改善了毛细血管的健康状况。通过提高心血系统的效率，运动使血压下降。</p>\n<h2 id=\"7-坚毅的心态\"><a href=\"#7-坚毅的心态\" class=\"headerlink\" title=\"7. 坚毅的心态\"></a>7. 坚毅的心态</h2><p><strong>心态点亮你的未来</strong><br>心理韧性面对逆境心存希望，竭尽所能促使转机出现，逆境变成顺境。</p>\n<p>通过冥想来培养积极心态和乐观情绪的人，其心理韧性更强。</p>\n<p>你培养的幽默感应当是积极向上的。</p>\n<h2 id=\"8-提升注意力\"><a href=\"#8-提升注意力\" class=\"headerlink\" title=\"8. 提升注意力\"></a>8. 提升注意力</h2><p>大脑需要稳定的血流，体操等伸展运动能促使健康的血液流向大脑，让人注意力更集中、精神更放松。</p>\n<p><strong>源于佛教的冥想被称作正念、内观或者内观禅修。</strong></p>\n<p>正念曾用于治疗焦虑症、抑郁。关注的是呼吸、旁观者的视角、接纳和不做批判的态度。</p>\n<blockquote>\n<p>通过保持旁观者的视角，养成不做评判的态度。如果你在任何时间只是旁观而不是对正在发生的事情做出反应，你就会延迟对情景的反应，移植到所有的信息都被正确的看待。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/doc/pic/item/5fdf8db1cb134954fec540815a4e9258d0094a78.jpg\" alt=\"\"></p>","more":"<h2 id=\"1-大脑重塑操作指南\"><a href=\"#1-大脑重塑操作指南\" class=\"headerlink\" title=\"1. 大脑重塑操作指南\"></a>1. 大脑重塑操作指南</h2><p>本书的主要是可以让我们具备：<strong>保持镇定和积极的心态的能力。</strong></p>\n<p>定期训练思考、感知和采取行动的能力，将会重塑你的大脑，并且使你感到内心平静和精神集中。</p>\n<p>由于你的大脑不是“硬连接”，而是真真正正的“软连接”，所以你的人生经历在如何培养你的天性方面发挥了重要的作用。</p>\n<h3 id=\"1-1-大脑工作原理概述\"><a href=\"#1-1-大脑工作原理概述\" class=\"headerlink\" title=\"1.1. 大脑工作原理概述\"></a>1.1. 大脑工作原理概述</h3><p>人类的<a href=\"https://baike.baidu.com/item/%E5%A4%A7%E8%84%91/791360?fr=aladdin\" target=\"_blank\" rel=\"noopener\">大脑</a>大致结构可参见下图：<br><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f45ccc0a8618367ab984778f4f1ae0b1/4a36acaf2edda3cc38d4b90301e93901213f92e4.jpg\" alt=\"\"></p>\n<p>神经元在名为模块的大脑区域中聚集在一起，这些模块有：皮层（外层，包含两个半球(每个半球都有外侧裂以上的额叶、外侧裂以下的颞叶、顶枕裂后方的枕叶)）、4个叶和皮层下模块。大脑中名为<a href=\"https://baike.baidu.com/item/%E8%83%BC%E8%83%9D%E4%BD%93\" target=\"_blank\" rel=\"noopener\">胼胝体(<br>pián zhī tǐ)</a>的纤维束将这个半球连接在一起，同时激发两个神经元联系起来。</p>\n<h3 id=\"1-2-神经元和神经递质简介\"><a href=\"#1-2-神经元和神经递质简介\" class=\"headerlink\" title=\"1.2. 神经元和神经递质简介\"></a>1.2. 神经元和神经递质简介</h3><p>神经元的功能部分依赖于化学作用，部分依赖于时短时续的脉冲放电激活。神经元相互之间通过发送神经递质这种化学信号，跨越突触间的间隙交流。</p>\n<h3 id=\"1-3-神经可塑性的功能\"><a href=\"#1-3-神经可塑性的功能\" class=\"headerlink\" title=\"1.3. 神经可塑性的功能\"></a>1.3. 神经可塑性的功能</h3><p>大量的证据表明突触突不是硬连接的，而是在变动之中，这就是突触可塑性或叫神经可塑性的含义。同时，他也证明了<strong>用进废退</strong>的道理，当你连接上体现某想技能的突触时，就是在强化这项技能。</p>\n<p><strong>不仅行为可以借助神经可塑性改变大脑结构，就算只是思考或想象某种行为也能改变大脑结构。</strong></p>\n<p>“<strong>给予就是获得</strong>”是脑神经的一条真理。感觉迟钝和自私自利对大脑和心里健康都是有害的，相反，同情和关爱更有益。</p>\n<p><strong>通过冥想和祈祷的平静和精神集中的练习将使大脑线路连接起来，有益于健康。</strong></p>\n<h3 id=\"1-4-重塑大脑的4个步骤\"><a href=\"#1-4-重塑大脑的4个步骤\" class=\"headerlink\" title=\"1.4.重塑大脑的4个步骤\"></a>1.4.重塑大脑的4个步骤</h3><p>简称为FEED</p>\n<ul>\n<li>聚精会神(Focus)</li>\n<li>努力练习(Effort)</li>\n<li>轻松自如(Effortlessness)</li>\n<li>坚持不懈(Determination)</li>\n</ul>\n<p>注意力和额叶在神经可塑性方面扮演着重要角色， 前额叶皮层相当于大脑的大脑。</p>\n<p>努力练习将使注意力从感知转移到行动上，尽量使你的大脑活跃起来，从而产生新的突触连接（刻意练习，使得它变成一个新习惯）。为达到重塑大脑的目的，你必须使新行为保持足够长的时间，直到新行为变成你下意识的动作。</p>\n<h2 id=\"2-如何赶走焦虑情绪？\"><a href=\"#2-如何赶走焦虑情绪？\" class=\"headerlink\" title=\"2. 如何赶走焦虑情绪？\"></a>2. 如何赶走焦虑情绪？</h2><p>一般遇到警报，杏仁核给下丘脑（负责许多新陈代谢过程并涉及自主神经系统）发出信号，它又给脑垂体发出信号，脑垂体又给肾上腺发出信号，释放出肾上腺素和皮质醇（它是比肾上腺素更能让你保持长久兴奋的应激激素），这一系列使得身体系统发生波动，造成呼吸加快，心跳加速，血压升高，这就是“战或逃反应”。<strong>杏仁核，本能的天使，现实的魔鬼。</strong></p>\n<p><strong>适度的焦虑有益于神经可塑性</strong>。在过度焦虑和不焦虑之间保持平衡对于学习和记忆是最好的选择，这种平衡关系呈“倒U形”曲线，也叫作”<a href=\"https://baike.baidu.com/item/%E8%80%B6%E5%85%8B%E6%96%AF-%E5%A4%9A%E5%BE%B7%E6%A3%AE%E5%AE%9A%E5%BE%8B/5723839?fr=aladdin\" target=\"_blank\" rel=\"noopener\">耶克斯-多德深曲线</a>“。</p>\n<p><strong>深度呼吸</strong><br>吸吸入更多氧气，降低血液中二氧化碳的含量（它有维持血液中PH值，PH值越低，你的神经元越兴奋，就会越感到紧张）。</p>\n<p><strong>不逃避</strong><br>从长远看，<strong>不逃避并尽可能面对事情可以减轻焦虑</strong>。 用”暴露法”取代逃避，即直面让你感到焦虑的事情，不断地将自己暴露在宁你焦虑达的情境下，让自己习以为常，最终减弱焦虑。</p>\n<h2 id=\"3-如何摆脱负面情绪\"><a href=\"#3-如何摆脱负面情绪\" class=\"headerlink\" title=\"3.如何摆脱负面情绪\"></a>3.如何摆脱负面情绪</h2><p>左额叶增进积极乐观的心态并促使你采取行动，而右额叶则会使你逆来顺受，加重消极的情绪。</p>\n<p>常用促使积极心态的产生：</p>\n<ul>\n<li>激发积极的情绪  </li>\n<li>多晒太阳  </li>\n<li>运动改变心情 </li>\n<li>以乐观的方式解读生活  </li>\n<li>打造积极思维  </li>\n<li>社交疗法  </li>\n<li>采取行动 </li>\n</ul>\n<p>常常微笑确实有帮助，它是这样发挥作用的：神经通路连接着面部肌肉、脑神经、皮层下区域和皮层。信息从大脑传向面部，也会传回大脑。例如，如果你收缩右脸的肌肉让你的左脑活跃起来，极可能产生积极的情绪。</p>\n<p>运动可以促进血液的氧合作用，也会降低体内的酸性水平。</p>\n<p>右脑更具全局性，也更情绪化，对主体本质和自传体记忆具有意义。但他也需要左脑，它是你生活经历的解读器，输入细节和积极的心态，帮助理解你理解你的体验。</p>\n<p>当你被另外一个人吸引时，神经递质多巴胺被激活，产生愉悦感。积极的人际关系引发积极的情绪。</p>\n<p><strong>积极的情绪模式不仅代表着更多快乐，它也需要更多的实践。如果情绪是积极的，你将更倾向于思考可能性和潜在性，把迎接生活中的挑战视为活力的释放。</strong></p>\n<h2 id=\"4-如何增强记忆力\"><a href=\"#4-如何增强记忆力\" class=\"headerlink\" title=\"4. 如何增强记忆力\"></a>4. 如何增强记忆力</h2><p>工作记忆通常被称作短时记忆。工作记忆是一条通向长时记忆的必经之路。它想长时记忆”供给”记忆，长时记忆需要将工作记忆进行编码整理。</p>\n<p>身体的脂肪的增加与记忆力的减退有关。</p>\n<ul>\n<li>提升注意力  </li>\n<li>学会运用不用类型的记忆技巧（视觉系，听觉系）  </li>\n<li><strong>利用联系法</strong></li>\n</ul>\n<blockquote>\n<p>使用联系法是一个特别有效的方式，就是将你想记住的东西与一个视觉影像联系起来。视觉联系之所以有效，是因为人们石峰擅长记忆非同寻常的视觉影像。</p>\n</blockquote>\n<p>随着你开始描述事件，你会想起围绕该事件的相关记忆，激活一个完整的联想链，并重新激发了一个更叫宽广的记忆范围，这是因为记忆就是在大的神经元群之间建立突触连接。</p>\n<p><strong>不管你处于什么年龄段，都应该不断挑战自我。</strong> 树突分枝会刺激神经元产生更多的连接。</p>\n<ul>\n<li>阅读费小说类的书籍  </li>\n<li>选修其他课程  </li>\n<li>旅游  </li>\n<li>参加由启发性的对话和辩论</li>\n</ul>\n<blockquote>\n<p>练习专注于一项活动，而且时间要越来越久。不要同时做好几件事，也不要从一件事情快速跳转到另一件事上。要让自己沉寂到感兴趣的某项活动之中，而且要全身心地投入。</p>\n</blockquote>\n<h2 id=\"5-合理安排饮食\"><a href=\"#5-合理安排饮食\" class=\"headerlink\" title=\"5.合理安排饮食\"></a>5.合理安排饮食</h2><p>氨基酸是神经递质的关键构成要素。 维生素C,E 是主要的抗氧化物。</p>\n<h2 id=\"6-改善睡眠\"><a href=\"#6-改善睡眠\" class=\"headerlink\" title=\"6.改善睡眠\"></a>6.改善睡眠</h2><p>电脑，手机的使用，会让视网膜感受光信号，大脑误认这是白天而不是夜晚，从而抑制了睡眠激素褪黑素的生成。</p>\n<p>运动是一剂良药。运动向大脑输送了更多的氧，改善了毛细血管的健康状况。通过提高心血系统的效率，运动使血压下降。</p>\n<h2 id=\"7-坚毅的心态\"><a href=\"#7-坚毅的心态\" class=\"headerlink\" title=\"7. 坚毅的心态\"></a>7. 坚毅的心态</h2><p><strong>心态点亮你的未来</strong><br>心理韧性面对逆境心存希望，竭尽所能促使转机出现，逆境变成顺境。</p>\n<p>通过冥想来培养积极心态和乐观情绪的人，其心理韧性更强。</p>\n<p>你培养的幽默感应当是积极向上的。</p>\n<h2 id=\"8-提升注意力\"><a href=\"#8-提升注意力\" class=\"headerlink\" title=\"8. 提升注意力\"></a>8. 提升注意力</h2><p>大脑需要稳定的血流，体操等伸展运动能促使健康的血液流向大脑，让人注意力更集中、精神更放松。</p>\n<p><strong>源于佛教的冥想被称作正念、内观或者内观禅修。</strong></p>\n<p>正念曾用于治疗焦虑症、抑郁。关注的是呼吸、旁观者的视角、接纳和不做批判的态度。</p>\n<blockquote>\n<p>通过保持旁观者的视角，养成不做评判的态度。如果你在任何时间只是旁观而不是对正在发生的事情做出反应，你就会延迟对情景的反应，移植到所有的信息都被正确的看待。</p>\n</blockquote>"},{"title":"史蒂夫.乔布斯传","date":"2019-04-16T14:18:35.000Z","_content":"\n他去印度追寻过佛，热衷于冥想；  \n他创立了苹果，Next，皮克斯公司； \n他推出了iMac, iPod, iPhone, iPad，iCloud产品;  \n他创建了iTunes, Apple Stores。\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=fa9cc120564e9258b2398ebcfdebba3d/8718367adab44aedddcc97a0b31c8701a08bfbf0.jpg)\n\n[史蒂夫·乔布斯传](https://baike.baidu.com/item/%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0/3751106?fr=aladdin), 是史蒂夫·乔布斯唯一授权的官方传记。\n\n<!--more-->\n\n## 1. 童年\n\n我父亲信奉诚实，极端的诚实。那是他教我的最重要的事。\n\n\"他拒绝机械的接受事实，任何事情他都要亲自检验。\" (辩证地接受事实)\n\n乔布斯总是有有意识地将自己置身于艺术与科技的交汇处。（紧邻科学与美）\n\n__\"求知若饥，虚心若愚 (Stay hungry, stay foolish) \"__ (文学翻译的艺术)\n\n印度古老的谚语中： __在人生的头30年里，你培养习惯；在后30年，习惯塑造你。__\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=e948e7bdc88065386fe7ac41f6b4ca21/8694a4c27d1ed21b74af4c16af6eddc450da3fda.jpg)\n\n禅修增强了乔布斯对直觉的信赖，教他如何过滤掉任何分散精力或不必要的事情。\n\n## 2. Apple I && Apple II\n 乔布斯的父亲教导他，最求完美意味着：__即便是别人看不到的地方，对其工艺也必须尽心尽力。__  （追求完美的执着性，不在于是否有人注意到）\n\n >你永远不该怀着赚钱的目的去创办一家公司，你的目标应该是做出让你自己深信不疑的产品，创办一家生命力很强的公司。\n\n 创建产品强调的三个点：\n - 共鸣，紧密结合顾客的感受  \n - 专注，为了做好我们决定做的事，拒绝所有不重要的激活  \n - 灌输，人们是根据公司或产品传达的信号，形成对他的判断（如果我们以创新、专业的方式展示产品，那优秀的形象也被灌输到顾客的思想中）  \n\n__至繁归于至简(Simple is the best)__\n\n\n天文学家[约翰尼斯·开普勒](https://baike.baidu.com/item/%E7%BA%A6%E7%BF%B0%E5%B0%BC%E6%96%AF%C2%B7%E5%BC%80%E6%99%AE%E5%8B%92/973574)：“__自然喜欢简洁与统一__”。  \n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=a9cf1122aeefce1bfe26c098ce3898bb/b2de9c82d158ccbf55a1e7ee10d8bc3eb03541c0.jpg)\n\n__预见未来最好的方式就是亲手创造未来（The best way to predict the future is to invent it）__  \n\n## 3. 苹果零售店Apple Stores && iTunes && iPad\n\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=0caaa0e82f2eb938f86072a0b40bee50/d043ad4bd11373f0da4fcc96a40f4bfbfbed0442.jpg)\n\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=7c9068d3b751f819e5280b18bbdd2188/0bd162d9f2d3572c545d72248d13632763d0c38f.jpg)\n\n如果你发现有些事做得不对，你不能只是忽略它，然后说：“以后再处理”，这是其他公司的做法。\n\n把关注点放在真正有价值的地方，以及革命性的营销手段。\n\n努力融合科技和人文艺术。\n\n## 4. 遗产 Legacy\n乔布斯没有直接发明很多东西，但他用大师级的手法把 __理念、艺术和科技融合在一起，就创造了未来。__\n\n>我的激情所在是打造一家可以传世的公司，这家公司里的人动力十足地创造伟大的产品，其他一切都是第二位的。当然，能赚钱很棒，因为那样你才能制造很伟大的产品。但是动力来自产品，而不是利润。\n\n>我们的责任是提前一步搞清他们将来要什么，而不是消费者想要什么就给他什么。\n(提前准备，塑造、引领未来)\n\n>我们试图用我们仅有的天分去表达我们深层的感受，去表达我们对前人所有贡献的感激，去为历史长河加上一点什么，那就是推动我的力量。\n(感恩，在历史长河上留下自己曾来到这个世界的足迹)\n\n","source":"_posts/史蒂夫-乔布斯传.md","raw":"---\ntitle: 史蒂夫.乔布斯传\ndate: 2019-04-16 22:18:35\ntags: bookmarks\ncategories: bookmarks\n---\n\n他去印度追寻过佛，热衷于冥想；  \n他创立了苹果，Next，皮克斯公司； \n他推出了iMac, iPod, iPhone, iPad，iCloud产品;  \n他创建了iTunes, Apple Stores。\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=fa9cc120564e9258b2398ebcfdebba3d/8718367adab44aedddcc97a0b31c8701a08bfbf0.jpg)\n\n[史蒂夫·乔布斯传](https://baike.baidu.com/item/%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0/3751106?fr=aladdin), 是史蒂夫·乔布斯唯一授权的官方传记。\n\n<!--more-->\n\n## 1. 童年\n\n我父亲信奉诚实，极端的诚实。那是他教我的最重要的事。\n\n\"他拒绝机械的接受事实，任何事情他都要亲自检验。\" (辩证地接受事实)\n\n乔布斯总是有有意识地将自己置身于艺术与科技的交汇处。（紧邻科学与美）\n\n__\"求知若饥，虚心若愚 (Stay hungry, stay foolish) \"__ (文学翻译的艺术)\n\n印度古老的谚语中： __在人生的头30年里，你培养习惯；在后30年，习惯塑造你。__\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=e948e7bdc88065386fe7ac41f6b4ca21/8694a4c27d1ed21b74af4c16af6eddc450da3fda.jpg)\n\n禅修增强了乔布斯对直觉的信赖，教他如何过滤掉任何分散精力或不必要的事情。\n\n## 2. Apple I && Apple II\n 乔布斯的父亲教导他，最求完美意味着：__即便是别人看不到的地方，对其工艺也必须尽心尽力。__  （追求完美的执着性，不在于是否有人注意到）\n\n >你永远不该怀着赚钱的目的去创办一家公司，你的目标应该是做出让你自己深信不疑的产品，创办一家生命力很强的公司。\n\n 创建产品强调的三个点：\n - 共鸣，紧密结合顾客的感受  \n - 专注，为了做好我们决定做的事，拒绝所有不重要的激活  \n - 灌输，人们是根据公司或产品传达的信号，形成对他的判断（如果我们以创新、专业的方式展示产品，那优秀的形象也被灌输到顾客的思想中）  \n\n__至繁归于至简(Simple is the best)__\n\n\n天文学家[约翰尼斯·开普勒](https://baike.baidu.com/item/%E7%BA%A6%E7%BF%B0%E5%B0%BC%E6%96%AF%C2%B7%E5%BC%80%E6%99%AE%E5%8B%92/973574)：“__自然喜欢简洁与统一__”。  \n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=a9cf1122aeefce1bfe26c098ce3898bb/b2de9c82d158ccbf55a1e7ee10d8bc3eb03541c0.jpg)\n\n__预见未来最好的方式就是亲手创造未来（The best way to predict the future is to invent it）__  \n\n## 3. 苹果零售店Apple Stores && iTunes && iPad\n\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=0caaa0e82f2eb938f86072a0b40bee50/d043ad4bd11373f0da4fcc96a40f4bfbfbed0442.jpg)\n\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=7c9068d3b751f819e5280b18bbdd2188/0bd162d9f2d3572c545d72248d13632763d0c38f.jpg)\n\n如果你发现有些事做得不对，你不能只是忽略它，然后说：“以后再处理”，这是其他公司的做法。\n\n把关注点放在真正有价值的地方，以及革命性的营销手段。\n\n努力融合科技和人文艺术。\n\n## 4. 遗产 Legacy\n乔布斯没有直接发明很多东西，但他用大师级的手法把 __理念、艺术和科技融合在一起，就创造了未来。__\n\n>我的激情所在是打造一家可以传世的公司，这家公司里的人动力十足地创造伟大的产品，其他一切都是第二位的。当然，能赚钱很棒，因为那样你才能制造很伟大的产品。但是动力来自产品，而不是利润。\n\n>我们的责任是提前一步搞清他们将来要什么，而不是消费者想要什么就给他什么。\n(提前准备，塑造、引领未来)\n\n>我们试图用我们仅有的天分去表达我们深层的感受，去表达我们对前人所有贡献的感激，去为历史长河加上一点什么，那就是推动我的力量。\n(感恩，在历史长河上留下自己曾来到这个世界的足迹)\n\n","slug":"史蒂夫-乔布斯传","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0rh004izkgr37ppd0ck","content":"<p>他去印度追寻过佛，热衷于冥想；<br>他创立了苹果，Next，皮克斯公司；<br>他推出了iMac, iPod, iPhone, iPad，iCloud产品;<br>他创建了iTunes, Apple Stores。</p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=fa9cc120564e9258b2398ebcfdebba3d/8718367adab44aedddcc97a0b31c8701a08bfbf0.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0/3751106?fr=aladdin\" target=\"_blank\" rel=\"noopener\">史蒂夫·乔布斯传</a>, 是史蒂夫·乔布斯唯一授权的官方传记。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-童年\"><a href=\"#1-童年\" class=\"headerlink\" title=\"1. 童年\"></a>1. 童年</h2><p>我父亲信奉诚实，极端的诚实。那是他教我的最重要的事。</p>\n<p>“他拒绝机械的接受事实，任何事情他都要亲自检验。” (辩证地接受事实)</p>\n<p>乔布斯总是有有意识地将自己置身于艺术与科技的交汇处。（紧邻科学与美）</p>\n<p><strong>“求知若饥，虚心若愚 (Stay hungry, stay foolish) “</strong> (文学翻译的艺术)</p>\n<p>印度古老的谚语中： <strong>在人生的头30年里，你培养习惯；在后30年，习惯塑造你。</strong></p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=e948e7bdc88065386fe7ac41f6b4ca21/8694a4c27d1ed21b74af4c16af6eddc450da3fda.jpg\" alt=\"\"></p>\n<p>禅修增强了乔布斯对直觉的信赖，教他如何过滤掉任何分散精力或不必要的事情。</p>\n<h2 id=\"2-Apple-I-amp-amp-Apple-II\"><a href=\"#2-Apple-I-amp-amp-Apple-II\" class=\"headerlink\" title=\"2. Apple I &amp;&amp; Apple II\"></a>2. Apple I &amp;&amp; Apple II</h2><p> 乔布斯的父亲教导他，最求完美意味着：<strong>即便是别人看不到的地方，对其工艺也必须尽心尽力。</strong>  （追求完美的执着性，不在于是否有人注意到）</p>\n<blockquote>\n<p>你永远不该怀着赚钱的目的去创办一家公司，你的目标应该是做出让你自己深信不疑的产品，创办一家生命力很强的公司。</p>\n</blockquote>\n<p> 创建产品强调的三个点：</p>\n<ul>\n<li>共鸣，紧密结合顾客的感受  </li>\n<li>专注，为了做好我们决定做的事，拒绝所有不重要的激活  </li>\n<li>灌输，人们是根据公司或产品传达的信号，形成对他的判断（如果我们以创新、专业的方式展示产品，那优秀的形象也被灌输到顾客的思想中）  </li>\n</ul>\n<p><strong>至繁归于至简(Simple is the best)</strong></p>\n<p>天文学家<a href=\"https://baike.baidu.com/item/%E7%BA%A6%E7%BF%B0%E5%B0%BC%E6%96%AF%C2%B7%E5%BC%80%E6%99%AE%E5%8B%92/973574\" target=\"_blank\" rel=\"noopener\">约翰尼斯·开普勒</a>：“<strong>自然喜欢简洁与统一</strong>”。<br><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=a9cf1122aeefce1bfe26c098ce3898bb/b2de9c82d158ccbf55a1e7ee10d8bc3eb03541c0.jpg\" alt=\"\"></p>\n<p><strong>预见未来最好的方式就是亲手创造未来（The best way to predict the future is to invent it）</strong>  </p>\n<h2 id=\"3-苹果零售店Apple-Stores-amp-amp-iTunes-amp-amp-iPad\"><a href=\"#3-苹果零售店Apple-Stores-amp-amp-iTunes-amp-amp-iPad\" class=\"headerlink\" title=\"3. 苹果零售店Apple Stores &amp;&amp; iTunes &amp;&amp; iPad\"></a>3. 苹果零售店Apple Stores &amp;&amp; iTunes &amp;&amp; iPad</h2><p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=0caaa0e82f2eb938f86072a0b40bee50/d043ad4bd11373f0da4fcc96a40f4bfbfbed0442.jpg\" alt=\"\"></p>\n<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=7c9068d3b751f819e5280b18bbdd2188/0bd162d9f2d3572c545d72248d13632763d0c38f.jpg\" alt=\"\"></p>\n<p>如果你发现有些事做得不对，你不能只是忽略它，然后说：“以后再处理”，这是其他公司的做法。</p>\n<p>把关注点放在真正有价值的地方，以及革命性的营销手段。</p>\n<p>努力融合科技和人文艺术。</p>\n<h2 id=\"4-遗产-Legacy\"><a href=\"#4-遗产-Legacy\" class=\"headerlink\" title=\"4. 遗产 Legacy\"></a>4. 遗产 Legacy</h2><p>乔布斯没有直接发明很多东西，但他用大师级的手法把 <strong>理念、艺术和科技融合在一起，就创造了未来。</strong></p>\n<blockquote>\n<p>我的激情所在是打造一家可以传世的公司，这家公司里的人动力十足地创造伟大的产品，其他一切都是第二位的。当然，能赚钱很棒，因为那样你才能制造很伟大的产品。但是动力来自产品，而不是利润。</p>\n</blockquote>\n<blockquote>\n<p>我们的责任是提前一步搞清他们将来要什么，而不是消费者想要什么就给他什么。<br>(提前准备，塑造、引领未来)</p>\n</blockquote>\n<blockquote>\n<p>我们试图用我们仅有的天分去表达我们深层的感受，去表达我们对前人所有贡献的感激，去为历史长河加上一点什么，那就是推动我的力量。<br>(感恩，在历史长河上留下自己曾来到这个世界的足迹)</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>他去印度追寻过佛，热衷于冥想；<br>他创立了苹果，Next，皮克斯公司；<br>他推出了iMac, iPod, iPhone, iPad，iCloud产品;<br>他创建了iTunes, Apple Stores。</p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=fa9cc120564e9258b2398ebcfdebba3d/8718367adab44aedddcc97a0b31c8701a08bfbf0.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0/3751106?fr=aladdin\" target=\"_blank\" rel=\"noopener\">史蒂夫·乔布斯传</a>, 是史蒂夫·乔布斯唯一授权的官方传记。</p>","more":"<h2 id=\"1-童年\"><a href=\"#1-童年\" class=\"headerlink\" title=\"1. 童年\"></a>1. 童年</h2><p>我父亲信奉诚实，极端的诚实。那是他教我的最重要的事。</p>\n<p>“他拒绝机械的接受事实，任何事情他都要亲自检验。” (辩证地接受事实)</p>\n<p>乔布斯总是有有意识地将自己置身于艺术与科技的交汇处。（紧邻科学与美）</p>\n<p><strong>“求知若饥，虚心若愚 (Stay hungry, stay foolish) “</strong> (文学翻译的艺术)</p>\n<p>印度古老的谚语中： <strong>在人生的头30年里，你培养习惯；在后30年，习惯塑造你。</strong></p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=e948e7bdc88065386fe7ac41f6b4ca21/8694a4c27d1ed21b74af4c16af6eddc450da3fda.jpg\" alt=\"\"></p>\n<p>禅修增强了乔布斯对直觉的信赖，教他如何过滤掉任何分散精力或不必要的事情。</p>\n<h2 id=\"2-Apple-I-amp-amp-Apple-II\"><a href=\"#2-Apple-I-amp-amp-Apple-II\" class=\"headerlink\" title=\"2. Apple I &amp;&amp; Apple II\"></a>2. Apple I &amp;&amp; Apple II</h2><p> 乔布斯的父亲教导他，最求完美意味着：<strong>即便是别人看不到的地方，对其工艺也必须尽心尽力。</strong>  （追求完美的执着性，不在于是否有人注意到）</p>\n<blockquote>\n<p>你永远不该怀着赚钱的目的去创办一家公司，你的目标应该是做出让你自己深信不疑的产品，创办一家生命力很强的公司。</p>\n</blockquote>\n<p> 创建产品强调的三个点：</p>\n<ul>\n<li>共鸣，紧密结合顾客的感受  </li>\n<li>专注，为了做好我们决定做的事，拒绝所有不重要的激活  </li>\n<li>灌输，人们是根据公司或产品传达的信号，形成对他的判断（如果我们以创新、专业的方式展示产品，那优秀的形象也被灌输到顾客的思想中）  </li>\n</ul>\n<p><strong>至繁归于至简(Simple is the best)</strong></p>\n<p>天文学家<a href=\"https://baike.baidu.com/item/%E7%BA%A6%E7%BF%B0%E5%B0%BC%E6%96%AF%C2%B7%E5%BC%80%E6%99%AE%E5%8B%92/973574\" target=\"_blank\" rel=\"noopener\">约翰尼斯·开普勒</a>：“<strong>自然喜欢简洁与统一</strong>”。<br><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=a9cf1122aeefce1bfe26c098ce3898bb/b2de9c82d158ccbf55a1e7ee10d8bc3eb03541c0.jpg\" alt=\"\"></p>\n<p><strong>预见未来最好的方式就是亲手创造未来（The best way to predict the future is to invent it）</strong>  </p>\n<h2 id=\"3-苹果零售店Apple-Stores-amp-amp-iTunes-amp-amp-iPad\"><a href=\"#3-苹果零售店Apple-Stores-amp-amp-iTunes-amp-amp-iPad\" class=\"headerlink\" title=\"3. 苹果零售店Apple Stores &amp;&amp; iTunes &amp;&amp; iPad\"></a>3. 苹果零售店Apple Stores &amp;&amp; iTunes &amp;&amp; iPad</h2><p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=0caaa0e82f2eb938f86072a0b40bee50/d043ad4bd11373f0da4fcc96a40f4bfbfbed0442.jpg\" alt=\"\"></p>\n<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=7c9068d3b751f819e5280b18bbdd2188/0bd162d9f2d3572c545d72248d13632763d0c38f.jpg\" alt=\"\"></p>\n<p>如果你发现有些事做得不对，你不能只是忽略它，然后说：“以后再处理”，这是其他公司的做法。</p>\n<p>把关注点放在真正有价值的地方，以及革命性的营销手段。</p>\n<p>努力融合科技和人文艺术。</p>\n<h2 id=\"4-遗产-Legacy\"><a href=\"#4-遗产-Legacy\" class=\"headerlink\" title=\"4. 遗产 Legacy\"></a>4. 遗产 Legacy</h2><p>乔布斯没有直接发明很多东西，但他用大师级的手法把 <strong>理念、艺术和科技融合在一起，就创造了未来。</strong></p>\n<blockquote>\n<p>我的激情所在是打造一家可以传世的公司，这家公司里的人动力十足地创造伟大的产品，其他一切都是第二位的。当然，能赚钱很棒，因为那样你才能制造很伟大的产品。但是动力来自产品，而不是利润。</p>\n</blockquote>\n<blockquote>\n<p>我们的责任是提前一步搞清他们将来要什么，而不是消费者想要什么就给他什么。<br>(提前准备，塑造、引领未来)</p>\n</blockquote>\n<blockquote>\n<p>我们试图用我们仅有的天分去表达我们深层的感受，去表达我们对前人所有贡献的感激，去为历史长河加上一点什么，那就是推动我的力量。<br>(感恩，在历史长河上留下自己曾来到这个世界的足迹)</p>\n</blockquote>"},{"title":"学习索引","date":"2020-02-20T10:21:20.000Z","top":true,"_content":"\n整理学习笔记链接 :-)\n\n<!--more-->\n\n## 1. bootloader \n[bootloader ](https://jshell07.github.io/2018/08/25/bootloader/)\n\n## 2. kernel\n### 2.1. Arch\n#### ARM\n[arm-generic-timer](https://jshell07.github.io/2019/11/27/arm-generic-timer/)\n\n### 2.2. Drivers\n#### MTD\n[Linux-Flash](https://jshell07.github.io/2018/08/22/Linux-Flash)\n[kernel_mtd ](https://jshell07.github.io/2019/06/25/kernel-mtd/)\n[kernel_ubi ](https://jshell07.github.io/2019/07/05/kernel-ubi/)\n\n#### Crypto\n[kernel-crypto-I](https://jshell07.github.io/2019/08/06/kernel-crypto-I/)\n[kernel-crypto-II](https://jshell07.github.io/2019/08/06/kernel-crypto-II/)\n[kernel-crypto-III](https://jshell07.github.io/2019/08/07/kernel-crypto-III/)\n\n#### Clock source\n[kernel-timer-system ](https://jshell07.github.io/2019/11/28/kernel-timer-system/)\n\n[tickless-idle](https://jshell07.github.io/2020/04/15/kernel-tickless-idle/)\n\n### 2.3. mm\n#### base\n[kernel_mem_base](https://jshell07.github.io/2020/03/04/kernel-mm-base/)\n\n#### cache\n[kernel_mem_cache](https://jshell07.github.io/2020/03/04/kernel-mm-cache/)\n\n#### TLB(Translation Lookaside Buffers)\n[TLB](https://jshell07.github.io/2020/03/12/kernel-tlb/)\n\n#### SLUB\n[SLUB](https://jshell07.github.io/2020/03/16/kernel-slub/)\n\n#### dma\n[kernel_dma_mem ](https://jshell07.github.io/2019/06/28/kernel-dma-mem/)\n\n#### mem map\n[kernel_virtual_addr_map](https://jshell07.github.io/2019/07/12/kernel-virtual-addr-map/)\n\n#### other\n[kernel-zero-copy](https://jshell07.github.io/2019/08/21/kernel-zero-copy/)\n\n### 2.4. filesystem\n#### ubifs\n[kernel-ubifs-design ](https://jshell07.github.io/2019/11/19/kernel-ubifs-design/\n)\n### 2.5. network\n[ipv6](https://jshell07.github.io/2019/07/03/ipv6/)\n\n### 2.6. tools\n[kernel_source_code_online ](https://jshell07.github.io/2019/08/23/kernel-source-code-online/)\n\n[buildbot ](https://jshell07.github.io/2019/07/02/buildbot/)\n类似的编译tool 还有出现在yocto 上的toaster。JAVA 应用方向上的maven。(JAVA集成工具发展ant -> maven -> gradle(新的发展趋势))\n\n[boot_time](https://jshell07.github.io/2020/04/09/boot-time-optimization/)\n[bootgraph](https://jshell07.github.io/2020/04/09/bootgraph/)\n[bootchart](https://jshell07.github.io/2020/04/09/bootchart/)\n\n[/proc/stat](https://jshell07.github.io/2020/04/10/measure-cpu-loading-by-proc-stat/)\n\n## 3. 设计模式\n[Design_Pattern ](https://jshell07.github.io/2018/07/12/Design-Pattern/)\n[Design_Pattern_II ](https://jshell07.github.io/2019/01/28/Design-Pattern-II/)\n[Design_Pattern_III](https://jshell07.github.io/2019/01/28/Design-Pattern-III/)\n\n## 4. 敏捷开发\n[敏捷软件开发原则与模式及实践 ](https://jshell07.github.io/2018/06/04/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E8%B7%B5/)\n\n## 5. UML\n[C++_UML ](https://jshell07.github.io/2017/12/14/C-UML/)\n\n\n## 6. Docker\n[Docker 简单介绍 ](https://jshell07.github.io/2018/06/01/Docker/)","source":"_posts/学习索引.md","raw":"---\ntitle: 学习索引\ndate: 2020-02-20 18:21:20\ntags:\ncategories: \ntop: true\n---\n\n整理学习笔记链接 :-)\n\n<!--more-->\n\n## 1. bootloader \n[bootloader ](https://jshell07.github.io/2018/08/25/bootloader/)\n\n## 2. kernel\n### 2.1. Arch\n#### ARM\n[arm-generic-timer](https://jshell07.github.io/2019/11/27/arm-generic-timer/)\n\n### 2.2. Drivers\n#### MTD\n[Linux-Flash](https://jshell07.github.io/2018/08/22/Linux-Flash)\n[kernel_mtd ](https://jshell07.github.io/2019/06/25/kernel-mtd/)\n[kernel_ubi ](https://jshell07.github.io/2019/07/05/kernel-ubi/)\n\n#### Crypto\n[kernel-crypto-I](https://jshell07.github.io/2019/08/06/kernel-crypto-I/)\n[kernel-crypto-II](https://jshell07.github.io/2019/08/06/kernel-crypto-II/)\n[kernel-crypto-III](https://jshell07.github.io/2019/08/07/kernel-crypto-III/)\n\n#### Clock source\n[kernel-timer-system ](https://jshell07.github.io/2019/11/28/kernel-timer-system/)\n\n[tickless-idle](https://jshell07.github.io/2020/04/15/kernel-tickless-idle/)\n\n### 2.3. mm\n#### base\n[kernel_mem_base](https://jshell07.github.io/2020/03/04/kernel-mm-base/)\n\n#### cache\n[kernel_mem_cache](https://jshell07.github.io/2020/03/04/kernel-mm-cache/)\n\n#### TLB(Translation Lookaside Buffers)\n[TLB](https://jshell07.github.io/2020/03/12/kernel-tlb/)\n\n#### SLUB\n[SLUB](https://jshell07.github.io/2020/03/16/kernel-slub/)\n\n#### dma\n[kernel_dma_mem ](https://jshell07.github.io/2019/06/28/kernel-dma-mem/)\n\n#### mem map\n[kernel_virtual_addr_map](https://jshell07.github.io/2019/07/12/kernel-virtual-addr-map/)\n\n#### other\n[kernel-zero-copy](https://jshell07.github.io/2019/08/21/kernel-zero-copy/)\n\n### 2.4. filesystem\n#### ubifs\n[kernel-ubifs-design ](https://jshell07.github.io/2019/11/19/kernel-ubifs-design/\n)\n### 2.5. network\n[ipv6](https://jshell07.github.io/2019/07/03/ipv6/)\n\n### 2.6. tools\n[kernel_source_code_online ](https://jshell07.github.io/2019/08/23/kernel-source-code-online/)\n\n[buildbot ](https://jshell07.github.io/2019/07/02/buildbot/)\n类似的编译tool 还有出现在yocto 上的toaster。JAVA 应用方向上的maven。(JAVA集成工具发展ant -> maven -> gradle(新的发展趋势))\n\n[boot_time](https://jshell07.github.io/2020/04/09/boot-time-optimization/)\n[bootgraph](https://jshell07.github.io/2020/04/09/bootgraph/)\n[bootchart](https://jshell07.github.io/2020/04/09/bootchart/)\n\n[/proc/stat](https://jshell07.github.io/2020/04/10/measure-cpu-loading-by-proc-stat/)\n\n## 3. 设计模式\n[Design_Pattern ](https://jshell07.github.io/2018/07/12/Design-Pattern/)\n[Design_Pattern_II ](https://jshell07.github.io/2019/01/28/Design-Pattern-II/)\n[Design_Pattern_III](https://jshell07.github.io/2019/01/28/Design-Pattern-III/)\n\n## 4. 敏捷开发\n[敏捷软件开发原则与模式及实践 ](https://jshell07.github.io/2018/06/04/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E8%B7%B5/)\n\n## 5. UML\n[C++_UML ](https://jshell07.github.io/2017/12/14/C-UML/)\n\n\n## 6. Docker\n[Docker 简单介绍 ](https://jshell07.github.io/2018/06/01/Docker/)","slug":"学习索引","published":1,"updated":"2020-04-15T10:03:34.445Z","_id":"ck915p0rj004lzkgrrynq29s5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>整理学习笔记链接 :-)</p>\n<a id=\"more\"></a>\n<h2 id=\"1-bootloader\"><a href=\"#1-bootloader\" class=\"headerlink\" title=\"1. bootloader\"></a>1. bootloader</h2><p><a href=\"https://jshell07.github.io/2018/08/25/bootloader/\" target=\"_blank\" rel=\"noopener\">bootloader </a></p>\n<h2 id=\"2-kernel\"><a href=\"#2-kernel\" class=\"headerlink\" title=\"2. kernel\"></a>2. kernel</h2><h3 id=\"2-1-Arch\"><a href=\"#2-1-Arch\" class=\"headerlink\" title=\"2.1. Arch\"></a>2.1. Arch</h3><h4 id=\"ARM\"><a href=\"#ARM\" class=\"headerlink\" title=\"ARM\"></a>ARM</h4><p><a href=\"https://jshell07.github.io/2019/11/27/arm-generic-timer/\" target=\"_blank\" rel=\"noopener\">arm-generic-timer</a></p>\n<h3 id=\"2-2-Drivers\"><a href=\"#2-2-Drivers\" class=\"headerlink\" title=\"2.2. Drivers\"></a>2.2. Drivers</h3><h4 id=\"MTD\"><a href=\"#MTD\" class=\"headerlink\" title=\"MTD\"></a>MTD</h4><p><a href=\"https://jshell07.github.io/2018/08/22/Linux-Flash\" target=\"_blank\" rel=\"noopener\">Linux-Flash</a><br><a href=\"https://jshell07.github.io/2019/06/25/kernel-mtd/\" target=\"_blank\" rel=\"noopener\">kernel_mtd </a><br><a href=\"https://jshell07.github.io/2019/07/05/kernel-ubi/\" target=\"_blank\" rel=\"noopener\">kernel_ubi </a></p>\n<h4 id=\"Crypto\"><a href=\"#Crypto\" class=\"headerlink\" title=\"Crypto\"></a>Crypto</h4><p><a href=\"https://jshell07.github.io/2019/08/06/kernel-crypto-I/\" target=\"_blank\" rel=\"noopener\">kernel-crypto-I</a><br><a href=\"https://jshell07.github.io/2019/08/06/kernel-crypto-II/\" target=\"_blank\" rel=\"noopener\">kernel-crypto-II</a><br><a href=\"https://jshell07.github.io/2019/08/07/kernel-crypto-III/\" target=\"_blank\" rel=\"noopener\">kernel-crypto-III</a></p>\n<h4 id=\"Clock-source\"><a href=\"#Clock-source\" class=\"headerlink\" title=\"Clock source\"></a>Clock source</h4><p><a href=\"https://jshell07.github.io/2019/11/28/kernel-timer-system/\" target=\"_blank\" rel=\"noopener\">kernel-timer-system </a></p>\n<p><a href=\"https://jshell07.github.io/2020/04/15/kernel-tickless-idle/\" target=\"_blank\" rel=\"noopener\">tickless-idle</a></p>\n<h3 id=\"2-3-mm\"><a href=\"#2-3-mm\" class=\"headerlink\" title=\"2.3. mm\"></a>2.3. mm</h3><h4 id=\"base\"><a href=\"#base\" class=\"headerlink\" title=\"base\"></a>base</h4><p><a href=\"https://jshell07.github.io/2020/03/04/kernel-mm-base/\" target=\"_blank\" rel=\"noopener\">kernel_mem_base</a></p>\n<h4 id=\"cache\"><a href=\"#cache\" class=\"headerlink\" title=\"cache\"></a>cache</h4><p><a href=\"https://jshell07.github.io/2020/03/04/kernel-mm-cache/\" target=\"_blank\" rel=\"noopener\">kernel_mem_cache</a></p>\n<h4 id=\"TLB-Translation-Lookaside-Buffers\"><a href=\"#TLB-Translation-Lookaside-Buffers\" class=\"headerlink\" title=\"TLB(Translation Lookaside Buffers)\"></a>TLB(Translation Lookaside Buffers)</h4><p><a href=\"https://jshell07.github.io/2020/03/12/kernel-tlb/\" target=\"_blank\" rel=\"noopener\">TLB</a></p>\n<h4 id=\"SLUB\"><a href=\"#SLUB\" class=\"headerlink\" title=\"SLUB\"></a>SLUB</h4><p><a href=\"https://jshell07.github.io/2020/03/16/kernel-slub/\" target=\"_blank\" rel=\"noopener\">SLUB</a></p>\n<h4 id=\"dma\"><a href=\"#dma\" class=\"headerlink\" title=\"dma\"></a>dma</h4><p><a href=\"https://jshell07.github.io/2019/06/28/kernel-dma-mem/\" target=\"_blank\" rel=\"noopener\">kernel_dma_mem </a></p>\n<h4 id=\"mem-map\"><a href=\"#mem-map\" class=\"headerlink\" title=\"mem map\"></a>mem map</h4><p><a href=\"https://jshell07.github.io/2019/07/12/kernel-virtual-addr-map/\" target=\"_blank\" rel=\"noopener\">kernel_virtual_addr_map</a></p>\n<h4 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h4><p><a href=\"https://jshell07.github.io/2019/08/21/kernel-zero-copy/\" target=\"_blank\" rel=\"noopener\">kernel-zero-copy</a></p>\n<h3 id=\"2-4-filesystem\"><a href=\"#2-4-filesystem\" class=\"headerlink\" title=\"2.4. filesystem\"></a>2.4. filesystem</h3><h4 id=\"ubifs\"><a href=\"#ubifs\" class=\"headerlink\" title=\"ubifs\"></a>ubifs</h4><p><a href=\"https://jshell07.github.io/2019/11/19/kernel-ubifs-design/\" target=\"_blank\" rel=\"noopener\">kernel-ubifs-design </a></p>\n<h3 id=\"2-5-network\"><a href=\"#2-5-network\" class=\"headerlink\" title=\"2.5. network\"></a>2.5. network</h3><p><a href=\"https://jshell07.github.io/2019/07/03/ipv6/\" target=\"_blank\" rel=\"noopener\">ipv6</a></p>\n<h3 id=\"2-6-tools\"><a href=\"#2-6-tools\" class=\"headerlink\" title=\"2.6. tools\"></a>2.6. tools</h3><p><a href=\"https://jshell07.github.io/2019/08/23/kernel-source-code-online/\" target=\"_blank\" rel=\"noopener\">kernel_source_code_online </a></p>\n<p><a href=\"https://jshell07.github.io/2019/07/02/buildbot/\" target=\"_blank\" rel=\"noopener\">buildbot </a><br>类似的编译tool 还有出现在yocto 上的toaster。JAVA 应用方向上的maven。(JAVA集成工具发展ant -&gt; maven -&gt; gradle(新的发展趋势))</p>\n<p><a href=\"https://jshell07.github.io/2020/04/09/boot-time-optimization/\" target=\"_blank\" rel=\"noopener\">boot_time</a><br><a href=\"https://jshell07.github.io/2020/04/09/bootgraph/\" target=\"_blank\" rel=\"noopener\">bootgraph</a><br><a href=\"https://jshell07.github.io/2020/04/09/bootchart/\" target=\"_blank\" rel=\"noopener\">bootchart</a></p>\n<p><a href=\"https://jshell07.github.io/2020/04/10/measure-cpu-loading-by-proc-stat/\" target=\"_blank\" rel=\"noopener\">/proc/stat</a></p>\n<h2 id=\"3-设计模式\"><a href=\"#3-设计模式\" class=\"headerlink\" title=\"3. 设计模式\"></a>3. 设计模式</h2><p><a href=\"https://jshell07.github.io/2018/07/12/Design-Pattern/\" target=\"_blank\" rel=\"noopener\">Design_Pattern </a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-II/\" target=\"_blank\" rel=\"noopener\">Design_Pattern_II </a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-III/\" target=\"_blank\" rel=\"noopener\">Design_Pattern_III</a></p>\n<h2 id=\"4-敏捷开发\"><a href=\"#4-敏捷开发\" class=\"headerlink\" title=\"4. 敏捷开发\"></a>4. 敏捷开发</h2><p><a href=\"https://jshell07.github.io/2018/06/04/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E8%B7%B5/\" target=\"_blank\" rel=\"noopener\">敏捷软件开发原则与模式及实践 </a></p>\n<h2 id=\"5-UML\"><a href=\"#5-UML\" class=\"headerlink\" title=\"5. UML\"></a>5. UML</h2><p><a href=\"https://jshell07.github.io/2017/12/14/C-UML/\" target=\"_blank\" rel=\"noopener\">C++_UML </a></p>\n<h2 id=\"6-Docker\"><a href=\"#6-Docker\" class=\"headerlink\" title=\"6. Docker\"></a>6. Docker</h2><p><a href=\"https://jshell07.github.io/2018/06/01/Docker/\" target=\"_blank\" rel=\"noopener\">Docker 简单介绍 </a></p>\n","site":{"data":{}},"excerpt":"<p>整理学习笔记链接 :-)</p>","more":"<h2 id=\"1-bootloader\"><a href=\"#1-bootloader\" class=\"headerlink\" title=\"1. bootloader\"></a>1. bootloader</h2><p><a href=\"https://jshell07.github.io/2018/08/25/bootloader/\" target=\"_blank\" rel=\"noopener\">bootloader </a></p>\n<h2 id=\"2-kernel\"><a href=\"#2-kernel\" class=\"headerlink\" title=\"2. kernel\"></a>2. kernel</h2><h3 id=\"2-1-Arch\"><a href=\"#2-1-Arch\" class=\"headerlink\" title=\"2.1. Arch\"></a>2.1. Arch</h3><h4 id=\"ARM\"><a href=\"#ARM\" class=\"headerlink\" title=\"ARM\"></a>ARM</h4><p><a href=\"https://jshell07.github.io/2019/11/27/arm-generic-timer/\" target=\"_blank\" rel=\"noopener\">arm-generic-timer</a></p>\n<h3 id=\"2-2-Drivers\"><a href=\"#2-2-Drivers\" class=\"headerlink\" title=\"2.2. Drivers\"></a>2.2. Drivers</h3><h4 id=\"MTD\"><a href=\"#MTD\" class=\"headerlink\" title=\"MTD\"></a>MTD</h4><p><a href=\"https://jshell07.github.io/2018/08/22/Linux-Flash\" target=\"_blank\" rel=\"noopener\">Linux-Flash</a><br><a href=\"https://jshell07.github.io/2019/06/25/kernel-mtd/\" target=\"_blank\" rel=\"noopener\">kernel_mtd </a><br><a href=\"https://jshell07.github.io/2019/07/05/kernel-ubi/\" target=\"_blank\" rel=\"noopener\">kernel_ubi </a></p>\n<h4 id=\"Crypto\"><a href=\"#Crypto\" class=\"headerlink\" title=\"Crypto\"></a>Crypto</h4><p><a href=\"https://jshell07.github.io/2019/08/06/kernel-crypto-I/\" target=\"_blank\" rel=\"noopener\">kernel-crypto-I</a><br><a href=\"https://jshell07.github.io/2019/08/06/kernel-crypto-II/\" target=\"_blank\" rel=\"noopener\">kernel-crypto-II</a><br><a href=\"https://jshell07.github.io/2019/08/07/kernel-crypto-III/\" target=\"_blank\" rel=\"noopener\">kernel-crypto-III</a></p>\n<h4 id=\"Clock-source\"><a href=\"#Clock-source\" class=\"headerlink\" title=\"Clock source\"></a>Clock source</h4><p><a href=\"https://jshell07.github.io/2019/11/28/kernel-timer-system/\" target=\"_blank\" rel=\"noopener\">kernel-timer-system </a></p>\n<p><a href=\"https://jshell07.github.io/2020/04/15/kernel-tickless-idle/\" target=\"_blank\" rel=\"noopener\">tickless-idle</a></p>\n<h3 id=\"2-3-mm\"><a href=\"#2-3-mm\" class=\"headerlink\" title=\"2.3. mm\"></a>2.3. mm</h3><h4 id=\"base\"><a href=\"#base\" class=\"headerlink\" title=\"base\"></a>base</h4><p><a href=\"https://jshell07.github.io/2020/03/04/kernel-mm-base/\" target=\"_blank\" rel=\"noopener\">kernel_mem_base</a></p>\n<h4 id=\"cache\"><a href=\"#cache\" class=\"headerlink\" title=\"cache\"></a>cache</h4><p><a href=\"https://jshell07.github.io/2020/03/04/kernel-mm-cache/\" target=\"_blank\" rel=\"noopener\">kernel_mem_cache</a></p>\n<h4 id=\"TLB-Translation-Lookaside-Buffers\"><a href=\"#TLB-Translation-Lookaside-Buffers\" class=\"headerlink\" title=\"TLB(Translation Lookaside Buffers)\"></a>TLB(Translation Lookaside Buffers)</h4><p><a href=\"https://jshell07.github.io/2020/03/12/kernel-tlb/\" target=\"_blank\" rel=\"noopener\">TLB</a></p>\n<h4 id=\"SLUB\"><a href=\"#SLUB\" class=\"headerlink\" title=\"SLUB\"></a>SLUB</h4><p><a href=\"https://jshell07.github.io/2020/03/16/kernel-slub/\" target=\"_blank\" rel=\"noopener\">SLUB</a></p>\n<h4 id=\"dma\"><a href=\"#dma\" class=\"headerlink\" title=\"dma\"></a>dma</h4><p><a href=\"https://jshell07.github.io/2019/06/28/kernel-dma-mem/\" target=\"_blank\" rel=\"noopener\">kernel_dma_mem </a></p>\n<h4 id=\"mem-map\"><a href=\"#mem-map\" class=\"headerlink\" title=\"mem map\"></a>mem map</h4><p><a href=\"https://jshell07.github.io/2019/07/12/kernel-virtual-addr-map/\" target=\"_blank\" rel=\"noopener\">kernel_virtual_addr_map</a></p>\n<h4 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h4><p><a href=\"https://jshell07.github.io/2019/08/21/kernel-zero-copy/\" target=\"_blank\" rel=\"noopener\">kernel-zero-copy</a></p>\n<h3 id=\"2-4-filesystem\"><a href=\"#2-4-filesystem\" class=\"headerlink\" title=\"2.4. filesystem\"></a>2.4. filesystem</h3><h4 id=\"ubifs\"><a href=\"#ubifs\" class=\"headerlink\" title=\"ubifs\"></a>ubifs</h4><p><a href=\"https://jshell07.github.io/2019/11/19/kernel-ubifs-design/\" target=\"_blank\" rel=\"noopener\">kernel-ubifs-design </a></p>\n<h3 id=\"2-5-network\"><a href=\"#2-5-network\" class=\"headerlink\" title=\"2.5. network\"></a>2.5. network</h3><p><a href=\"https://jshell07.github.io/2019/07/03/ipv6/\" target=\"_blank\" rel=\"noopener\">ipv6</a></p>\n<h3 id=\"2-6-tools\"><a href=\"#2-6-tools\" class=\"headerlink\" title=\"2.6. tools\"></a>2.6. tools</h3><p><a href=\"https://jshell07.github.io/2019/08/23/kernel-source-code-online/\" target=\"_blank\" rel=\"noopener\">kernel_source_code_online </a></p>\n<p><a href=\"https://jshell07.github.io/2019/07/02/buildbot/\" target=\"_blank\" rel=\"noopener\">buildbot </a><br>类似的编译tool 还有出现在yocto 上的toaster。JAVA 应用方向上的maven。(JAVA集成工具发展ant -&gt; maven -&gt; gradle(新的发展趋势))</p>\n<p><a href=\"https://jshell07.github.io/2020/04/09/boot-time-optimization/\" target=\"_blank\" rel=\"noopener\">boot_time</a><br><a href=\"https://jshell07.github.io/2020/04/09/bootgraph/\" target=\"_blank\" rel=\"noopener\">bootgraph</a><br><a href=\"https://jshell07.github.io/2020/04/09/bootchart/\" target=\"_blank\" rel=\"noopener\">bootchart</a></p>\n<p><a href=\"https://jshell07.github.io/2020/04/10/measure-cpu-loading-by-proc-stat/\" target=\"_blank\" rel=\"noopener\">/proc/stat</a></p>\n<h2 id=\"3-设计模式\"><a href=\"#3-设计模式\" class=\"headerlink\" title=\"3. 设计模式\"></a>3. 设计模式</h2><p><a href=\"https://jshell07.github.io/2018/07/12/Design-Pattern/\" target=\"_blank\" rel=\"noopener\">Design_Pattern </a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-II/\" target=\"_blank\" rel=\"noopener\">Design_Pattern_II </a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-III/\" target=\"_blank\" rel=\"noopener\">Design_Pattern_III</a></p>\n<h2 id=\"4-敏捷开发\"><a href=\"#4-敏捷开发\" class=\"headerlink\" title=\"4. 敏捷开发\"></a>4. 敏捷开发</h2><p><a href=\"https://jshell07.github.io/2018/06/04/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E8%B7%B5/\" target=\"_blank\" rel=\"noopener\">敏捷软件开发原则与模式及实践 </a></p>\n<h2 id=\"5-UML\"><a href=\"#5-UML\" class=\"headerlink\" title=\"5. UML\"></a>5. UML</h2><p><a href=\"https://jshell07.github.io/2017/12/14/C-UML/\" target=\"_blank\" rel=\"noopener\">C++_UML </a></p>\n<h2 id=\"6-Docker\"><a href=\"#6-Docker\" class=\"headerlink\" title=\"6. Docker\"></a>6. Docker</h2><p><a href=\"https://jshell07.github.io/2018/06/01/Docker/\" target=\"_blank\" rel=\"noopener\">Docker 简单介绍 </a></p>"},{"title":"吴晓波：年轻人如何独立思考","date":"2018-11-21T11:07:18.000Z","_content":"\n![](https://easyreadfs.nosdn.127.net/BIPHWlboTqsirR5yv4uy0g==/8796093024371903210)\n\n读《吴晓波：年轻人如何独立思考》笔记。\n\n<!--more-->\n\n## 1. 积累越多的能力越强\n\n不同的行业不同的工作可能会不一样，但是有两点是一样的：\n- 工具\n- 数据的能力\n在这个逻辑里，每个人都可能需要形成自己的方法论。\n\n**时间长了就会有规律，这是一个时间轴的规律。**\n>当第五年股票有跌掉了一个点的时候，你会告诉大家在三年前曾经跌过一次，两年前跌过一次。\n\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D480/sign=0f66771ef136afc30e0c3e6d8318eb85/4d086e061d950a7b0e21741a0cd162d9f3d3c9d3.jpg)\n任何一个人在一个行业里面，可能他是时间轴和空间轴到一个点的选择。\n\n**人和人之所以有的人很优秀，有的人不优秀，很大的原因是他们的坐标轴的时间宽度也不一样。时间宽度越长的人，积累越多的人他的能力越强。当你的时间轴空间轴建立起来以后，剩下怎么研究波动的变化**，这个时候要形成自己的一种工具--解释世界到方法或者解释行业的方法。\n\n## 2. 成长是拒绝诱惑的过程\n> 我是一个很笨的人。我就养成了很好的习惯，给我认为的一些我值得关注的企业建立档案。\n\n>人的成长是一个什么过程，我认为是一个拒绝诱惑的过程。比较好的人是像我这样，天资比较中等的，没有啥诱惑你，你就干一件事，二十年时间就干一件事，我二十年时间干财经写作。\n\n## 3. 人生跟赌博差不多\n不断训练，这个工作跟烧菜、剃头是没有任何差异的，**还是你要建立自己独特性**。**当一个人在这个行业里面具有识别性以后，他成功的一步就存在了**。\n\n## 4. 人生是一场持久站\n**靠时间熬**。\n>年轻的太早太成功很可能是一个祸害，很可能就被自己消耗光了。\n\n**正常人走的道路应该是五年做一个规划，二十年做一个周期**。二十年你在这个行业里面混不出来，也就算了，那就别混了。**就是五年可以给，不断的给自己做一个职业规划，要打持久战就是最关键的，人生其实就是一场持久战**。\n\n## 5. 再穷也要站在富人堆里\n>我进大学听的第一堂演讲题目叫做《上帝死了》。尼采写过《[查拉斯图拉如是说](https://baike.baidu.com/item/%E6%9F%A5%E6%8B%89%E5%9B%BE%E6%96%AF%E7%89%B9%E6%8B%89%E5%A6%82%E6%98%AF%E8%AF%B4/81677)》他说上帝死了。\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=d0375ef5d233c895b2739029b07a1895/b8014a90f603738d76642540b81bb051f819eca2.jpg)\n\n[尼采](https://baike.baidu.com/item/%E5%BC%97%E9%87%8C%E5%BE%B7%E9%87%8C%E5%B8%8C%C2%B7%E5%A8%81%E5%BB%89%C2%B7%E5%B0%BC%E9%87%87/2630781?fr=aladdin)\n\n你的一切都是要重新建立自己的价值观，要培养自己的独立精神是很震撼的，那天对我的一生来将是个重大的转折点。\n\n>我觉得财务独立是思想独立的前提。\n\n**要理财。人生一定要规划，必须要理财。一个人必须要学会打理自己的财富，必须要知道钱在哪里**。\n\n## 6. 天资平凡是上帝最好的礼物\n\n人必须要知道，哪幢楼一定有很好的风景，我不能说更好的风景。人不能太花心，生活上这样，工作上也是这样。\n\n**神话只有落到地上是真实的。**\n\n## 7. 60-75年出生的人最幸运\n\n当年法国人定义企业家是对资产进行重组的人，这个是在任何一个职业中都可以有的。**人生是资源不断配置，拿自己的才华和社会的资源进行不断配置的过程**。\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=6878307ed40735fa91f049bfa66a688e/cb8065380cd7912354bd0611ad345982b2b78072.jpg)\n\n[约瑟夫·熊彼特](https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%C2%B7%E7%86%8A%E5%BD%BC%E7%89%B9/5044851?fr=aladdin)：企业家就是一个具有破坏的创新精神的人。**我觉得任何一个行业的人，都需要有这样的破坏的创新的精神，有一种面对不确定世界冒险的精神。**\n\n## 8.企业家是一个冲动的动物\n\n一个人之所以他要奋斗，是因为我不满现状，我对现状不满，所以一定会有抱怨。**抱怨的方式不一样，有的人可能通过放弃自我，有的人只在口头上抱怨，但有的人积极去改变，他们用解决方法去面对这些抱怨**。\n\n## 9. 把生命浪费在美好的事务上\n一句格言是我把它当作自己人生的座右铭：**把生命浪费在美好的事务上**。","source":"_posts/年轻人如何独立思考.md","raw":"---\ntitle: 吴晓波：年轻人如何独立思考\ndate: 2018-11-21 19:07:18\ntags: bookmarks\ncategories: bookmarks\n---\n\n![](https://easyreadfs.nosdn.127.net/BIPHWlboTqsirR5yv4uy0g==/8796093024371903210)\n\n读《吴晓波：年轻人如何独立思考》笔记。\n\n<!--more-->\n\n## 1. 积累越多的能力越强\n\n不同的行业不同的工作可能会不一样，但是有两点是一样的：\n- 工具\n- 数据的能力\n在这个逻辑里，每个人都可能需要形成自己的方法论。\n\n**时间长了就会有规律，这是一个时间轴的规律。**\n>当第五年股票有跌掉了一个点的时候，你会告诉大家在三年前曾经跌过一次，两年前跌过一次。\n\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D480/sign=0f66771ef136afc30e0c3e6d8318eb85/4d086e061d950a7b0e21741a0cd162d9f3d3c9d3.jpg)\n任何一个人在一个行业里面，可能他是时间轴和空间轴到一个点的选择。\n\n**人和人之所以有的人很优秀，有的人不优秀，很大的原因是他们的坐标轴的时间宽度也不一样。时间宽度越长的人，积累越多的人他的能力越强。当你的时间轴空间轴建立起来以后，剩下怎么研究波动的变化**，这个时候要形成自己的一种工具--解释世界到方法或者解释行业的方法。\n\n## 2. 成长是拒绝诱惑的过程\n> 我是一个很笨的人。我就养成了很好的习惯，给我认为的一些我值得关注的企业建立档案。\n\n>人的成长是一个什么过程，我认为是一个拒绝诱惑的过程。比较好的人是像我这样，天资比较中等的，没有啥诱惑你，你就干一件事，二十年时间就干一件事，我二十年时间干财经写作。\n\n## 3. 人生跟赌博差不多\n不断训练，这个工作跟烧菜、剃头是没有任何差异的，**还是你要建立自己独特性**。**当一个人在这个行业里面具有识别性以后，他成功的一步就存在了**。\n\n## 4. 人生是一场持久站\n**靠时间熬**。\n>年轻的太早太成功很可能是一个祸害，很可能就被自己消耗光了。\n\n**正常人走的道路应该是五年做一个规划，二十年做一个周期**。二十年你在这个行业里面混不出来，也就算了，那就别混了。**就是五年可以给，不断的给自己做一个职业规划，要打持久战就是最关键的，人生其实就是一场持久战**。\n\n## 5. 再穷也要站在富人堆里\n>我进大学听的第一堂演讲题目叫做《上帝死了》。尼采写过《[查拉斯图拉如是说](https://baike.baidu.com/item/%E6%9F%A5%E6%8B%89%E5%9B%BE%E6%96%AF%E7%89%B9%E6%8B%89%E5%A6%82%E6%98%AF%E8%AF%B4/81677)》他说上帝死了。\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=d0375ef5d233c895b2739029b07a1895/b8014a90f603738d76642540b81bb051f819eca2.jpg)\n\n[尼采](https://baike.baidu.com/item/%E5%BC%97%E9%87%8C%E5%BE%B7%E9%87%8C%E5%B8%8C%C2%B7%E5%A8%81%E5%BB%89%C2%B7%E5%B0%BC%E9%87%87/2630781?fr=aladdin)\n\n你的一切都是要重新建立自己的价值观，要培养自己的独立精神是很震撼的，那天对我的一生来将是个重大的转折点。\n\n>我觉得财务独立是思想独立的前提。\n\n**要理财。人生一定要规划，必须要理财。一个人必须要学会打理自己的财富，必须要知道钱在哪里**。\n\n## 6. 天资平凡是上帝最好的礼物\n\n人必须要知道，哪幢楼一定有很好的风景，我不能说更好的风景。人不能太花心，生活上这样，工作上也是这样。\n\n**神话只有落到地上是真实的。**\n\n## 7. 60-75年出生的人最幸运\n\n当年法国人定义企业家是对资产进行重组的人，这个是在任何一个职业中都可以有的。**人生是资源不断配置，拿自己的才华和社会的资源进行不断配置的过程**。\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=6878307ed40735fa91f049bfa66a688e/cb8065380cd7912354bd0611ad345982b2b78072.jpg)\n\n[约瑟夫·熊彼特](https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%C2%B7%E7%86%8A%E5%BD%BC%E7%89%B9/5044851?fr=aladdin)：企业家就是一个具有破坏的创新精神的人。**我觉得任何一个行业的人，都需要有这样的破坏的创新的精神，有一种面对不确定世界冒险的精神。**\n\n## 8.企业家是一个冲动的动物\n\n一个人之所以他要奋斗，是因为我不满现状，我对现状不满，所以一定会有抱怨。**抱怨的方式不一样，有的人可能通过放弃自我，有的人只在口头上抱怨，但有的人积极去改变，他们用解决方法去面对这些抱怨**。\n\n## 9. 把生命浪费在美好的事务上\n一句格言是我把它当作自己人生的座右铭：**把生命浪费在美好的事务上**。","slug":"年轻人如何独立思考","published":1,"updated":"2019-07-08T06:16:07.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0rl004qzkgrw4lc5zre","content":"<p><img src=\"https://easyreadfs.nosdn.127.net/BIPHWlboTqsirR5yv4uy0g==/8796093024371903210\" alt=\"\"></p>\n<p>读《吴晓波：年轻人如何独立思考》笔记。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-积累越多的能力越强\"><a href=\"#1-积累越多的能力越强\" class=\"headerlink\" title=\"1. 积累越多的能力越强\"></a>1. 积累越多的能力越强</h2><p>不同的行业不同的工作可能会不一样，但是有两点是一样的：</p>\n<ul>\n<li>工具</li>\n<li>数据的能力<br>在这个逻辑里，每个人都可能需要形成自己的方法论。</li>\n</ul>\n<p><strong>时间长了就会有规律，这是一个时间轴的规律。</strong></p>\n<blockquote>\n<p>当第五年股票有跌掉了一个点的时候，你会告诉大家在三年前曾经跌过一次，两年前跌过一次。</p>\n</blockquote>\n<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D480/sign=0f66771ef136afc30e0c3e6d8318eb85/4d086e061d950a7b0e21741a0cd162d9f3d3c9d3.jpg\" alt=\"\"><br>任何一个人在一个行业里面，可能他是时间轴和空间轴到一个点的选择。</p>\n<p><strong>人和人之所以有的人很优秀，有的人不优秀，很大的原因是他们的坐标轴的时间宽度也不一样。时间宽度越长的人，积累越多的人他的能力越强。当你的时间轴空间轴建立起来以后，剩下怎么研究波动的变化</strong>，这个时候要形成自己的一种工具–解释世界到方法或者解释行业的方法。</p>\n<h2 id=\"2-成长是拒绝诱惑的过程\"><a href=\"#2-成长是拒绝诱惑的过程\" class=\"headerlink\" title=\"2. 成长是拒绝诱惑的过程\"></a>2. 成长是拒绝诱惑的过程</h2><blockquote>\n<p>我是一个很笨的人。我就养成了很好的习惯，给我认为的一些我值得关注的企业建立档案。</p>\n</blockquote>\n<blockquote>\n<p>人的成长是一个什么过程，我认为是一个拒绝诱惑的过程。比较好的人是像我这样，天资比较中等的，没有啥诱惑你，你就干一件事，二十年时间就干一件事，我二十年时间干财经写作。</p>\n</blockquote>\n<h2 id=\"3-人生跟赌博差不多\"><a href=\"#3-人生跟赌博差不多\" class=\"headerlink\" title=\"3. 人生跟赌博差不多\"></a>3. 人生跟赌博差不多</h2><p>不断训练，这个工作跟烧菜、剃头是没有任何差异的，<strong>还是你要建立自己独特性</strong>。<strong>当一个人在这个行业里面具有识别性以后，他成功的一步就存在了</strong>。</p>\n<h2 id=\"4-人生是一场持久站\"><a href=\"#4-人生是一场持久站\" class=\"headerlink\" title=\"4. 人生是一场持久站\"></a>4. 人生是一场持久站</h2><p><strong>靠时间熬</strong>。</p>\n<blockquote>\n<p>年轻的太早太成功很可能是一个祸害，很可能就被自己消耗光了。</p>\n</blockquote>\n<p><strong>正常人走的道路应该是五年做一个规划，二十年做一个周期</strong>。二十年你在这个行业里面混不出来，也就算了，那就别混了。<strong>就是五年可以给，不断的给自己做一个职业规划，要打持久战就是最关键的，人生其实就是一场持久战</strong>。</p>\n<h2 id=\"5-再穷也要站在富人堆里\"><a href=\"#5-再穷也要站在富人堆里\" class=\"headerlink\" title=\"5. 再穷也要站在富人堆里\"></a>5. 再穷也要站在富人堆里</h2><blockquote>\n<p>我进大学听的第一堂演讲题目叫做《上帝死了》。尼采写过《<a href=\"https://baike.baidu.com/item/%E6%9F%A5%E6%8B%89%E5%9B%BE%E6%96%AF%E7%89%B9%E6%8B%89%E5%A6%82%E6%98%AF%E8%AF%B4/81677\" target=\"_blank\" rel=\"noopener\">查拉斯图拉如是说</a>》他说上帝死了。</p>\n</blockquote>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=d0375ef5d233c895b2739029b07a1895/b8014a90f603738d76642540b81bb051f819eca2.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%BC%97%E9%87%8C%E5%BE%B7%E9%87%8C%E5%B8%8C%C2%B7%E5%A8%81%E5%BB%89%C2%B7%E5%B0%BC%E9%87%87/2630781?fr=aladdin\" target=\"_blank\" rel=\"noopener\">尼采</a></p>\n<p>你的一切都是要重新建立自己的价值观，要培养自己的独立精神是很震撼的，那天对我的一生来将是个重大的转折点。</p>\n<blockquote>\n<p>我觉得财务独立是思想独立的前提。</p>\n</blockquote>\n<p><strong>要理财。人生一定要规划，必须要理财。一个人必须要学会打理自己的财富，必须要知道钱在哪里</strong>。</p>\n<h2 id=\"6-天资平凡是上帝最好的礼物\"><a href=\"#6-天资平凡是上帝最好的礼物\" class=\"headerlink\" title=\"6. 天资平凡是上帝最好的礼物\"></a>6. 天资平凡是上帝最好的礼物</h2><p>人必须要知道，哪幢楼一定有很好的风景，我不能说更好的风景。人不能太花心，生活上这样，工作上也是这样。</p>\n<p><strong>神话只有落到地上是真实的。</strong></p>\n<h2 id=\"7-60-75年出生的人最幸运\"><a href=\"#7-60-75年出生的人最幸运\" class=\"headerlink\" title=\"7. 60-75年出生的人最幸运\"></a>7. 60-75年出生的人最幸运</h2><p>当年法国人定义企业家是对资产进行重组的人，这个是在任何一个职业中都可以有的。<strong>人生是资源不断配置，拿自己的才华和社会的资源进行不断配置的过程</strong>。</p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=6878307ed40735fa91f049bfa66a688e/cb8065380cd7912354bd0611ad345982b2b78072.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%C2%B7%E7%86%8A%E5%BD%BC%E7%89%B9/5044851?fr=aladdin\" target=\"_blank\" rel=\"noopener\">约瑟夫·熊彼特</a>：企业家就是一个具有破坏的创新精神的人。<strong>我觉得任何一个行业的人，都需要有这样的破坏的创新的精神，有一种面对不确定世界冒险的精神。</strong></p>\n<h2 id=\"8-企业家是一个冲动的动物\"><a href=\"#8-企业家是一个冲动的动物\" class=\"headerlink\" title=\"8.企业家是一个冲动的动物\"></a>8.企业家是一个冲动的动物</h2><p>一个人之所以他要奋斗，是因为我不满现状，我对现状不满，所以一定会有抱怨。<strong>抱怨的方式不一样，有的人可能通过放弃自我，有的人只在口头上抱怨，但有的人积极去改变，他们用解决方法去面对这些抱怨</strong>。</p>\n<h2 id=\"9-把生命浪费在美好的事务上\"><a href=\"#9-把生命浪费在美好的事务上\" class=\"headerlink\" title=\"9. 把生命浪费在美好的事务上\"></a>9. 把生命浪费在美好的事务上</h2><p>一句格言是我把它当作自己人生的座右铭：<strong>把生命浪费在美好的事务上</strong>。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://easyreadfs.nosdn.127.net/BIPHWlboTqsirR5yv4uy0g==/8796093024371903210\" alt=\"\"></p>\n<p>读《吴晓波：年轻人如何独立思考》笔记。</p>","more":"<h2 id=\"1-积累越多的能力越强\"><a href=\"#1-积累越多的能力越强\" class=\"headerlink\" title=\"1. 积累越多的能力越强\"></a>1. 积累越多的能力越强</h2><p>不同的行业不同的工作可能会不一样，但是有两点是一样的：</p>\n<ul>\n<li>工具</li>\n<li>数据的能力<br>在这个逻辑里，每个人都可能需要形成自己的方法论。</li>\n</ul>\n<p><strong>时间长了就会有规律，这是一个时间轴的规律。</strong></p>\n<blockquote>\n<p>当第五年股票有跌掉了一个点的时候，你会告诉大家在三年前曾经跌过一次，两年前跌过一次。</p>\n</blockquote>\n<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D480/sign=0f66771ef136afc30e0c3e6d8318eb85/4d086e061d950a7b0e21741a0cd162d9f3d3c9d3.jpg\" alt=\"\"><br>任何一个人在一个行业里面，可能他是时间轴和空间轴到一个点的选择。</p>\n<p><strong>人和人之所以有的人很优秀，有的人不优秀，很大的原因是他们的坐标轴的时间宽度也不一样。时间宽度越长的人，积累越多的人他的能力越强。当你的时间轴空间轴建立起来以后，剩下怎么研究波动的变化</strong>，这个时候要形成自己的一种工具–解释世界到方法或者解释行业的方法。</p>\n<h2 id=\"2-成长是拒绝诱惑的过程\"><a href=\"#2-成长是拒绝诱惑的过程\" class=\"headerlink\" title=\"2. 成长是拒绝诱惑的过程\"></a>2. 成长是拒绝诱惑的过程</h2><blockquote>\n<p>我是一个很笨的人。我就养成了很好的习惯，给我认为的一些我值得关注的企业建立档案。</p>\n</blockquote>\n<blockquote>\n<p>人的成长是一个什么过程，我认为是一个拒绝诱惑的过程。比较好的人是像我这样，天资比较中等的，没有啥诱惑你，你就干一件事，二十年时间就干一件事，我二十年时间干财经写作。</p>\n</blockquote>\n<h2 id=\"3-人生跟赌博差不多\"><a href=\"#3-人生跟赌博差不多\" class=\"headerlink\" title=\"3. 人生跟赌博差不多\"></a>3. 人生跟赌博差不多</h2><p>不断训练，这个工作跟烧菜、剃头是没有任何差异的，<strong>还是你要建立自己独特性</strong>。<strong>当一个人在这个行业里面具有识别性以后，他成功的一步就存在了</strong>。</p>\n<h2 id=\"4-人生是一场持久站\"><a href=\"#4-人生是一场持久站\" class=\"headerlink\" title=\"4. 人生是一场持久站\"></a>4. 人生是一场持久站</h2><p><strong>靠时间熬</strong>。</p>\n<blockquote>\n<p>年轻的太早太成功很可能是一个祸害，很可能就被自己消耗光了。</p>\n</blockquote>\n<p><strong>正常人走的道路应该是五年做一个规划，二十年做一个周期</strong>。二十年你在这个行业里面混不出来，也就算了，那就别混了。<strong>就是五年可以给，不断的给自己做一个职业规划，要打持久战就是最关键的，人生其实就是一场持久战</strong>。</p>\n<h2 id=\"5-再穷也要站在富人堆里\"><a href=\"#5-再穷也要站在富人堆里\" class=\"headerlink\" title=\"5. 再穷也要站在富人堆里\"></a>5. 再穷也要站在富人堆里</h2><blockquote>\n<p>我进大学听的第一堂演讲题目叫做《上帝死了》。尼采写过《<a href=\"https://baike.baidu.com/item/%E6%9F%A5%E6%8B%89%E5%9B%BE%E6%96%AF%E7%89%B9%E6%8B%89%E5%A6%82%E6%98%AF%E8%AF%B4/81677\" target=\"_blank\" rel=\"noopener\">查拉斯图拉如是说</a>》他说上帝死了。</p>\n</blockquote>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=d0375ef5d233c895b2739029b07a1895/b8014a90f603738d76642540b81bb051f819eca2.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%BC%97%E9%87%8C%E5%BE%B7%E9%87%8C%E5%B8%8C%C2%B7%E5%A8%81%E5%BB%89%C2%B7%E5%B0%BC%E9%87%87/2630781?fr=aladdin\" target=\"_blank\" rel=\"noopener\">尼采</a></p>\n<p>你的一切都是要重新建立自己的价值观，要培养自己的独立精神是很震撼的，那天对我的一生来将是个重大的转折点。</p>\n<blockquote>\n<p>我觉得财务独立是思想独立的前提。</p>\n</blockquote>\n<p><strong>要理财。人生一定要规划，必须要理财。一个人必须要学会打理自己的财富，必须要知道钱在哪里</strong>。</p>\n<h2 id=\"6-天资平凡是上帝最好的礼物\"><a href=\"#6-天资平凡是上帝最好的礼物\" class=\"headerlink\" title=\"6. 天资平凡是上帝最好的礼物\"></a>6. 天资平凡是上帝最好的礼物</h2><p>人必须要知道，哪幢楼一定有很好的风景，我不能说更好的风景。人不能太花心，生活上这样，工作上也是这样。</p>\n<p><strong>神话只有落到地上是真实的。</strong></p>\n<h2 id=\"7-60-75年出生的人最幸运\"><a href=\"#7-60-75年出生的人最幸运\" class=\"headerlink\" title=\"7. 60-75年出生的人最幸运\"></a>7. 60-75年出生的人最幸运</h2><p>当年法国人定义企业家是对资产进行重组的人，这个是在任何一个职业中都可以有的。<strong>人生是资源不断配置，拿自己的才华和社会的资源进行不断配置的过程</strong>。</p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=6878307ed40735fa91f049bfa66a688e/cb8065380cd7912354bd0611ad345982b2b78072.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%C2%B7%E7%86%8A%E5%BD%BC%E7%89%B9/5044851?fr=aladdin\" target=\"_blank\" rel=\"noopener\">约瑟夫·熊彼特</a>：企业家就是一个具有破坏的创新精神的人。<strong>我觉得任何一个行业的人，都需要有这样的破坏的创新的精神，有一种面对不确定世界冒险的精神。</strong></p>\n<h2 id=\"8-企业家是一个冲动的动物\"><a href=\"#8-企业家是一个冲动的动物\" class=\"headerlink\" title=\"8.企业家是一个冲动的动物\"></a>8.企业家是一个冲动的动物</h2><p>一个人之所以他要奋斗，是因为我不满现状，我对现状不满，所以一定会有抱怨。<strong>抱怨的方式不一样，有的人可能通过放弃自我，有的人只在口头上抱怨，但有的人积极去改变，他们用解决方法去面对这些抱怨</strong>。</p>\n<h2 id=\"9-把生命浪费在美好的事务上\"><a href=\"#9-把生命浪费在美好的事务上\" class=\"headerlink\" title=\"9. 把生命浪费在美好的事务上\"></a>9. 把生命浪费在美好的事务上</h2><p>一句格言是我把它当作自己人生的座右铭：<strong>把生命浪费在美好的事务上</strong>。</p>"},{"title":"富甲美国：沃尔玛创始人山姆.沃尔顿自传","date":"2019-04-15T15:52:02.000Z","_content":"![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b7a9bc86d20735fa85fd46ebff3864d6/8644ebf81a4c510fc548fc876659252dd52aa59a.jpg)\n\n[山姆·沃尔顿](https://baike.baidu.com/item/%E5%B1%B1%E5%A7%86%C2%B7%E6%B2%83%E5%B0%94%E9%A1%BF/2955977?fr=aladdin)\n\n<!--more-->\n\n## 序言\n零售商存在的意义，就是不断提高效率，降低中间环节的费用，为消费者创造价值。\n\n在简单的快捷、方便之外，__必须设计更加有温度、有情感的联系__。(从单纯的买卖过渡到情感纽带，以及体验式的购物)\n\n__平凡人齐心协力，完成非凡之事__。（人们往往高估了自己短期的努力效果，远远低估了尝试努力的效果）\n\n我们让自己大吃一惊，而后没过多久，我们就让全世界都大吃一惊。（怀才只有等到十月才会更明显，以及显露）\n\n## 1.重视每一分钱\n最不乱花一分钱\n>我已经对一块钱的价值有一种强烈的、根深蒂固的尊重。\n\n金钱对我的意义从来就没那么大，即使是从账目意义上也是，只要我们有足够的事物、有不错的住处，以及然子女接受良好的教育——这就是有钱了。（每个人富有，金钱自由的定义的不同点）\n\n## 2. 改变行业面貌的规律\n>母亲一定是特别能激励他人积极进取的人，因为当她告诉我，__无论做什么都应该始终尽力做到最好时，我认真听了她的话。__\n（听取正确的意见并执行）\n\n__我终是把麻烦看成挑战__ （善于解决问题而不是抱怨问题，积极面对避免拖延处理）\n\n山姆通过待人和善迎来滚滚财源。（做自己喜欢的事，能顺带赚钱更好）\n\n\n\n","source":"_posts/富甲美国：沃尔玛创始人山姆-沃尔顿自传.md","raw":"---\ntitle: 富甲美国：沃尔玛创始人山姆.沃尔顿自传\ndate: 2019-04-15 23:52:02\ntags: bookmarks\ncategories: bookmarks\n---\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b7a9bc86d20735fa85fd46ebff3864d6/8644ebf81a4c510fc548fc876659252dd52aa59a.jpg)\n\n[山姆·沃尔顿](https://baike.baidu.com/item/%E5%B1%B1%E5%A7%86%C2%B7%E6%B2%83%E5%B0%94%E9%A1%BF/2955977?fr=aladdin)\n\n<!--more-->\n\n## 序言\n零售商存在的意义，就是不断提高效率，降低中间环节的费用，为消费者创造价值。\n\n在简单的快捷、方便之外，__必须设计更加有温度、有情感的联系__。(从单纯的买卖过渡到情感纽带，以及体验式的购物)\n\n__平凡人齐心协力，完成非凡之事__。（人们往往高估了自己短期的努力效果，远远低估了尝试努力的效果）\n\n我们让自己大吃一惊，而后没过多久，我们就让全世界都大吃一惊。（怀才只有等到十月才会更明显，以及显露）\n\n## 1.重视每一分钱\n最不乱花一分钱\n>我已经对一块钱的价值有一种强烈的、根深蒂固的尊重。\n\n金钱对我的意义从来就没那么大，即使是从账目意义上也是，只要我们有足够的事物、有不错的住处，以及然子女接受良好的教育——这就是有钱了。（每个人富有，金钱自由的定义的不同点）\n\n## 2. 改变行业面貌的规律\n>母亲一定是特别能激励他人积极进取的人，因为当她告诉我，__无论做什么都应该始终尽力做到最好时，我认真听了她的话。__\n（听取正确的意见并执行）\n\n__我终是把麻烦看成挑战__ （善于解决问题而不是抱怨问题，积极面对避免拖延处理）\n\n山姆通过待人和善迎来滚滚财源。（做自己喜欢的事，能顺带赚钱更好）\n\n\n\n","slug":"富甲美国：沃尔玛创始人山姆-沃尔顿自传","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0rn004tzkgrnavkcsok","content":"<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b7a9bc86d20735fa85fd46ebff3864d6/8644ebf81a4c510fc548fc876659252dd52aa59a.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%B1%B1%E5%A7%86%C2%B7%E6%B2%83%E5%B0%94%E9%A1%BF/2955977?fr=aladdin\" target=\"_blank\" rel=\"noopener\">山姆·沃尔顿</a></p>\n<a id=\"more\"></a>\n<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>零售商存在的意义，就是不断提高效率，降低中间环节的费用，为消费者创造价值。</p>\n<p>在简单的快捷、方便之外，<strong>必须设计更加有温度、有情感的联系</strong>。(从单纯的买卖过渡到情感纽带，以及体验式的购物)</p>\n<p><strong>平凡人齐心协力，完成非凡之事</strong>。（人们往往高估了自己短期的努力效果，远远低估了尝试努力的效果）</p>\n<p>我们让自己大吃一惊，而后没过多久，我们就让全世界都大吃一惊。（怀才只有等到十月才会更明显，以及显露）</p>\n<h2 id=\"1-重视每一分钱\"><a href=\"#1-重视每一分钱\" class=\"headerlink\" title=\"1.重视每一分钱\"></a>1.重视每一分钱</h2><p>最不乱花一分钱</p>\n<blockquote>\n<p>我已经对一块钱的价值有一种强烈的、根深蒂固的尊重。</p>\n</blockquote>\n<p>金钱对我的意义从来就没那么大，即使是从账目意义上也是，只要我们有足够的事物、有不错的住处，以及然子女接受良好的教育——这就是有钱了。（每个人富有，金钱自由的定义的不同点）</p>\n<h2 id=\"2-改变行业面貌的规律\"><a href=\"#2-改变行业面貌的规律\" class=\"headerlink\" title=\"2. 改变行业面貌的规律\"></a>2. 改变行业面貌的规律</h2><blockquote>\n<p>母亲一定是特别能激励他人积极进取的人，因为当她告诉我，<strong>无论做什么都应该始终尽力做到最好时，我认真听了她的话。</strong><br>（听取正确的意见并执行）</p>\n</blockquote>\n<p><strong>我终是把麻烦看成挑战</strong> （善于解决问题而不是抱怨问题，积极面对避免拖延处理）</p>\n<p>山姆通过待人和善迎来滚滚财源。（做自己喜欢的事，能顺带赚钱更好）</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b7a9bc86d20735fa85fd46ebff3864d6/8644ebf81a4c510fc548fc876659252dd52aa59a.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%B1%B1%E5%A7%86%C2%B7%E6%B2%83%E5%B0%94%E9%A1%BF/2955977?fr=aladdin\" target=\"_blank\" rel=\"noopener\">山姆·沃尔顿</a></p>","more":"<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>零售商存在的意义，就是不断提高效率，降低中间环节的费用，为消费者创造价值。</p>\n<p>在简单的快捷、方便之外，<strong>必须设计更加有温度、有情感的联系</strong>。(从单纯的买卖过渡到情感纽带，以及体验式的购物)</p>\n<p><strong>平凡人齐心协力，完成非凡之事</strong>。（人们往往高估了自己短期的努力效果，远远低估了尝试努力的效果）</p>\n<p>我们让自己大吃一惊，而后没过多久，我们就让全世界都大吃一惊。（怀才只有等到十月才会更明显，以及显露）</p>\n<h2 id=\"1-重视每一分钱\"><a href=\"#1-重视每一分钱\" class=\"headerlink\" title=\"1.重视每一分钱\"></a>1.重视每一分钱</h2><p>最不乱花一分钱</p>\n<blockquote>\n<p>我已经对一块钱的价值有一种强烈的、根深蒂固的尊重。</p>\n</blockquote>\n<p>金钱对我的意义从来就没那么大，即使是从账目意义上也是，只要我们有足够的事物、有不错的住处，以及然子女接受良好的教育——这就是有钱了。（每个人富有，金钱自由的定义的不同点）</p>\n<h2 id=\"2-改变行业面貌的规律\"><a href=\"#2-改变行业面貌的规律\" class=\"headerlink\" title=\"2. 改变行业面貌的规律\"></a>2. 改变行业面貌的规律</h2><blockquote>\n<p>母亲一定是特别能激励他人积极进取的人，因为当她告诉我，<strong>无论做什么都应该始终尽力做到最好时，我认真听了她的话。</strong><br>（听取正确的意见并执行）</p>\n</blockquote>\n<p><strong>我终是把麻烦看成挑战</strong> （善于解决问题而不是抱怨问题，积极面对避免拖延处理）</p>\n<p>山姆通过待人和善迎来滚滚财源。（做自己喜欢的事，能顺带赚钱更好）</p>"},{"title":"快速阅读术","date":"2019-04-15T14:11:34.000Z","_content":"\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=e485b9283a4e251ff6faecaac6efa272/38dbb6fd5266d016ac95853a9d2bd40735fa3517.jpg)\n\n[快速阅读术](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E6%9C%AF/20785287)\n\n<!--more-->\n\n多读一些书，看到的世界也会不同。(You are what you read!)\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/readbook.jpg)\n\n\n### 1. 阅读速度缓慢的原因\n阅读速度与理解程度、记忆效果并不成正比。即使放慢了速度，非常仔细的阅读，也并不意味着能牢记书中的内容。\n\n__读书的真正意义，并不在于“复制100%”的原文，而是在于“邂逅1%”的收获。__\n\n>花一周时间仔细阅读一本书，一个月之后，仅能记住1%的内容。那么，同样花一周的时间，我们快速阅读10本书，一年之后，就能记住全部内容的10%，后者岂不更加理想？并非深入仔细阅读一本书，而是提高阅读量，获取其中的“知识片段”，积少成多，汇小溪已成江海。这样的理念正是阅读速度缓慢的人们所欠缺的。\n\n不奢求通过阅读一本书就获得一个大型积木块，而是先通过多读，让自己积累更多的积木碎块。\n\n记忆音符的排列、能够用乐器完美地再现旋律、背诵歌词——这些都不是聆听音乐的初衷。音乐的根本价值也不在此，而是在于听过音乐之后，对个人产生的影响和带来的改变。\n\n流水式阅读是信息大爆炸时代最合理并且可以“避免堆积”的阅读方式。\n\n### 2.养成阅读的习惯\n\n__不仅是读书，任何习惯的养成，最重要的都是在每天同一时间做这件事。__\n\n书籍可分为三种类型：\n- 不必读的书  \n- 无法快速阅读的书  \n- 可以快速阅读的书  \n\n故事性强的内容，没有必要快速阅读。\n\n无法快速阅读的书，数量通常不会太多。\n\n__丰富多彩的多读生活，9：1原则是关键__\n>不能仅有想要慢慢品读的书籍，还要尽量列入能够快速读完的书籍。\n\n为了享受阅读的过程，我们主张集中阅读一本书的时间不应该超过10天，这是一个原则。__想办法避免厌倦，也是养成阅读习惯的必要条件__.\n\n### 3.避免读后忘记\n\n只有书评人才知道的唯一妙招，“__为了写而读__”(输入与输出)\n\n让我们摒弃“将信息印刻在自己心中的”理念，将其转换成“记录在身外”。\n\n__令人心动的段落，不要记忆，要记录。__\n>准备好A4纸，读到佳处随时摘录。遇到想记住的内容，就摘抄下来。开头标明页码，之后是文章内容，如此不断累积。最好不要原封不动地抄写整个段落，而是短小精悍，将内容控制在几行之内。__一行采集__\n\n__另外，留住对“那一行\"产生共鸣的原因，回味重要段落。__\n>随着时间流逝，就会逐渐遗忘为之心动的原因，这样摘抄失去意义。\n\n__仅凭一行感想，唤醒一册记忆。__\n\n### 4.流水式阅读规则\n\n跳读，以小标题为单位。小标题用来判断这一章节是否需要阅读 。\n\n- 仔细阅读序言和目录  \n- 仅读开头和结尾的5行  \n- __确定关键词在阅读__  \n- 使用多种阅读节奏  \n\n__合理利用序言和目录，是确保高效轻松阅读体验的铁则。__  确保翻开书之前，明确目的，进行关键词搜索阅读法。\n\n### 5. 如何与书籍相遇，又如何区分他们\n打破兴趣壁垒，增加喜欢的书籍。__只选择自己想读的书籍，读书就会千篇一律.__\n\n最好每隔三个月就整理一次书架。\n","source":"_posts/快速阅读术.md","raw":"---\ntitle: 快速阅读术\ndate: 2019-04-15 22:11:34\ntags: bookmarks\ncategories: bookmarks\n---\n\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=e485b9283a4e251ff6faecaac6efa272/38dbb6fd5266d016ac95853a9d2bd40735fa3517.jpg)\n\n[快速阅读术](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E6%9C%AF/20785287)\n\n<!--more-->\n\n多读一些书，看到的世界也会不同。(You are what you read!)\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/readbook.jpg)\n\n\n### 1. 阅读速度缓慢的原因\n阅读速度与理解程度、记忆效果并不成正比。即使放慢了速度，非常仔细的阅读，也并不意味着能牢记书中的内容。\n\n__读书的真正意义，并不在于“复制100%”的原文，而是在于“邂逅1%”的收获。__\n\n>花一周时间仔细阅读一本书，一个月之后，仅能记住1%的内容。那么，同样花一周的时间，我们快速阅读10本书，一年之后，就能记住全部内容的10%，后者岂不更加理想？并非深入仔细阅读一本书，而是提高阅读量，获取其中的“知识片段”，积少成多，汇小溪已成江海。这样的理念正是阅读速度缓慢的人们所欠缺的。\n\n不奢求通过阅读一本书就获得一个大型积木块，而是先通过多读，让自己积累更多的积木碎块。\n\n记忆音符的排列、能够用乐器完美地再现旋律、背诵歌词——这些都不是聆听音乐的初衷。音乐的根本价值也不在此，而是在于听过音乐之后，对个人产生的影响和带来的改变。\n\n流水式阅读是信息大爆炸时代最合理并且可以“避免堆积”的阅读方式。\n\n### 2.养成阅读的习惯\n\n__不仅是读书，任何习惯的养成，最重要的都是在每天同一时间做这件事。__\n\n书籍可分为三种类型：\n- 不必读的书  \n- 无法快速阅读的书  \n- 可以快速阅读的书  \n\n故事性强的内容，没有必要快速阅读。\n\n无法快速阅读的书，数量通常不会太多。\n\n__丰富多彩的多读生活，9：1原则是关键__\n>不能仅有想要慢慢品读的书籍，还要尽量列入能够快速读完的书籍。\n\n为了享受阅读的过程，我们主张集中阅读一本书的时间不应该超过10天，这是一个原则。__想办法避免厌倦，也是养成阅读习惯的必要条件__.\n\n### 3.避免读后忘记\n\n只有书评人才知道的唯一妙招，“__为了写而读__”(输入与输出)\n\n让我们摒弃“将信息印刻在自己心中的”理念，将其转换成“记录在身外”。\n\n__令人心动的段落，不要记忆，要记录。__\n>准备好A4纸，读到佳处随时摘录。遇到想记住的内容，就摘抄下来。开头标明页码，之后是文章内容，如此不断累积。最好不要原封不动地抄写整个段落，而是短小精悍，将内容控制在几行之内。__一行采集__\n\n__另外，留住对“那一行\"产生共鸣的原因，回味重要段落。__\n>随着时间流逝，就会逐渐遗忘为之心动的原因，这样摘抄失去意义。\n\n__仅凭一行感想，唤醒一册记忆。__\n\n### 4.流水式阅读规则\n\n跳读，以小标题为单位。小标题用来判断这一章节是否需要阅读 。\n\n- 仔细阅读序言和目录  \n- 仅读开头和结尾的5行  \n- __确定关键词在阅读__  \n- 使用多种阅读节奏  \n\n__合理利用序言和目录，是确保高效轻松阅读体验的铁则。__  确保翻开书之前，明确目的，进行关键词搜索阅读法。\n\n### 5. 如何与书籍相遇，又如何区分他们\n打破兴趣壁垒，增加喜欢的书籍。__只选择自己想读的书籍，读书就会千篇一律.__\n\n最好每隔三个月就整理一次书架。\n","slug":"快速阅读术","published":1,"updated":"2019-07-08T06:16:07.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0rw004yzkgr0a3vzzn4","content":"<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=e485b9283a4e251ff6faecaac6efa272/38dbb6fd5266d016ac95853a9d2bd40735fa3517.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E6%9C%AF/20785287\" target=\"_blank\" rel=\"noopener\">快速阅读术</a></p>\n<a id=\"more\"></a>\n<p>多读一些书，看到的世界也会不同。(You are what you read!)<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/readbook.jpg\" alt=\"\"></p>\n<h3 id=\"1-阅读速度缓慢的原因\"><a href=\"#1-阅读速度缓慢的原因\" class=\"headerlink\" title=\"1. 阅读速度缓慢的原因\"></a>1. 阅读速度缓慢的原因</h3><p>阅读速度与理解程度、记忆效果并不成正比。即使放慢了速度，非常仔细的阅读，也并不意味着能牢记书中的内容。</p>\n<p><strong>读书的真正意义，并不在于“复制100%”的原文，而是在于“邂逅1%”的收获。</strong></p>\n<blockquote>\n<p>花一周时间仔细阅读一本书，一个月之后，仅能记住1%的内容。那么，同样花一周的时间，我们快速阅读10本书，一年之后，就能记住全部内容的10%，后者岂不更加理想？并非深入仔细阅读一本书，而是提高阅读量，获取其中的“知识片段”，积少成多，汇小溪已成江海。这样的理念正是阅读速度缓慢的人们所欠缺的。</p>\n</blockquote>\n<p>不奢求通过阅读一本书就获得一个大型积木块，而是先通过多读，让自己积累更多的积木碎块。</p>\n<p>记忆音符的排列、能够用乐器完美地再现旋律、背诵歌词——这些都不是聆听音乐的初衷。音乐的根本价值也不在此，而是在于听过音乐之后，对个人产生的影响和带来的改变。</p>\n<p>流水式阅读是信息大爆炸时代最合理并且可以“避免堆积”的阅读方式。</p>\n<h3 id=\"2-养成阅读的习惯\"><a href=\"#2-养成阅读的习惯\" class=\"headerlink\" title=\"2.养成阅读的习惯\"></a>2.养成阅读的习惯</h3><p><strong>不仅是读书，任何习惯的养成，最重要的都是在每天同一时间做这件事。</strong></p>\n<p>书籍可分为三种类型：</p>\n<ul>\n<li>不必读的书  </li>\n<li>无法快速阅读的书  </li>\n<li>可以快速阅读的书  </li>\n</ul>\n<p>故事性强的内容，没有必要快速阅读。</p>\n<p>无法快速阅读的书，数量通常不会太多。</p>\n<p><strong>丰富多彩的多读生活，9：1原则是关键</strong></p>\n<blockquote>\n<p>不能仅有想要慢慢品读的书籍，还要尽量列入能够快速读完的书籍。</p>\n</blockquote>\n<p>为了享受阅读的过程，我们主张集中阅读一本书的时间不应该超过10天，这是一个原则。<strong>想办法避免厌倦，也是养成阅读习惯的必要条件</strong>.</p>\n<h3 id=\"3-避免读后忘记\"><a href=\"#3-避免读后忘记\" class=\"headerlink\" title=\"3.避免读后忘记\"></a>3.避免读后忘记</h3><p>只有书评人才知道的唯一妙招，“<strong>为了写而读</strong>”(输入与输出)</p>\n<p>让我们摒弃“将信息印刻在自己心中的”理念，将其转换成“记录在身外”。</p>\n<p><strong>令人心动的段落，不要记忆，要记录。</strong></p>\n<blockquote>\n<p>准备好A4纸，读到佳处随时摘录。遇到想记住的内容，就摘抄下来。开头标明页码，之后是文章内容，如此不断累积。最好不要原封不动地抄写整个段落，而是短小精悍，将内容控制在几行之内。<strong>一行采集</strong></p>\n</blockquote>\n<p><strong>另外，留住对“那一行”产生共鸣的原因，回味重要段落。</strong></p>\n<blockquote>\n<p>随着时间流逝，就会逐渐遗忘为之心动的原因，这样摘抄失去意义。</p>\n</blockquote>\n<p><strong>仅凭一行感想，唤醒一册记忆。</strong></p>\n<h3 id=\"4-流水式阅读规则\"><a href=\"#4-流水式阅读规则\" class=\"headerlink\" title=\"4.流水式阅读规则\"></a>4.流水式阅读规则</h3><p>跳读，以小标题为单位。小标题用来判断这一章节是否需要阅读 。</p>\n<ul>\n<li>仔细阅读序言和目录  </li>\n<li>仅读开头和结尾的5行  </li>\n<li><strong>确定关键词在阅读</strong>  </li>\n<li>使用多种阅读节奏  </li>\n</ul>\n<p><strong>合理利用序言和目录，是确保高效轻松阅读体验的铁则。</strong>  确保翻开书之前，明确目的，进行关键词搜索阅读法。</p>\n<h3 id=\"5-如何与书籍相遇，又如何区分他们\"><a href=\"#5-如何与书籍相遇，又如何区分他们\" class=\"headerlink\" title=\"5. 如何与书籍相遇，又如何区分他们\"></a>5. 如何与书籍相遇，又如何区分他们</h3><p>打破兴趣壁垒，增加喜欢的书籍。<strong>只选择自己想读的书籍，读书就会千篇一律.</strong></p>\n<p>最好每隔三个月就整理一次书架。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=e485b9283a4e251ff6faecaac6efa272/38dbb6fd5266d016ac95853a9d2bd40735fa3517.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E6%9C%AF/20785287\" target=\"_blank\" rel=\"noopener\">快速阅读术</a></p>","more":"<p>多读一些书，看到的世界也会不同。(You are what you read!)<br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/readbook.jpg\" alt=\"\"></p>\n<h3 id=\"1-阅读速度缓慢的原因\"><a href=\"#1-阅读速度缓慢的原因\" class=\"headerlink\" title=\"1. 阅读速度缓慢的原因\"></a>1. 阅读速度缓慢的原因</h3><p>阅读速度与理解程度、记忆效果并不成正比。即使放慢了速度，非常仔细的阅读，也并不意味着能牢记书中的内容。</p>\n<p><strong>读书的真正意义，并不在于“复制100%”的原文，而是在于“邂逅1%”的收获。</strong></p>\n<blockquote>\n<p>花一周时间仔细阅读一本书，一个月之后，仅能记住1%的内容。那么，同样花一周的时间，我们快速阅读10本书，一年之后，就能记住全部内容的10%，后者岂不更加理想？并非深入仔细阅读一本书，而是提高阅读量，获取其中的“知识片段”，积少成多，汇小溪已成江海。这样的理念正是阅读速度缓慢的人们所欠缺的。</p>\n</blockquote>\n<p>不奢求通过阅读一本书就获得一个大型积木块，而是先通过多读，让自己积累更多的积木碎块。</p>\n<p>记忆音符的排列、能够用乐器完美地再现旋律、背诵歌词——这些都不是聆听音乐的初衷。音乐的根本价值也不在此，而是在于听过音乐之后，对个人产生的影响和带来的改变。</p>\n<p>流水式阅读是信息大爆炸时代最合理并且可以“避免堆积”的阅读方式。</p>\n<h3 id=\"2-养成阅读的习惯\"><a href=\"#2-养成阅读的习惯\" class=\"headerlink\" title=\"2.养成阅读的习惯\"></a>2.养成阅读的习惯</h3><p><strong>不仅是读书，任何习惯的养成，最重要的都是在每天同一时间做这件事。</strong></p>\n<p>书籍可分为三种类型：</p>\n<ul>\n<li>不必读的书  </li>\n<li>无法快速阅读的书  </li>\n<li>可以快速阅读的书  </li>\n</ul>\n<p>故事性强的内容，没有必要快速阅读。</p>\n<p>无法快速阅读的书，数量通常不会太多。</p>\n<p><strong>丰富多彩的多读生活，9：1原则是关键</strong></p>\n<blockquote>\n<p>不能仅有想要慢慢品读的书籍，还要尽量列入能够快速读完的书籍。</p>\n</blockquote>\n<p>为了享受阅读的过程，我们主张集中阅读一本书的时间不应该超过10天，这是一个原则。<strong>想办法避免厌倦，也是养成阅读习惯的必要条件</strong>.</p>\n<h3 id=\"3-避免读后忘记\"><a href=\"#3-避免读后忘记\" class=\"headerlink\" title=\"3.避免读后忘记\"></a>3.避免读后忘记</h3><p>只有书评人才知道的唯一妙招，“<strong>为了写而读</strong>”(输入与输出)</p>\n<p>让我们摒弃“将信息印刻在自己心中的”理念，将其转换成“记录在身外”。</p>\n<p><strong>令人心动的段落，不要记忆，要记录。</strong></p>\n<blockquote>\n<p>准备好A4纸，读到佳处随时摘录。遇到想记住的内容，就摘抄下来。开头标明页码，之后是文章内容，如此不断累积。最好不要原封不动地抄写整个段落，而是短小精悍，将内容控制在几行之内。<strong>一行采集</strong></p>\n</blockquote>\n<p><strong>另外，留住对“那一行”产生共鸣的原因，回味重要段落。</strong></p>\n<blockquote>\n<p>随着时间流逝，就会逐渐遗忘为之心动的原因，这样摘抄失去意义。</p>\n</blockquote>\n<p><strong>仅凭一行感想，唤醒一册记忆。</strong></p>\n<h3 id=\"4-流水式阅读规则\"><a href=\"#4-流水式阅读规则\" class=\"headerlink\" title=\"4.流水式阅读规则\"></a>4.流水式阅读规则</h3><p>跳读，以小标题为单位。小标题用来判断这一章节是否需要阅读 。</p>\n<ul>\n<li>仔细阅读序言和目录  </li>\n<li>仅读开头和结尾的5行  </li>\n<li><strong>确定关键词在阅读</strong>  </li>\n<li>使用多种阅读节奏  </li>\n</ul>\n<p><strong>合理利用序言和目录，是确保高效轻松阅读体验的铁则。</strong>  确保翻开书之前，明确目的，进行关键词搜索阅读法。</p>\n<h3 id=\"5-如何与书籍相遇，又如何区分他们\"><a href=\"#5-如何与书籍相遇，又如何区分他们\" class=\"headerlink\" title=\"5. 如何与书籍相遇，又如何区分他们\"></a>5. 如何与书籍相遇，又如何区分他们</h3><p>打破兴趣壁垒，增加喜欢的书籍。<strong>只选择自己想读的书籍，读书就会千篇一律.</strong></p>\n<p>最好每隔三个月就整理一次书架。</p>"},{"title":"我的读书","date":"2020-02-20T10:17:47.000Z","top":true,"_content":"\n读书笔记链接。\n\n<!--more-->\n\n## 名人传\n[史蒂夫.乔布斯传](https://jshell07.github.io/2019/04/16/%E5%8F%B2%E8%92%82%E5%A4%AB-%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0/)\n\n[褚时健传](https://jshell07.github.io/2019/04/15/%E8%A4%9A%E6%97%B6%E5%81%A5%E4%BC%A0/)\n\n[穷查理宝典](https://jshell07.github.io/2019/08/27/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/)\n\n[李开复自传](https://jshell07.github.io/2019/08/28/%E6%9D%8E%E5%BC%80%E5%A4%8D%E8%87%AA%E4%BC%A0/)\n\n## 理财\n[钱:7步创造终生收入 ](https://jshell07.github.io/2019/05/12/%E9%92%B1%EF%BC%9A7%E6%AD%A5%E5%88%9B%E9%80%A0%E7%BB%88%E7%94%9F%E6%94%B6%E5%85%A5/)\n\n[财务自由之路 ](https://jshell07.github.io/2019/04/24/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/)\n\n[富甲美国：沃尔玛创始人山姆.沃尔顿自传 ](https://jshell07.github.io/2019/04/15/%E5%AF%8C%E7%94%B2%E7%BE%8E%E5%9B%BD%EF%BC%9A%E6%B2%83%E5%B0%94%E7%8E%9B%E5%88%9B%E5%A7%8B%E4%BA%BA%E5%B1%B1%E5%A7%86-%E6%B2%83%E5%B0%94%E9%A1%BF%E8%87%AA%E4%BC%A0/)\n\n## 成长\n[把时间当做朋友](https://jshell07.github.io/2018/04/15/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E5%90%AC%E4%B9%A6%E7%AC%94%E8%AE%B0/)\n\n[吴晓波：年轻人如何独立思考](https://jshell07.github.io/2018/11/21/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/)\n\n[大脑整理术](https://jshell07.github.io/2018/11/26/%E5%A4%A7%E8%84%91%E6%95%B4%E7%90%86%E6%9C%AF/)\n\n[快速阅读术](https://jshell07.github.io/2019/04/15/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E6%9C%AF/)\n\n## 心理\n[人性的弱点](https://jshell07.github.io/2019/09/05/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9/)\n\n## 技术书籍\n[敏捷软件开发原则与模式及实践](https://jshell07.github.io/2018/06/04/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E8%B7%B5/)\n\n[Design-Pattern-I](https://jshell07.github.io/2018/07/12/Design-Pattern/)\n[Design-Pattern-II](https://jshell07.github.io/2019/01/28/Design-Pattern-II/)\n[Design-Pattern-III](https://jshell07.github.io/2019/01/28/Design-Pattern-III/)\n[Design-Pattern-IV](https://jshell07.github.io/2019/01/28/Design-Pattern-IV/)\n\n## 小说\n[挪威的森林 ](https://jshell07.github.io/2019/08/27/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/)\n\n[老子是癞蛤蟆](https://jshell07.github.io/2018/04/26/%E8%80%81%E5%AD%90%E6%98%AF%E7%99%9E%E8%9B%A4%E8%9F%86%E4%B9%A6%E6%91%98/)","source":"_posts/我的读书.md","raw":"---\ntitle: 我的读书\ndate: 2020-02-20 18:17:47\ntags:\ncategories: \ntop: true\n---\n\n读书笔记链接。\n\n<!--more-->\n\n## 名人传\n[史蒂夫.乔布斯传](https://jshell07.github.io/2019/04/16/%E5%8F%B2%E8%92%82%E5%A4%AB-%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0/)\n\n[褚时健传](https://jshell07.github.io/2019/04/15/%E8%A4%9A%E6%97%B6%E5%81%A5%E4%BC%A0/)\n\n[穷查理宝典](https://jshell07.github.io/2019/08/27/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/)\n\n[李开复自传](https://jshell07.github.io/2019/08/28/%E6%9D%8E%E5%BC%80%E5%A4%8D%E8%87%AA%E4%BC%A0/)\n\n## 理财\n[钱:7步创造终生收入 ](https://jshell07.github.io/2019/05/12/%E9%92%B1%EF%BC%9A7%E6%AD%A5%E5%88%9B%E9%80%A0%E7%BB%88%E7%94%9F%E6%94%B6%E5%85%A5/)\n\n[财务自由之路 ](https://jshell07.github.io/2019/04/24/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/)\n\n[富甲美国：沃尔玛创始人山姆.沃尔顿自传 ](https://jshell07.github.io/2019/04/15/%E5%AF%8C%E7%94%B2%E7%BE%8E%E5%9B%BD%EF%BC%9A%E6%B2%83%E5%B0%94%E7%8E%9B%E5%88%9B%E5%A7%8B%E4%BA%BA%E5%B1%B1%E5%A7%86-%E6%B2%83%E5%B0%94%E9%A1%BF%E8%87%AA%E4%BC%A0/)\n\n## 成长\n[把时间当做朋友](https://jshell07.github.io/2018/04/15/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E5%90%AC%E4%B9%A6%E7%AC%94%E8%AE%B0/)\n\n[吴晓波：年轻人如何独立思考](https://jshell07.github.io/2018/11/21/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/)\n\n[大脑整理术](https://jshell07.github.io/2018/11/26/%E5%A4%A7%E8%84%91%E6%95%B4%E7%90%86%E6%9C%AF/)\n\n[快速阅读术](https://jshell07.github.io/2019/04/15/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E6%9C%AF/)\n\n## 心理\n[人性的弱点](https://jshell07.github.io/2019/09/05/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9/)\n\n## 技术书籍\n[敏捷软件开发原则与模式及实践](https://jshell07.github.io/2018/06/04/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E8%B7%B5/)\n\n[Design-Pattern-I](https://jshell07.github.io/2018/07/12/Design-Pattern/)\n[Design-Pattern-II](https://jshell07.github.io/2019/01/28/Design-Pattern-II/)\n[Design-Pattern-III](https://jshell07.github.io/2019/01/28/Design-Pattern-III/)\n[Design-Pattern-IV](https://jshell07.github.io/2019/01/28/Design-Pattern-IV/)\n\n## 小说\n[挪威的森林 ](https://jshell07.github.io/2019/08/27/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/)\n\n[老子是癞蛤蟆](https://jshell07.github.io/2018/04/26/%E8%80%81%E5%AD%90%E6%98%AF%E7%99%9E%E8%9B%A4%E8%9F%86%E4%B9%A6%E6%91%98/)","slug":"我的读书","published":1,"updated":"2020-03-05T09:36:01.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0ry0051zkgrk4hqp1wa","content":"<p>读书笔记链接。</p>\n<a id=\"more\"></a>\n<h2 id=\"名人传\"><a href=\"#名人传\" class=\"headerlink\" title=\"名人传\"></a>名人传</h2><p><a href=\"https://jshell07.github.io/2019/04/16/%E5%8F%B2%E8%92%82%E5%A4%AB-%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0/\" target=\"_blank\" rel=\"noopener\">史蒂夫.乔布斯传</a></p>\n<p><a href=\"https://jshell07.github.io/2019/04/15/%E8%A4%9A%E6%97%B6%E5%81%A5%E4%BC%A0/\" target=\"_blank\" rel=\"noopener\">褚时健传</a></p>\n<p><a href=\"https://jshell07.github.io/2019/08/27/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/\" target=\"_blank\" rel=\"noopener\">穷查理宝典</a></p>\n<p><a href=\"https://jshell07.github.io/2019/08/28/%E6%9D%8E%E5%BC%80%E5%A4%8D%E8%87%AA%E4%BC%A0/\" target=\"_blank\" rel=\"noopener\">李开复自传</a></p>\n<h2 id=\"理财\"><a href=\"#理财\" class=\"headerlink\" title=\"理财\"></a>理财</h2><p><a href=\"https://jshell07.github.io/2019/05/12/%E9%92%B1%EF%BC%9A7%E6%AD%A5%E5%88%9B%E9%80%A0%E7%BB%88%E7%94%9F%E6%94%B6%E5%85%A5/\" target=\"_blank\" rel=\"noopener\">钱:7步创造终生收入 </a></p>\n<p><a href=\"https://jshell07.github.io/2019/04/24/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/\" target=\"_blank\" rel=\"noopener\">财务自由之路 </a></p>\n<p><a href=\"https://jshell07.github.io/2019/04/15/%E5%AF%8C%E7%94%B2%E7%BE%8E%E5%9B%BD%EF%BC%9A%E6%B2%83%E5%B0%94%E7%8E%9B%E5%88%9B%E5%A7%8B%E4%BA%BA%E5%B1%B1%E5%A7%86-%E6%B2%83%E5%B0%94%E9%A1%BF%E8%87%AA%E4%BC%A0/\" target=\"_blank\" rel=\"noopener\">富甲美国：沃尔玛创始人山姆.沃尔顿自传 </a></p>\n<h2 id=\"成长\"><a href=\"#成长\" class=\"headerlink\" title=\"成长\"></a>成长</h2><p><a href=\"https://jshell07.github.io/2018/04/15/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E5%90%AC%E4%B9%A6%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"noopener\">把时间当做朋友</a></p>\n<p><a href=\"https://jshell07.github.io/2018/11/21/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/\" target=\"_blank\" rel=\"noopener\">吴晓波：年轻人如何独立思考</a></p>\n<p><a href=\"https://jshell07.github.io/2018/11/26/%E5%A4%A7%E8%84%91%E6%95%B4%E7%90%86%E6%9C%AF/\" target=\"_blank\" rel=\"noopener\">大脑整理术</a></p>\n<p><a href=\"https://jshell07.github.io/2019/04/15/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E6%9C%AF/\" target=\"_blank\" rel=\"noopener\">快速阅读术</a></p>\n<h2 id=\"心理\"><a href=\"#心理\" class=\"headerlink\" title=\"心理\"></a>心理</h2><p><a href=\"https://jshell07.github.io/2019/09/05/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9/\" target=\"_blank\" rel=\"noopener\">人性的弱点</a></p>\n<h2 id=\"技术书籍\"><a href=\"#技术书籍\" class=\"headerlink\" title=\"技术书籍\"></a>技术书籍</h2><p><a href=\"https://jshell07.github.io/2018/06/04/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E8%B7%B5/\" target=\"_blank\" rel=\"noopener\">敏捷软件开发原则与模式及实践</a></p>\n<p><a href=\"https://jshell07.github.io/2018/07/12/Design-Pattern/\" target=\"_blank\" rel=\"noopener\">Design-Pattern-I</a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-II/\" target=\"_blank\" rel=\"noopener\">Design-Pattern-II</a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-III/\" target=\"_blank\" rel=\"noopener\">Design-Pattern-III</a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-IV/\" target=\"_blank\" rel=\"noopener\">Design-Pattern-IV</a></p>\n<h2 id=\"小说\"><a href=\"#小说\" class=\"headerlink\" title=\"小说\"></a>小说</h2><p><a href=\"https://jshell07.github.io/2019/08/27/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/\" target=\"_blank\" rel=\"noopener\">挪威的森林 </a></p>\n<p><a href=\"https://jshell07.github.io/2018/04/26/%E8%80%81%E5%AD%90%E6%98%AF%E7%99%9E%E8%9B%A4%E8%9F%86%E4%B9%A6%E6%91%98/\" target=\"_blank\" rel=\"noopener\">老子是癞蛤蟆</a></p>\n","site":{"data":{}},"excerpt":"<p>读书笔记链接。</p>","more":"<h2 id=\"名人传\"><a href=\"#名人传\" class=\"headerlink\" title=\"名人传\"></a>名人传</h2><p><a href=\"https://jshell07.github.io/2019/04/16/%E5%8F%B2%E8%92%82%E5%A4%AB-%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0/\" target=\"_blank\" rel=\"noopener\">史蒂夫.乔布斯传</a></p>\n<p><a href=\"https://jshell07.github.io/2019/04/15/%E8%A4%9A%E6%97%B6%E5%81%A5%E4%BC%A0/\" target=\"_blank\" rel=\"noopener\">褚时健传</a></p>\n<p><a href=\"https://jshell07.github.io/2019/08/27/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/\" target=\"_blank\" rel=\"noopener\">穷查理宝典</a></p>\n<p><a href=\"https://jshell07.github.io/2019/08/28/%E6%9D%8E%E5%BC%80%E5%A4%8D%E8%87%AA%E4%BC%A0/\" target=\"_blank\" rel=\"noopener\">李开复自传</a></p>\n<h2 id=\"理财\"><a href=\"#理财\" class=\"headerlink\" title=\"理财\"></a>理财</h2><p><a href=\"https://jshell07.github.io/2019/05/12/%E9%92%B1%EF%BC%9A7%E6%AD%A5%E5%88%9B%E9%80%A0%E7%BB%88%E7%94%9F%E6%94%B6%E5%85%A5/\" target=\"_blank\" rel=\"noopener\">钱:7步创造终生收入 </a></p>\n<p><a href=\"https://jshell07.github.io/2019/04/24/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/\" target=\"_blank\" rel=\"noopener\">财务自由之路 </a></p>\n<p><a href=\"https://jshell07.github.io/2019/04/15/%E5%AF%8C%E7%94%B2%E7%BE%8E%E5%9B%BD%EF%BC%9A%E6%B2%83%E5%B0%94%E7%8E%9B%E5%88%9B%E5%A7%8B%E4%BA%BA%E5%B1%B1%E5%A7%86-%E6%B2%83%E5%B0%94%E9%A1%BF%E8%87%AA%E4%BC%A0/\" target=\"_blank\" rel=\"noopener\">富甲美国：沃尔玛创始人山姆.沃尔顿自传 </a></p>\n<h2 id=\"成长\"><a href=\"#成长\" class=\"headerlink\" title=\"成长\"></a>成长</h2><p><a href=\"https://jshell07.github.io/2018/04/15/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E5%90%AC%E4%B9%A6%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"noopener\">把时间当做朋友</a></p>\n<p><a href=\"https://jshell07.github.io/2018/11/21/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/\" target=\"_blank\" rel=\"noopener\">吴晓波：年轻人如何独立思考</a></p>\n<p><a href=\"https://jshell07.github.io/2018/11/26/%E5%A4%A7%E8%84%91%E6%95%B4%E7%90%86%E6%9C%AF/\" target=\"_blank\" rel=\"noopener\">大脑整理术</a></p>\n<p><a href=\"https://jshell07.github.io/2019/04/15/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E6%9C%AF/\" target=\"_blank\" rel=\"noopener\">快速阅读术</a></p>\n<h2 id=\"心理\"><a href=\"#心理\" class=\"headerlink\" title=\"心理\"></a>心理</h2><p><a href=\"https://jshell07.github.io/2019/09/05/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9/\" target=\"_blank\" rel=\"noopener\">人性的弱点</a></p>\n<h2 id=\"技术书籍\"><a href=\"#技术书籍\" class=\"headerlink\" title=\"技术书籍\"></a>技术书籍</h2><p><a href=\"https://jshell07.github.io/2018/06/04/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E8%B7%B5/\" target=\"_blank\" rel=\"noopener\">敏捷软件开发原则与模式及实践</a></p>\n<p><a href=\"https://jshell07.github.io/2018/07/12/Design-Pattern/\" target=\"_blank\" rel=\"noopener\">Design-Pattern-I</a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-II/\" target=\"_blank\" rel=\"noopener\">Design-Pattern-II</a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-III/\" target=\"_blank\" rel=\"noopener\">Design-Pattern-III</a><br><a href=\"https://jshell07.github.io/2019/01/28/Design-Pattern-IV/\" target=\"_blank\" rel=\"noopener\">Design-Pattern-IV</a></p>\n<h2 id=\"小说\"><a href=\"#小说\" class=\"headerlink\" title=\"小说\"></a>小说</h2><p><a href=\"https://jshell07.github.io/2019/08/27/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/\" target=\"_blank\" rel=\"noopener\">挪威的森林 </a></p>\n<p><a href=\"https://jshell07.github.io/2018/04/26/%E8%80%81%E5%AD%90%E6%98%AF%E7%99%9E%E8%9B%A4%E8%9F%86%E4%B9%A6%E6%91%98/\" target=\"_blank\" rel=\"noopener\">老子是癞蛤蟆</a></p>"},{"title":"挪威的森林","date":"2019-08-27T11:21:31.000Z","_content":"\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=66c6eb64e924b899ca31716a0f6f76f0/730e0cf3d7ca7bcb44b8064bbe096b63f724a897.jpg)\n\n来源于[村上春树](https://baike.baidu.com/item/%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/1070)的挪威的森林。\n\n挪威的森林最开始出自于[披头士的演唱单曲](https://baike.baidu.com/item/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/983772)\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=dfa5063ba286c9171c0e5a6ba8541baa/7af40ad162d9f2d31d43c62cacec8a136227cca7.jpg)\n\n<!--more-->\n\n经典词句：\n\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f6aef71c0846f21fdd395601974d0005/18d8bc3eb13533faa3ef2ac9aad3fd1f40345bff.jpg)\n渡边看待直子的死：\n>死并非生的对立面，而作为生的一部分永存。\n\n![]()\n直子：\n>哪里会有人喜欢孤独，不过是不喜欢失望。\n\n玲子对渡边劝说慢慢处理直子的心理问题时的态度：\n>急躁不得。及时事物在错综复杂，甚至叫人无计可施，也不能灰心丧气，不能急于求成强拉硬扯。要有打持久战的思想准备，必须一根根耐心清理。\n\n玲子对有天赋的孩童看法：\n>尽管有卓越的天赋才华，去承受不住系统训练，而终归将才华支离破碎地挥霍掉。\n\n渣男却能得到成功的永泽：\n>那不是努力，只是劳动。我所说的努力与这截然不同。所谓的努力，指的是**主动而有目的的活动**。\n\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f237fca390529822113e3191b6a310ae/b2de9c82d158ccbfd895755e19d8bc3eb13541ad.jpg)\n把人生当做饼干罐的绿子：\n>你把人生当做饼干罐就可以了。它装有各种各样的饼干，喜欢的和不喜欢的都在里面。如果一个劲儿挑你喜欢的吃，那么剩下的就全是不喜欢的，每次遇到麻烦我就总这样想：想把这个应付过去，往下就好办了。","source":"_posts/挪威的森林.md","raw":"---\ntitle: 挪威的森林\ndate: 2019-08-27 19:21:31\ntags: bookmarks\ncategories: bookmarks\n---\n\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=66c6eb64e924b899ca31716a0f6f76f0/730e0cf3d7ca7bcb44b8064bbe096b63f724a897.jpg)\n\n来源于[村上春树](https://baike.baidu.com/item/%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/1070)的挪威的森林。\n\n挪威的森林最开始出自于[披头士的演唱单曲](https://baike.baidu.com/item/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/983772)\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=dfa5063ba286c9171c0e5a6ba8541baa/7af40ad162d9f2d31d43c62cacec8a136227cca7.jpg)\n\n<!--more-->\n\n经典词句：\n\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f6aef71c0846f21fdd395601974d0005/18d8bc3eb13533faa3ef2ac9aad3fd1f40345bff.jpg)\n渡边看待直子的死：\n>死并非生的对立面，而作为生的一部分永存。\n\n![]()\n直子：\n>哪里会有人喜欢孤独，不过是不喜欢失望。\n\n玲子对渡边劝说慢慢处理直子的心理问题时的态度：\n>急躁不得。及时事物在错综复杂，甚至叫人无计可施，也不能灰心丧气，不能急于求成强拉硬扯。要有打持久战的思想准备，必须一根根耐心清理。\n\n玲子对有天赋的孩童看法：\n>尽管有卓越的天赋才华，去承受不住系统训练，而终归将才华支离破碎地挥霍掉。\n\n渣男却能得到成功的永泽：\n>那不是努力，只是劳动。我所说的努力与这截然不同。所谓的努力，指的是**主动而有目的的活动**。\n\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f237fca390529822113e3191b6a310ae/b2de9c82d158ccbfd895755e19d8bc3eb13541ad.jpg)\n把人生当做饼干罐的绿子：\n>你把人生当做饼干罐就可以了。它装有各种各样的饼干，喜欢的和不喜欢的都在里面。如果一个劲儿挑你喜欢的吃，那么剩下的就全是不喜欢的，每次遇到麻烦我就总这样想：想把这个应付过去，往下就好办了。","slug":"挪威的森林","published":1,"updated":"2019-08-27T11:43:23.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0s10055zkgrnreqg3ze","content":"<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=66c6eb64e924b899ca31716a0f6f76f0/730e0cf3d7ca7bcb44b8064bbe096b63f724a897.jpg\" alt=\"\"></p>\n<p>来源于<a href=\"https://baike.baidu.com/item/%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/1070\" target=\"_blank\" rel=\"noopener\">村上春树</a>的挪威的森林。</p>\n<p>挪威的森林最开始出自于<a href=\"https://baike.baidu.com/item/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/983772\" target=\"_blank\" rel=\"noopener\">披头士的演唱单曲</a></p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=dfa5063ba286c9171c0e5a6ba8541baa/7af40ad162d9f2d31d43c62cacec8a136227cca7.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>经典词句：</p>\n<p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f6aef71c0846f21fdd395601974d0005/18d8bc3eb13533faa3ef2ac9aad3fd1f40345bff.jpg\" alt=\"\"><br>渡边看待直子的死：</p>\n<blockquote>\n<p>死并非生的对立面，而作为生的一部分永存。</p>\n</blockquote>\n<p><img src=\"\" alt=\"\"><br>直子：</p>\n<blockquote>\n<p>哪里会有人喜欢孤独，不过是不喜欢失望。</p>\n</blockquote>\n<p>玲子对渡边劝说慢慢处理直子的心理问题时的态度：</p>\n<blockquote>\n<p>急躁不得。及时事物在错综复杂，甚至叫人无计可施，也不能灰心丧气，不能急于求成强拉硬扯。要有打持久战的思想准备，必须一根根耐心清理。</p>\n</blockquote>\n<p>玲子对有天赋的孩童看法：</p>\n<blockquote>\n<p>尽管有卓越的天赋才华，去承受不住系统训练，而终归将才华支离破碎地挥霍掉。</p>\n</blockquote>\n<p>渣男却能得到成功的永泽：</p>\n<blockquote>\n<p>那不是努力，只是劳动。我所说的努力与这截然不同。所谓的努力，指的是<strong>主动而有目的的活动</strong>。</p>\n</blockquote>\n<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f237fca390529822113e3191b6a310ae/b2de9c82d158ccbfd895755e19d8bc3eb13541ad.jpg\" alt=\"\"><br>把人生当做饼干罐的绿子：</p>\n<blockquote>\n<p>你把人生当做饼干罐就可以了。它装有各种各样的饼干，喜欢的和不喜欢的都在里面。如果一个劲儿挑你喜欢的吃，那么剩下的就全是不喜欢的，每次遇到麻烦我就总这样想：想把这个应付过去，往下就好办了。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=66c6eb64e924b899ca31716a0f6f76f0/730e0cf3d7ca7bcb44b8064bbe096b63f724a897.jpg\" alt=\"\"></p>\n<p>来源于<a href=\"https://baike.baidu.com/item/%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/1070\" target=\"_blank\" rel=\"noopener\">村上春树</a>的挪威的森林。</p>\n<p>挪威的森林最开始出自于<a href=\"https://baike.baidu.com/item/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/983772\" target=\"_blank\" rel=\"noopener\">披头士的演唱单曲</a></p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=dfa5063ba286c9171c0e5a6ba8541baa/7af40ad162d9f2d31d43c62cacec8a136227cca7.jpg\" alt=\"\"></p>","more":"<p>经典词句：</p>\n<p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f6aef71c0846f21fdd395601974d0005/18d8bc3eb13533faa3ef2ac9aad3fd1f40345bff.jpg\" alt=\"\"><br>渡边看待直子的死：</p>\n<blockquote>\n<p>死并非生的对立面，而作为生的一部分永存。</p>\n</blockquote>\n<p><img src=\"\" alt=\"\"><br>直子：</p>\n<blockquote>\n<p>哪里会有人喜欢孤独，不过是不喜欢失望。</p>\n</blockquote>\n<p>玲子对渡边劝说慢慢处理直子的心理问题时的态度：</p>\n<blockquote>\n<p>急躁不得。及时事物在错综复杂，甚至叫人无计可施，也不能灰心丧气，不能急于求成强拉硬扯。要有打持久战的思想准备，必须一根根耐心清理。</p>\n</blockquote>\n<p>玲子对有天赋的孩童看法：</p>\n<blockquote>\n<p>尽管有卓越的天赋才华，去承受不住系统训练，而终归将才华支离破碎地挥霍掉。</p>\n</blockquote>\n<p>渣男却能得到成功的永泽：</p>\n<blockquote>\n<p>那不是努力，只是劳动。我所说的努力与这截然不同。所谓的努力，指的是<strong>主动而有目的的活动</strong>。</p>\n</blockquote>\n<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f237fca390529822113e3191b6a310ae/b2de9c82d158ccbfd895755e19d8bc3eb13541ad.jpg\" alt=\"\"><br>把人生当做饼干罐的绿子：</p>\n<blockquote>\n<p>你把人生当做饼干罐就可以了。它装有各种各样的饼干，喜欢的和不喜欢的都在里面。如果一个劲儿挑你喜欢的吃，那么剩下的就全是不喜欢的，每次遇到麻烦我就总这样想：想把这个应付过去，往下就好办了。</p>\n</blockquote>"},{"title":"把时间当做朋友","date":"2018-04-15T15:39:59.000Z","_content":"\n## 背景\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=57139f628bcb39dbc1c06050e82d6e19/342ac65c1038534371257ca99913b07ecb808854.jpg)\n\n这是[晓书童喜马拉雅](http://www.ximalaya.com/zhubo/3983764/)音频作品中[李笑来](https://baike.baidu.com/item/%E6%9D%8E%E7%AC%91%E6%9D%A5/10966850?fr=aladdin)[《把时间当做朋友》](https://baike.baidu.com/item/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B/7192643?fr=aladdin)([_在线文档_](https://www.sbkk88.com/lizhishu/bashijiandangzuopengyou/))的音频整理笔记。\n\n本书的核心点：**心智**。\n\n心智力量的不同，使不同的人面对相同的境遇，做出不同的解释，得到不同的结论，产生不同的选择。\n\n<!--more-->\n\n## 1. 心智\n人与人之间的差异，除了看得见的相貌、身材、出身、财富的外，还有心智力量。\n\n心智力量的不同造成不同的看法的例子：\n**兴趣真的那么重要？**\n往往并不是有兴趣才能做好，而是做好了才有兴趣。 大多数事情都需要熟能生巧。做得多了，自然就擅长了；擅长了，就自然做得比别人好；做得比别人好，兴趣就大起来了，而后就更喜欢做，更擅长，更……良性循环。\n\n**学习方法真的重要？**\n>当然，只有聪明的人才去关心方法，这没什么不对。然而，学生总是过分关心自己正在用的方法是不是正确。仅仅正确还不够。\n\n学习上的成功，都只靠两件事：**策略和坚持**，而坚持本身就应该是最重要的策略之一。坚持，其实就是重复，而重复，说到底就是时间的投入。\n\n**总结**\n>没有什么要比发现、培养、呵护、调整自己的心智的力量更重要的事情了。一旦我们的心智出现了问题，我们就会因为错误的理解而做出错误的判断，因此浪费的时间往往不仅无法估量，更可怕的是，这种错误和浪费甚至可能根本无从知晓。\n\n## 2. 开启心智\n用我们的大脑控制我们的大脑，即开启心智，控制我们的大脑。***你要明白你不应该隶属于你的大脑，而应该是你拥有你的大脑，并且应该是你可以控制你的大脑。***\n\n### 2.1. 大脑控制\n>人之为人，在于我们具有特殊的“大脑额页”正因如此，我们才具备其他动物很难具备的一种能力--“反思能力”--也许恰恰就是人与猴子之间3%不到的差异的具体体现。有了反思能力的人类，最终拥有了语言，发明了文字，形成了逻辑思考能力，最终拥有了强大的心智力量。\n\n>“即使是在极端恶劣的环境里，人们也会拥有一种最后的自由 ，那就是选择自己的态度的自由 。” -- 心理学家[维克托·弗兰克](https://baike.baidu.com/item/%E7%BB%B4%E5%85%8B%E5%A4%9A%C2%B7%E5%BC%97%E5%85%B0%E5%85%8B/6628766?fromtitle=%E7%BB%B4%E5%85%8B%E6%89%98%C2%B7%E5%BC%97%E5%85%B0%E5%85%8B&fromid=11237205&fr=aladdin)![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=af148d81e1f81a4c323fe49bb6430b3c/4034970a304e251f36eddb0dad86c9177f3e5328.jpg)\n\n### 2.2. 情绪控制\n另外，心智还能帮助我们控制情绪。\n>你所面临的所有尴尬，最终肯定有一部分原因是你自己造成的。所以，没必要找借口，没必要抱怨别人，没必要觉得这世界就对你一个人不公平，要记得“你并不孤独”--肯定还有别人也在不同的地方、不同的时代遭遇过同样的尴尬和痛苦。\n\n很多人并不了解自己大脑的机制（具备遗忘痛苦机制，回顾过去的痛苦，现在能平常对待），所以，他们不由自主地被自己的感觉所控制。\n\n>\"相信我，你并不孤独”，你遇见的事情总是有人遇见过，总能解决度过。\n\n>你永远都不应该在面对一些难以置信的悲剧的时候，因为自己失去信念而让他演变成第二个，甚至是第三个。我一旦吸取了教训，就不会跟过往纠缠不休，花更多的时间去后悔过去发生的事。 -- 《查理芒格传》（晓书童解读）\n\n>阅读、学习、实践、反思，将有限的生命孤注于有价值的事情，等待时间的回报。 --《穷查理宝典》 (晓书童解读)\n\n> 我面对过去，背靠未来，从来不去做任何的预测。 -- [本杰明.格雷厄姆](https://baike.baidu.com/item/%E6%9C%AC%E6%9D%B0%E6%98%8E%C2%B7%E6%A0%BC%E9%9B%B7%E5%8E%84%E5%A7%86/3481029?fromtitle=%E6%9C%AC%E6%9D%B0%E6%98%8E.%E6%A0%BC%E9%9B%B7%E5%8E%84%E5%A7%86&fromid=11166116&fr=aladdin)\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=e9b600bbb312c8fcb4f3f1cbc40292b4/d833c895d143ad4b4a2e345b88025aafa40f062c.jpg)\n[查理芒格](https://baike.baidu.com/item/%E6%9F%A5%E7%90%86%C2%B7%E8%8A%92%E6%A0%BC/4325934?fromtitle=%E6%9F%A5%E7%90%86%E8%8A%92%E6%A0%BC&fromid=3578442&fr=aladdin) ，[伯克希尔·哈撒韦 ](https://baike.baidu.com/item/%E4%BC%AF%E5%85%8B%E5%B8%8C%E5%B0%94%C2%B7%E5%93%88%E6%92%92%E9%9F%A6/489043?fromtitle=%E4%BC%AF%E5%85%8B%E5%B8%8C%E5%B0%94-%E5%93%88%E6%92%92%E9%9F%A6&fromid=11258250&fr=aladdin)第二大股东(CEO为[沃伦·巴菲特](https://baike.baidu.com/item/%E6%B2%83%E4%BC%A6%C2%B7%E5%B7%B4%E8%8F%B2%E7%89%B9))。\n[查理·芒格推荐书单](https://xueqiu.com/1830611415/23012486)\n\n例如背单词的时候，事实上，在做所有类似的必须记住大量信息的工作的时候，一定要想办法由衷地把这件事**当作快乐的事情来做**。\n\n### 2.3. 满足感控制\n>要取得大的成绩就不能**急功近利**，不能为当前名利所诱惑 ，能按社会需要不怕挫折、坚持不懈奋斗是取得成就的重要因素。\n希望自己的欲望马上获得满足，是每个人的天性，我们要做的是稍加控制和改善。改善建议：\n\n1. 挑选自己某些方面的天性\n2. 纸笔罗列\n3. 反复审视\n\n推迟满足感会表现出“更有耐心”，这些耐心可以被用来不动声色地承受更多的打击和挫折，坦然面对更多的威逼和诱惑。\n\n\n另外，在对待自己的心智上还需要注意：\n\n### 2.4. 留心成功者说的话\n\n成功者往往没有足够的时间去讲述所有的细节，并且通常会夸大遇到的问题与取得的成功。成功者们又会有意无意的美化包装他们的经验，而这一切，都在干扰你的判断。当然，只有经过仔细甄别之后，真正的成功者的真正的宝贵经验，才是无价的。\n\n我们更应该关注“**失败者**” -- 努力从失败者身上汲取经验。失败的原因往往很容易确定,并且失败者数量更多，更便于我们的观察。\n\n### 2.5. 不要相信运气\n\n相信运气其实是缺乏自制力的表现。概率是独立于任何人存在的，因此绝对不会仅因为我的期望就发生任何变化。\n>好运气发生在你身上，你当然应该非常开心；坏运气降临在你身上，你应该平静接受--无论怎样你都要继续生活，当然就还要继续面对你不能控制的事物。其实，这是苏轼早就总结过的生活态度：“骤然临之而不惊， 无故加之而不怒。”\n\n>千万不要相信”机不可失，失不再来“。**当你没有准备好的时候，对你来讲，不存在任何机会**。机会时时刻刻都会出现在你身边，关键在于，你有没有足够努力，可以做到像诸葛亮那样，”万事俱备，只欠东风“。而当你准备好的时候，随处都有机会，而且所有的机会都是切实的，并且可以把握的机会。\n\n### 2.6. 打造人脉不如打造自己\n整体上来看，人脉当然很重要。不过，针对某个个体来说的话，更重要的是他所拥有的资源。有些资源很难瞬间获得，比如金钱、地位、名誉，尤其在这些资源的获得更多地依赖出身和运气的现实世界里。然而有些资源却可以很容易从零开始，比如一个人的才华与学识。才华也好学识也罢，是可以通过努力必然获得的东西。\n\n人脉之间大多存在着“交换的概念”，如果我们只是单纯的“索取方”，那给予方势必有“被抢，被夺走”东西的感觉。\n\n>生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要。打造自己，就等于打造人脉。\n\n以下是我的几个简单的，但实践起来并不是那么容易的建议：\n\n- 专心做可以**提升自己**的事情；学习并拥有更多更好的技能；成为一个**值得交往**的人；\n- 学会独善其身，以不给他人制造麻烦为美德；用你的**独立**赢得尊重；\n- 除非有特殊原因，应该尽量回避那些连在物质、精神生活上都不能独善其身的人；\n- 真正关心一个朋友的意思是说，你情愿在他身上花费甚至浪费更多的时间；\n- 记住，一个人的幸福程度，往往取决于他多大程度上可以脱离对外部世界的依附。\n\n## 3. 与时间做朋友\n>时间无法管理，你要管理的是你自己。\n\n一切的时间管理、立志行动等等说到底都离不开这两个词：**积累、坚持**。积累才是最有效的力量，唯有坚持才有希望，深信积累的力量，时间就是你的朋友。\n>从根本上，时间又是不能管理的，想要真正的掌控时间，需要的是开启心智，管理自己，掌控自我。\n\n### 3.1. 精确感知时间\n>“管理时间”是不可能的，那么解决方法就只能是，想尽一切办法真正了解自己，真正了解时间、精确地感知时间；而后再想尽一切办法使自己以及自己的行为与时间“合拍”。\n\n常见做法是“**基于过程记录**”。\n\n以下是摘自《奇特的一生》中[柳比歇夫](https://baike.baidu.com/item/%E6%9F%B3%E6%AF%94%E6%AD%87%E5%A4%AB/3389273?fr=aladdin)的日志样本\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=4727d7e26c061d95694b3f6a1a9d61b4/e4dde71190ef76c649c955f19f16fdfaae5167d5.jpg)\n\n\n| 事件 | 耗时 | 时间 |\n|:-|:-:|:-|\n| 分类昆虫学（画两张无名袋蛾的图）|三小时十五分|一九六四 年四月八日|\n|鉴定袋蛾|二十分|一九六四 年四月八日|\n|开始写关于袋蛾的报告|一小时五分|一九六四 年四月八日|\n\n### 3.2. 时间预算\n“To plan， or not to Plan， is a question.” 但是我们大多数都是\"We do not plan to fail， we fail to plan.”  哈哈\n\n在开始一天的活动之前，花费15至30分钟仔细制作你当天的时间预算绝对是特别划算的，磨刀不误砍柴工。\n在选择事情的重要性，推荐使用以下粒度，太细的划分会显得繁琐：\n- 重要\n- 一般\n- 不重要\n\n但是，在重要的事情上有：“显得重要”，“真的重要”。我们要去区分他们，其实只需要一个标准：**这个任务的完成是否对你的目标达成是否确实有益**。\n\n>强迫自己理智一些，就会知道，无用的事情，哪怕非常有趣都不应该去做；而有用的事情，哪怕非常无趣，你都应该做。但是，请你认真面对你自己，过去你一直是这样*用理智指导你的行为的么*？\n\n另外，在制作时间预算计划时，需要注意以下，避免时间的浪费：\n- 目标不现实或者目前暂时尚不可行（难度大，需要细分小任务）\n- 计划时间要比想象的更多点\n- 越是短期的目标，越容易清晰。越是清晰的目标越容易实现\n- 为了达到目标而制定的实施的策略\n- 考虑到一些变化因素\n- 计划固然重要，行动却更重要\n\n>当然，有些时候，你必须拖延你的行动。比如，当你决定买个新潮手机的时候，故意拖延三个月，会让你享受更低的价格；如果你决定买一辆你非常中意的高级轿车，故意拖延上一年，也许就会让你意识到当初的审美观其实很有问题。我个人的经验是，在所有的大额消费活动，乃至其他一切涉及到金钱的活动诸如投资之类上，“马上行动”的建议肯定不适用。\n\n### 3.3. 时间审计\n我们现在会早上制作计划，晚上回顾时间消耗（有点类似有财务记账）。一段时间之后，固定的时间消耗不用再出现在时间预算上面，不用天真填满每一分钟。尽管总是有意外发生，时间不够用的情况，我们也不要采用消减其他时间的时间类似睡觉休息的时间，而是应该使用“多线程”的做法:\n- 其中一件事情最好是机械的，少技术含量的\n- 另一件事情不是特别需要脑力的\n\nExample: 1) 跑步健身； 2）听audio book\n\n## 4. 更多思考\n\n### 4.1. 效率\n>记住，你不可能百分之百地有效率，至少不可能总是百分之百地有效率。有些时候，你会非常有效率，但是，这种情况不可能永远维持；并且肯定的是，如果你竟然强迫自己一定要如此做的话，你就会像那些用100%的功率运转的机器一样，由于损耗太大而提前报废。\n\n在做时间预算的时候，一定要留有空间。\n1. 你必须清楚肯定会有意外事件发生(意外总发生原因绝不是因为你的运气格外差，而往往只不过是因为你考虑得不够周全)\n2. 你必须用适当的方法休息、放松，以便恢复良好的状态去做更多的事情。\n\n>其实这世间的绝大多数事情都一样的--你不见得一定要做到极致才可以。有一个简单的算法：如果满分是100分，还是可以按照黄金分割定律，61.8分是恰好的。因为61.8分以上的成绩，意味着说你必须放弃很多才可以获的。\n\n于是，在你规划你的时间的时候，你应该明白为了能够完全专注120分钟，你最终需要规划出差不多150分钟左右的时间开销。这个方法非常简单，但非常有效。而因为它简单而有效，所以会很容易体会到效果。类似于[西红柿工作法](https://baike.baidu.com/item/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/6353502?fr=aladdin)\n\n### 4.2. 把生活节奏调整得慢一点\n>凡是值得做的事情，都值得慢慢做--做很久很久。\n\n因此，我们不用在最开始就制定“超人计划”，这样会很让你快速疲惫，进而放弃。\n>要想办法提前预知自己会需要怎样的技能，然后确定那是一个自己可以通过练习真正熟练掌握的技能之后，而后制定长期计划，一点一点地执行该计划。\n\n题外话：\n正确的减脂跑步方式应该是慢跑。慢跑到稍微气喘的地步，就改为快走，等气匀了再改为慢跑。这样就很容易坚持到30分钟，然后，在接下来的10~15 分钟之内，如果体力允许的话（通常要经过以两个月的适应），就尽量快跑，或者至少强度比前30分钟再高一点，以便消耗更多的脂肪。(有氧运动大约20分钟之内，消耗的往往只是水分，30分钟之后才开始消耗脂肪)\n\n### 4.3. 时间不一定是金钱\n>越是收入低的人越是不爱惜时间--因为他的时间实在是没有什么价值，每一秒钟都几乎可以忽略不计。越是收入高的人越是吝惜自己的时间，因为他的每一秒都有着确定的价值。\n\n问问自己，“我的时间究竟可以标价多少？”--这就是一个人决心不再浪费时间的最有效的起点和动力。只有爱惜才可能产生节约的动力。\n\n>世界上有一个银行每天给你86400元当日花销，不能接受存款预支。这就是我们每日度过的时间，`24 * 60 * 60 = 86400`\n\n将抽象的时间具体度量化，能帮助我们开始格外爱惜时间。\n\n### 4.4. 提前准备的好处\n\n>原来现在科学家们对所谓的“潜意识”也有了更多简单明了科学解释。我们大脑中的灰质中储存的各种信息只有很少一部分（很难超过12%）是有序储存的，这部分被我们称作是“有意识的”。而更多的信息，或者信息碎片，是非有序储存的，甚至很难有意识地直接调出，这些往往就是被我们称为“无意识”或者“潜意识”的部分。梦境的存在，就是潜意识存在的最基本证据。\n\n>而随着信息输入越来越多，大脑就需要越来越多的灰质细胞。科学家们已经发现使用两种或者两种以上语言的人，有更多地灰质细胞。而颅腔的大小是有限的，于是，灰质细胞的增加，最终会导致灰质密度越来越高。于是，灰质细胞之间就越有可能由神经元连接起来。于是就有可能产生我们所说的“融会贯通”的现象 --那些原本可能貌似毫不相干的信息现在有机会被联系在一起了。所以，所谓知识渊博的人，就是那些存储于脑中的信息量超常地多的人，这些人总是可以“融会贯通”，于是，超常地充满了“智慧”。\n\n","source":"_posts/把时间当做朋友听书笔记.md","raw":"---\ntitle: 把时间当做朋友\ndate: 2018-04-15 23:39:59\ntags: bookmarks\ncategories: bookmarks\n---\n\n## 背景\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=57139f628bcb39dbc1c06050e82d6e19/342ac65c1038534371257ca99913b07ecb808854.jpg)\n\n这是[晓书童喜马拉雅](http://www.ximalaya.com/zhubo/3983764/)音频作品中[李笑来](https://baike.baidu.com/item/%E6%9D%8E%E7%AC%91%E6%9D%A5/10966850?fr=aladdin)[《把时间当做朋友》](https://baike.baidu.com/item/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B/7192643?fr=aladdin)([_在线文档_](https://www.sbkk88.com/lizhishu/bashijiandangzuopengyou/))的音频整理笔记。\n\n本书的核心点：**心智**。\n\n心智力量的不同，使不同的人面对相同的境遇，做出不同的解释，得到不同的结论，产生不同的选择。\n\n<!--more-->\n\n## 1. 心智\n人与人之间的差异，除了看得见的相貌、身材、出身、财富的外，还有心智力量。\n\n心智力量的不同造成不同的看法的例子：\n**兴趣真的那么重要？**\n往往并不是有兴趣才能做好，而是做好了才有兴趣。 大多数事情都需要熟能生巧。做得多了，自然就擅长了；擅长了，就自然做得比别人好；做得比别人好，兴趣就大起来了，而后就更喜欢做，更擅长，更……良性循环。\n\n**学习方法真的重要？**\n>当然，只有聪明的人才去关心方法，这没什么不对。然而，学生总是过分关心自己正在用的方法是不是正确。仅仅正确还不够。\n\n学习上的成功，都只靠两件事：**策略和坚持**，而坚持本身就应该是最重要的策略之一。坚持，其实就是重复，而重复，说到底就是时间的投入。\n\n**总结**\n>没有什么要比发现、培养、呵护、调整自己的心智的力量更重要的事情了。一旦我们的心智出现了问题，我们就会因为错误的理解而做出错误的判断，因此浪费的时间往往不仅无法估量，更可怕的是，这种错误和浪费甚至可能根本无从知晓。\n\n## 2. 开启心智\n用我们的大脑控制我们的大脑，即开启心智，控制我们的大脑。***你要明白你不应该隶属于你的大脑，而应该是你拥有你的大脑，并且应该是你可以控制你的大脑。***\n\n### 2.1. 大脑控制\n>人之为人，在于我们具有特殊的“大脑额页”正因如此，我们才具备其他动物很难具备的一种能力--“反思能力”--也许恰恰就是人与猴子之间3%不到的差异的具体体现。有了反思能力的人类，最终拥有了语言，发明了文字，形成了逻辑思考能力，最终拥有了强大的心智力量。\n\n>“即使是在极端恶劣的环境里，人们也会拥有一种最后的自由 ，那就是选择自己的态度的自由 。” -- 心理学家[维克托·弗兰克](https://baike.baidu.com/item/%E7%BB%B4%E5%85%8B%E5%A4%9A%C2%B7%E5%BC%97%E5%85%B0%E5%85%8B/6628766?fromtitle=%E7%BB%B4%E5%85%8B%E6%89%98%C2%B7%E5%BC%97%E5%85%B0%E5%85%8B&fromid=11237205&fr=aladdin)![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=af148d81e1f81a4c323fe49bb6430b3c/4034970a304e251f36eddb0dad86c9177f3e5328.jpg)\n\n### 2.2. 情绪控制\n另外，心智还能帮助我们控制情绪。\n>你所面临的所有尴尬，最终肯定有一部分原因是你自己造成的。所以，没必要找借口，没必要抱怨别人，没必要觉得这世界就对你一个人不公平，要记得“你并不孤独”--肯定还有别人也在不同的地方、不同的时代遭遇过同样的尴尬和痛苦。\n\n很多人并不了解自己大脑的机制（具备遗忘痛苦机制，回顾过去的痛苦，现在能平常对待），所以，他们不由自主地被自己的感觉所控制。\n\n>\"相信我，你并不孤独”，你遇见的事情总是有人遇见过，总能解决度过。\n\n>你永远都不应该在面对一些难以置信的悲剧的时候，因为自己失去信念而让他演变成第二个，甚至是第三个。我一旦吸取了教训，就不会跟过往纠缠不休，花更多的时间去后悔过去发生的事。 -- 《查理芒格传》（晓书童解读）\n\n>阅读、学习、实践、反思，将有限的生命孤注于有价值的事情，等待时间的回报。 --《穷查理宝典》 (晓书童解读)\n\n> 我面对过去，背靠未来，从来不去做任何的预测。 -- [本杰明.格雷厄姆](https://baike.baidu.com/item/%E6%9C%AC%E6%9D%B0%E6%98%8E%C2%B7%E6%A0%BC%E9%9B%B7%E5%8E%84%E5%A7%86/3481029?fromtitle=%E6%9C%AC%E6%9D%B0%E6%98%8E.%E6%A0%BC%E9%9B%B7%E5%8E%84%E5%A7%86&fromid=11166116&fr=aladdin)\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=e9b600bbb312c8fcb4f3f1cbc40292b4/d833c895d143ad4b4a2e345b88025aafa40f062c.jpg)\n[查理芒格](https://baike.baidu.com/item/%E6%9F%A5%E7%90%86%C2%B7%E8%8A%92%E6%A0%BC/4325934?fromtitle=%E6%9F%A5%E7%90%86%E8%8A%92%E6%A0%BC&fromid=3578442&fr=aladdin) ，[伯克希尔·哈撒韦 ](https://baike.baidu.com/item/%E4%BC%AF%E5%85%8B%E5%B8%8C%E5%B0%94%C2%B7%E5%93%88%E6%92%92%E9%9F%A6/489043?fromtitle=%E4%BC%AF%E5%85%8B%E5%B8%8C%E5%B0%94-%E5%93%88%E6%92%92%E9%9F%A6&fromid=11258250&fr=aladdin)第二大股东(CEO为[沃伦·巴菲特](https://baike.baidu.com/item/%E6%B2%83%E4%BC%A6%C2%B7%E5%B7%B4%E8%8F%B2%E7%89%B9))。\n[查理·芒格推荐书单](https://xueqiu.com/1830611415/23012486)\n\n例如背单词的时候，事实上，在做所有类似的必须记住大量信息的工作的时候，一定要想办法由衷地把这件事**当作快乐的事情来做**。\n\n### 2.3. 满足感控制\n>要取得大的成绩就不能**急功近利**，不能为当前名利所诱惑 ，能按社会需要不怕挫折、坚持不懈奋斗是取得成就的重要因素。\n希望自己的欲望马上获得满足，是每个人的天性，我们要做的是稍加控制和改善。改善建议：\n\n1. 挑选自己某些方面的天性\n2. 纸笔罗列\n3. 反复审视\n\n推迟满足感会表现出“更有耐心”，这些耐心可以被用来不动声色地承受更多的打击和挫折，坦然面对更多的威逼和诱惑。\n\n\n另外，在对待自己的心智上还需要注意：\n\n### 2.4. 留心成功者说的话\n\n成功者往往没有足够的时间去讲述所有的细节，并且通常会夸大遇到的问题与取得的成功。成功者们又会有意无意的美化包装他们的经验，而这一切，都在干扰你的判断。当然，只有经过仔细甄别之后，真正的成功者的真正的宝贵经验，才是无价的。\n\n我们更应该关注“**失败者**” -- 努力从失败者身上汲取经验。失败的原因往往很容易确定,并且失败者数量更多，更便于我们的观察。\n\n### 2.5. 不要相信运气\n\n相信运气其实是缺乏自制力的表现。概率是独立于任何人存在的，因此绝对不会仅因为我的期望就发生任何变化。\n>好运气发生在你身上，你当然应该非常开心；坏运气降临在你身上，你应该平静接受--无论怎样你都要继续生活，当然就还要继续面对你不能控制的事物。其实，这是苏轼早就总结过的生活态度：“骤然临之而不惊， 无故加之而不怒。”\n\n>千万不要相信”机不可失，失不再来“。**当你没有准备好的时候，对你来讲，不存在任何机会**。机会时时刻刻都会出现在你身边，关键在于，你有没有足够努力，可以做到像诸葛亮那样，”万事俱备，只欠东风“。而当你准备好的时候，随处都有机会，而且所有的机会都是切实的，并且可以把握的机会。\n\n### 2.6. 打造人脉不如打造自己\n整体上来看，人脉当然很重要。不过，针对某个个体来说的话，更重要的是他所拥有的资源。有些资源很难瞬间获得，比如金钱、地位、名誉，尤其在这些资源的获得更多地依赖出身和运气的现实世界里。然而有些资源却可以很容易从零开始，比如一个人的才华与学识。才华也好学识也罢，是可以通过努力必然获得的东西。\n\n人脉之间大多存在着“交换的概念”，如果我们只是单纯的“索取方”，那给予方势必有“被抢，被夺走”东西的感觉。\n\n>生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要。打造自己，就等于打造人脉。\n\n以下是我的几个简单的，但实践起来并不是那么容易的建议：\n\n- 专心做可以**提升自己**的事情；学习并拥有更多更好的技能；成为一个**值得交往**的人；\n- 学会独善其身，以不给他人制造麻烦为美德；用你的**独立**赢得尊重；\n- 除非有特殊原因，应该尽量回避那些连在物质、精神生活上都不能独善其身的人；\n- 真正关心一个朋友的意思是说，你情愿在他身上花费甚至浪费更多的时间；\n- 记住，一个人的幸福程度，往往取决于他多大程度上可以脱离对外部世界的依附。\n\n## 3. 与时间做朋友\n>时间无法管理，你要管理的是你自己。\n\n一切的时间管理、立志行动等等说到底都离不开这两个词：**积累、坚持**。积累才是最有效的力量，唯有坚持才有希望，深信积累的力量，时间就是你的朋友。\n>从根本上，时间又是不能管理的，想要真正的掌控时间，需要的是开启心智，管理自己，掌控自我。\n\n### 3.1. 精确感知时间\n>“管理时间”是不可能的，那么解决方法就只能是，想尽一切办法真正了解自己，真正了解时间、精确地感知时间；而后再想尽一切办法使自己以及自己的行为与时间“合拍”。\n\n常见做法是“**基于过程记录**”。\n\n以下是摘自《奇特的一生》中[柳比歇夫](https://baike.baidu.com/item/%E6%9F%B3%E6%AF%94%E6%AD%87%E5%A4%AB/3389273?fr=aladdin)的日志样本\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=4727d7e26c061d95694b3f6a1a9d61b4/e4dde71190ef76c649c955f19f16fdfaae5167d5.jpg)\n\n\n| 事件 | 耗时 | 时间 |\n|:-|:-:|:-|\n| 分类昆虫学（画两张无名袋蛾的图）|三小时十五分|一九六四 年四月八日|\n|鉴定袋蛾|二十分|一九六四 年四月八日|\n|开始写关于袋蛾的报告|一小时五分|一九六四 年四月八日|\n\n### 3.2. 时间预算\n“To plan， or not to Plan， is a question.” 但是我们大多数都是\"We do not plan to fail， we fail to plan.”  哈哈\n\n在开始一天的活动之前，花费15至30分钟仔细制作你当天的时间预算绝对是特别划算的，磨刀不误砍柴工。\n在选择事情的重要性，推荐使用以下粒度，太细的划分会显得繁琐：\n- 重要\n- 一般\n- 不重要\n\n但是，在重要的事情上有：“显得重要”，“真的重要”。我们要去区分他们，其实只需要一个标准：**这个任务的完成是否对你的目标达成是否确实有益**。\n\n>强迫自己理智一些，就会知道，无用的事情，哪怕非常有趣都不应该去做；而有用的事情，哪怕非常无趣，你都应该做。但是，请你认真面对你自己，过去你一直是这样*用理智指导你的行为的么*？\n\n另外，在制作时间预算计划时，需要注意以下，避免时间的浪费：\n- 目标不现实或者目前暂时尚不可行（难度大，需要细分小任务）\n- 计划时间要比想象的更多点\n- 越是短期的目标，越容易清晰。越是清晰的目标越容易实现\n- 为了达到目标而制定的实施的策略\n- 考虑到一些变化因素\n- 计划固然重要，行动却更重要\n\n>当然，有些时候，你必须拖延你的行动。比如，当你决定买个新潮手机的时候，故意拖延三个月，会让你享受更低的价格；如果你决定买一辆你非常中意的高级轿车，故意拖延上一年，也许就会让你意识到当初的审美观其实很有问题。我个人的经验是，在所有的大额消费活动，乃至其他一切涉及到金钱的活动诸如投资之类上，“马上行动”的建议肯定不适用。\n\n### 3.3. 时间审计\n我们现在会早上制作计划，晚上回顾时间消耗（有点类似有财务记账）。一段时间之后，固定的时间消耗不用再出现在时间预算上面，不用天真填满每一分钟。尽管总是有意外发生，时间不够用的情况，我们也不要采用消减其他时间的时间类似睡觉休息的时间，而是应该使用“多线程”的做法:\n- 其中一件事情最好是机械的，少技术含量的\n- 另一件事情不是特别需要脑力的\n\nExample: 1) 跑步健身； 2）听audio book\n\n## 4. 更多思考\n\n### 4.1. 效率\n>记住，你不可能百分之百地有效率，至少不可能总是百分之百地有效率。有些时候，你会非常有效率，但是，这种情况不可能永远维持；并且肯定的是，如果你竟然强迫自己一定要如此做的话，你就会像那些用100%的功率运转的机器一样，由于损耗太大而提前报废。\n\n在做时间预算的时候，一定要留有空间。\n1. 你必须清楚肯定会有意外事件发生(意外总发生原因绝不是因为你的运气格外差，而往往只不过是因为你考虑得不够周全)\n2. 你必须用适当的方法休息、放松，以便恢复良好的状态去做更多的事情。\n\n>其实这世间的绝大多数事情都一样的--你不见得一定要做到极致才可以。有一个简单的算法：如果满分是100分，还是可以按照黄金分割定律，61.8分是恰好的。因为61.8分以上的成绩，意味着说你必须放弃很多才可以获的。\n\n于是，在你规划你的时间的时候，你应该明白为了能够完全专注120分钟，你最终需要规划出差不多150分钟左右的时间开销。这个方法非常简单，但非常有效。而因为它简单而有效，所以会很容易体会到效果。类似于[西红柿工作法](https://baike.baidu.com/item/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/6353502?fr=aladdin)\n\n### 4.2. 把生活节奏调整得慢一点\n>凡是值得做的事情，都值得慢慢做--做很久很久。\n\n因此，我们不用在最开始就制定“超人计划”，这样会很让你快速疲惫，进而放弃。\n>要想办法提前预知自己会需要怎样的技能，然后确定那是一个自己可以通过练习真正熟练掌握的技能之后，而后制定长期计划，一点一点地执行该计划。\n\n题外话：\n正确的减脂跑步方式应该是慢跑。慢跑到稍微气喘的地步，就改为快走，等气匀了再改为慢跑。这样就很容易坚持到30分钟，然后，在接下来的10~15 分钟之内，如果体力允许的话（通常要经过以两个月的适应），就尽量快跑，或者至少强度比前30分钟再高一点，以便消耗更多的脂肪。(有氧运动大约20分钟之内，消耗的往往只是水分，30分钟之后才开始消耗脂肪)\n\n### 4.3. 时间不一定是金钱\n>越是收入低的人越是不爱惜时间--因为他的时间实在是没有什么价值，每一秒钟都几乎可以忽略不计。越是收入高的人越是吝惜自己的时间，因为他的每一秒都有着确定的价值。\n\n问问自己，“我的时间究竟可以标价多少？”--这就是一个人决心不再浪费时间的最有效的起点和动力。只有爱惜才可能产生节约的动力。\n\n>世界上有一个银行每天给你86400元当日花销，不能接受存款预支。这就是我们每日度过的时间，`24 * 60 * 60 = 86400`\n\n将抽象的时间具体度量化，能帮助我们开始格外爱惜时间。\n\n### 4.4. 提前准备的好处\n\n>原来现在科学家们对所谓的“潜意识”也有了更多简单明了科学解释。我们大脑中的灰质中储存的各种信息只有很少一部分（很难超过12%）是有序储存的，这部分被我们称作是“有意识的”。而更多的信息，或者信息碎片，是非有序储存的，甚至很难有意识地直接调出，这些往往就是被我们称为“无意识”或者“潜意识”的部分。梦境的存在，就是潜意识存在的最基本证据。\n\n>而随着信息输入越来越多，大脑就需要越来越多的灰质细胞。科学家们已经发现使用两种或者两种以上语言的人，有更多地灰质细胞。而颅腔的大小是有限的，于是，灰质细胞的增加，最终会导致灰质密度越来越高。于是，灰质细胞之间就越有可能由神经元连接起来。于是就有可能产生我们所说的“融会贯通”的现象 --那些原本可能貌似毫不相干的信息现在有机会被联系在一起了。所以，所谓知识渊博的人，就是那些存储于脑中的信息量超常地多的人，这些人总是可以“融会贯通”，于是，超常地充满了“智慧”。\n\n","slug":"把时间当做朋友听书笔记","published":1,"updated":"2019-07-08T06:16:07.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0s20059zkgrurmrgq2q","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=57139f628bcb39dbc1c06050e82d6e19/342ac65c1038534371257ca99913b07ecb808854.jpg\" alt=\"\"></p>\n<p>这是<a href=\"http://www.ximalaya.com/zhubo/3983764/\" target=\"_blank\" rel=\"noopener\">晓书童喜马拉雅</a>音频作品中<a href=\"https://baike.baidu.com/item/%E6%9D%8E%E7%AC%91%E6%9D%A5/10966850?fr=aladdin\" target=\"_blank\" rel=\"noopener\">李笑来</a><a href=\"https://baike.baidu.com/item/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B/7192643?fr=aladdin\" target=\"_blank\" rel=\"noopener\">《把时间当做朋友》</a>(<a href=\"https://www.sbkk88.com/lizhishu/bashijiandangzuopengyou/\" target=\"_blank\" rel=\"noopener\"><em>在线文档</em></a>)的音频整理笔记。</p>\n<p>本书的核心点：<strong>心智</strong>。</p>\n<p>心智力量的不同，使不同的人面对相同的境遇，做出不同的解释，得到不同的结论，产生不同的选择。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-心智\"><a href=\"#1-心智\" class=\"headerlink\" title=\"1. 心智\"></a>1. 心智</h2><p>人与人之间的差异，除了看得见的相貌、身材、出身、财富的外，还有心智力量。</p>\n<p>心智力量的不同造成不同的看法的例子：<br><strong>兴趣真的那么重要？</strong><br>往往并不是有兴趣才能做好，而是做好了才有兴趣。 大多数事情都需要熟能生巧。做得多了，自然就擅长了；擅长了，就自然做得比别人好；做得比别人好，兴趣就大起来了，而后就更喜欢做，更擅长，更……良性循环。</p>\n<p><strong>学习方法真的重要？</strong></p>\n<blockquote>\n<p>当然，只有聪明的人才去关心方法，这没什么不对。然而，学生总是过分关心自己正在用的方法是不是正确。仅仅正确还不够。</p>\n</blockquote>\n<p>学习上的成功，都只靠两件事：<strong>策略和坚持</strong>，而坚持本身就应该是最重要的策略之一。坚持，其实就是重复，而重复，说到底就是时间的投入。</p>\n<p><strong>总结</strong></p>\n<blockquote>\n<p>没有什么要比发现、培养、呵护、调整自己的心智的力量更重要的事情了。一旦我们的心智出现了问题，我们就会因为错误的理解而做出错误的判断，因此浪费的时间往往不仅无法估量，更可怕的是，这种错误和浪费甚至可能根本无从知晓。</p>\n</blockquote>\n<h2 id=\"2-开启心智\"><a href=\"#2-开启心智\" class=\"headerlink\" title=\"2. 开启心智\"></a>2. 开启心智</h2><p>用我们的大脑控制我们的大脑，即开启心智，控制我们的大脑。<strong><em>你要明白你不应该隶属于你的大脑，而应该是你拥有你的大脑，并且应该是你可以控制你的大脑。</em></strong></p>\n<h3 id=\"2-1-大脑控制\"><a href=\"#2-1-大脑控制\" class=\"headerlink\" title=\"2.1. 大脑控制\"></a>2.1. 大脑控制</h3><blockquote>\n<p>人之为人，在于我们具有特殊的“大脑额页”正因如此，我们才具备其他动物很难具备的一种能力–“反思能力”–也许恰恰就是人与猴子之间3%不到的差异的具体体现。有了反思能力的人类，最终拥有了语言，发明了文字，形成了逻辑思考能力，最终拥有了强大的心智力量。</p>\n</blockquote>\n<blockquote>\n<p>“即使是在极端恶劣的环境里，人们也会拥有一种最后的自由 ，那就是选择自己的态度的自由 。” – 心理学家<a href=\"https://baike.baidu.com/item/%E7%BB%B4%E5%85%8B%E5%A4%9A%C2%B7%E5%BC%97%E5%85%B0%E5%85%8B/6628766?fromtitle=%E7%BB%B4%E5%85%8B%E6%89%98%C2%B7%E5%BC%97%E5%85%B0%E5%85%8B&amp;fromid=11237205&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">维克托·弗兰克</a><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=af148d81e1f81a4c323fe49bb6430b3c/4034970a304e251f36eddb0dad86c9177f3e5328.jpg\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"2-2-情绪控制\"><a href=\"#2-2-情绪控制\" class=\"headerlink\" title=\"2.2. 情绪控制\"></a>2.2. 情绪控制</h3><p>另外，心智还能帮助我们控制情绪。</p>\n<blockquote>\n<p>你所面临的所有尴尬，最终肯定有一部分原因是你自己造成的。所以，没必要找借口，没必要抱怨别人，没必要觉得这世界就对你一个人不公平，要记得“你并不孤独”–肯定还有别人也在不同的地方、不同的时代遭遇过同样的尴尬和痛苦。</p>\n</blockquote>\n<p>很多人并不了解自己大脑的机制（具备遗忘痛苦机制，回顾过去的痛苦，现在能平常对待），所以，他们不由自主地被自己的感觉所控制。</p>\n<blockquote>\n<p>“相信我，你并不孤独”，你遇见的事情总是有人遇见过，总能解决度过。</p>\n</blockquote>\n<blockquote>\n<p>你永远都不应该在面对一些难以置信的悲剧的时候，因为自己失去信念而让他演变成第二个，甚至是第三个。我一旦吸取了教训，就不会跟过往纠缠不休，花更多的时间去后悔过去发生的事。 – 《查理芒格传》（晓书童解读）</p>\n</blockquote>\n<blockquote>\n<p>阅读、学习、实践、反思，将有限的生命孤注于有价值的事情，等待时间的回报。 –《穷查理宝典》 (晓书童解读)</p>\n</blockquote>\n<blockquote>\n<p>我面对过去，背靠未来，从来不去做任何的预测。 – <a href=\"https://baike.baidu.com/item/%E6%9C%AC%E6%9D%B0%E6%98%8E%C2%B7%E6%A0%BC%E9%9B%B7%E5%8E%84%E5%A7%86/3481029?fromtitle=%E6%9C%AC%E6%9D%B0%E6%98%8E.%E6%A0%BC%E9%9B%B7%E5%8E%84%E5%A7%86&amp;fromid=11166116&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">本杰明.格雷厄姆</a></p>\n</blockquote>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=e9b600bbb312c8fcb4f3f1cbc40292b4/d833c895d143ad4b4a2e345b88025aafa40f062c.jpg\" alt=\"\"><br><a href=\"https://baike.baidu.com/item/%E6%9F%A5%E7%90%86%C2%B7%E8%8A%92%E6%A0%BC/4325934?fromtitle=%E6%9F%A5%E7%90%86%E8%8A%92%E6%A0%BC&amp;fromid=3578442&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">查理芒格</a> ，<a href=\"https://baike.baidu.com/item/%E4%BC%AF%E5%85%8B%E5%B8%8C%E5%B0%94%C2%B7%E5%93%88%E6%92%92%E9%9F%A6/489043?fromtitle=%E4%BC%AF%E5%85%8B%E5%B8%8C%E5%B0%94-%E5%93%88%E6%92%92%E9%9F%A6&amp;fromid=11258250&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">伯克希尔·哈撒韦 </a>第二大股东(CEO为<a href=\"https://baike.baidu.com/item/%E6%B2%83%E4%BC%A6%C2%B7%E5%B7%B4%E8%8F%B2%E7%89%B9\" target=\"_blank\" rel=\"noopener\">沃伦·巴菲特</a>)。<br><a href=\"https://xueqiu.com/1830611415/23012486\" target=\"_blank\" rel=\"noopener\">查理·芒格推荐书单</a></p>\n<p>例如背单词的时候，事实上，在做所有类似的必须记住大量信息的工作的时候，一定要想办法由衷地把这件事<strong>当作快乐的事情来做</strong>。</p>\n<h3 id=\"2-3-满足感控制\"><a href=\"#2-3-满足感控制\" class=\"headerlink\" title=\"2.3. 满足感控制\"></a>2.3. 满足感控制</h3><blockquote>\n<p>要取得大的成绩就不能<strong>急功近利</strong>，不能为当前名利所诱惑 ，能按社会需要不怕挫折、坚持不懈奋斗是取得成就的重要因素。<br>希望自己的欲望马上获得满足，是每个人的天性，我们要做的是稍加控制和改善。改善建议：</p>\n</blockquote>\n<ol>\n<li>挑选自己某些方面的天性</li>\n<li>纸笔罗列</li>\n<li>反复审视</li>\n</ol>\n<p>推迟满足感会表现出“更有耐心”，这些耐心可以被用来不动声色地承受更多的打击和挫折，坦然面对更多的威逼和诱惑。</p>\n<p>另外，在对待自己的心智上还需要注意：</p>\n<h3 id=\"2-4-留心成功者说的话\"><a href=\"#2-4-留心成功者说的话\" class=\"headerlink\" title=\"2.4. 留心成功者说的话\"></a>2.4. 留心成功者说的话</h3><p>成功者往往没有足够的时间去讲述所有的细节，并且通常会夸大遇到的问题与取得的成功。成功者们又会有意无意的美化包装他们的经验，而这一切，都在干扰你的判断。当然，只有经过仔细甄别之后，真正的成功者的真正的宝贵经验，才是无价的。</p>\n<p>我们更应该关注“<strong>失败者</strong>” – 努力从失败者身上汲取经验。失败的原因往往很容易确定,并且失败者数量更多，更便于我们的观察。</p>\n<h3 id=\"2-5-不要相信运气\"><a href=\"#2-5-不要相信运气\" class=\"headerlink\" title=\"2.5. 不要相信运气\"></a>2.5. 不要相信运气</h3><p>相信运气其实是缺乏自制力的表现。概率是独立于任何人存在的，因此绝对不会仅因为我的期望就发生任何变化。</p>\n<blockquote>\n<p>好运气发生在你身上，你当然应该非常开心；坏运气降临在你身上，你应该平静接受–无论怎样你都要继续生活，当然就还要继续面对你不能控制的事物。其实，这是苏轼早就总结过的生活态度：“骤然临之而不惊， 无故加之而不怒。”</p>\n</blockquote>\n<blockquote>\n<p>千万不要相信”机不可失，失不再来“。<strong>当你没有准备好的时候，对你来讲，不存在任何机会</strong>。机会时时刻刻都会出现在你身边，关键在于，你有没有足够努力，可以做到像诸葛亮那样，”万事俱备，只欠东风“。而当你准备好的时候，随处都有机会，而且所有的机会都是切实的，并且可以把握的机会。</p>\n</blockquote>\n<h3 id=\"2-6-打造人脉不如打造自己\"><a href=\"#2-6-打造人脉不如打造自己\" class=\"headerlink\" title=\"2.6. 打造人脉不如打造自己\"></a>2.6. 打造人脉不如打造自己</h3><p>整体上来看，人脉当然很重要。不过，针对某个个体来说的话，更重要的是他所拥有的资源。有些资源很难瞬间获得，比如金钱、地位、名誉，尤其在这些资源的获得更多地依赖出身和运气的现实世界里。然而有些资源却可以很容易从零开始，比如一个人的才华与学识。才华也好学识也罢，是可以通过努力必然获得的东西。</p>\n<p>人脉之间大多存在着“交换的概念”，如果我们只是单纯的“索取方”，那给予方势必有“被抢，被夺走”东西的感觉。</p>\n<blockquote>\n<p>生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要。打造自己，就等于打造人脉。</p>\n</blockquote>\n<p>以下是我的几个简单的，但实践起来并不是那么容易的建议：</p>\n<ul>\n<li>专心做可以<strong>提升自己</strong>的事情；学习并拥有更多更好的技能；成为一个<strong>值得交往</strong>的人；</li>\n<li>学会独善其身，以不给他人制造麻烦为美德；用你的<strong>独立</strong>赢得尊重；</li>\n<li>除非有特殊原因，应该尽量回避那些连在物质、精神生活上都不能独善其身的人；</li>\n<li>真正关心一个朋友的意思是说，你情愿在他身上花费甚至浪费更多的时间；</li>\n<li>记住，一个人的幸福程度，往往取决于他多大程度上可以脱离对外部世界的依附。</li>\n</ul>\n<h2 id=\"3-与时间做朋友\"><a href=\"#3-与时间做朋友\" class=\"headerlink\" title=\"3. 与时间做朋友\"></a>3. 与时间做朋友</h2><blockquote>\n<p>时间无法管理，你要管理的是你自己。</p>\n</blockquote>\n<p>一切的时间管理、立志行动等等说到底都离不开这两个词：<strong>积累、坚持</strong>。积累才是最有效的力量，唯有坚持才有希望，深信积累的力量，时间就是你的朋友。</p>\n<blockquote>\n<p>从根本上，时间又是不能管理的，想要真正的掌控时间，需要的是开启心智，管理自己，掌控自我。</p>\n</blockquote>\n<h3 id=\"3-1-精确感知时间\"><a href=\"#3-1-精确感知时间\" class=\"headerlink\" title=\"3.1. 精确感知时间\"></a>3.1. 精确感知时间</h3><blockquote>\n<p>“管理时间”是不可能的，那么解决方法就只能是，想尽一切办法真正了解自己，真正了解时间、精确地感知时间；而后再想尽一切办法使自己以及自己的行为与时间“合拍”。</p>\n</blockquote>\n<p>常见做法是“<strong>基于过程记录</strong>”。</p>\n<p>以下是摘自《奇特的一生》中<a href=\"https://baike.baidu.com/item/%E6%9F%B3%E6%AF%94%E6%AD%87%E5%A4%AB/3389273?fr=aladdin\" target=\"_blank\" rel=\"noopener\">柳比歇夫</a>的日志样本<br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=4727d7e26c061d95694b3f6a1a9d61b4/e4dde71190ef76c649c955f19f16fdfaae5167d5.jpg\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">事件</th>\n<th style=\"text-align:center\">耗时</th>\n<th style=\"text-align:left\">时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">分类昆虫学（画两张无名袋蛾的图）</td>\n<td style=\"text-align:center\">三小时十五分</td>\n<td style=\"text-align:left\">一九六四 年四月八日</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">鉴定袋蛾</td>\n<td style=\"text-align:center\">二十分</td>\n<td style=\"text-align:left\">一九六四 年四月八日</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">开始写关于袋蛾的报告</td>\n<td style=\"text-align:center\">一小时五分</td>\n<td style=\"text-align:left\">一九六四 年四月八日</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-2-时间预算\"><a href=\"#3-2-时间预算\" class=\"headerlink\" title=\"3.2. 时间预算\"></a>3.2. 时间预算</h3><p>“To plan， or not to Plan， is a question.” 但是我们大多数都是”We do not plan to fail， we fail to plan.”  哈哈</p>\n<p>在开始一天的活动之前，花费15至30分钟仔细制作你当天的时间预算绝对是特别划算的，磨刀不误砍柴工。<br>在选择事情的重要性，推荐使用以下粒度，太细的划分会显得繁琐：</p>\n<ul>\n<li>重要</li>\n<li>一般</li>\n<li>不重要</li>\n</ul>\n<p>但是，在重要的事情上有：“显得重要”，“真的重要”。我们要去区分他们，其实只需要一个标准：<strong>这个任务的完成是否对你的目标达成是否确实有益</strong>。</p>\n<blockquote>\n<p>强迫自己理智一些，就会知道，无用的事情，哪怕非常有趣都不应该去做；而有用的事情，哪怕非常无趣，你都应该做。但是，请你认真面对你自己，过去你一直是这样<em>用理智指导你的行为的么</em>？</p>\n</blockquote>\n<p>另外，在制作时间预算计划时，需要注意以下，避免时间的浪费：</p>\n<ul>\n<li>目标不现实或者目前暂时尚不可行（难度大，需要细分小任务）</li>\n<li>计划时间要比想象的更多点</li>\n<li>越是短期的目标，越容易清晰。越是清晰的目标越容易实现</li>\n<li>为了达到目标而制定的实施的策略</li>\n<li>考虑到一些变化因素</li>\n<li>计划固然重要，行动却更重要</li>\n</ul>\n<blockquote>\n<p>当然，有些时候，你必须拖延你的行动。比如，当你决定买个新潮手机的时候，故意拖延三个月，会让你享受更低的价格；如果你决定买一辆你非常中意的高级轿车，故意拖延上一年，也许就会让你意识到当初的审美观其实很有问题。我个人的经验是，在所有的大额消费活动，乃至其他一切涉及到金钱的活动诸如投资之类上，“马上行动”的建议肯定不适用。</p>\n</blockquote>\n<h3 id=\"3-3-时间审计\"><a href=\"#3-3-时间审计\" class=\"headerlink\" title=\"3.3. 时间审计\"></a>3.3. 时间审计</h3><p>我们现在会早上制作计划，晚上回顾时间消耗（有点类似有财务记账）。一段时间之后，固定的时间消耗不用再出现在时间预算上面，不用天真填满每一分钟。尽管总是有意外发生，时间不够用的情况，我们也不要采用消减其他时间的时间类似睡觉休息的时间，而是应该使用“多线程”的做法:</p>\n<ul>\n<li>其中一件事情最好是机械的，少技术含量的</li>\n<li>另一件事情不是特别需要脑力的</li>\n</ul>\n<p>Example: 1) 跑步健身； 2）听audio book</p>\n<h2 id=\"4-更多思考\"><a href=\"#4-更多思考\" class=\"headerlink\" title=\"4. 更多思考\"></a>4. 更多思考</h2><h3 id=\"4-1-效率\"><a href=\"#4-1-效率\" class=\"headerlink\" title=\"4.1. 效率\"></a>4.1. 效率</h3><blockquote>\n<p>记住，你不可能百分之百地有效率，至少不可能总是百分之百地有效率。有些时候，你会非常有效率，但是，这种情况不可能永远维持；并且肯定的是，如果你竟然强迫自己一定要如此做的话，你就会像那些用100%的功率运转的机器一样，由于损耗太大而提前报废。</p>\n</blockquote>\n<p>在做时间预算的时候，一定要留有空间。</p>\n<ol>\n<li>你必须清楚肯定会有意外事件发生(意外总发生原因绝不是因为你的运气格外差，而往往只不过是因为你考虑得不够周全)</li>\n<li>你必须用适当的方法休息、放松，以便恢复良好的状态去做更多的事情。</li>\n</ol>\n<blockquote>\n<p>其实这世间的绝大多数事情都一样的–你不见得一定要做到极致才可以。有一个简单的算法：如果满分是100分，还是可以按照黄金分割定律，61.8分是恰好的。因为61.8分以上的成绩，意味着说你必须放弃很多才可以获的。</p>\n</blockquote>\n<p>于是，在你规划你的时间的时候，你应该明白为了能够完全专注120分钟，你最终需要规划出差不多150分钟左右的时间开销。这个方法非常简单，但非常有效。而因为它简单而有效，所以会很容易体会到效果。类似于<a href=\"https://baike.baidu.com/item/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/6353502?fr=aladdin\" target=\"_blank\" rel=\"noopener\">西红柿工作法</a></p>\n<h3 id=\"4-2-把生活节奏调整得慢一点\"><a href=\"#4-2-把生活节奏调整得慢一点\" class=\"headerlink\" title=\"4.2. 把生活节奏调整得慢一点\"></a>4.2. 把生活节奏调整得慢一点</h3><blockquote>\n<p>凡是值得做的事情，都值得慢慢做–做很久很久。</p>\n</blockquote>\n<p>因此，我们不用在最开始就制定“超人计划”，这样会很让你快速疲惫，进而放弃。</p>\n<blockquote>\n<p>要想办法提前预知自己会需要怎样的技能，然后确定那是一个自己可以通过练习真正熟练掌握的技能之后，而后制定长期计划，一点一点地执行该计划。</p>\n</blockquote>\n<p>题外话：<br>正确的减脂跑步方式应该是慢跑。慢跑到稍微气喘的地步，就改为快走，等气匀了再改为慢跑。这样就很容易坚持到30分钟，然后，在接下来的10~15 分钟之内，如果体力允许的话（通常要经过以两个月的适应），就尽量快跑，或者至少强度比前30分钟再高一点，以便消耗更多的脂肪。(有氧运动大约20分钟之内，消耗的往往只是水分，30分钟之后才开始消耗脂肪)</p>\n<h3 id=\"4-3-时间不一定是金钱\"><a href=\"#4-3-时间不一定是金钱\" class=\"headerlink\" title=\"4.3. 时间不一定是金钱\"></a>4.3. 时间不一定是金钱</h3><blockquote>\n<p>越是收入低的人越是不爱惜时间–因为他的时间实在是没有什么价值，每一秒钟都几乎可以忽略不计。越是收入高的人越是吝惜自己的时间，因为他的每一秒都有着确定的价值。</p>\n</blockquote>\n<p>问问自己，“我的时间究竟可以标价多少？”–这就是一个人决心不再浪费时间的最有效的起点和动力。只有爱惜才可能产生节约的动力。</p>\n<blockquote>\n<p>世界上有一个银行每天给你86400元当日花销，不能接受存款预支。这就是我们每日度过的时间，<code>24 * 60 * 60 = 86400</code></p>\n</blockquote>\n<p>将抽象的时间具体度量化，能帮助我们开始格外爱惜时间。</p>\n<h3 id=\"4-4-提前准备的好处\"><a href=\"#4-4-提前准备的好处\" class=\"headerlink\" title=\"4.4. 提前准备的好处\"></a>4.4. 提前准备的好处</h3><blockquote>\n<p>原来现在科学家们对所谓的“潜意识”也有了更多简单明了科学解释。我们大脑中的灰质中储存的各种信息只有很少一部分（很难超过12%）是有序储存的，这部分被我们称作是“有意识的”。而更多的信息，或者信息碎片，是非有序储存的，甚至很难有意识地直接调出，这些往往就是被我们称为“无意识”或者“潜意识”的部分。梦境的存在，就是潜意识存在的最基本证据。</p>\n</blockquote>\n<blockquote>\n<p>而随着信息输入越来越多，大脑就需要越来越多的灰质细胞。科学家们已经发现使用两种或者两种以上语言的人，有更多地灰质细胞。而颅腔的大小是有限的，于是，灰质细胞的增加，最终会导致灰质密度越来越高。于是，灰质细胞之间就越有可能由神经元连接起来。于是就有可能产生我们所说的“融会贯通”的现象 –那些原本可能貌似毫不相干的信息现在有机会被联系在一起了。所以，所谓知识渊博的人，就是那些存储于脑中的信息量超常地多的人，这些人总是可以“融会贯通”，于是，超常地充满了“智慧”。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=57139f628bcb39dbc1c06050e82d6e19/342ac65c1038534371257ca99913b07ecb808854.jpg\" alt=\"\"></p>\n<p>这是<a href=\"http://www.ximalaya.com/zhubo/3983764/\" target=\"_blank\" rel=\"noopener\">晓书童喜马拉雅</a>音频作品中<a href=\"https://baike.baidu.com/item/%E6%9D%8E%E7%AC%91%E6%9D%A5/10966850?fr=aladdin\" target=\"_blank\" rel=\"noopener\">李笑来</a><a href=\"https://baike.baidu.com/item/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B/7192643?fr=aladdin\" target=\"_blank\" rel=\"noopener\">《把时间当做朋友》</a>(<a href=\"https://www.sbkk88.com/lizhishu/bashijiandangzuopengyou/\" target=\"_blank\" rel=\"noopener\"><em>在线文档</em></a>)的音频整理笔记。</p>\n<p>本书的核心点：<strong>心智</strong>。</p>\n<p>心智力量的不同，使不同的人面对相同的境遇，做出不同的解释，得到不同的结论，产生不同的选择。</p>","more":"<h2 id=\"1-心智\"><a href=\"#1-心智\" class=\"headerlink\" title=\"1. 心智\"></a>1. 心智</h2><p>人与人之间的差异，除了看得见的相貌、身材、出身、财富的外，还有心智力量。</p>\n<p>心智力量的不同造成不同的看法的例子：<br><strong>兴趣真的那么重要？</strong><br>往往并不是有兴趣才能做好，而是做好了才有兴趣。 大多数事情都需要熟能生巧。做得多了，自然就擅长了；擅长了，就自然做得比别人好；做得比别人好，兴趣就大起来了，而后就更喜欢做，更擅长，更……良性循环。</p>\n<p><strong>学习方法真的重要？</strong></p>\n<blockquote>\n<p>当然，只有聪明的人才去关心方法，这没什么不对。然而，学生总是过分关心自己正在用的方法是不是正确。仅仅正确还不够。</p>\n</blockquote>\n<p>学习上的成功，都只靠两件事：<strong>策略和坚持</strong>，而坚持本身就应该是最重要的策略之一。坚持，其实就是重复，而重复，说到底就是时间的投入。</p>\n<p><strong>总结</strong></p>\n<blockquote>\n<p>没有什么要比发现、培养、呵护、调整自己的心智的力量更重要的事情了。一旦我们的心智出现了问题，我们就会因为错误的理解而做出错误的判断，因此浪费的时间往往不仅无法估量，更可怕的是，这种错误和浪费甚至可能根本无从知晓。</p>\n</blockquote>\n<h2 id=\"2-开启心智\"><a href=\"#2-开启心智\" class=\"headerlink\" title=\"2. 开启心智\"></a>2. 开启心智</h2><p>用我们的大脑控制我们的大脑，即开启心智，控制我们的大脑。<strong><em>你要明白你不应该隶属于你的大脑，而应该是你拥有你的大脑，并且应该是你可以控制你的大脑。</em></strong></p>\n<h3 id=\"2-1-大脑控制\"><a href=\"#2-1-大脑控制\" class=\"headerlink\" title=\"2.1. 大脑控制\"></a>2.1. 大脑控制</h3><blockquote>\n<p>人之为人，在于我们具有特殊的“大脑额页”正因如此，我们才具备其他动物很难具备的一种能力–“反思能力”–也许恰恰就是人与猴子之间3%不到的差异的具体体现。有了反思能力的人类，最终拥有了语言，发明了文字，形成了逻辑思考能力，最终拥有了强大的心智力量。</p>\n</blockquote>\n<blockquote>\n<p>“即使是在极端恶劣的环境里，人们也会拥有一种最后的自由 ，那就是选择自己的态度的自由 。” – 心理学家<a href=\"https://baike.baidu.com/item/%E7%BB%B4%E5%85%8B%E5%A4%9A%C2%B7%E5%BC%97%E5%85%B0%E5%85%8B/6628766?fromtitle=%E7%BB%B4%E5%85%8B%E6%89%98%C2%B7%E5%BC%97%E5%85%B0%E5%85%8B&amp;fromid=11237205&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">维克托·弗兰克</a><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=af148d81e1f81a4c323fe49bb6430b3c/4034970a304e251f36eddb0dad86c9177f3e5328.jpg\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"2-2-情绪控制\"><a href=\"#2-2-情绪控制\" class=\"headerlink\" title=\"2.2. 情绪控制\"></a>2.2. 情绪控制</h3><p>另外，心智还能帮助我们控制情绪。</p>\n<blockquote>\n<p>你所面临的所有尴尬，最终肯定有一部分原因是你自己造成的。所以，没必要找借口，没必要抱怨别人，没必要觉得这世界就对你一个人不公平，要记得“你并不孤独”–肯定还有别人也在不同的地方、不同的时代遭遇过同样的尴尬和痛苦。</p>\n</blockquote>\n<p>很多人并不了解自己大脑的机制（具备遗忘痛苦机制，回顾过去的痛苦，现在能平常对待），所以，他们不由自主地被自己的感觉所控制。</p>\n<blockquote>\n<p>“相信我，你并不孤独”，你遇见的事情总是有人遇见过，总能解决度过。</p>\n</blockquote>\n<blockquote>\n<p>你永远都不应该在面对一些难以置信的悲剧的时候，因为自己失去信念而让他演变成第二个，甚至是第三个。我一旦吸取了教训，就不会跟过往纠缠不休，花更多的时间去后悔过去发生的事。 – 《查理芒格传》（晓书童解读）</p>\n</blockquote>\n<blockquote>\n<p>阅读、学习、实践、反思，将有限的生命孤注于有价值的事情，等待时间的回报。 –《穷查理宝典》 (晓书童解读)</p>\n</blockquote>\n<blockquote>\n<p>我面对过去，背靠未来，从来不去做任何的预测。 – <a href=\"https://baike.baidu.com/item/%E6%9C%AC%E6%9D%B0%E6%98%8E%C2%B7%E6%A0%BC%E9%9B%B7%E5%8E%84%E5%A7%86/3481029?fromtitle=%E6%9C%AC%E6%9D%B0%E6%98%8E.%E6%A0%BC%E9%9B%B7%E5%8E%84%E5%A7%86&amp;fromid=11166116&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">本杰明.格雷厄姆</a></p>\n</blockquote>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=e9b600bbb312c8fcb4f3f1cbc40292b4/d833c895d143ad4b4a2e345b88025aafa40f062c.jpg\" alt=\"\"><br><a href=\"https://baike.baidu.com/item/%E6%9F%A5%E7%90%86%C2%B7%E8%8A%92%E6%A0%BC/4325934?fromtitle=%E6%9F%A5%E7%90%86%E8%8A%92%E6%A0%BC&amp;fromid=3578442&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">查理芒格</a> ，<a href=\"https://baike.baidu.com/item/%E4%BC%AF%E5%85%8B%E5%B8%8C%E5%B0%94%C2%B7%E5%93%88%E6%92%92%E9%9F%A6/489043?fromtitle=%E4%BC%AF%E5%85%8B%E5%B8%8C%E5%B0%94-%E5%93%88%E6%92%92%E9%9F%A6&amp;fromid=11258250&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">伯克希尔·哈撒韦 </a>第二大股东(CEO为<a href=\"https://baike.baidu.com/item/%E6%B2%83%E4%BC%A6%C2%B7%E5%B7%B4%E8%8F%B2%E7%89%B9\" target=\"_blank\" rel=\"noopener\">沃伦·巴菲特</a>)。<br><a href=\"https://xueqiu.com/1830611415/23012486\" target=\"_blank\" rel=\"noopener\">查理·芒格推荐书单</a></p>\n<p>例如背单词的时候，事实上，在做所有类似的必须记住大量信息的工作的时候，一定要想办法由衷地把这件事<strong>当作快乐的事情来做</strong>。</p>\n<h3 id=\"2-3-满足感控制\"><a href=\"#2-3-满足感控制\" class=\"headerlink\" title=\"2.3. 满足感控制\"></a>2.3. 满足感控制</h3><blockquote>\n<p>要取得大的成绩就不能<strong>急功近利</strong>，不能为当前名利所诱惑 ，能按社会需要不怕挫折、坚持不懈奋斗是取得成就的重要因素。<br>希望自己的欲望马上获得满足，是每个人的天性，我们要做的是稍加控制和改善。改善建议：</p>\n</blockquote>\n<ol>\n<li>挑选自己某些方面的天性</li>\n<li>纸笔罗列</li>\n<li>反复审视</li>\n</ol>\n<p>推迟满足感会表现出“更有耐心”，这些耐心可以被用来不动声色地承受更多的打击和挫折，坦然面对更多的威逼和诱惑。</p>\n<p>另外，在对待自己的心智上还需要注意：</p>\n<h3 id=\"2-4-留心成功者说的话\"><a href=\"#2-4-留心成功者说的话\" class=\"headerlink\" title=\"2.4. 留心成功者说的话\"></a>2.4. 留心成功者说的话</h3><p>成功者往往没有足够的时间去讲述所有的细节，并且通常会夸大遇到的问题与取得的成功。成功者们又会有意无意的美化包装他们的经验，而这一切，都在干扰你的判断。当然，只有经过仔细甄别之后，真正的成功者的真正的宝贵经验，才是无价的。</p>\n<p>我们更应该关注“<strong>失败者</strong>” – 努力从失败者身上汲取经验。失败的原因往往很容易确定,并且失败者数量更多，更便于我们的观察。</p>\n<h3 id=\"2-5-不要相信运气\"><a href=\"#2-5-不要相信运气\" class=\"headerlink\" title=\"2.5. 不要相信运气\"></a>2.5. 不要相信运气</h3><p>相信运气其实是缺乏自制力的表现。概率是独立于任何人存在的，因此绝对不会仅因为我的期望就发生任何变化。</p>\n<blockquote>\n<p>好运气发生在你身上，你当然应该非常开心；坏运气降临在你身上，你应该平静接受–无论怎样你都要继续生活，当然就还要继续面对你不能控制的事物。其实，这是苏轼早就总结过的生活态度：“骤然临之而不惊， 无故加之而不怒。”</p>\n</blockquote>\n<blockquote>\n<p>千万不要相信”机不可失，失不再来“。<strong>当你没有准备好的时候，对你来讲，不存在任何机会</strong>。机会时时刻刻都会出现在你身边，关键在于，你有没有足够努力，可以做到像诸葛亮那样，”万事俱备，只欠东风“。而当你准备好的时候，随处都有机会，而且所有的机会都是切实的，并且可以把握的机会。</p>\n</blockquote>\n<h3 id=\"2-6-打造人脉不如打造自己\"><a href=\"#2-6-打造人脉不如打造自己\" class=\"headerlink\" title=\"2.6. 打造人脉不如打造自己\"></a>2.6. 打造人脉不如打造自己</h3><p>整体上来看，人脉当然很重要。不过，针对某个个体来说的话，更重要的是他所拥有的资源。有些资源很难瞬间获得，比如金钱、地位、名誉，尤其在这些资源的获得更多地依赖出身和运气的现实世界里。然而有些资源却可以很容易从零开始，比如一个人的才华与学识。才华也好学识也罢，是可以通过努力必然获得的东西。</p>\n<p>人脉之间大多存在着“交换的概念”，如果我们只是单纯的“索取方”，那给予方势必有“被抢，被夺走”东西的感觉。</p>\n<blockquote>\n<p>生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要。打造自己，就等于打造人脉。</p>\n</blockquote>\n<p>以下是我的几个简单的，但实践起来并不是那么容易的建议：</p>\n<ul>\n<li>专心做可以<strong>提升自己</strong>的事情；学习并拥有更多更好的技能；成为一个<strong>值得交往</strong>的人；</li>\n<li>学会独善其身，以不给他人制造麻烦为美德；用你的<strong>独立</strong>赢得尊重；</li>\n<li>除非有特殊原因，应该尽量回避那些连在物质、精神生活上都不能独善其身的人；</li>\n<li>真正关心一个朋友的意思是说，你情愿在他身上花费甚至浪费更多的时间；</li>\n<li>记住，一个人的幸福程度，往往取决于他多大程度上可以脱离对外部世界的依附。</li>\n</ul>\n<h2 id=\"3-与时间做朋友\"><a href=\"#3-与时间做朋友\" class=\"headerlink\" title=\"3. 与时间做朋友\"></a>3. 与时间做朋友</h2><blockquote>\n<p>时间无法管理，你要管理的是你自己。</p>\n</blockquote>\n<p>一切的时间管理、立志行动等等说到底都离不开这两个词：<strong>积累、坚持</strong>。积累才是最有效的力量，唯有坚持才有希望，深信积累的力量，时间就是你的朋友。</p>\n<blockquote>\n<p>从根本上，时间又是不能管理的，想要真正的掌控时间，需要的是开启心智，管理自己，掌控自我。</p>\n</blockquote>\n<h3 id=\"3-1-精确感知时间\"><a href=\"#3-1-精确感知时间\" class=\"headerlink\" title=\"3.1. 精确感知时间\"></a>3.1. 精确感知时间</h3><blockquote>\n<p>“管理时间”是不可能的，那么解决方法就只能是，想尽一切办法真正了解自己，真正了解时间、精确地感知时间；而后再想尽一切办法使自己以及自己的行为与时间“合拍”。</p>\n</blockquote>\n<p>常见做法是“<strong>基于过程记录</strong>”。</p>\n<p>以下是摘自《奇特的一生》中<a href=\"https://baike.baidu.com/item/%E6%9F%B3%E6%AF%94%E6%AD%87%E5%A4%AB/3389273?fr=aladdin\" target=\"_blank\" rel=\"noopener\">柳比歇夫</a>的日志样本<br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=4727d7e26c061d95694b3f6a1a9d61b4/e4dde71190ef76c649c955f19f16fdfaae5167d5.jpg\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">事件</th>\n<th style=\"text-align:center\">耗时</th>\n<th style=\"text-align:left\">时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">分类昆虫学（画两张无名袋蛾的图）</td>\n<td style=\"text-align:center\">三小时十五分</td>\n<td style=\"text-align:left\">一九六四 年四月八日</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">鉴定袋蛾</td>\n<td style=\"text-align:center\">二十分</td>\n<td style=\"text-align:left\">一九六四 年四月八日</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">开始写关于袋蛾的报告</td>\n<td style=\"text-align:center\">一小时五分</td>\n<td style=\"text-align:left\">一九六四 年四月八日</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-2-时间预算\"><a href=\"#3-2-时间预算\" class=\"headerlink\" title=\"3.2. 时间预算\"></a>3.2. 时间预算</h3><p>“To plan， or not to Plan， is a question.” 但是我们大多数都是”We do not plan to fail， we fail to plan.”  哈哈</p>\n<p>在开始一天的活动之前，花费15至30分钟仔细制作你当天的时间预算绝对是特别划算的，磨刀不误砍柴工。<br>在选择事情的重要性，推荐使用以下粒度，太细的划分会显得繁琐：</p>\n<ul>\n<li>重要</li>\n<li>一般</li>\n<li>不重要</li>\n</ul>\n<p>但是，在重要的事情上有：“显得重要”，“真的重要”。我们要去区分他们，其实只需要一个标准：<strong>这个任务的完成是否对你的目标达成是否确实有益</strong>。</p>\n<blockquote>\n<p>强迫自己理智一些，就会知道，无用的事情，哪怕非常有趣都不应该去做；而有用的事情，哪怕非常无趣，你都应该做。但是，请你认真面对你自己，过去你一直是这样<em>用理智指导你的行为的么</em>？</p>\n</blockquote>\n<p>另外，在制作时间预算计划时，需要注意以下，避免时间的浪费：</p>\n<ul>\n<li>目标不现实或者目前暂时尚不可行（难度大，需要细分小任务）</li>\n<li>计划时间要比想象的更多点</li>\n<li>越是短期的目标，越容易清晰。越是清晰的目标越容易实现</li>\n<li>为了达到目标而制定的实施的策略</li>\n<li>考虑到一些变化因素</li>\n<li>计划固然重要，行动却更重要</li>\n</ul>\n<blockquote>\n<p>当然，有些时候，你必须拖延你的行动。比如，当你决定买个新潮手机的时候，故意拖延三个月，会让你享受更低的价格；如果你决定买一辆你非常中意的高级轿车，故意拖延上一年，也许就会让你意识到当初的审美观其实很有问题。我个人的经验是，在所有的大额消费活动，乃至其他一切涉及到金钱的活动诸如投资之类上，“马上行动”的建议肯定不适用。</p>\n</blockquote>\n<h3 id=\"3-3-时间审计\"><a href=\"#3-3-时间审计\" class=\"headerlink\" title=\"3.3. 时间审计\"></a>3.3. 时间审计</h3><p>我们现在会早上制作计划，晚上回顾时间消耗（有点类似有财务记账）。一段时间之后，固定的时间消耗不用再出现在时间预算上面，不用天真填满每一分钟。尽管总是有意外发生，时间不够用的情况，我们也不要采用消减其他时间的时间类似睡觉休息的时间，而是应该使用“多线程”的做法:</p>\n<ul>\n<li>其中一件事情最好是机械的，少技术含量的</li>\n<li>另一件事情不是特别需要脑力的</li>\n</ul>\n<p>Example: 1) 跑步健身； 2）听audio book</p>\n<h2 id=\"4-更多思考\"><a href=\"#4-更多思考\" class=\"headerlink\" title=\"4. 更多思考\"></a>4. 更多思考</h2><h3 id=\"4-1-效率\"><a href=\"#4-1-效率\" class=\"headerlink\" title=\"4.1. 效率\"></a>4.1. 效率</h3><blockquote>\n<p>记住，你不可能百分之百地有效率，至少不可能总是百分之百地有效率。有些时候，你会非常有效率，但是，这种情况不可能永远维持；并且肯定的是，如果你竟然强迫自己一定要如此做的话，你就会像那些用100%的功率运转的机器一样，由于损耗太大而提前报废。</p>\n</blockquote>\n<p>在做时间预算的时候，一定要留有空间。</p>\n<ol>\n<li>你必须清楚肯定会有意外事件发生(意外总发生原因绝不是因为你的运气格外差，而往往只不过是因为你考虑得不够周全)</li>\n<li>你必须用适当的方法休息、放松，以便恢复良好的状态去做更多的事情。</li>\n</ol>\n<blockquote>\n<p>其实这世间的绝大多数事情都一样的–你不见得一定要做到极致才可以。有一个简单的算法：如果满分是100分，还是可以按照黄金分割定律，61.8分是恰好的。因为61.8分以上的成绩，意味着说你必须放弃很多才可以获的。</p>\n</blockquote>\n<p>于是，在你规划你的时间的时候，你应该明白为了能够完全专注120分钟，你最终需要规划出差不多150分钟左右的时间开销。这个方法非常简单，但非常有效。而因为它简单而有效，所以会很容易体会到效果。类似于<a href=\"https://baike.baidu.com/item/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/6353502?fr=aladdin\" target=\"_blank\" rel=\"noopener\">西红柿工作法</a></p>\n<h3 id=\"4-2-把生活节奏调整得慢一点\"><a href=\"#4-2-把生活节奏调整得慢一点\" class=\"headerlink\" title=\"4.2. 把生活节奏调整得慢一点\"></a>4.2. 把生活节奏调整得慢一点</h3><blockquote>\n<p>凡是值得做的事情，都值得慢慢做–做很久很久。</p>\n</blockquote>\n<p>因此，我们不用在最开始就制定“超人计划”，这样会很让你快速疲惫，进而放弃。</p>\n<blockquote>\n<p>要想办法提前预知自己会需要怎样的技能，然后确定那是一个自己可以通过练习真正熟练掌握的技能之后，而后制定长期计划，一点一点地执行该计划。</p>\n</blockquote>\n<p>题外话：<br>正确的减脂跑步方式应该是慢跑。慢跑到稍微气喘的地步，就改为快走，等气匀了再改为慢跑。这样就很容易坚持到30分钟，然后，在接下来的10~15 分钟之内，如果体力允许的话（通常要经过以两个月的适应），就尽量快跑，或者至少强度比前30分钟再高一点，以便消耗更多的脂肪。(有氧运动大约20分钟之内，消耗的往往只是水分，30分钟之后才开始消耗脂肪)</p>\n<h3 id=\"4-3-时间不一定是金钱\"><a href=\"#4-3-时间不一定是金钱\" class=\"headerlink\" title=\"4.3. 时间不一定是金钱\"></a>4.3. 时间不一定是金钱</h3><blockquote>\n<p>越是收入低的人越是不爱惜时间–因为他的时间实在是没有什么价值，每一秒钟都几乎可以忽略不计。越是收入高的人越是吝惜自己的时间，因为他的每一秒都有着确定的价值。</p>\n</blockquote>\n<p>问问自己，“我的时间究竟可以标价多少？”–这就是一个人决心不再浪费时间的最有效的起点和动力。只有爱惜才可能产生节约的动力。</p>\n<blockquote>\n<p>世界上有一个银行每天给你86400元当日花销，不能接受存款预支。这就是我们每日度过的时间，<code>24 * 60 * 60 = 86400</code></p>\n</blockquote>\n<p>将抽象的时间具体度量化，能帮助我们开始格外爱惜时间。</p>\n<h3 id=\"4-4-提前准备的好处\"><a href=\"#4-4-提前准备的好处\" class=\"headerlink\" title=\"4.4. 提前准备的好处\"></a>4.4. 提前准备的好处</h3><blockquote>\n<p>原来现在科学家们对所谓的“潜意识”也有了更多简单明了科学解释。我们大脑中的灰质中储存的各种信息只有很少一部分（很难超过12%）是有序储存的，这部分被我们称作是“有意识的”。而更多的信息，或者信息碎片，是非有序储存的，甚至很难有意识地直接调出，这些往往就是被我们称为“无意识”或者“潜意识”的部分。梦境的存在，就是潜意识存在的最基本证据。</p>\n</blockquote>\n<blockquote>\n<p>而随着信息输入越来越多，大脑就需要越来越多的灰质细胞。科学家们已经发现使用两种或者两种以上语言的人，有更多地灰质细胞。而颅腔的大小是有限的，于是，灰质细胞的增加，最终会导致灰质密度越来越高。于是，灰质细胞之间就越有可能由神经元连接起来。于是就有可能产生我们所说的“融会贯通”的现象 –那些原本可能貌似毫不相干的信息现在有机会被联系在一起了。所以，所谓知识渊博的人，就是那些存储于脑中的信息量超常地多的人，这些人总是可以“融会贯通”，于是，超常地充满了“智慧”。</p>\n</blockquote>"},{"title":"敏捷软件开发原则与模式及实践","date":"2018-06-04T11:59:25.000Z","_content":"\n[敏捷开发](https://baike.baidu.com/item/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/7108658?fr=aladdin)(Agile Development) 是一种面临迅速变化的需求快速开发软件的能力。我们需要：\n\n1. 纪律和反馈的时间\n\n2. 保持软件灵活、可维护的设计原则\n\n3. 平衡这些原则的**设计模式**\n\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=bc5f38dbd343ad4bb2234e92e36b31ca/359b033b5bb5c9ea70a2c69dd739b6003af3b37f.jpg)\n\n<!-- more -->\n\n## 1. 敏捷开发\n> 人与人之间的交互是复杂的，并且其效果从来都难以预期，但确实工作中最为重要的方面。 --《人件》\n\n[人件-百度百科](https://baike.baidu.com/item/%E4%BA%BA%E4%BB%B6/4119178?fr=aladdin)\n\n原则(principle)、模式（parttern）、实践（practice）是重要的，但是人更重要。*如果想要项目取得成功，就必须构建起具有合作精神的、自组织的团队。*\n\n### 1.1. 敏捷实践\n缺乏有效的实践会导致不可预测、重复的错误。\n\n#### 1.1.1. 敏捷联盟\n以下观点不是认为后面的不重要，而是前者重要性更高。\n\n**个体和交互     >  过程和工具** （先构建团队，再让团队基于需求配置环境。）\n\n**可工作的软件   >  面面俱到的文档**\n\n**客户合作      >  合同谈判**\n\n**响应变化      >  遵循计划**\n\n当我们构建计划时，应该确保计划是灵活的并且易于适应商务和技术方面的变化。\n较好的策略：为下两周做详细的计划，为下三个月做粗率的计划，再以后就做极为粗糙的计划。\n\n#### 1.1.2. 原则\n\n- 围绕被激励起来的人构建项目，提供需要的环境和支持\n- 工作的软件是首要的进度度量标准\n- 最优先的是通过尽早的、持续的交互有价值的软件来是客户满意，间隔时间可以是几周到几个月\n- 即使在开发后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势\n- 开发周期，业务人员和开发人员天天在一起工作\n- 面对面的交谈是最有效的传递信息方法\n- 最后的构架、需求和设计出自于自组织的团队\n- 不断关注优秀的技能和好的设计增强敏捷能力\n- 周期性的在提高效率上反思，并做出调整\n\n### 1.2. 极限编程概述\n极限编程（eXtreme Programming, 简称XP）\n\n#### 1.2.1. 客户成为团队成员\n以便知晓对方面临的问题，并共同去解决这些问题。\n\n#### 1.2.2. 用户素材\n做计划只需要了解到能估算它的程度就可以了，需求的特定细节会随时间而改变，在新版本之后是关注新需求的好时机。\n在XP 中，重要的是对需求细节的理解，而不是捕获细节。\n\n#### 1.2.3. 短交互周期\n\n**用户素材**\n用户会一直编写新的真正重要的用户元素到项目中\n\n**迭代计划**\n\n`客户`：选择不超过开发人员本次迭代周期的用户素材，并在迭代开始后，不在修改当次迭代用户素材的定义和优先级别。\n\n`开发人员`：根据之前的迭代工作量预算本次迭代，在迭代期间自由分解用户素材为任务，并根据最具技术和商务意义的顺序开发任务。\n\n**发布计划**\n\nXP 团队通常会创建一个计划来规划随后大约6次迭代的内容。\n\n**验收测试**\n\n验收测试使用能够让他们自动并且反复运行的某种脚本语言编写，这些测试共同来验证系统是否按照用户指定行为运行。\n\n**集体所有权**\n\n如果你是专业领域有关GUI的，那么你最有可能去从事GUI 方面的任务，但是你将会被邀请去和别人结对从事有关中间件和数据库方面的任务。如果你决定学习另一们专业知识，你可以承担相关任务，并和能传授你这方面知识的专家一起工作，不会被限制在自己的专业领域。（个人认为有点偏重于理想化。）\n\n**持续集成**\n\n每个模块都可以在完成单元测试之后，合并到主线中。因而，XP 团队每天会进行多次系统构建。\n\n**可持续的开发速度**\n\n软件项目是马拉松长跑，而不是全速的短跑。团队必须要以一种可持续的速度前进，有意识的保持稳定、始终的速度。\n团队位于开放的空间，充满交谈的环境下。每个人都可以获知Partner 遇到的麻烦，工作状态。\n\n**简单的设计**\n\n- 考虑能够工作的最简单的事情（如选择平面文件而不是数据库，选择简单的socket 而不是ORB（对象请求代理），RMI（远程方法调用）），只有在有证据情况下，才去引入这些。\n\n- 代码的重构，消除退化腐朽的代码\n\n- 使用简单的比喻，来说明指导整个脉络流程\n\n## 2. 敏捷设计\n\n敏捷团队，全局视图与软件一起演化。每次迭代中，系统设计都尽可能适用于当前系统，不会过多的预测未来的需求，更加关注于当前的系统结构。\n\n较好的原则设计：\n\n- 单一职责原则（The Single Responsibility Principle, 简称SRP）\n- 开放-封闭原则（The Open-Close Principle, 简称OCP）\n- Liskov 替换原则( The Liskov Substitution Principle, 简称LSP)\n- 依赖倒置原则( The Dependency Inversion Principle， 简称DIP)\n- 接口隔离原则（The Interface Segregation Principle 简称ISP）\n\n### 2.1. 什么是敏捷设计\n\n敏捷设计师一个过程，是一个持续应用原则、模式以及实践来改进软件的结构和可读性的过程。保证系统设计在任何时间都尽可能简单、干净，杜绝代码的腐化。\n\n- 遵循敏捷实践去发现问题\n- 应用设计原则去诊断问题\n- 应用适当的设计模式解决问题\n\n### 2.2. 单一职责原则（SRP）\n\n就一个类而言，应该仅有一个引起他变化的原因。\n如果一个类承担的职责太多，就等于把这些职责耦合在一起，进而导致脆弱的设计。\n\n```java\ninterface Modem \n{\n\tpublic void dial(string pno);\n\tpublic void hanguo();\n\tpublic void send(char c);\n\tpublic void recv();\n}\n```\n接口中有两个职责：连接， 数据通信。如果应用程序的变化会影响连接函数的签名，那么这个设计就具有僵化性的臭味。在这情况下，我们分离两个职责。\n\n```java\ninterface Data_Channel\n{\n\tpublic void send(char c);\n\tpublic void recv();\n}\n\ninterface Connection\n{\n\tpublic void dial(stirng pno);\n\tpublic void hangup();\n}\n\ninterface Modem_middle extends Data_Channel, Connection\n{\n\n}\n\n```\n但是，如果程序的变化总是导致这两个职责同事变化，就不必分离他们。\n\n### 2.3. 开放-封闭原则（OCP）\n\n主要特征：\n1. “对于扩展是开放的（Open for extension ）”: 对模块进行扩张，使其满足新行为。\n2. “对于更改是封闭的（Closed for modification)”： 对模块行为扩张时，不必改动模块的源代码，模块的二进制执行版本（库、DLL，.jar文件）都无需改变。\n\n这两点看似是矛盾的，请看如下解释。\n\n**抽象**\n\n模块依赖于某一抽象体，所以对它的更改是关闭的，通过这个抽象体的派生，扩展此模块的行为。\n\n遵循OCP 代价是昂贵的，增加设计的复杂性，开发人员处理抽象数量有限。我们希望OCP 的应用限定在可能发生变化的上。\n\n**吊钩(hook)**\n\n在认为可能发生变化的地方放置吊钩（hook），会使软件更灵活些。\n\nOCP 主要机制是抽象（abstraction） 和多态 (polymorphism)。\n\n### 2.4. Liskov 替换原则(LSP)\n\nLSP 提供了继承层次保持OCP 的指导， 只有保持了OCP 才会保证我们软件的灵活性，可重用性。\n\nLSP： 子类型（subtype）必须能够替换掉他们的基类型（base type）。\nBarbara Liskov 在1988年写下这个原则：\n> 若对每隔类型S 的对象s, 都存在一个类型T 的对象t ,使得在所有针对T 编写的程序P 中，用s 替换t 后，程序P 的行为功能保持不变，则S 是T 的子类型。\n\n\n### 2.5. 依赖倒置原则 (DIP)\n\n依赖倒置原则：\n\n- **高层模块不应该依赖于低层模块，二者都应该依赖于抽象**\n- 抽象不应该依赖于细节，细节应该依赖于抽象\n\n如果高层模块依赖于低层模块，那么低层模块的修改将会影响并作用于高层模块。\n\n### 2.6. 接口隔离原则（ISP）\n\n> 不应该强迫客户依赖于他们不用的方法。\n\n如果强迫客户程序依赖于他们不使用的方法，那么这些客户程序就面临着由于这些未使用的方法的改变所带来的变更。\n\n更多的策略是： **使用多重继承分离接口**","source":"_posts/敏捷软件开发原则与模式及实践.md","raw":"---\ntitle: 敏捷软件开发原则与模式及实践\ndate: 2018-06-04 19:59:25\ntags: bookmarks\ncategories: bookmarks\n---\n\n[敏捷开发](https://baike.baidu.com/item/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/7108658?fr=aladdin)(Agile Development) 是一种面临迅速变化的需求快速开发软件的能力。我们需要：\n\n1. 纪律和反馈的时间\n\n2. 保持软件灵活、可维护的设计原则\n\n3. 平衡这些原则的**设计模式**\n\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=bc5f38dbd343ad4bb2234e92e36b31ca/359b033b5bb5c9ea70a2c69dd739b6003af3b37f.jpg)\n\n<!-- more -->\n\n## 1. 敏捷开发\n> 人与人之间的交互是复杂的，并且其效果从来都难以预期，但确实工作中最为重要的方面。 --《人件》\n\n[人件-百度百科](https://baike.baidu.com/item/%E4%BA%BA%E4%BB%B6/4119178?fr=aladdin)\n\n原则(principle)、模式（parttern）、实践（practice）是重要的，但是人更重要。*如果想要项目取得成功，就必须构建起具有合作精神的、自组织的团队。*\n\n### 1.1. 敏捷实践\n缺乏有效的实践会导致不可预测、重复的错误。\n\n#### 1.1.1. 敏捷联盟\n以下观点不是认为后面的不重要，而是前者重要性更高。\n\n**个体和交互     >  过程和工具** （先构建团队，再让团队基于需求配置环境。）\n\n**可工作的软件   >  面面俱到的文档**\n\n**客户合作      >  合同谈判**\n\n**响应变化      >  遵循计划**\n\n当我们构建计划时，应该确保计划是灵活的并且易于适应商务和技术方面的变化。\n较好的策略：为下两周做详细的计划，为下三个月做粗率的计划，再以后就做极为粗糙的计划。\n\n#### 1.1.2. 原则\n\n- 围绕被激励起来的人构建项目，提供需要的环境和支持\n- 工作的软件是首要的进度度量标准\n- 最优先的是通过尽早的、持续的交互有价值的软件来是客户满意，间隔时间可以是几周到几个月\n- 即使在开发后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势\n- 开发周期，业务人员和开发人员天天在一起工作\n- 面对面的交谈是最有效的传递信息方法\n- 最后的构架、需求和设计出自于自组织的团队\n- 不断关注优秀的技能和好的设计增强敏捷能力\n- 周期性的在提高效率上反思，并做出调整\n\n### 1.2. 极限编程概述\n极限编程（eXtreme Programming, 简称XP）\n\n#### 1.2.1. 客户成为团队成员\n以便知晓对方面临的问题，并共同去解决这些问题。\n\n#### 1.2.2. 用户素材\n做计划只需要了解到能估算它的程度就可以了，需求的特定细节会随时间而改变，在新版本之后是关注新需求的好时机。\n在XP 中，重要的是对需求细节的理解，而不是捕获细节。\n\n#### 1.2.3. 短交互周期\n\n**用户素材**\n用户会一直编写新的真正重要的用户元素到项目中\n\n**迭代计划**\n\n`客户`：选择不超过开发人员本次迭代周期的用户素材，并在迭代开始后，不在修改当次迭代用户素材的定义和优先级别。\n\n`开发人员`：根据之前的迭代工作量预算本次迭代，在迭代期间自由分解用户素材为任务，并根据最具技术和商务意义的顺序开发任务。\n\n**发布计划**\n\nXP 团队通常会创建一个计划来规划随后大约6次迭代的内容。\n\n**验收测试**\n\n验收测试使用能够让他们自动并且反复运行的某种脚本语言编写，这些测试共同来验证系统是否按照用户指定行为运行。\n\n**集体所有权**\n\n如果你是专业领域有关GUI的，那么你最有可能去从事GUI 方面的任务，但是你将会被邀请去和别人结对从事有关中间件和数据库方面的任务。如果你决定学习另一们专业知识，你可以承担相关任务，并和能传授你这方面知识的专家一起工作，不会被限制在自己的专业领域。（个人认为有点偏重于理想化。）\n\n**持续集成**\n\n每个模块都可以在完成单元测试之后，合并到主线中。因而，XP 团队每天会进行多次系统构建。\n\n**可持续的开发速度**\n\n软件项目是马拉松长跑，而不是全速的短跑。团队必须要以一种可持续的速度前进，有意识的保持稳定、始终的速度。\n团队位于开放的空间，充满交谈的环境下。每个人都可以获知Partner 遇到的麻烦，工作状态。\n\n**简单的设计**\n\n- 考虑能够工作的最简单的事情（如选择平面文件而不是数据库，选择简单的socket 而不是ORB（对象请求代理），RMI（远程方法调用）），只有在有证据情况下，才去引入这些。\n\n- 代码的重构，消除退化腐朽的代码\n\n- 使用简单的比喻，来说明指导整个脉络流程\n\n## 2. 敏捷设计\n\n敏捷团队，全局视图与软件一起演化。每次迭代中，系统设计都尽可能适用于当前系统，不会过多的预测未来的需求，更加关注于当前的系统结构。\n\n较好的原则设计：\n\n- 单一职责原则（The Single Responsibility Principle, 简称SRP）\n- 开放-封闭原则（The Open-Close Principle, 简称OCP）\n- Liskov 替换原则( The Liskov Substitution Principle, 简称LSP)\n- 依赖倒置原则( The Dependency Inversion Principle， 简称DIP)\n- 接口隔离原则（The Interface Segregation Principle 简称ISP）\n\n### 2.1. 什么是敏捷设计\n\n敏捷设计师一个过程，是一个持续应用原则、模式以及实践来改进软件的结构和可读性的过程。保证系统设计在任何时间都尽可能简单、干净，杜绝代码的腐化。\n\n- 遵循敏捷实践去发现问题\n- 应用设计原则去诊断问题\n- 应用适当的设计模式解决问题\n\n### 2.2. 单一职责原则（SRP）\n\n就一个类而言，应该仅有一个引起他变化的原因。\n如果一个类承担的职责太多，就等于把这些职责耦合在一起，进而导致脆弱的设计。\n\n```java\ninterface Modem \n{\n\tpublic void dial(string pno);\n\tpublic void hanguo();\n\tpublic void send(char c);\n\tpublic void recv();\n}\n```\n接口中有两个职责：连接， 数据通信。如果应用程序的变化会影响连接函数的签名，那么这个设计就具有僵化性的臭味。在这情况下，我们分离两个职责。\n\n```java\ninterface Data_Channel\n{\n\tpublic void send(char c);\n\tpublic void recv();\n}\n\ninterface Connection\n{\n\tpublic void dial(stirng pno);\n\tpublic void hangup();\n}\n\ninterface Modem_middle extends Data_Channel, Connection\n{\n\n}\n\n```\n但是，如果程序的变化总是导致这两个职责同事变化，就不必分离他们。\n\n### 2.3. 开放-封闭原则（OCP）\n\n主要特征：\n1. “对于扩展是开放的（Open for extension ）”: 对模块进行扩张，使其满足新行为。\n2. “对于更改是封闭的（Closed for modification)”： 对模块行为扩张时，不必改动模块的源代码，模块的二进制执行版本（库、DLL，.jar文件）都无需改变。\n\n这两点看似是矛盾的，请看如下解释。\n\n**抽象**\n\n模块依赖于某一抽象体，所以对它的更改是关闭的，通过这个抽象体的派生，扩展此模块的行为。\n\n遵循OCP 代价是昂贵的，增加设计的复杂性，开发人员处理抽象数量有限。我们希望OCP 的应用限定在可能发生变化的上。\n\n**吊钩(hook)**\n\n在认为可能发生变化的地方放置吊钩（hook），会使软件更灵活些。\n\nOCP 主要机制是抽象（abstraction） 和多态 (polymorphism)。\n\n### 2.4. Liskov 替换原则(LSP)\n\nLSP 提供了继承层次保持OCP 的指导， 只有保持了OCP 才会保证我们软件的灵活性，可重用性。\n\nLSP： 子类型（subtype）必须能够替换掉他们的基类型（base type）。\nBarbara Liskov 在1988年写下这个原则：\n> 若对每隔类型S 的对象s, 都存在一个类型T 的对象t ,使得在所有针对T 编写的程序P 中，用s 替换t 后，程序P 的行为功能保持不变，则S 是T 的子类型。\n\n\n### 2.5. 依赖倒置原则 (DIP)\n\n依赖倒置原则：\n\n- **高层模块不应该依赖于低层模块，二者都应该依赖于抽象**\n- 抽象不应该依赖于细节，细节应该依赖于抽象\n\n如果高层模块依赖于低层模块，那么低层模块的修改将会影响并作用于高层模块。\n\n### 2.6. 接口隔离原则（ISP）\n\n> 不应该强迫客户依赖于他们不用的方法。\n\n如果强迫客户程序依赖于他们不使用的方法，那么这些客户程序就面临着由于这些未使用的方法的改变所带来的变更。\n\n更多的策略是： **使用多重继承分离接口**","slug":"敏捷软件开发原则与模式及实践","published":1,"updated":"2019-07-08T06:16:07.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0s4005dzkgrkcu42tv0","content":"<p><a href=\"https://baike.baidu.com/item/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/7108658?fr=aladdin\" target=\"_blank\" rel=\"noopener\">敏捷开发</a>(Agile Development) 是一种面临迅速变化的需求快速开发软件的能力。我们需要：</p>\n<ol>\n<li><p>纪律和反馈的时间</p>\n</li>\n<li><p>保持软件灵活、可维护的设计原则</p>\n</li>\n<li><p>平衡这些原则的<strong>设计模式</strong></p>\n</li>\n</ol>\n<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=bc5f38dbd343ad4bb2234e92e36b31ca/359b033b5bb5c9ea70a2c69dd739b6003af3b37f.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"1-敏捷开发\"><a href=\"#1-敏捷开发\" class=\"headerlink\" title=\"1. 敏捷开发\"></a>1. 敏捷开发</h2><blockquote>\n<p>人与人之间的交互是复杂的，并且其效果从来都难以预期，但确实工作中最为重要的方面。 –《人件》</p>\n</blockquote>\n<p><a href=\"https://baike.baidu.com/item/%E4%BA%BA%E4%BB%B6/4119178?fr=aladdin\" target=\"_blank\" rel=\"noopener\">人件-百度百科</a></p>\n<p>原则(principle)、模式（parttern）、实践（practice）是重要的，但是人更重要。<em>如果想要项目取得成功，就必须构建起具有合作精神的、自组织的团队。</em></p>\n<h3 id=\"1-1-敏捷实践\"><a href=\"#1-1-敏捷实践\" class=\"headerlink\" title=\"1.1. 敏捷实践\"></a>1.1. 敏捷实践</h3><p>缺乏有效的实践会导致不可预测、重复的错误。</p>\n<h4 id=\"1-1-1-敏捷联盟\"><a href=\"#1-1-1-敏捷联盟\" class=\"headerlink\" title=\"1.1.1. 敏捷联盟\"></a>1.1.1. 敏捷联盟</h4><p>以下观点不是认为后面的不重要，而是前者重要性更高。</p>\n<p><strong>个体和交互     &gt;  过程和工具</strong> （先构建团队，再让团队基于需求配置环境。）</p>\n<p><strong>可工作的软件   &gt;  面面俱到的文档</strong></p>\n<p><strong>客户合作      &gt;  合同谈判</strong></p>\n<p><strong>响应变化      &gt;  遵循计划</strong></p>\n<p>当我们构建计划时，应该确保计划是灵活的并且易于适应商务和技术方面的变化。<br>较好的策略：为下两周做详细的计划，为下三个月做粗率的计划，再以后就做极为粗糙的计划。</p>\n<h4 id=\"1-1-2-原则\"><a href=\"#1-1-2-原则\" class=\"headerlink\" title=\"1.1.2. 原则\"></a>1.1.2. 原则</h4><ul>\n<li>围绕被激励起来的人构建项目，提供需要的环境和支持</li>\n<li>工作的软件是首要的进度度量标准</li>\n<li>最优先的是通过尽早的、持续的交互有价值的软件来是客户满意，间隔时间可以是几周到几个月</li>\n<li>即使在开发后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势</li>\n<li>开发周期，业务人员和开发人员天天在一起工作</li>\n<li>面对面的交谈是最有效的传递信息方法</li>\n<li>最后的构架、需求和设计出自于自组织的团队</li>\n<li>不断关注优秀的技能和好的设计增强敏捷能力</li>\n<li>周期性的在提高效率上反思，并做出调整</li>\n</ul>\n<h3 id=\"1-2-极限编程概述\"><a href=\"#1-2-极限编程概述\" class=\"headerlink\" title=\"1.2. 极限编程概述\"></a>1.2. 极限编程概述</h3><p>极限编程（eXtreme Programming, 简称XP）</p>\n<h4 id=\"1-2-1-客户成为团队成员\"><a href=\"#1-2-1-客户成为团队成员\" class=\"headerlink\" title=\"1.2.1. 客户成为团队成员\"></a>1.2.1. 客户成为团队成员</h4><p>以便知晓对方面临的问题，并共同去解决这些问题。</p>\n<h4 id=\"1-2-2-用户素材\"><a href=\"#1-2-2-用户素材\" class=\"headerlink\" title=\"1.2.2. 用户素材\"></a>1.2.2. 用户素材</h4><p>做计划只需要了解到能估算它的程度就可以了，需求的特定细节会随时间而改变，在新版本之后是关注新需求的好时机。<br>在XP 中，重要的是对需求细节的理解，而不是捕获细节。</p>\n<h4 id=\"1-2-3-短交互周期\"><a href=\"#1-2-3-短交互周期\" class=\"headerlink\" title=\"1.2.3. 短交互周期\"></a>1.2.3. 短交互周期</h4><p><strong>用户素材</strong><br>用户会一直编写新的真正重要的用户元素到项目中</p>\n<p><strong>迭代计划</strong></p>\n<p><code>客户</code>：选择不超过开发人员本次迭代周期的用户素材，并在迭代开始后，不在修改当次迭代用户素材的定义和优先级别。</p>\n<p><code>开发人员</code>：根据之前的迭代工作量预算本次迭代，在迭代期间自由分解用户素材为任务，并根据最具技术和商务意义的顺序开发任务。</p>\n<p><strong>发布计划</strong></p>\n<p>XP 团队通常会创建一个计划来规划随后大约6次迭代的内容。</p>\n<p><strong>验收测试</strong></p>\n<p>验收测试使用能够让他们自动并且反复运行的某种脚本语言编写，这些测试共同来验证系统是否按照用户指定行为运行。</p>\n<p><strong>集体所有权</strong></p>\n<p>如果你是专业领域有关GUI的，那么你最有可能去从事GUI 方面的任务，但是你将会被邀请去和别人结对从事有关中间件和数据库方面的任务。如果你决定学习另一们专业知识，你可以承担相关任务，并和能传授你这方面知识的专家一起工作，不会被限制在自己的专业领域。（个人认为有点偏重于理想化。）</p>\n<p><strong>持续集成</strong></p>\n<p>每个模块都可以在完成单元测试之后，合并到主线中。因而，XP 团队每天会进行多次系统构建。</p>\n<p><strong>可持续的开发速度</strong></p>\n<p>软件项目是马拉松长跑，而不是全速的短跑。团队必须要以一种可持续的速度前进，有意识的保持稳定、始终的速度。<br>团队位于开放的空间，充满交谈的环境下。每个人都可以获知Partner 遇到的麻烦，工作状态。</p>\n<p><strong>简单的设计</strong></p>\n<ul>\n<li><p>考虑能够工作的最简单的事情（如选择平面文件而不是数据库，选择简单的socket 而不是ORB（对象请求代理），RMI（远程方法调用）），只有在有证据情况下，才去引入这些。</p>\n</li>\n<li><p>代码的重构，消除退化腐朽的代码</p>\n</li>\n<li><p>使用简单的比喻，来说明指导整个脉络流程</p>\n</li>\n</ul>\n<h2 id=\"2-敏捷设计\"><a href=\"#2-敏捷设计\" class=\"headerlink\" title=\"2. 敏捷设计\"></a>2. 敏捷设计</h2><p>敏捷团队，全局视图与软件一起演化。每次迭代中，系统设计都尽可能适用于当前系统，不会过多的预测未来的需求，更加关注于当前的系统结构。</p>\n<p>较好的原则设计：</p>\n<ul>\n<li>单一职责原则（The Single Responsibility Principle, 简称SRP）</li>\n<li>开放-封闭原则（The Open-Close Principle, 简称OCP）</li>\n<li>Liskov 替换原则( The Liskov Substitution Principle, 简称LSP)</li>\n<li>依赖倒置原则( The Dependency Inversion Principle， 简称DIP)</li>\n<li>接口隔离原则（The Interface Segregation Principle 简称ISP）</li>\n</ul>\n<h3 id=\"2-1-什么是敏捷设计\"><a href=\"#2-1-什么是敏捷设计\" class=\"headerlink\" title=\"2.1. 什么是敏捷设计\"></a>2.1. 什么是敏捷设计</h3><p>敏捷设计师一个过程，是一个持续应用原则、模式以及实践来改进软件的结构和可读性的过程。保证系统设计在任何时间都尽可能简单、干净，杜绝代码的腐化。</p>\n<ul>\n<li>遵循敏捷实践去发现问题</li>\n<li>应用设计原则去诊断问题</li>\n<li>应用适当的设计模式解决问题</li>\n</ul>\n<h3 id=\"2-2-单一职责原则（SRP）\"><a href=\"#2-2-单一职责原则（SRP）\" class=\"headerlink\" title=\"2.2. 单一职责原则（SRP）\"></a>2.2. 单一职责原则（SRP）</h3><p>就一个类而言，应该仅有一个引起他变化的原因。<br>如果一个类承担的职责太多，就等于把这些职责耦合在一起，进而导致脆弱的设计。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Modem</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dial</span><span class=\"params\">(string pno)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hanguo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recv</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口中有两个职责：连接， 数据通信。如果应用程序的变化会影响连接函数的签名，那么这个设计就具有僵化性的臭味。在这情况下，我们分离两个职责。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Data_Channel</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recv</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Connection</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dial</span><span class=\"params\">(stirng pno)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hangup</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Modem_middle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Data_Channel</span>, <span class=\"title\">Connection</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，如果程序的变化总是导致这两个职责同事变化，就不必分离他们。</p>\n<h3 id=\"2-3-开放-封闭原则（OCP）\"><a href=\"#2-3-开放-封闭原则（OCP）\" class=\"headerlink\" title=\"2.3. 开放-封闭原则（OCP）\"></a>2.3. 开放-封闭原则（OCP）</h3><p>主要特征：</p>\n<ol>\n<li>“对于扩展是开放的（Open for extension ）”: 对模块进行扩张，使其满足新行为。</li>\n<li>“对于更改是封闭的（Closed for modification)”： 对模块行为扩张时，不必改动模块的源代码，模块的二进制执行版本（库、DLL，.jar文件）都无需改变。</li>\n</ol>\n<p>这两点看似是矛盾的，请看如下解释。</p>\n<p><strong>抽象</strong></p>\n<p>模块依赖于某一抽象体，所以对它的更改是关闭的，通过这个抽象体的派生，扩展此模块的行为。</p>\n<p>遵循OCP 代价是昂贵的，增加设计的复杂性，开发人员处理抽象数量有限。我们希望OCP 的应用限定在可能发生变化的上。</p>\n<p><strong>吊钩(hook)</strong></p>\n<p>在认为可能发生变化的地方放置吊钩（hook），会使软件更灵活些。</p>\n<p>OCP 主要机制是抽象（abstraction） 和多态 (polymorphism)。</p>\n<h3 id=\"2-4-Liskov-替换原则-LSP\"><a href=\"#2-4-Liskov-替换原则-LSP\" class=\"headerlink\" title=\"2.4. Liskov 替换原则(LSP)\"></a>2.4. Liskov 替换原则(LSP)</h3><p>LSP 提供了继承层次保持OCP 的指导， 只有保持了OCP 才会保证我们软件的灵活性，可重用性。</p>\n<p>LSP： 子类型（subtype）必须能够替换掉他们的基类型（base type）。<br>Barbara Liskov 在1988年写下这个原则：</p>\n<blockquote>\n<p>若对每隔类型S 的对象s, 都存在一个类型T 的对象t ,使得在所有针对T 编写的程序P 中，用s 替换t 后，程序P 的行为功能保持不变，则S 是T 的子类型。</p>\n</blockquote>\n<h3 id=\"2-5-依赖倒置原则-DIP\"><a href=\"#2-5-依赖倒置原则-DIP\" class=\"headerlink\" title=\"2.5. 依赖倒置原则 (DIP)\"></a>2.5. 依赖倒置原则 (DIP)</h3><p>依赖倒置原则：</p>\n<ul>\n<li><strong>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</strong></li>\n<li>抽象不应该依赖于细节，细节应该依赖于抽象</li>\n</ul>\n<p>如果高层模块依赖于低层模块，那么低层模块的修改将会影响并作用于高层模块。</p>\n<h3 id=\"2-6-接口隔离原则（ISP）\"><a href=\"#2-6-接口隔离原则（ISP）\" class=\"headerlink\" title=\"2.6. 接口隔离原则（ISP）\"></a>2.6. 接口隔离原则（ISP）</h3><blockquote>\n<p>不应该强迫客户依赖于他们不用的方法。</p>\n</blockquote>\n<p>如果强迫客户程序依赖于他们不使用的方法，那么这些客户程序就面临着由于这些未使用的方法的改变所带来的变更。</p>\n<p>更多的策略是： <strong>使用多重继承分离接口</strong></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://baike.baidu.com/item/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/7108658?fr=aladdin\" target=\"_blank\" rel=\"noopener\">敏捷开发</a>(Agile Development) 是一种面临迅速变化的需求快速开发软件的能力。我们需要：</p>\n<ol>\n<li><p>纪律和反馈的时间</p>\n</li>\n<li><p>保持软件灵活、可维护的设计原则</p>\n</li>\n<li><p>平衡这些原则的<strong>设计模式</strong></p>\n</li>\n</ol>\n<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=bc5f38dbd343ad4bb2234e92e36b31ca/359b033b5bb5c9ea70a2c69dd739b6003af3b37f.jpg\" alt=\"\"></p>","more":"<h2 id=\"1-敏捷开发\"><a href=\"#1-敏捷开发\" class=\"headerlink\" title=\"1. 敏捷开发\"></a>1. 敏捷开发</h2><blockquote>\n<p>人与人之间的交互是复杂的，并且其效果从来都难以预期，但确实工作中最为重要的方面。 –《人件》</p>\n</blockquote>\n<p><a href=\"https://baike.baidu.com/item/%E4%BA%BA%E4%BB%B6/4119178?fr=aladdin\" target=\"_blank\" rel=\"noopener\">人件-百度百科</a></p>\n<p>原则(principle)、模式（parttern）、实践（practice）是重要的，但是人更重要。<em>如果想要项目取得成功，就必须构建起具有合作精神的、自组织的团队。</em></p>\n<h3 id=\"1-1-敏捷实践\"><a href=\"#1-1-敏捷实践\" class=\"headerlink\" title=\"1.1. 敏捷实践\"></a>1.1. 敏捷实践</h3><p>缺乏有效的实践会导致不可预测、重复的错误。</p>\n<h4 id=\"1-1-1-敏捷联盟\"><a href=\"#1-1-1-敏捷联盟\" class=\"headerlink\" title=\"1.1.1. 敏捷联盟\"></a>1.1.1. 敏捷联盟</h4><p>以下观点不是认为后面的不重要，而是前者重要性更高。</p>\n<p><strong>个体和交互     &gt;  过程和工具</strong> （先构建团队，再让团队基于需求配置环境。）</p>\n<p><strong>可工作的软件   &gt;  面面俱到的文档</strong></p>\n<p><strong>客户合作      &gt;  合同谈判</strong></p>\n<p><strong>响应变化      &gt;  遵循计划</strong></p>\n<p>当我们构建计划时，应该确保计划是灵活的并且易于适应商务和技术方面的变化。<br>较好的策略：为下两周做详细的计划，为下三个月做粗率的计划，再以后就做极为粗糙的计划。</p>\n<h4 id=\"1-1-2-原则\"><a href=\"#1-1-2-原则\" class=\"headerlink\" title=\"1.1.2. 原则\"></a>1.1.2. 原则</h4><ul>\n<li>围绕被激励起来的人构建项目，提供需要的环境和支持</li>\n<li>工作的软件是首要的进度度量标准</li>\n<li>最优先的是通过尽早的、持续的交互有价值的软件来是客户满意，间隔时间可以是几周到几个月</li>\n<li>即使在开发后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势</li>\n<li>开发周期，业务人员和开发人员天天在一起工作</li>\n<li>面对面的交谈是最有效的传递信息方法</li>\n<li>最后的构架、需求和设计出自于自组织的团队</li>\n<li>不断关注优秀的技能和好的设计增强敏捷能力</li>\n<li>周期性的在提高效率上反思，并做出调整</li>\n</ul>\n<h3 id=\"1-2-极限编程概述\"><a href=\"#1-2-极限编程概述\" class=\"headerlink\" title=\"1.2. 极限编程概述\"></a>1.2. 极限编程概述</h3><p>极限编程（eXtreme Programming, 简称XP）</p>\n<h4 id=\"1-2-1-客户成为团队成员\"><a href=\"#1-2-1-客户成为团队成员\" class=\"headerlink\" title=\"1.2.1. 客户成为团队成员\"></a>1.2.1. 客户成为团队成员</h4><p>以便知晓对方面临的问题，并共同去解决这些问题。</p>\n<h4 id=\"1-2-2-用户素材\"><a href=\"#1-2-2-用户素材\" class=\"headerlink\" title=\"1.2.2. 用户素材\"></a>1.2.2. 用户素材</h4><p>做计划只需要了解到能估算它的程度就可以了，需求的特定细节会随时间而改变，在新版本之后是关注新需求的好时机。<br>在XP 中，重要的是对需求细节的理解，而不是捕获细节。</p>\n<h4 id=\"1-2-3-短交互周期\"><a href=\"#1-2-3-短交互周期\" class=\"headerlink\" title=\"1.2.3. 短交互周期\"></a>1.2.3. 短交互周期</h4><p><strong>用户素材</strong><br>用户会一直编写新的真正重要的用户元素到项目中</p>\n<p><strong>迭代计划</strong></p>\n<p><code>客户</code>：选择不超过开发人员本次迭代周期的用户素材，并在迭代开始后，不在修改当次迭代用户素材的定义和优先级别。</p>\n<p><code>开发人员</code>：根据之前的迭代工作量预算本次迭代，在迭代期间自由分解用户素材为任务，并根据最具技术和商务意义的顺序开发任务。</p>\n<p><strong>发布计划</strong></p>\n<p>XP 团队通常会创建一个计划来规划随后大约6次迭代的内容。</p>\n<p><strong>验收测试</strong></p>\n<p>验收测试使用能够让他们自动并且反复运行的某种脚本语言编写，这些测试共同来验证系统是否按照用户指定行为运行。</p>\n<p><strong>集体所有权</strong></p>\n<p>如果你是专业领域有关GUI的，那么你最有可能去从事GUI 方面的任务，但是你将会被邀请去和别人结对从事有关中间件和数据库方面的任务。如果你决定学习另一们专业知识，你可以承担相关任务，并和能传授你这方面知识的专家一起工作，不会被限制在自己的专业领域。（个人认为有点偏重于理想化。）</p>\n<p><strong>持续集成</strong></p>\n<p>每个模块都可以在完成单元测试之后，合并到主线中。因而，XP 团队每天会进行多次系统构建。</p>\n<p><strong>可持续的开发速度</strong></p>\n<p>软件项目是马拉松长跑，而不是全速的短跑。团队必须要以一种可持续的速度前进，有意识的保持稳定、始终的速度。<br>团队位于开放的空间，充满交谈的环境下。每个人都可以获知Partner 遇到的麻烦，工作状态。</p>\n<p><strong>简单的设计</strong></p>\n<ul>\n<li><p>考虑能够工作的最简单的事情（如选择平面文件而不是数据库，选择简单的socket 而不是ORB（对象请求代理），RMI（远程方法调用）），只有在有证据情况下，才去引入这些。</p>\n</li>\n<li><p>代码的重构，消除退化腐朽的代码</p>\n</li>\n<li><p>使用简单的比喻，来说明指导整个脉络流程</p>\n</li>\n</ul>\n<h2 id=\"2-敏捷设计\"><a href=\"#2-敏捷设计\" class=\"headerlink\" title=\"2. 敏捷设计\"></a>2. 敏捷设计</h2><p>敏捷团队，全局视图与软件一起演化。每次迭代中，系统设计都尽可能适用于当前系统，不会过多的预测未来的需求，更加关注于当前的系统结构。</p>\n<p>较好的原则设计：</p>\n<ul>\n<li>单一职责原则（The Single Responsibility Principle, 简称SRP）</li>\n<li>开放-封闭原则（The Open-Close Principle, 简称OCP）</li>\n<li>Liskov 替换原则( The Liskov Substitution Principle, 简称LSP)</li>\n<li>依赖倒置原则( The Dependency Inversion Principle， 简称DIP)</li>\n<li>接口隔离原则（The Interface Segregation Principle 简称ISP）</li>\n</ul>\n<h3 id=\"2-1-什么是敏捷设计\"><a href=\"#2-1-什么是敏捷设计\" class=\"headerlink\" title=\"2.1. 什么是敏捷设计\"></a>2.1. 什么是敏捷设计</h3><p>敏捷设计师一个过程，是一个持续应用原则、模式以及实践来改进软件的结构和可读性的过程。保证系统设计在任何时间都尽可能简单、干净，杜绝代码的腐化。</p>\n<ul>\n<li>遵循敏捷实践去发现问题</li>\n<li>应用设计原则去诊断问题</li>\n<li>应用适当的设计模式解决问题</li>\n</ul>\n<h3 id=\"2-2-单一职责原则（SRP）\"><a href=\"#2-2-单一职责原则（SRP）\" class=\"headerlink\" title=\"2.2. 单一职责原则（SRP）\"></a>2.2. 单一职责原则（SRP）</h3><p>就一个类而言，应该仅有一个引起他变化的原因。<br>如果一个类承担的职责太多，就等于把这些职责耦合在一起，进而导致脆弱的设计。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Modem</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dial</span><span class=\"params\">(string pno)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hanguo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recv</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口中有两个职责：连接， 数据通信。如果应用程序的变化会影响连接函数的签名，那么这个设计就具有僵化性的臭味。在这情况下，我们分离两个职责。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Data_Channel</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recv</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Connection</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dial</span><span class=\"params\">(stirng pno)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hangup</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Modem_middle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Data_Channel</span>, <span class=\"title\">Connection</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，如果程序的变化总是导致这两个职责同事变化，就不必分离他们。</p>\n<h3 id=\"2-3-开放-封闭原则（OCP）\"><a href=\"#2-3-开放-封闭原则（OCP）\" class=\"headerlink\" title=\"2.3. 开放-封闭原则（OCP）\"></a>2.3. 开放-封闭原则（OCP）</h3><p>主要特征：</p>\n<ol>\n<li>“对于扩展是开放的（Open for extension ）”: 对模块进行扩张，使其满足新行为。</li>\n<li>“对于更改是封闭的（Closed for modification)”： 对模块行为扩张时，不必改动模块的源代码，模块的二进制执行版本（库、DLL，.jar文件）都无需改变。</li>\n</ol>\n<p>这两点看似是矛盾的，请看如下解释。</p>\n<p><strong>抽象</strong></p>\n<p>模块依赖于某一抽象体，所以对它的更改是关闭的，通过这个抽象体的派生，扩展此模块的行为。</p>\n<p>遵循OCP 代价是昂贵的，增加设计的复杂性，开发人员处理抽象数量有限。我们希望OCP 的应用限定在可能发生变化的上。</p>\n<p><strong>吊钩(hook)</strong></p>\n<p>在认为可能发生变化的地方放置吊钩（hook），会使软件更灵活些。</p>\n<p>OCP 主要机制是抽象（abstraction） 和多态 (polymorphism)。</p>\n<h3 id=\"2-4-Liskov-替换原则-LSP\"><a href=\"#2-4-Liskov-替换原则-LSP\" class=\"headerlink\" title=\"2.4. Liskov 替换原则(LSP)\"></a>2.4. Liskov 替换原则(LSP)</h3><p>LSP 提供了继承层次保持OCP 的指导， 只有保持了OCP 才会保证我们软件的灵活性，可重用性。</p>\n<p>LSP： 子类型（subtype）必须能够替换掉他们的基类型（base type）。<br>Barbara Liskov 在1988年写下这个原则：</p>\n<blockquote>\n<p>若对每隔类型S 的对象s, 都存在一个类型T 的对象t ,使得在所有针对T 编写的程序P 中，用s 替换t 后，程序P 的行为功能保持不变，则S 是T 的子类型。</p>\n</blockquote>\n<h3 id=\"2-5-依赖倒置原则-DIP\"><a href=\"#2-5-依赖倒置原则-DIP\" class=\"headerlink\" title=\"2.5. 依赖倒置原则 (DIP)\"></a>2.5. 依赖倒置原则 (DIP)</h3><p>依赖倒置原则：</p>\n<ul>\n<li><strong>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</strong></li>\n<li>抽象不应该依赖于细节，细节应该依赖于抽象</li>\n</ul>\n<p>如果高层模块依赖于低层模块，那么低层模块的修改将会影响并作用于高层模块。</p>\n<h3 id=\"2-6-接口隔离原则（ISP）\"><a href=\"#2-6-接口隔离原则（ISP）\" class=\"headerlink\" title=\"2.6. 接口隔离原则（ISP）\"></a>2.6. 接口隔离原则（ISP）</h3><blockquote>\n<p>不应该强迫客户依赖于他们不用的方法。</p>\n</blockquote>\n<p>如果强迫客户程序依赖于他们不使用的方法，那么这些客户程序就面临着由于这些未使用的方法的改变所带来的变更。</p>\n<p>更多的策略是： <strong>使用多重继承分离接口</strong></p>"},{"title":"李开复自传","date":"2019-08-28T11:51:20.000Z","_content":"\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=65c6a093b74543a9f51bfdca26168a7b/4d086e061d950a7bd4d730a30ad162d9f3d3c9f3.jpg)\n\n抓住一切去探寻生命的意义，总有一天，世界将因你不同。\n\n<!--more-->\n\n人生中常被问到“我是谁”、“从哪里来”、“到哪里去”，其实就是认识自己，认识客观世界，寻找人生目的的过程，永远没有终点。 未来自己主宰。\n\n>做最好的自己、世界因你不同！我总是鞭策自己最求最有价值的人生，每时每刻都得好好善用，要让自己有限的生命发挥最大的效益。\n\n来自父亲的教诲：\n>老牛明知夕阳短，不用扬鞭自奋蹄。\n\n### 1. 自省，如果生命只剩100天\n\n如果觉察到自己沉溺于担心会失去某些东西时，“记住你即将死去”会是最好的解药。只留下真正重要的东西。\n\n人到无求品自高，人生应为所当为。若将名利挂心头，编入苍蝇追逐腐肉，把人生的追求浪费在满足最低层级的欲望上。\n\n成功的定义因人而异，没有一定的标准，不需要和别人竞赛。你竞赛的对象是自己，比昨天更好一点儿，更积极地面对挑战，面对不如意是，让内心更加平静。\n\n有容德乃大，无求品自高。\n>必有忍,其乃有济;有容,德乃大。 --[《尚书·君陈》](https://baijiahao.baidu.com/s?id=1623416993220011212&wfr=spider&for=pc)\n\n### 2. 授惑，与星云大师对谈\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=caf3ee4446c2d562e605d8bf8678fb8a/72f082025aafa40f38308ef9a264034f78f0191b.jpg)\n\n真正有益于世界的做法不是除恶，而是行善；不是打击负能量，而是弘扬正能量。\n\n珍贵的生命旅程，应该抱着初学者的心态，对世界保持儿童般的好奇心，好好体验人生；让自己每天都比以前一天有进步、有成长，不必改变别人，只要做事问心无愧，对人真诚平等，这就足够了。\n\n### 3. 生活\n__每天都是最特殊的一天。__ 再也不要把好东西留到特别的日子才用，你或者的每一天都是特别的日子。\n\n多交点正向的朋友，补充正能量。\n\n从追求100分到只要80分，常将世间种种可爱放在心上。\n\n>成功的婚姻不是建立在安全、拥有的基础上，而是建立在平等、自由之上。\n\n>婚姻不是在制造罪恶感的义务，而是彼此互补，彼此互谅，彼此相互扶持的过程。\n\n>与自己最爱的人攻读生命之旅，分享权力，分担责任，才能沐浴在光辉中。就想交换的戒子：象征合一，而非占有；象征结合，而非限制；象征环抱，而非羁绊。\n\n### 4. 学习&&工作生涯\n李开复哲学系老师：\n>知道什么是make a difference? 想象有两个世界，一个世界中有你，一个世界中没你，让两者的不同最大，最大化你的影响力，这就是你一生的意义。\n\n只会思考而不会表达的人，与不会思考的人没什么两样。\n\n瑞迪教授：\n>我不同意你，但是我支持你。这是一种真正的科学家精神。\n\n卡内基.梅隆海博曼教授：\n>你从学校带走最有价值的不是论文，而是你分析和独立思考的能力、研究和发现真理的经验。\n\n选择工作的标准：__成长，兴趣和影响力。__\n\n作为领导，相信：__架子最不值钱，而点子最值钱。__\n\n### 5. 总结，世界因你而不同\n最富有的人不是拥有最多的人，而是雪球最少的人。\n\n不要盲目地跟随别人，不要被信条所惑，只有你的内心知道你真正想成为什么样的人，只有你能找到自己的价值。\n\n","source":"_posts/李开复自传.md","raw":"---\ntitle: 李开复自传\ndate: 2019-08-28 19:51:20\ntags: bookmarks\ncategories: bookmarks\n---\n\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=65c6a093b74543a9f51bfdca26168a7b/4d086e061d950a7bd4d730a30ad162d9f3d3c9f3.jpg)\n\n抓住一切去探寻生命的意义，总有一天，世界将因你不同。\n\n<!--more-->\n\n人生中常被问到“我是谁”、“从哪里来”、“到哪里去”，其实就是认识自己，认识客观世界，寻找人生目的的过程，永远没有终点。 未来自己主宰。\n\n>做最好的自己、世界因你不同！我总是鞭策自己最求最有价值的人生，每时每刻都得好好善用，要让自己有限的生命发挥最大的效益。\n\n来自父亲的教诲：\n>老牛明知夕阳短，不用扬鞭自奋蹄。\n\n### 1. 自省，如果生命只剩100天\n\n如果觉察到自己沉溺于担心会失去某些东西时，“记住你即将死去”会是最好的解药。只留下真正重要的东西。\n\n人到无求品自高，人生应为所当为。若将名利挂心头，编入苍蝇追逐腐肉，把人生的追求浪费在满足最低层级的欲望上。\n\n成功的定义因人而异，没有一定的标准，不需要和别人竞赛。你竞赛的对象是自己，比昨天更好一点儿，更积极地面对挑战，面对不如意是，让内心更加平静。\n\n有容德乃大，无求品自高。\n>必有忍,其乃有济;有容,德乃大。 --[《尚书·君陈》](https://baijiahao.baidu.com/s?id=1623416993220011212&wfr=spider&for=pc)\n\n### 2. 授惑，与星云大师对谈\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=caf3ee4446c2d562e605d8bf8678fb8a/72f082025aafa40f38308ef9a264034f78f0191b.jpg)\n\n真正有益于世界的做法不是除恶，而是行善；不是打击负能量，而是弘扬正能量。\n\n珍贵的生命旅程，应该抱着初学者的心态，对世界保持儿童般的好奇心，好好体验人生；让自己每天都比以前一天有进步、有成长，不必改变别人，只要做事问心无愧，对人真诚平等，这就足够了。\n\n### 3. 生活\n__每天都是最特殊的一天。__ 再也不要把好东西留到特别的日子才用，你或者的每一天都是特别的日子。\n\n多交点正向的朋友，补充正能量。\n\n从追求100分到只要80分，常将世间种种可爱放在心上。\n\n>成功的婚姻不是建立在安全、拥有的基础上，而是建立在平等、自由之上。\n\n>婚姻不是在制造罪恶感的义务，而是彼此互补，彼此互谅，彼此相互扶持的过程。\n\n>与自己最爱的人攻读生命之旅，分享权力，分担责任，才能沐浴在光辉中。就想交换的戒子：象征合一，而非占有；象征结合，而非限制；象征环抱，而非羁绊。\n\n### 4. 学习&&工作生涯\n李开复哲学系老师：\n>知道什么是make a difference? 想象有两个世界，一个世界中有你，一个世界中没你，让两者的不同最大，最大化你的影响力，这就是你一生的意义。\n\n只会思考而不会表达的人，与不会思考的人没什么两样。\n\n瑞迪教授：\n>我不同意你，但是我支持你。这是一种真正的科学家精神。\n\n卡内基.梅隆海博曼教授：\n>你从学校带走最有价值的不是论文，而是你分析和独立思考的能力、研究和发现真理的经验。\n\n选择工作的标准：__成长，兴趣和影响力。__\n\n作为领导，相信：__架子最不值钱，而点子最值钱。__\n\n### 5. 总结，世界因你而不同\n最富有的人不是拥有最多的人，而是雪球最少的人。\n\n不要盲目地跟随别人，不要被信条所惑，只有你的内心知道你真正想成为什么样的人，只有你能找到自己的价值。\n\n","slug":"李开复自传","published":1,"updated":"2019-08-30T03:30:20.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0s6005hzkgrtkuwhqka","content":"<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=65c6a093b74543a9f51bfdca26168a7b/4d086e061d950a7bd4d730a30ad162d9f3d3c9f3.jpg\" alt=\"\"></p>\n<p>抓住一切去探寻生命的意义，总有一天，世界将因你不同。</p>\n<a id=\"more\"></a>\n<p>人生中常被问到“我是谁”、“从哪里来”、“到哪里去”，其实就是认识自己，认识客观世界，寻找人生目的的过程，永远没有终点。 未来自己主宰。</p>\n<blockquote>\n<p>做最好的自己、世界因你不同！我总是鞭策自己最求最有价值的人生，每时每刻都得好好善用，要让自己有限的生命发挥最大的效益。</p>\n</blockquote>\n<p>来自父亲的教诲：</p>\n<blockquote>\n<p>老牛明知夕阳短，不用扬鞭自奋蹄。</p>\n</blockquote>\n<h3 id=\"1-自省，如果生命只剩100天\"><a href=\"#1-自省，如果生命只剩100天\" class=\"headerlink\" title=\"1. 自省，如果生命只剩100天\"></a>1. 自省，如果生命只剩100天</h3><p>如果觉察到自己沉溺于担心会失去某些东西时，“记住你即将死去”会是最好的解药。只留下真正重要的东西。</p>\n<p>人到无求品自高，人生应为所当为。若将名利挂心头，编入苍蝇追逐腐肉，把人生的追求浪费在满足最低层级的欲望上。</p>\n<p>成功的定义因人而异，没有一定的标准，不需要和别人竞赛。你竞赛的对象是自己，比昨天更好一点儿，更积极地面对挑战，面对不如意是，让内心更加平静。</p>\n<p>有容德乃大，无求品自高。</p>\n<blockquote>\n<p>必有忍,其乃有济;有容,德乃大。 –<a href=\"https://baijiahao.baidu.com/s?id=1623416993220011212&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">《尚书·君陈》</a></p>\n</blockquote>\n<h3 id=\"2-授惑，与星云大师对谈\"><a href=\"#2-授惑，与星云大师对谈\" class=\"headerlink\" title=\"2. 授惑，与星云大师对谈\"></a>2. 授惑，与星云大师对谈</h3><p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=caf3ee4446c2d562e605d8bf8678fb8a/72f082025aafa40f38308ef9a264034f78f0191b.jpg\" alt=\"\"></p>\n<p>真正有益于世界的做法不是除恶，而是行善；不是打击负能量，而是弘扬正能量。</p>\n<p>珍贵的生命旅程，应该抱着初学者的心态，对世界保持儿童般的好奇心，好好体验人生；让自己每天都比以前一天有进步、有成长，不必改变别人，只要做事问心无愧，对人真诚平等，这就足够了。</p>\n<h3 id=\"3-生活\"><a href=\"#3-生活\" class=\"headerlink\" title=\"3. 生活\"></a>3. 生活</h3><p><strong>每天都是最特殊的一天。</strong> 再也不要把好东西留到特别的日子才用，你或者的每一天都是特别的日子。</p>\n<p>多交点正向的朋友，补充正能量。</p>\n<p>从追求100分到只要80分，常将世间种种可爱放在心上。</p>\n<blockquote>\n<p>成功的婚姻不是建立在安全、拥有的基础上，而是建立在平等、自由之上。</p>\n</blockquote>\n<blockquote>\n<p>婚姻不是在制造罪恶感的义务，而是彼此互补，彼此互谅，彼此相互扶持的过程。</p>\n</blockquote>\n<blockquote>\n<p>与自己最爱的人攻读生命之旅，分享权力，分担责任，才能沐浴在光辉中。就想交换的戒子：象征合一，而非占有；象征结合，而非限制；象征环抱，而非羁绊。</p>\n</blockquote>\n<h3 id=\"4-学习-amp-amp-工作生涯\"><a href=\"#4-学习-amp-amp-工作生涯\" class=\"headerlink\" title=\"4. 学习&amp;&amp;工作生涯\"></a>4. 学习&amp;&amp;工作生涯</h3><p>李开复哲学系老师：</p>\n<blockquote>\n<p>知道什么是make a difference? 想象有两个世界，一个世界中有你，一个世界中没你，让两者的不同最大，最大化你的影响力，这就是你一生的意义。</p>\n</blockquote>\n<p>只会思考而不会表达的人，与不会思考的人没什么两样。</p>\n<p>瑞迪教授：</p>\n<blockquote>\n<p>我不同意你，但是我支持你。这是一种真正的科学家精神。</p>\n</blockquote>\n<p>卡内基.梅隆海博曼教授：</p>\n<blockquote>\n<p>你从学校带走最有价值的不是论文，而是你分析和独立思考的能力、研究和发现真理的经验。</p>\n</blockquote>\n<p>选择工作的标准：<strong>成长，兴趣和影响力。</strong></p>\n<p>作为领导，相信：<strong>架子最不值钱，而点子最值钱。</strong></p>\n<h3 id=\"5-总结，世界因你而不同\"><a href=\"#5-总结，世界因你而不同\" class=\"headerlink\" title=\"5. 总结，世界因你而不同\"></a>5. 总结，世界因你而不同</h3><p>最富有的人不是拥有最多的人，而是雪球最少的人。</p>\n<p>不要盲目地跟随别人，不要被信条所惑，只有你的内心知道你真正想成为什么样的人，只有你能找到自己的价值。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=65c6a093b74543a9f51bfdca26168a7b/4d086e061d950a7bd4d730a30ad162d9f3d3c9f3.jpg\" alt=\"\"></p>\n<p>抓住一切去探寻生命的意义，总有一天，世界将因你不同。</p>","more":"<p>人生中常被问到“我是谁”、“从哪里来”、“到哪里去”，其实就是认识自己，认识客观世界，寻找人生目的的过程，永远没有终点。 未来自己主宰。</p>\n<blockquote>\n<p>做最好的自己、世界因你不同！我总是鞭策自己最求最有价值的人生，每时每刻都得好好善用，要让自己有限的生命发挥最大的效益。</p>\n</blockquote>\n<p>来自父亲的教诲：</p>\n<blockquote>\n<p>老牛明知夕阳短，不用扬鞭自奋蹄。</p>\n</blockquote>\n<h3 id=\"1-自省，如果生命只剩100天\"><a href=\"#1-自省，如果生命只剩100天\" class=\"headerlink\" title=\"1. 自省，如果生命只剩100天\"></a>1. 自省，如果生命只剩100天</h3><p>如果觉察到自己沉溺于担心会失去某些东西时，“记住你即将死去”会是最好的解药。只留下真正重要的东西。</p>\n<p>人到无求品自高，人生应为所当为。若将名利挂心头，编入苍蝇追逐腐肉，把人生的追求浪费在满足最低层级的欲望上。</p>\n<p>成功的定义因人而异，没有一定的标准，不需要和别人竞赛。你竞赛的对象是自己，比昨天更好一点儿，更积极地面对挑战，面对不如意是，让内心更加平静。</p>\n<p>有容德乃大，无求品自高。</p>\n<blockquote>\n<p>必有忍,其乃有济;有容,德乃大。 –<a href=\"https://baijiahao.baidu.com/s?id=1623416993220011212&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">《尚书·君陈》</a></p>\n</blockquote>\n<h3 id=\"2-授惑，与星云大师对谈\"><a href=\"#2-授惑，与星云大师对谈\" class=\"headerlink\" title=\"2. 授惑，与星云大师对谈\"></a>2. 授惑，与星云大师对谈</h3><p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=caf3ee4446c2d562e605d8bf8678fb8a/72f082025aafa40f38308ef9a264034f78f0191b.jpg\" alt=\"\"></p>\n<p>真正有益于世界的做法不是除恶，而是行善；不是打击负能量，而是弘扬正能量。</p>\n<p>珍贵的生命旅程，应该抱着初学者的心态，对世界保持儿童般的好奇心，好好体验人生；让自己每天都比以前一天有进步、有成长，不必改变别人，只要做事问心无愧，对人真诚平等，这就足够了。</p>\n<h3 id=\"3-生活\"><a href=\"#3-生活\" class=\"headerlink\" title=\"3. 生活\"></a>3. 生活</h3><p><strong>每天都是最特殊的一天。</strong> 再也不要把好东西留到特别的日子才用，你或者的每一天都是特别的日子。</p>\n<p>多交点正向的朋友，补充正能量。</p>\n<p>从追求100分到只要80分，常将世间种种可爱放在心上。</p>\n<blockquote>\n<p>成功的婚姻不是建立在安全、拥有的基础上，而是建立在平等、自由之上。</p>\n</blockquote>\n<blockquote>\n<p>婚姻不是在制造罪恶感的义务，而是彼此互补，彼此互谅，彼此相互扶持的过程。</p>\n</blockquote>\n<blockquote>\n<p>与自己最爱的人攻读生命之旅，分享权力，分担责任，才能沐浴在光辉中。就想交换的戒子：象征合一，而非占有；象征结合，而非限制；象征环抱，而非羁绊。</p>\n</blockquote>\n<h3 id=\"4-学习-amp-amp-工作生涯\"><a href=\"#4-学习-amp-amp-工作生涯\" class=\"headerlink\" title=\"4. 学习&amp;&amp;工作生涯\"></a>4. 学习&amp;&amp;工作生涯</h3><p>李开复哲学系老师：</p>\n<blockquote>\n<p>知道什么是make a difference? 想象有两个世界，一个世界中有你，一个世界中没你，让两者的不同最大，最大化你的影响力，这就是你一生的意义。</p>\n</blockquote>\n<p>只会思考而不会表达的人，与不会思考的人没什么两样。</p>\n<p>瑞迪教授：</p>\n<blockquote>\n<p>我不同意你，但是我支持你。这是一种真正的科学家精神。</p>\n</blockquote>\n<p>卡内基.梅隆海博曼教授：</p>\n<blockquote>\n<p>你从学校带走最有价值的不是论文，而是你分析和独立思考的能力、研究和发现真理的经验。</p>\n</blockquote>\n<p>选择工作的标准：<strong>成长，兴趣和影响力。</strong></p>\n<p>作为领导，相信：<strong>架子最不值钱，而点子最值钱。</strong></p>\n<h3 id=\"5-总结，世界因你而不同\"><a href=\"#5-总结，世界因你而不同\" class=\"headerlink\" title=\"5. 总结，世界因你而不同\"></a>5. 总结，世界因你而不同</h3><p>最富有的人不是拥有最多的人，而是雪球最少的人。</p>\n<p>不要盲目地跟随别人，不要被信条所惑，只有你的内心知道你真正想成为什么样的人，只有你能找到自己的价值。</p>"},{"title":"程序员40岁后该如何发展","date":"2019-06-03T15:48:38.000Z","_content":"2019年6月8号，看到的记录。\n\n[网易技术大牛：程序员40岁后该如何发展？](https://www.bilibili.com/video/av54080851?spm_id_from=333.334.b_62696c695f746563686e6f6c6f6779.6)\n\n[油腻的中年人，请对自己好一点](http://3g.163.com/dy/article/EGM5MBA10517QCLU.html)\n\n<!--more-->\n## 1. 网易技术大牛：程序员40岁后该如何发展？\n### 1.1. 总结--积累性\n程序员并不像医生，生物学等可以线性积累。个人的技能积累一般有三种：\n- 抛物线\n- 线性\n- 指数型\n\n因此，程序员也是强调积累性。我们可以通过如下：\n- 个人博客（分享，方便自己查阅）\n- 写书籍 （个人博客积累到一定程度）\n- 参加开源社区，沙龙等交流，产生个人影响力等\n\n### 1.2.成长录\n#### 1.2.1.面试发现\n越大的企业越注重基础知识，计算机原理，数据结构，操作系统等。 （基础知识牢靠，人的可塑性更强，每方面都能去尝试）\n\nBAT，Facebook 等一般看中算法与思路。\n\n#### 1.2.2. 简历的书写建议\n##### 1.2.2.1. 相对简单（不超过2、3页）\n信息多，对面试官不能选择重点。\n\n##### 1.2.2.2. 量化\n多使用量化的东西，少一些模糊的。\n如：多大规模，处理的多大的数据量，管理多少机器，处理的速度，实际如何。具体使用了什么技术。\n\n##### 1.2.2.3. 清晰（表格、列表），专业术语\n避免大段的描述，使用清晰的表格。\n\n##### 1.2.2.4. 点，面，体\n__技术提炼（点）__\n从平时的琐碎的事情中，发现提炼自我感觉或者行业中认为的技术亮点。\n我们就去深挖他。\n\n__横向对比(面)__\n研究由点到面。从技术亮点展开。\n- 你知道还有些什么方式技术可以达到这个需求？  \n- 为什么选择当前的方式？  \n- 其他方式的优缺点，适用环境？\n\n例如负载均衡的实现方式有哪些？\n\n__拓展开(体)__\n由面的发散，涉及的相关知识。\n>例如：你研究了多线程，你知道它内部的机理吗？有哪些同步机制等展开问题。\n\n##### 1.2.2.5. 理论升华\n反复阅读一些经典书籍（例如深入理解Linux网络内幕，深入理解Linux等四库全书），积攒一些理论体系，自己的底蕴。\n\n有些东西，思路是相通的，学习理解类似的东西更快。例如：\nCPU的缓存，\nFS 的缓存，\n网络中的缓存，\nCDN 的缓存。\n\n__之前的点、面、体都是招式，理论升华是内功。__ 不仅能到达能用，而且还能说的头头是道，在面试时能总结说出自己做过的事情，避免吃亏。\n\n例如：线程同步有这几种方式，什么情况下改用什么，现在是基于什么特殊场景，使用什么方式，这样比单纯的说只用了xxx技术更好。\n\n#### 1.2.3. 代码分析\n代码不会说谎。源码分析刚开始不能总结一些，需要借助书籍进行理论升华。\n\n不要永远选择自己熟悉的上手，而是应该选择最核心的、有价值的东西。（脱离舒适区，善于去问大牛，放下面子）\n\n#### 1.2.4. 开源软件的源代码学习\n1. 手动安装  \n2. 使用起来  \n3. 经典相关数据  \n4. 阅读核心源代码  \n5. Debug  \n\n#### 1.3. 沟通的重要性\n分享，与同事，客户产品需要有效交流。\n\n体系的思考，提前打好心理草稿：\n- 要表达的点  \n- 要让比人get 到的点\n\n\n## 2.油腻的中年人，请对自己好一点\n### 2.1. 要花额外的时间锻炼身体\n >健康排在第一位，任何事情，都不要拿健康去做交换。\n\n### 2.2. 多花一些时间陪家人\n>happy wife, happy life.\n>这是我最大的心得。\n\n### 2.3. 旅行？阅读？培养几个自己的爱好。\n到世上一趟不容易，人生本身就是“体验”的集合：\n- __空间维度，大千世界，多出去走走，被大自然的鬼斧神工所震撼__\n- __时间维度，历史长河，多阅读看看，学习前人多年的智慧沉淀__\n除了上班，陪家人，尽量要有几项自己的兴趣爱好。\n\n## 3. 年轻人必须尽早掌握的思维方式\n[现在赚钱还是以后赚大钱？年轻人必须尽早掌握的思维方式！纯干货输出丨ztalk](https://www.bilibili.com/video/av57285232/?spm_id_from=333.334.b_72616e6b696e675f6c696665.2)\n\n### 3.1. 寻找确定性\n找到大概率可以成功的方法和道路。寻找确定性的结果，在过程中需要与人性，个人理论知识相结合，同时，也要拉长时间的维度。\n>例如选择长期的投资基金而不是做短期的频繁交易买进卖出，这样只会让基金公司赚得更多的管理费用。\n>现在是夏天，短期的天气是不可能精确的，但是几个月之后一定会进入冬天。\n\n### 3.2. 更高时间的维度去思考\n__我们要做的就是基于长时间维度的考量，押注于更确定性的事情上。__ \n\n例如，在大学期间，确定性的事情是：将有限的金钱加上无限时间和精力，投入到能让你赚钱的技能上，这远比投资理财要好的多。\n\n同样，我们也应该站在人生的时间维度上去考虑事情（培养自己的眼光）。\n\n### 3.3. 有舍有得，太极阴阳\n在某一个行业没有摧毁性的问题时，都会有阴阳，[福兮祸所伏，祸兮福所倚](https://baike.baidu.com/item/%E7%A5%B8%E5%85%AE%E7%A6%8F%E6%89%80%E5%80%9A%EF%BC%8C%E7%A6%8F%E5%85%AE%E7%A5%B8%E6%89%80%E4%BC%8F/856363?fr=aladdin)。即西方的经济周期的想法。\n\n在别人恐惧时我贪婪，在别人贪婪时我恐惧。 -- 沃伦.巴菲特","source":"_posts/程序员40岁后该如何发展.md","raw":"---\ntitle: '程序员40岁后该如何发展'\ndate: 2019-06-03 23:48:38\ntags: programmer\ncategories:\n    - life\n---\n2019年6月8号，看到的记录。\n\n[网易技术大牛：程序员40岁后该如何发展？](https://www.bilibili.com/video/av54080851?spm_id_from=333.334.b_62696c695f746563686e6f6c6f6779.6)\n\n[油腻的中年人，请对自己好一点](http://3g.163.com/dy/article/EGM5MBA10517QCLU.html)\n\n<!--more-->\n## 1. 网易技术大牛：程序员40岁后该如何发展？\n### 1.1. 总结--积累性\n程序员并不像医生，生物学等可以线性积累。个人的技能积累一般有三种：\n- 抛物线\n- 线性\n- 指数型\n\n因此，程序员也是强调积累性。我们可以通过如下：\n- 个人博客（分享，方便自己查阅）\n- 写书籍 （个人博客积累到一定程度）\n- 参加开源社区，沙龙等交流，产生个人影响力等\n\n### 1.2.成长录\n#### 1.2.1.面试发现\n越大的企业越注重基础知识，计算机原理，数据结构，操作系统等。 （基础知识牢靠，人的可塑性更强，每方面都能去尝试）\n\nBAT，Facebook 等一般看中算法与思路。\n\n#### 1.2.2. 简历的书写建议\n##### 1.2.2.1. 相对简单（不超过2、3页）\n信息多，对面试官不能选择重点。\n\n##### 1.2.2.2. 量化\n多使用量化的东西，少一些模糊的。\n如：多大规模，处理的多大的数据量，管理多少机器，处理的速度，实际如何。具体使用了什么技术。\n\n##### 1.2.2.3. 清晰（表格、列表），专业术语\n避免大段的描述，使用清晰的表格。\n\n##### 1.2.2.4. 点，面，体\n__技术提炼（点）__\n从平时的琐碎的事情中，发现提炼自我感觉或者行业中认为的技术亮点。\n我们就去深挖他。\n\n__横向对比(面)__\n研究由点到面。从技术亮点展开。\n- 你知道还有些什么方式技术可以达到这个需求？  \n- 为什么选择当前的方式？  \n- 其他方式的优缺点，适用环境？\n\n例如负载均衡的实现方式有哪些？\n\n__拓展开(体)__\n由面的发散，涉及的相关知识。\n>例如：你研究了多线程，你知道它内部的机理吗？有哪些同步机制等展开问题。\n\n##### 1.2.2.5. 理论升华\n反复阅读一些经典书籍（例如深入理解Linux网络内幕，深入理解Linux等四库全书），积攒一些理论体系，自己的底蕴。\n\n有些东西，思路是相通的，学习理解类似的东西更快。例如：\nCPU的缓存，\nFS 的缓存，\n网络中的缓存，\nCDN 的缓存。\n\n__之前的点、面、体都是招式，理论升华是内功。__ 不仅能到达能用，而且还能说的头头是道，在面试时能总结说出自己做过的事情，避免吃亏。\n\n例如：线程同步有这几种方式，什么情况下改用什么，现在是基于什么特殊场景，使用什么方式，这样比单纯的说只用了xxx技术更好。\n\n#### 1.2.3. 代码分析\n代码不会说谎。源码分析刚开始不能总结一些，需要借助书籍进行理论升华。\n\n不要永远选择自己熟悉的上手，而是应该选择最核心的、有价值的东西。（脱离舒适区，善于去问大牛，放下面子）\n\n#### 1.2.4. 开源软件的源代码学习\n1. 手动安装  \n2. 使用起来  \n3. 经典相关数据  \n4. 阅读核心源代码  \n5. Debug  \n\n#### 1.3. 沟通的重要性\n分享，与同事，客户产品需要有效交流。\n\n体系的思考，提前打好心理草稿：\n- 要表达的点  \n- 要让比人get 到的点\n\n\n## 2.油腻的中年人，请对自己好一点\n### 2.1. 要花额外的时间锻炼身体\n >健康排在第一位，任何事情，都不要拿健康去做交换。\n\n### 2.2. 多花一些时间陪家人\n>happy wife, happy life.\n>这是我最大的心得。\n\n### 2.3. 旅行？阅读？培养几个自己的爱好。\n到世上一趟不容易，人生本身就是“体验”的集合：\n- __空间维度，大千世界，多出去走走，被大自然的鬼斧神工所震撼__\n- __时间维度，历史长河，多阅读看看，学习前人多年的智慧沉淀__\n除了上班，陪家人，尽量要有几项自己的兴趣爱好。\n\n## 3. 年轻人必须尽早掌握的思维方式\n[现在赚钱还是以后赚大钱？年轻人必须尽早掌握的思维方式！纯干货输出丨ztalk](https://www.bilibili.com/video/av57285232/?spm_id_from=333.334.b_72616e6b696e675f6c696665.2)\n\n### 3.1. 寻找确定性\n找到大概率可以成功的方法和道路。寻找确定性的结果，在过程中需要与人性，个人理论知识相结合，同时，也要拉长时间的维度。\n>例如选择长期的投资基金而不是做短期的频繁交易买进卖出，这样只会让基金公司赚得更多的管理费用。\n>现在是夏天，短期的天气是不可能精确的，但是几个月之后一定会进入冬天。\n\n### 3.2. 更高时间的维度去思考\n__我们要做的就是基于长时间维度的考量，押注于更确定性的事情上。__ \n\n例如，在大学期间，确定性的事情是：将有限的金钱加上无限时间和精力，投入到能让你赚钱的技能上，这远比投资理财要好的多。\n\n同样，我们也应该站在人生的时间维度上去考虑事情（培养自己的眼光）。\n\n### 3.3. 有舍有得，太极阴阳\n在某一个行业没有摧毁性的问题时，都会有阴阳，[福兮祸所伏，祸兮福所倚](https://baike.baidu.com/item/%E7%A5%B8%E5%85%AE%E7%A6%8F%E6%89%80%E5%80%9A%EF%BC%8C%E7%A6%8F%E5%85%AE%E7%A5%B8%E6%89%80%E4%BC%8F/856363?fr=aladdin)。即西方的经济周期的想法。\n\n在别人恐惧时我贪婪，在别人贪婪时我恐惧。 -- 沃伦.巴菲特","slug":"程序员40岁后该如何发展","published":1,"updated":"2019-12-03T12:24:26.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0s8005lzkgr9ulqa547","content":"<p>2019年6月8号，看到的记录。</p>\n<p><a href=\"https://www.bilibili.com/video/av54080851?spm_id_from=333.334.b_62696c695f746563686e6f6c6f6779.6\" target=\"_blank\" rel=\"noopener\">网易技术大牛：程序员40岁后该如何发展？</a></p>\n<p><a href=\"http://3g.163.com/dy/article/EGM5MBA10517QCLU.html\" target=\"_blank\" rel=\"noopener\">油腻的中年人，请对自己好一点</a></p>\n<a id=\"more\"></a>\n<h2 id=\"1-网易技术大牛：程序员40岁后该如何发展？\"><a href=\"#1-网易技术大牛：程序员40岁后该如何发展？\" class=\"headerlink\" title=\"1. 网易技术大牛：程序员40岁后该如何发展？\"></a>1. 网易技术大牛：程序员40岁后该如何发展？</h2><h3 id=\"1-1-总结–积累性\"><a href=\"#1-1-总结–积累性\" class=\"headerlink\" title=\"1.1. 总结–积累性\"></a>1.1. 总结–积累性</h3><p>程序员并不像医生，生物学等可以线性积累。个人的技能积累一般有三种：</p>\n<ul>\n<li>抛物线</li>\n<li>线性</li>\n<li>指数型</li>\n</ul>\n<p>因此，程序员也是强调积累性。我们可以通过如下：</p>\n<ul>\n<li>个人博客（分享，方便自己查阅）</li>\n<li>写书籍 （个人博客积累到一定程度）</li>\n<li>参加开源社区，沙龙等交流，产生个人影响力等</li>\n</ul>\n<h3 id=\"1-2-成长录\"><a href=\"#1-2-成长录\" class=\"headerlink\" title=\"1.2.成长录\"></a>1.2.成长录</h3><h4 id=\"1-2-1-面试发现\"><a href=\"#1-2-1-面试发现\" class=\"headerlink\" title=\"1.2.1.面试发现\"></a>1.2.1.面试发现</h4><p>越大的企业越注重基础知识，计算机原理，数据结构，操作系统等。 （基础知识牢靠，人的可塑性更强，每方面都能去尝试）</p>\n<p>BAT，Facebook 等一般看中算法与思路。</p>\n<h4 id=\"1-2-2-简历的书写建议\"><a href=\"#1-2-2-简历的书写建议\" class=\"headerlink\" title=\"1.2.2. 简历的书写建议\"></a>1.2.2. 简历的书写建议</h4><h5 id=\"1-2-2-1-相对简单（不超过2、3页）\"><a href=\"#1-2-2-1-相对简单（不超过2、3页）\" class=\"headerlink\" title=\"1.2.2.1. 相对简单（不超过2、3页）\"></a>1.2.2.1. 相对简单（不超过2、3页）</h5><p>信息多，对面试官不能选择重点。</p>\n<h5 id=\"1-2-2-2-量化\"><a href=\"#1-2-2-2-量化\" class=\"headerlink\" title=\"1.2.2.2. 量化\"></a>1.2.2.2. 量化</h5><p>多使用量化的东西，少一些模糊的。<br>如：多大规模，处理的多大的数据量，管理多少机器，处理的速度，实际如何。具体使用了什么技术。</p>\n<h5 id=\"1-2-2-3-清晰（表格、列表），专业术语\"><a href=\"#1-2-2-3-清晰（表格、列表），专业术语\" class=\"headerlink\" title=\"1.2.2.3. 清晰（表格、列表），专业术语\"></a>1.2.2.3. 清晰（表格、列表），专业术语</h5><p>避免大段的描述，使用清晰的表格。</p>\n<h5 id=\"1-2-2-4-点，面，体\"><a href=\"#1-2-2-4-点，面，体\" class=\"headerlink\" title=\"1.2.2.4. 点，面，体\"></a>1.2.2.4. 点，面，体</h5><p><strong>技术提炼（点）</strong><br>从平时的琐碎的事情中，发现提炼自我感觉或者行业中认为的技术亮点。<br>我们就去深挖他。</p>\n<p><strong>横向对比(面)</strong><br>研究由点到面。从技术亮点展开。</p>\n<ul>\n<li>你知道还有些什么方式技术可以达到这个需求？  </li>\n<li>为什么选择当前的方式？  </li>\n<li>其他方式的优缺点，适用环境？</li>\n</ul>\n<p>例如负载均衡的实现方式有哪些？</p>\n<p><strong>拓展开(体)</strong><br>由面的发散，涉及的相关知识。</p>\n<blockquote>\n<p>例如：你研究了多线程，你知道它内部的机理吗？有哪些同步机制等展开问题。</p>\n</blockquote>\n<h5 id=\"1-2-2-5-理论升华\"><a href=\"#1-2-2-5-理论升华\" class=\"headerlink\" title=\"1.2.2.5. 理论升华\"></a>1.2.2.5. 理论升华</h5><p>反复阅读一些经典书籍（例如深入理解Linux网络内幕，深入理解Linux等四库全书），积攒一些理论体系，自己的底蕴。</p>\n<p>有些东西，思路是相通的，学习理解类似的东西更快。例如：<br>CPU的缓存，<br>FS 的缓存，<br>网络中的缓存，<br>CDN 的缓存。</p>\n<p><strong>之前的点、面、体都是招式，理论升华是内功。</strong> 不仅能到达能用，而且还能说的头头是道，在面试时能总结说出自己做过的事情，避免吃亏。</p>\n<p>例如：线程同步有这几种方式，什么情况下改用什么，现在是基于什么特殊场景，使用什么方式，这样比单纯的说只用了xxx技术更好。</p>\n<h4 id=\"1-2-3-代码分析\"><a href=\"#1-2-3-代码分析\" class=\"headerlink\" title=\"1.2.3. 代码分析\"></a>1.2.3. 代码分析</h4><p>代码不会说谎。源码分析刚开始不能总结一些，需要借助书籍进行理论升华。</p>\n<p>不要永远选择自己熟悉的上手，而是应该选择最核心的、有价值的东西。（脱离舒适区，善于去问大牛，放下面子）</p>\n<h4 id=\"1-2-4-开源软件的源代码学习\"><a href=\"#1-2-4-开源软件的源代码学习\" class=\"headerlink\" title=\"1.2.4. 开源软件的源代码学习\"></a>1.2.4. 开源软件的源代码学习</h4><ol>\n<li>手动安装  </li>\n<li>使用起来  </li>\n<li>经典相关数据  </li>\n<li>阅读核心源代码  </li>\n<li>Debug  </li>\n</ol>\n<h4 id=\"1-3-沟通的重要性\"><a href=\"#1-3-沟通的重要性\" class=\"headerlink\" title=\"1.3. 沟通的重要性\"></a>1.3. 沟通的重要性</h4><p>分享，与同事，客户产品需要有效交流。</p>\n<p>体系的思考，提前打好心理草稿：</p>\n<ul>\n<li>要表达的点  </li>\n<li>要让比人get 到的点</li>\n</ul>\n<h2 id=\"2-油腻的中年人，请对自己好一点\"><a href=\"#2-油腻的中年人，请对自己好一点\" class=\"headerlink\" title=\"2.油腻的中年人，请对自己好一点\"></a>2.油腻的中年人，请对自己好一点</h2><h3 id=\"2-1-要花额外的时间锻炼身体\"><a href=\"#2-1-要花额外的时间锻炼身体\" class=\"headerlink\" title=\"2.1. 要花额外的时间锻炼身体\"></a>2.1. 要花额外的时间锻炼身体</h3><blockquote>\n<p>健康排在第一位，任何事情，都不要拿健康去做交换。</p>\n</blockquote>\n<h3 id=\"2-2-多花一些时间陪家人\"><a href=\"#2-2-多花一些时间陪家人\" class=\"headerlink\" title=\"2.2. 多花一些时间陪家人\"></a>2.2. 多花一些时间陪家人</h3><blockquote>\n<p>happy wife, happy life.<br>这是我最大的心得。</p>\n</blockquote>\n<h3 id=\"2-3-旅行？阅读？培养几个自己的爱好。\"><a href=\"#2-3-旅行？阅读？培养几个自己的爱好。\" class=\"headerlink\" title=\"2.3. 旅行？阅读？培养几个自己的爱好。\"></a>2.3. 旅行？阅读？培养几个自己的爱好。</h3><p>到世上一趟不容易，人生本身就是“体验”的集合：</p>\n<ul>\n<li><strong>空间维度，大千世界，多出去走走，被大自然的鬼斧神工所震撼</strong></li>\n<li><strong>时间维度，历史长河，多阅读看看，学习前人多年的智慧沉淀</strong><br>除了上班，陪家人，尽量要有几项自己的兴趣爱好。</li>\n</ul>\n<h2 id=\"3-年轻人必须尽早掌握的思维方式\"><a href=\"#3-年轻人必须尽早掌握的思维方式\" class=\"headerlink\" title=\"3. 年轻人必须尽早掌握的思维方式\"></a>3. 年轻人必须尽早掌握的思维方式</h2><p><a href=\"https://www.bilibili.com/video/av57285232/?spm_id_from=333.334.b_72616e6b696e675f6c696665.2\" target=\"_blank\" rel=\"noopener\">现在赚钱还是以后赚大钱？年轻人必须尽早掌握的思维方式！纯干货输出丨ztalk</a></p>\n<h3 id=\"3-1-寻找确定性\"><a href=\"#3-1-寻找确定性\" class=\"headerlink\" title=\"3.1. 寻找确定性\"></a>3.1. 寻找确定性</h3><p>找到大概率可以成功的方法和道路。寻找确定性的结果，在过程中需要与人性，个人理论知识相结合，同时，也要拉长时间的维度。</p>\n<blockquote>\n<p>例如选择长期的投资基金而不是做短期的频繁交易买进卖出，这样只会让基金公司赚得更多的管理费用。<br>现在是夏天，短期的天气是不可能精确的，但是几个月之后一定会进入冬天。</p>\n</blockquote>\n<h3 id=\"3-2-更高时间的维度去思考\"><a href=\"#3-2-更高时间的维度去思考\" class=\"headerlink\" title=\"3.2. 更高时间的维度去思考\"></a>3.2. 更高时间的维度去思考</h3><p><strong>我们要做的就是基于长时间维度的考量，押注于更确定性的事情上。</strong> </p>\n<p>例如，在大学期间，确定性的事情是：将有限的金钱加上无限时间和精力，投入到能让你赚钱的技能上，这远比投资理财要好的多。</p>\n<p>同样，我们也应该站在人生的时间维度上去考虑事情（培养自己的眼光）。</p>\n<h3 id=\"3-3-有舍有得，太极阴阳\"><a href=\"#3-3-有舍有得，太极阴阳\" class=\"headerlink\" title=\"3.3. 有舍有得，太极阴阳\"></a>3.3. 有舍有得，太极阴阳</h3><p>在某一个行业没有摧毁性的问题时，都会有阴阳，<a href=\"https://baike.baidu.com/item/%E7%A5%B8%E5%85%AE%E7%A6%8F%E6%89%80%E5%80%9A%EF%BC%8C%E7%A6%8F%E5%85%AE%E7%A5%B8%E6%89%80%E4%BC%8F/856363?fr=aladdin\" target=\"_blank\" rel=\"noopener\">福兮祸所伏，祸兮福所倚</a>。即西方的经济周期的想法。</p>\n<p>在别人恐惧时我贪婪，在别人贪婪时我恐惧。 – 沃伦.巴菲特</p>\n","site":{"data":{}},"excerpt":"<p>2019年6月8号，看到的记录。</p>\n<p><a href=\"https://www.bilibili.com/video/av54080851?spm_id_from=333.334.b_62696c695f746563686e6f6c6f6779.6\" target=\"_blank\" rel=\"noopener\">网易技术大牛：程序员40岁后该如何发展？</a></p>\n<p><a href=\"http://3g.163.com/dy/article/EGM5MBA10517QCLU.html\" target=\"_blank\" rel=\"noopener\">油腻的中年人，请对自己好一点</a></p>","more":"<h2 id=\"1-网易技术大牛：程序员40岁后该如何发展？\"><a href=\"#1-网易技术大牛：程序员40岁后该如何发展？\" class=\"headerlink\" title=\"1. 网易技术大牛：程序员40岁后该如何发展？\"></a>1. 网易技术大牛：程序员40岁后该如何发展？</h2><h3 id=\"1-1-总结–积累性\"><a href=\"#1-1-总结–积累性\" class=\"headerlink\" title=\"1.1. 总结–积累性\"></a>1.1. 总结–积累性</h3><p>程序员并不像医生，生物学等可以线性积累。个人的技能积累一般有三种：</p>\n<ul>\n<li>抛物线</li>\n<li>线性</li>\n<li>指数型</li>\n</ul>\n<p>因此，程序员也是强调积累性。我们可以通过如下：</p>\n<ul>\n<li>个人博客（分享，方便自己查阅）</li>\n<li>写书籍 （个人博客积累到一定程度）</li>\n<li>参加开源社区，沙龙等交流，产生个人影响力等</li>\n</ul>\n<h3 id=\"1-2-成长录\"><a href=\"#1-2-成长录\" class=\"headerlink\" title=\"1.2.成长录\"></a>1.2.成长录</h3><h4 id=\"1-2-1-面试发现\"><a href=\"#1-2-1-面试发现\" class=\"headerlink\" title=\"1.2.1.面试发现\"></a>1.2.1.面试发现</h4><p>越大的企业越注重基础知识，计算机原理，数据结构，操作系统等。 （基础知识牢靠，人的可塑性更强，每方面都能去尝试）</p>\n<p>BAT，Facebook 等一般看中算法与思路。</p>\n<h4 id=\"1-2-2-简历的书写建议\"><a href=\"#1-2-2-简历的书写建议\" class=\"headerlink\" title=\"1.2.2. 简历的书写建议\"></a>1.2.2. 简历的书写建议</h4><h5 id=\"1-2-2-1-相对简单（不超过2、3页）\"><a href=\"#1-2-2-1-相对简单（不超过2、3页）\" class=\"headerlink\" title=\"1.2.2.1. 相对简单（不超过2、3页）\"></a>1.2.2.1. 相对简单（不超过2、3页）</h5><p>信息多，对面试官不能选择重点。</p>\n<h5 id=\"1-2-2-2-量化\"><a href=\"#1-2-2-2-量化\" class=\"headerlink\" title=\"1.2.2.2. 量化\"></a>1.2.2.2. 量化</h5><p>多使用量化的东西，少一些模糊的。<br>如：多大规模，处理的多大的数据量，管理多少机器，处理的速度，实际如何。具体使用了什么技术。</p>\n<h5 id=\"1-2-2-3-清晰（表格、列表），专业术语\"><a href=\"#1-2-2-3-清晰（表格、列表），专业术语\" class=\"headerlink\" title=\"1.2.2.3. 清晰（表格、列表），专业术语\"></a>1.2.2.3. 清晰（表格、列表），专业术语</h5><p>避免大段的描述，使用清晰的表格。</p>\n<h5 id=\"1-2-2-4-点，面，体\"><a href=\"#1-2-2-4-点，面，体\" class=\"headerlink\" title=\"1.2.2.4. 点，面，体\"></a>1.2.2.4. 点，面，体</h5><p><strong>技术提炼（点）</strong><br>从平时的琐碎的事情中，发现提炼自我感觉或者行业中认为的技术亮点。<br>我们就去深挖他。</p>\n<p><strong>横向对比(面)</strong><br>研究由点到面。从技术亮点展开。</p>\n<ul>\n<li>你知道还有些什么方式技术可以达到这个需求？  </li>\n<li>为什么选择当前的方式？  </li>\n<li>其他方式的优缺点，适用环境？</li>\n</ul>\n<p>例如负载均衡的实现方式有哪些？</p>\n<p><strong>拓展开(体)</strong><br>由面的发散，涉及的相关知识。</p>\n<blockquote>\n<p>例如：你研究了多线程，你知道它内部的机理吗？有哪些同步机制等展开问题。</p>\n</blockquote>\n<h5 id=\"1-2-2-5-理论升华\"><a href=\"#1-2-2-5-理论升华\" class=\"headerlink\" title=\"1.2.2.5. 理论升华\"></a>1.2.2.5. 理论升华</h5><p>反复阅读一些经典书籍（例如深入理解Linux网络内幕，深入理解Linux等四库全书），积攒一些理论体系，自己的底蕴。</p>\n<p>有些东西，思路是相通的，学习理解类似的东西更快。例如：<br>CPU的缓存，<br>FS 的缓存，<br>网络中的缓存，<br>CDN 的缓存。</p>\n<p><strong>之前的点、面、体都是招式，理论升华是内功。</strong> 不仅能到达能用，而且还能说的头头是道，在面试时能总结说出自己做过的事情，避免吃亏。</p>\n<p>例如：线程同步有这几种方式，什么情况下改用什么，现在是基于什么特殊场景，使用什么方式，这样比单纯的说只用了xxx技术更好。</p>\n<h4 id=\"1-2-3-代码分析\"><a href=\"#1-2-3-代码分析\" class=\"headerlink\" title=\"1.2.3. 代码分析\"></a>1.2.3. 代码分析</h4><p>代码不会说谎。源码分析刚开始不能总结一些，需要借助书籍进行理论升华。</p>\n<p>不要永远选择自己熟悉的上手，而是应该选择最核心的、有价值的东西。（脱离舒适区，善于去问大牛，放下面子）</p>\n<h4 id=\"1-2-4-开源软件的源代码学习\"><a href=\"#1-2-4-开源软件的源代码学习\" class=\"headerlink\" title=\"1.2.4. 开源软件的源代码学习\"></a>1.2.4. 开源软件的源代码学习</h4><ol>\n<li>手动安装  </li>\n<li>使用起来  </li>\n<li>经典相关数据  </li>\n<li>阅读核心源代码  </li>\n<li>Debug  </li>\n</ol>\n<h4 id=\"1-3-沟通的重要性\"><a href=\"#1-3-沟通的重要性\" class=\"headerlink\" title=\"1.3. 沟通的重要性\"></a>1.3. 沟通的重要性</h4><p>分享，与同事，客户产品需要有效交流。</p>\n<p>体系的思考，提前打好心理草稿：</p>\n<ul>\n<li>要表达的点  </li>\n<li>要让比人get 到的点</li>\n</ul>\n<h2 id=\"2-油腻的中年人，请对自己好一点\"><a href=\"#2-油腻的中年人，请对自己好一点\" class=\"headerlink\" title=\"2.油腻的中年人，请对自己好一点\"></a>2.油腻的中年人，请对自己好一点</h2><h3 id=\"2-1-要花额外的时间锻炼身体\"><a href=\"#2-1-要花额外的时间锻炼身体\" class=\"headerlink\" title=\"2.1. 要花额外的时间锻炼身体\"></a>2.1. 要花额外的时间锻炼身体</h3><blockquote>\n<p>健康排在第一位，任何事情，都不要拿健康去做交换。</p>\n</blockquote>\n<h3 id=\"2-2-多花一些时间陪家人\"><a href=\"#2-2-多花一些时间陪家人\" class=\"headerlink\" title=\"2.2. 多花一些时间陪家人\"></a>2.2. 多花一些时间陪家人</h3><blockquote>\n<p>happy wife, happy life.<br>这是我最大的心得。</p>\n</blockquote>\n<h3 id=\"2-3-旅行？阅读？培养几个自己的爱好。\"><a href=\"#2-3-旅行？阅读？培养几个自己的爱好。\" class=\"headerlink\" title=\"2.3. 旅行？阅读？培养几个自己的爱好。\"></a>2.3. 旅行？阅读？培养几个自己的爱好。</h3><p>到世上一趟不容易，人生本身就是“体验”的集合：</p>\n<ul>\n<li><strong>空间维度，大千世界，多出去走走，被大自然的鬼斧神工所震撼</strong></li>\n<li><strong>时间维度，历史长河，多阅读看看，学习前人多年的智慧沉淀</strong><br>除了上班，陪家人，尽量要有几项自己的兴趣爱好。</li>\n</ul>\n<h2 id=\"3-年轻人必须尽早掌握的思维方式\"><a href=\"#3-年轻人必须尽早掌握的思维方式\" class=\"headerlink\" title=\"3. 年轻人必须尽早掌握的思维方式\"></a>3. 年轻人必须尽早掌握的思维方式</h2><p><a href=\"https://www.bilibili.com/video/av57285232/?spm_id_from=333.334.b_72616e6b696e675f6c696665.2\" target=\"_blank\" rel=\"noopener\">现在赚钱还是以后赚大钱？年轻人必须尽早掌握的思维方式！纯干货输出丨ztalk</a></p>\n<h3 id=\"3-1-寻找确定性\"><a href=\"#3-1-寻找确定性\" class=\"headerlink\" title=\"3.1. 寻找确定性\"></a>3.1. 寻找确定性</h3><p>找到大概率可以成功的方法和道路。寻找确定性的结果，在过程中需要与人性，个人理论知识相结合，同时，也要拉长时间的维度。</p>\n<blockquote>\n<p>例如选择长期的投资基金而不是做短期的频繁交易买进卖出，这样只会让基金公司赚得更多的管理费用。<br>现在是夏天，短期的天气是不可能精确的，但是几个月之后一定会进入冬天。</p>\n</blockquote>\n<h3 id=\"3-2-更高时间的维度去思考\"><a href=\"#3-2-更高时间的维度去思考\" class=\"headerlink\" title=\"3.2. 更高时间的维度去思考\"></a>3.2. 更高时间的维度去思考</h3><p><strong>我们要做的就是基于长时间维度的考量，押注于更确定性的事情上。</strong> </p>\n<p>例如，在大学期间，确定性的事情是：将有限的金钱加上无限时间和精力，投入到能让你赚钱的技能上，这远比投资理财要好的多。</p>\n<p>同样，我们也应该站在人生的时间维度上去考虑事情（培养自己的眼光）。</p>\n<h3 id=\"3-3-有舍有得，太极阴阳\"><a href=\"#3-3-有舍有得，太极阴阳\" class=\"headerlink\" title=\"3.3. 有舍有得，太极阴阳\"></a>3.3. 有舍有得，太极阴阳</h3><p>在某一个行业没有摧毁性的问题时，都会有阴阳，<a href=\"https://baike.baidu.com/item/%E7%A5%B8%E5%85%AE%E7%A6%8F%E6%89%80%E5%80%9A%EF%BC%8C%E7%A6%8F%E5%85%AE%E7%A5%B8%E6%89%80%E4%BC%8F/856363?fr=aladdin\" target=\"_blank\" rel=\"noopener\">福兮祸所伏，祸兮福所倚</a>。即西方的经济周期的想法。</p>\n<p>在别人恐惧时我贪婪，在别人贪婪时我恐惧。 – 沃伦.巴菲特</p>"},{"title":"程序员未来的考虑","date":"2018-04-26T12:15:53.000Z","_content":"\n\n## 大龄程序员\n\n## 优势\n\n- 思维，开发思想\n- 阅历\n- 解决问题的框架\n- 学习，自我管理\n\n技术基础-》进阶，能抓出本质-》思维方式，知识体系\n\n有所意识的保留自己的积累，如文章，代码库等，总结劳动成果。\n\n看C++代码的方式：<br>\n1.类用例图，简化（继承，聚合，关联，组合等）<br>\n2.用例图\n\n# 主副业\n\n副业不影响主业\n\n## 业余时间\n\n- 长线看涨\n- 可积累性\n- 可重复复制（每个人的时间成本相同，让一份时间的付出可以获得不止一份时间的报酬）\n\n上班是一份时间，一份对应报酬\n出书，咨询，打赏是一份时间，多份对应报酬\n** 让相同的时间创造出更多的收获 ** \n\n[阮一峰第8周金句](http://www.ruanyifeng.com/blog/2018/06/weekly-issue-8.html)\n>如果你在很年轻的时候，就遭受到了失败，一定要把它当作老天送你的礼物。如果等到四十岁再失败，你会经受不起的。为什么年纪越大，走路越小心，因为越来越经不起跌倒了。\n\n不要惧怕这些，不浪费时间，不停止进步。** Keep it! **","source":"_posts/程序员未来的考虑.md","raw":"---\ntitle: 程序员未来的考虑\ndate: 2018-04-26 20:15:53\ntags: work life\ncategories: life\n---\n\n\n## 大龄程序员\n\n## 优势\n\n- 思维，开发思想\n- 阅历\n- 解决问题的框架\n- 学习，自我管理\n\n技术基础-》进阶，能抓出本质-》思维方式，知识体系\n\n有所意识的保留自己的积累，如文章，代码库等，总结劳动成果。\n\n看C++代码的方式：<br>\n1.类用例图，简化（继承，聚合，关联，组合等）<br>\n2.用例图\n\n# 主副业\n\n副业不影响主业\n\n## 业余时间\n\n- 长线看涨\n- 可积累性\n- 可重复复制（每个人的时间成本相同，让一份时间的付出可以获得不止一份时间的报酬）\n\n上班是一份时间，一份对应报酬\n出书，咨询，打赏是一份时间，多份对应报酬\n** 让相同的时间创造出更多的收获 ** \n\n[阮一峰第8周金句](http://www.ruanyifeng.com/blog/2018/06/weekly-issue-8.html)\n>如果你在很年轻的时候，就遭受到了失败，一定要把它当作老天送你的礼物。如果等到四十岁再失败，你会经受不起的。为什么年纪越大，走路越小心，因为越来越经不起跌倒了。\n\n不要惧怕这些，不浪费时间，不停止进步。** Keep it! **","slug":"程序员未来的考虑","published":1,"updated":"2019-07-08T06:16:07.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0sa005pzkgrym66cvbw","content":"<h2 id=\"大龄程序员\"><a href=\"#大龄程序员\" class=\"headerlink\" title=\"大龄程序员\"></a>大龄程序员</h2><h2 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h2><ul>\n<li>思维，开发思想</li>\n<li>阅历</li>\n<li>解决问题的框架</li>\n<li>学习，自我管理</li>\n</ul>\n<p>技术基础-》进阶，能抓出本质-》思维方式，知识体系</p>\n<p>有所意识的保留自己的积累，如文章，代码库等，总结劳动成果。</p>\n<p>看C++代码的方式：<br><br>1.类用例图，简化（继承，聚合，关联，组合等）<br><br>2.用例图</p>\n<h1 id=\"主副业\"><a href=\"#主副业\" class=\"headerlink\" title=\"主副业\"></a>主副业</h1><p>副业不影响主业</p>\n<h2 id=\"业余时间\"><a href=\"#业余时间\" class=\"headerlink\" title=\"业余时间\"></a>业余时间</h2><ul>\n<li>长线看涨</li>\n<li>可积累性</li>\n<li>可重复复制（每个人的时间成本相同，让一份时间的付出可以获得不止一份时间的报酬）</li>\n</ul>\n<p>上班是一份时间，一份对应报酬<br>出书，咨询，打赏是一份时间，多份对应报酬<br><strong> 让相同的时间创造出更多的收获 </strong> </p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/06/weekly-issue-8.html\" target=\"_blank\" rel=\"noopener\">阮一峰第8周金句</a></p>\n<blockquote>\n<p>如果你在很年轻的时候，就遭受到了失败，一定要把它当作老天送你的礼物。如果等到四十岁再失败，你会经受不起的。为什么年纪越大，走路越小心，因为越来越经不起跌倒了。</p>\n</blockquote>\n<p>不要惧怕这些，不浪费时间，不停止进步。<strong> Keep it! </strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"大龄程序员\"><a href=\"#大龄程序员\" class=\"headerlink\" title=\"大龄程序员\"></a>大龄程序员</h2><h2 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h2><ul>\n<li>思维，开发思想</li>\n<li>阅历</li>\n<li>解决问题的框架</li>\n<li>学习，自我管理</li>\n</ul>\n<p>技术基础-》进阶，能抓出本质-》思维方式，知识体系</p>\n<p>有所意识的保留自己的积累，如文章，代码库等，总结劳动成果。</p>\n<p>看C++代码的方式：<br><br>1.类用例图，简化（继承，聚合，关联，组合等）<br><br>2.用例图</p>\n<h1 id=\"主副业\"><a href=\"#主副业\" class=\"headerlink\" title=\"主副业\"></a>主副业</h1><p>副业不影响主业</p>\n<h2 id=\"业余时间\"><a href=\"#业余时间\" class=\"headerlink\" title=\"业余时间\"></a>业余时间</h2><ul>\n<li>长线看涨</li>\n<li>可积累性</li>\n<li>可重复复制（每个人的时间成本相同，让一份时间的付出可以获得不止一份时间的报酬）</li>\n</ul>\n<p>上班是一份时间，一份对应报酬<br>出书，咨询，打赏是一份时间，多份对应报酬<br><strong> 让相同的时间创造出更多的收获 </strong> </p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/06/weekly-issue-8.html\" target=\"_blank\" rel=\"noopener\">阮一峰第8周金句</a></p>\n<blockquote>\n<p>如果你在很年轻的时候，就遭受到了失败，一定要把它当作老天送你的礼物。如果等到四十岁再失败，你会经受不起的。为什么年纪越大，走路越小心，因为越来越经不起跌倒了。</p>\n</blockquote>\n<p>不要惧怕这些，不浪费时间，不停止进步。<strong> Keep it! </strong></p>\n"},{"title":"穷查理宝典","date":"2019-08-27T11:52:50.000Z","_content":"[查理·芒格](https://baike.baidu.com/item/%E6%9F%A5%E7%90%86%C2%B7%E8%8A%92%E6%A0%BC)， 沃伦·巴菲特的黄金搭档，伯克希尔·哈撒韦公司的副主席，同时也是被号称为移动的书屋。\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=b5421fb0e7fe9925cf0c6e5204a95ee4/cc11728b4710b9124797f18bc4fdfc0392452274.jpg)\n\n无论在顺境，逆境，都保持客观积极的心态。\n\n<!--more-->\n\n### 1. 核心原则\n在最开始当律师时，查理并没有忘记祖父教导的铁律：__专注于当前的任务，控制支出。__\n\n耐心是最伟大的美德。-- 马尔库斯，罗马政治家\n\n对付失望，那就是幽默。\n\n### 2.芒格的生活、学习和决策方法\n凡事往简单处想，往认真处行。（笨人做加法，聪明人做减法，智者做除法）\n\n以跨学科的方式思考\n\n在头脑中拥有一些思维模型，并且愿意甚至渴望去证实和承认自己的错误，并从中吸取教训。否则手里只拿着铁锤的人看来，每个问题都像是钉子。\n\n记住浅显的，而不是掌握深奥的。我们从来不去试图成为非常聪明的人，而是持续地试图别变成蠢货，久而久子，我们这种人便能获得非常大的优势。\n\n### 3. 投资评估过程\n先弄清应该别做什么事情，然后才会考虑接下来采取的行动。\n>我只想知道我将来会是在什么地方，这样我就可以永远不去那里啦。\n\n花在学习和思考上的时间，比花在行动上的时间要多。\n\n查理在意的并不是他本人能否赢牌，而是是否能把手上的牌打好。\n\n你要有浓厚的兴趣去弄明白正在发生的事情背后的原因。如果你能长期保持这种心态，你关注现实的能力将会逐渐得到提高。\n\n弄清自己的优势在哪里，必须在自己的能力圈之内竞争。\n\n一个人可以从书籍上或者人们身上培养眼光。\n\n聪明人在发现机会之后就会狠狠下注，碰到好机会就下重注，其他时间则按兵不动。\n\n投资清单：\n- 随大流只会让你望平均值靠近，只能获得中等业绩\n- 广泛的阅读把自己培养成一个终生自学者，培养好奇心，每天努力让自己更聪明一点点\n- 比求胜的意愿更重要的是做好准备的意愿\n- 记住浅显的好过掌握深奥的\n- 享受结果，也享受过程，因为你活在过程当中\n- 认识和适应你身边的世界的真实本质，别指望它来适应你\n\n<font color=red>最根本的人生哲学：准备、纪律、耐心、决心。</font>\n\n","source":"_posts/穷查理宝典.md","raw":"---\ntitle: 穷查理宝典\ndate: 2019-08-27 19:52:50\ntags: bookmarks\ncategories: bookmarks\n---\n[查理·芒格](https://baike.baidu.com/item/%E6%9F%A5%E7%90%86%C2%B7%E8%8A%92%E6%A0%BC)， 沃伦·巴菲特的黄金搭档，伯克希尔·哈撒韦公司的副主席，同时也是被号称为移动的书屋。\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=b5421fb0e7fe9925cf0c6e5204a95ee4/cc11728b4710b9124797f18bc4fdfc0392452274.jpg)\n\n无论在顺境，逆境，都保持客观积极的心态。\n\n<!--more-->\n\n### 1. 核心原则\n在最开始当律师时，查理并没有忘记祖父教导的铁律：__专注于当前的任务，控制支出。__\n\n耐心是最伟大的美德。-- 马尔库斯，罗马政治家\n\n对付失望，那就是幽默。\n\n### 2.芒格的生活、学习和决策方法\n凡事往简单处想，往认真处行。（笨人做加法，聪明人做减法，智者做除法）\n\n以跨学科的方式思考\n\n在头脑中拥有一些思维模型，并且愿意甚至渴望去证实和承认自己的错误，并从中吸取教训。否则手里只拿着铁锤的人看来，每个问题都像是钉子。\n\n记住浅显的，而不是掌握深奥的。我们从来不去试图成为非常聪明的人，而是持续地试图别变成蠢货，久而久子，我们这种人便能获得非常大的优势。\n\n### 3. 投资评估过程\n先弄清应该别做什么事情，然后才会考虑接下来采取的行动。\n>我只想知道我将来会是在什么地方，这样我就可以永远不去那里啦。\n\n花在学习和思考上的时间，比花在行动上的时间要多。\n\n查理在意的并不是他本人能否赢牌，而是是否能把手上的牌打好。\n\n你要有浓厚的兴趣去弄明白正在发生的事情背后的原因。如果你能长期保持这种心态，你关注现实的能力将会逐渐得到提高。\n\n弄清自己的优势在哪里，必须在自己的能力圈之内竞争。\n\n一个人可以从书籍上或者人们身上培养眼光。\n\n聪明人在发现机会之后就会狠狠下注，碰到好机会就下重注，其他时间则按兵不动。\n\n投资清单：\n- 随大流只会让你望平均值靠近，只能获得中等业绩\n- 广泛的阅读把自己培养成一个终生自学者，培养好奇心，每天努力让自己更聪明一点点\n- 比求胜的意愿更重要的是做好准备的意愿\n- 记住浅显的好过掌握深奥的\n- 享受结果，也享受过程，因为你活在过程当中\n- 认识和适应你身边的世界的真实本质，别指望它来适应你\n\n<font color=red>最根本的人生哲学：准备、纪律、耐心、决心。</font>\n\n","slug":"穷查理宝典","published":1,"updated":"2020-02-18T07:41:04.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0sb005tzkgra5ehurld","content":"<p><a href=\"https://baike.baidu.com/item/%E6%9F%A5%E7%90%86%C2%B7%E8%8A%92%E6%A0%BC\" target=\"_blank\" rel=\"noopener\">查理·芒格</a>， 沃伦·巴菲特的黄金搭档，伯克希尔·哈撒韦公司的副主席，同时也是被号称为移动的书屋。</p>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=b5421fb0e7fe9925cf0c6e5204a95ee4/cc11728b4710b9124797f18bc4fdfc0392452274.jpg\" alt=\"\"></p>\n<p>无论在顺境，逆境，都保持客观积极的心态。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-核心原则\"><a href=\"#1-核心原则\" class=\"headerlink\" title=\"1. 核心原则\"></a>1. 核心原则</h3><p>在最开始当律师时，查理并没有忘记祖父教导的铁律：<strong>专注于当前的任务，控制支出。</strong></p>\n<p>耐心是最伟大的美德。– 马尔库斯，罗马政治家</p>\n<p>对付失望，那就是幽默。</p>\n<h3 id=\"2-芒格的生活、学习和决策方法\"><a href=\"#2-芒格的生活、学习和决策方法\" class=\"headerlink\" title=\"2.芒格的生活、学习和决策方法\"></a>2.芒格的生活、学习和决策方法</h3><p>凡事往简单处想，往认真处行。（笨人做加法，聪明人做减法，智者做除法）</p>\n<p>以跨学科的方式思考</p>\n<p>在头脑中拥有一些思维模型，并且愿意甚至渴望去证实和承认自己的错误，并从中吸取教训。否则手里只拿着铁锤的人看来，每个问题都像是钉子。</p>\n<p>记住浅显的，而不是掌握深奥的。我们从来不去试图成为非常聪明的人，而是持续地试图别变成蠢货，久而久子，我们这种人便能获得非常大的优势。</p>\n<h3 id=\"3-投资评估过程\"><a href=\"#3-投资评估过程\" class=\"headerlink\" title=\"3. 投资评估过程\"></a>3. 投资评估过程</h3><p>先弄清应该别做什么事情，然后才会考虑接下来采取的行动。</p>\n<blockquote>\n<p>我只想知道我将来会是在什么地方，这样我就可以永远不去那里啦。</p>\n</blockquote>\n<p>花在学习和思考上的时间，比花在行动上的时间要多。</p>\n<p>查理在意的并不是他本人能否赢牌，而是是否能把手上的牌打好。</p>\n<p>你要有浓厚的兴趣去弄明白正在发生的事情背后的原因。如果你能长期保持这种心态，你关注现实的能力将会逐渐得到提高。</p>\n<p>弄清自己的优势在哪里，必须在自己的能力圈之内竞争。</p>\n<p>一个人可以从书籍上或者人们身上培养眼光。</p>\n<p>聪明人在发现机会之后就会狠狠下注，碰到好机会就下重注，其他时间则按兵不动。</p>\n<p>投资清单：</p>\n<ul>\n<li>随大流只会让你望平均值靠近，只能获得中等业绩</li>\n<li>广泛的阅读把自己培养成一个终生自学者，培养好奇心，每天努力让自己更聪明一点点</li>\n<li>比求胜的意愿更重要的是做好准备的意愿</li>\n<li>记住浅显的好过掌握深奥的</li>\n<li>享受结果，也享受过程，因为你活在过程当中</li>\n<li>认识和适应你身边的世界的真实本质，别指望它来适应你</li>\n</ul>\n<font color=\"red\">最根本的人生哲学：准备、纪律、耐心、决心。</font>\n\n","site":{"data":{}},"excerpt":"<p><a href=\"https://baike.baidu.com/item/%E6%9F%A5%E7%90%86%C2%B7%E8%8A%92%E6%A0%BC\" target=\"_blank\" rel=\"noopener\">查理·芒格</a>， 沃伦·巴菲特的黄金搭档，伯克希尔·哈撒韦公司的副主席，同时也是被号称为移动的书屋。</p>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=b5421fb0e7fe9925cf0c6e5204a95ee4/cc11728b4710b9124797f18bc4fdfc0392452274.jpg\" alt=\"\"></p>\n<p>无论在顺境，逆境，都保持客观积极的心态。</p>","more":"<h3 id=\"1-核心原则\"><a href=\"#1-核心原则\" class=\"headerlink\" title=\"1. 核心原则\"></a>1. 核心原则</h3><p>在最开始当律师时，查理并没有忘记祖父教导的铁律：<strong>专注于当前的任务，控制支出。</strong></p>\n<p>耐心是最伟大的美德。– 马尔库斯，罗马政治家</p>\n<p>对付失望，那就是幽默。</p>\n<h3 id=\"2-芒格的生活、学习和决策方法\"><a href=\"#2-芒格的生活、学习和决策方法\" class=\"headerlink\" title=\"2.芒格的生活、学习和决策方法\"></a>2.芒格的生活、学习和决策方法</h3><p>凡事往简单处想，往认真处行。（笨人做加法，聪明人做减法，智者做除法）</p>\n<p>以跨学科的方式思考</p>\n<p>在头脑中拥有一些思维模型，并且愿意甚至渴望去证实和承认自己的错误，并从中吸取教训。否则手里只拿着铁锤的人看来，每个问题都像是钉子。</p>\n<p>记住浅显的，而不是掌握深奥的。我们从来不去试图成为非常聪明的人，而是持续地试图别变成蠢货，久而久子，我们这种人便能获得非常大的优势。</p>\n<h3 id=\"3-投资评估过程\"><a href=\"#3-投资评估过程\" class=\"headerlink\" title=\"3. 投资评估过程\"></a>3. 投资评估过程</h3><p>先弄清应该别做什么事情，然后才会考虑接下来采取的行动。</p>\n<blockquote>\n<p>我只想知道我将来会是在什么地方，这样我就可以永远不去那里啦。</p>\n</blockquote>\n<p>花在学习和思考上的时间，比花在行动上的时间要多。</p>\n<p>查理在意的并不是他本人能否赢牌，而是是否能把手上的牌打好。</p>\n<p>你要有浓厚的兴趣去弄明白正在发生的事情背后的原因。如果你能长期保持这种心态，你关注现实的能力将会逐渐得到提高。</p>\n<p>弄清自己的优势在哪里，必须在自己的能力圈之内竞争。</p>\n<p>一个人可以从书籍上或者人们身上培养眼光。</p>\n<p>聪明人在发现机会之后就会狠狠下注，碰到好机会就下重注，其他时间则按兵不动。</p>\n<p>投资清单：</p>\n<ul>\n<li>随大流只会让你望平均值靠近，只能获得中等业绩</li>\n<li>广泛的阅读把自己培养成一个终生自学者，培养好奇心，每天努力让自己更聪明一点点</li>\n<li>比求胜的意愿更重要的是做好准备的意愿</li>\n<li>记住浅显的好过掌握深奥的</li>\n<li>享受结果，也享受过程，因为你活在过程当中</li>\n<li>认识和适应你身边的世界的真实本质，别指望它来适应你</li>\n</ul>\n<font color=\"red\">最根本的人生哲学：准备、纪律、耐心、决心。</font>"},{"title":"老子是癞蛤蟆","date":"2018-04-26T12:01:06.000Z","_content":"\n## 序\n读[烽火](https://baike.baidu.com/item/%E7%83%BD%E7%81%AB%E6%88%8F%E8%AF%B8%E4%BE%AF/9127348?fr=aladdin)的这本书《[老子是癞蛤蟆](https://baike.baidu.com/item/%E8%80%81%E5%AD%90%E6%98%AF%E7%99%9E%E8%9B%A4%E8%9F%86/4871434?fr=aladdin)》，\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=e306f7ec0c33874488c8272e3066b29c/b03533fa828ba61ebdf161934134970a304e596a.jpg)\n\n总是能给予自己很多的触动，他总能鼓动风雨--[波澜哥](https://baike.baidu.com/item/%E6%B3%A2%E6%BE%9C%E5%93%A5)：）。\n\n<!--more-->\n\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=7a3962be72310a55d029d6a6d62c28cc/5243fbf2b21193133d7107fd6e380cd791238d49.jpg)\n\n---\n\n## 1. 执念\n\n人必有所执，方能有所成。\n\n不忘初心，方得始终。（[概括自《华严经》](https://baike.baidu.com/item/%E5%8D%8E%E4%B8%A5%E7%BB%8F/1930991?fr=aladdin)，[靡不有初，鲜克有终](https://baike.baidu.com/item/%E9%9D%A1%E4%B8%8D%E6%9C%89%E5%88%9D%EF%BC%8C%E9%B2%9C%E5%85%8B%E6%9C%89%E7%BB%88/4433245?fr=aladdin)）\n\n哪怕是一只癞蛤蟆，能够几十年如一日地充实自己，迟早都有跳出池塘吃上天鹅肉的一天，这个天鹅肉可以是桃李满天下，可以是抱得美人归，也可以是功成名就光耀门楣。\n\n像一头不知疲倦的狼，肚里咽着肉，嘴里叼着肉，还要弓着腰，咬着牙去搏杀。\n\n我看她的世界 就像是站在阴间看阳间。（陈靖）\n\n我就是穷人的孩子，能做的除了拼命还是拼命最后他妈的还是拼命，一定要让我的孩子，成为富人的孩子。\n\n就是被人踩得一滩烂泥，也要捏出狗尾巴花来。\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike220%2C5%2C5%2C220%2C73/sign=bb3d0303d0a20cf4529df68d17602053/ae51f3deb48f8c54765141ab3a292df5e1fe7fb0.jpg)\n\n---\n\n## 2. UP Myself\n\n### 2.1. 个人\n\n一个上升的态度比什么都重要。 \n\n**坚持去坚持**。\n\n尽人事，听天命。\n\n生活中，所有人的角色定位都在改变，一些人在后退，一些则在前行，厉害的，则是奔跑，最牛的，当然是在冲刺的那一类。\n\n顺境能够看一个人的先天品性，逆境能够看一个人的后天品性。\n品性，品行，一字之差，却悬殊千里，哪个更重，仁者见仁智者见智。\n\n一个男人平性如何，顺境时看他如何对待以前的朋友，这些人往往无益于他如今事业；逆境时看他如何对待自己的亲人，敢不敢承担责任，能不能放弃一些东西。\n\n熬一熬，说不定这道坎就熬过去了。\n\n总之别把简单问题复杂化，聪明孩子就要错减法，大智慧的孩子甚至会做除法。\n\n每逢大事有静气，就算做不到，也要假装做得到。等到习惯成自然，城府也就出来了。\n\n为学第一功夫，是**降得浮躁之气定**，做人第一紧要，是有**慈悲心**。\n\n下棋如做人，行错一步，不能摆在脸上，得放在心上。\n\n做错事，成小丑或者傻瓜了，从不怨恨谁，也不会悔自己的决定。\n\n### 2.2. 心态\n人生为棋我为卒，行动虽慢，命运多牟，可谁曾见我后退半步？\n\n>是岐山凤雏，南阳卧龙，渭水飞熊？还是那五眼鸡，两头蛇，三脚猫？一退再退，风波恼我，我恼风波。逆水行舟，风波远我，我远风波。 -- [《水仙子·讥时》，张鸣善](https://baike.baidu.com/item/%E6%B0%B4%E4%BB%99%E5%AD%90%C2%B7%E8%AE%A5%E6%97%B6/4075463?fr=aladdin)\n\n>我不急不躁，心如磐石，若青松，八风不动，清风拂山岗，明月照大江……\n虽千万人，虽黑云压城，虽遍地魑魅魍魉，我往矣…… \n\n走旁门，信左道，九次成功一次失败就败得一塌糊涂，再无东山再起。走正道，九次失败一次成功就能终生受益。\n\n岁月是一把牛B的屠龙刀，能让某些男人飞黄腾达。但岁月也是一把贱B的杀猪刀，能让某些女人明日黄花。\n\n人的一生只有一个终点，却有很多个起点。\n\n对的起自己，对自己负责，才能对得起别人，自己在乎的人。\n一个爷们，想要爱人，必须先学会好好爱自己。\n\n### 2.3. 待人\n**学着感恩，学着理解，学着友善**。\n有些花花草草，自小生长在营养优渥的温室环境，不知道风雨，所以不懂得**感恩**。\n\n>**争取不要错过谁，错过的，尽量去祝福.**\n\n>**人下人，要把自己当人；人上人，要把别人当人。**\n\n太精明了，所以不够聪明。\n\n被精明人占小便宜的，只要心里有数就行，被蒙一点钱无所谓，最重要的是不能蒙在鼓里，生意场上，退一小步，进几大步。\n\n### 2.4. 读书\n\n多读书，是腹有诗书气自华，看人待物能多几分透彻，多识人，是以人为镜，能够多自省自知。\n\n**一个人是不是井底之蛙，自己说了不算。假如有一天你能饱览井底甚至是井上的风光，真不是井底之蛙了，心存一点谦恭，总不是坏事。**\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/readbook.jpg)\n\n做学问要钻牛角尖，越死越好，但做人，要活络一些，不涉及原则性问题，总不是坏事。做学问做到家徒四壁，连带家人一起穷困潦倒，那不叫做学问，叫作孽。 -- 国士陈平安与赵甲第对话\n\n---\n\n## 3. 生活社会\n\n>生活才是最荒诞的艺术。\n\n>男孩子帅不帅，要看有没有理想，女孩子漂亮不漂亮，要看善不善良。\n\n**不惮以最大恶意揣度他人，这样才能最大限度的不去失望**\n\n很多人，光看是瞧不出厉害不厉害的。听其言不够，还得观其行，再揣度其心。\n\n就算自己不喜欢撒谎，在必须撒谎的时候，就尽量放烟幕弹打马虎眼，坚决不能做有一说一的实诚人。\n\n再好的木料，只要小时候长歪了，就废了。\n\n这才是真正到人生，每个人都按照惯性进步或者滑落，更多是在煮沸温水中逐渐死去的青蛙，愚昧无知到连跳出去的欲望都欠奉\n\n很多道理，越是亲近的人苦口婆心，效果不大，反而是敌人和不相干的人，偶尔发语，才初期的振聋发聩。\n\n世界就是这样，年轻的时候难免流亡他乡。世界就是这样，年轻的时候难免颠沛流离。（此心安处即吾乡 -- << [定风波](https://baike.baidu.com/item/%E6%AD%A4%E5%BF%83%E5%AE%89%E5%A4%84%E6%98%AF%E5%90%BE%E4%B9%A1/19189793?fr=aladdin) >>，苏轼）\n\n贩夫走卒，市井小民，高官显贵，皇亲国戚，说到底都是一只只披着身份衣裳的阿猫阿狗，有些笨点，有些聪明点，每天喂养一下，总有物尽其用的一天。\n\n>人走茶凉是常态，可那个愿意陪冷宫的人喝冷茶的人，才会被当做朋友。\n\n>有些交情，太早粘上钱，不是好事。也许一开始看着是赚，其实是亏，会从头亏到尾。\n\n人情这两个字，就跟倒过来的“情人”，一词一个德行，得温火慢炖“日”久见人心。\n\n人情的火炉，是需要时不时“撩拨”一下的，不能一路冷却下去。\n\n>有些女人，是那种见到男人就拼命绽放的花朵，而有些女人，则矜持骄傲地只为一个男人娇艳摇曳。\n\n太完美的女人都容易红颜薄命，还是有点残缺美比较让人安稳 :)\n\n>能杀得人需先能救得人，能救得人却还需能活得己。\n>世上很多弱者，极少数是因为善良质朴，而主动选择退让。但更多的，可能是一种狡黠的处世智慧，处于劣势，却不是真的占据礼仪理义。相反，一旦有利可图，狰狞程度，可憎程度，丝毫不逊色任何人。**强者未必都在为恶，弱者未必都是心善**。","source":"_posts/老子是癞蛤蟆书摘.md","raw":"---\ntitle: 老子是癞蛤蟆\ndate: 2018-04-26 20:01:06\ntags: bookmarks\ncategories: bookmarks\n---\n\n## 序\n读[烽火](https://baike.baidu.com/item/%E7%83%BD%E7%81%AB%E6%88%8F%E8%AF%B8%E4%BE%AF/9127348?fr=aladdin)的这本书《[老子是癞蛤蟆](https://baike.baidu.com/item/%E8%80%81%E5%AD%90%E6%98%AF%E7%99%9E%E8%9B%A4%E8%9F%86/4871434?fr=aladdin)》，\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=e306f7ec0c33874488c8272e3066b29c/b03533fa828ba61ebdf161934134970a304e596a.jpg)\n\n总是能给予自己很多的触动，他总能鼓动风雨--[波澜哥](https://baike.baidu.com/item/%E6%B3%A2%E6%BE%9C%E5%93%A5)：）。\n\n<!--more-->\n\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=7a3962be72310a55d029d6a6d62c28cc/5243fbf2b21193133d7107fd6e380cd791238d49.jpg)\n\n---\n\n## 1. 执念\n\n人必有所执，方能有所成。\n\n不忘初心，方得始终。（[概括自《华严经》](https://baike.baidu.com/item/%E5%8D%8E%E4%B8%A5%E7%BB%8F/1930991?fr=aladdin)，[靡不有初，鲜克有终](https://baike.baidu.com/item/%E9%9D%A1%E4%B8%8D%E6%9C%89%E5%88%9D%EF%BC%8C%E9%B2%9C%E5%85%8B%E6%9C%89%E7%BB%88/4433245?fr=aladdin)）\n\n哪怕是一只癞蛤蟆，能够几十年如一日地充实自己，迟早都有跳出池塘吃上天鹅肉的一天，这个天鹅肉可以是桃李满天下，可以是抱得美人归，也可以是功成名就光耀门楣。\n\n像一头不知疲倦的狼，肚里咽着肉，嘴里叼着肉，还要弓着腰，咬着牙去搏杀。\n\n我看她的世界 就像是站在阴间看阳间。（陈靖）\n\n我就是穷人的孩子，能做的除了拼命还是拼命最后他妈的还是拼命，一定要让我的孩子，成为富人的孩子。\n\n就是被人踩得一滩烂泥，也要捏出狗尾巴花来。\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike220%2C5%2C5%2C220%2C73/sign=bb3d0303d0a20cf4529df68d17602053/ae51f3deb48f8c54765141ab3a292df5e1fe7fb0.jpg)\n\n---\n\n## 2. UP Myself\n\n### 2.1. 个人\n\n一个上升的态度比什么都重要。 \n\n**坚持去坚持**。\n\n尽人事，听天命。\n\n生活中，所有人的角色定位都在改变，一些人在后退，一些则在前行，厉害的，则是奔跑，最牛的，当然是在冲刺的那一类。\n\n顺境能够看一个人的先天品性，逆境能够看一个人的后天品性。\n品性，品行，一字之差，却悬殊千里，哪个更重，仁者见仁智者见智。\n\n一个男人平性如何，顺境时看他如何对待以前的朋友，这些人往往无益于他如今事业；逆境时看他如何对待自己的亲人，敢不敢承担责任，能不能放弃一些东西。\n\n熬一熬，说不定这道坎就熬过去了。\n\n总之别把简单问题复杂化，聪明孩子就要错减法，大智慧的孩子甚至会做除法。\n\n每逢大事有静气，就算做不到，也要假装做得到。等到习惯成自然，城府也就出来了。\n\n为学第一功夫，是**降得浮躁之气定**，做人第一紧要，是有**慈悲心**。\n\n下棋如做人，行错一步，不能摆在脸上，得放在心上。\n\n做错事，成小丑或者傻瓜了，从不怨恨谁，也不会悔自己的决定。\n\n### 2.2. 心态\n人生为棋我为卒，行动虽慢，命运多牟，可谁曾见我后退半步？\n\n>是岐山凤雏，南阳卧龙，渭水飞熊？还是那五眼鸡，两头蛇，三脚猫？一退再退，风波恼我，我恼风波。逆水行舟，风波远我，我远风波。 -- [《水仙子·讥时》，张鸣善](https://baike.baidu.com/item/%E6%B0%B4%E4%BB%99%E5%AD%90%C2%B7%E8%AE%A5%E6%97%B6/4075463?fr=aladdin)\n\n>我不急不躁，心如磐石，若青松，八风不动，清风拂山岗，明月照大江……\n虽千万人，虽黑云压城，虽遍地魑魅魍魉，我往矣…… \n\n走旁门，信左道，九次成功一次失败就败得一塌糊涂，再无东山再起。走正道，九次失败一次成功就能终生受益。\n\n岁月是一把牛B的屠龙刀，能让某些男人飞黄腾达。但岁月也是一把贱B的杀猪刀，能让某些女人明日黄花。\n\n人的一生只有一个终点，却有很多个起点。\n\n对的起自己，对自己负责，才能对得起别人，自己在乎的人。\n一个爷们，想要爱人，必须先学会好好爱自己。\n\n### 2.3. 待人\n**学着感恩，学着理解，学着友善**。\n有些花花草草，自小生长在营养优渥的温室环境，不知道风雨，所以不懂得**感恩**。\n\n>**争取不要错过谁，错过的，尽量去祝福.**\n\n>**人下人，要把自己当人；人上人，要把别人当人。**\n\n太精明了，所以不够聪明。\n\n被精明人占小便宜的，只要心里有数就行，被蒙一点钱无所谓，最重要的是不能蒙在鼓里，生意场上，退一小步，进几大步。\n\n### 2.4. 读书\n\n多读书，是腹有诗书气自华，看人待物能多几分透彻，多识人，是以人为镜，能够多自省自知。\n\n**一个人是不是井底之蛙，自己说了不算。假如有一天你能饱览井底甚至是井上的风光，真不是井底之蛙了，心存一点谦恭，总不是坏事。**\n![](https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/readbook.jpg)\n\n做学问要钻牛角尖，越死越好，但做人，要活络一些，不涉及原则性问题，总不是坏事。做学问做到家徒四壁，连带家人一起穷困潦倒，那不叫做学问，叫作孽。 -- 国士陈平安与赵甲第对话\n\n---\n\n## 3. 生活社会\n\n>生活才是最荒诞的艺术。\n\n>男孩子帅不帅，要看有没有理想，女孩子漂亮不漂亮，要看善不善良。\n\n**不惮以最大恶意揣度他人，这样才能最大限度的不去失望**\n\n很多人，光看是瞧不出厉害不厉害的。听其言不够，还得观其行，再揣度其心。\n\n就算自己不喜欢撒谎，在必须撒谎的时候，就尽量放烟幕弹打马虎眼，坚决不能做有一说一的实诚人。\n\n再好的木料，只要小时候长歪了，就废了。\n\n这才是真正到人生，每个人都按照惯性进步或者滑落，更多是在煮沸温水中逐渐死去的青蛙，愚昧无知到连跳出去的欲望都欠奉\n\n很多道理，越是亲近的人苦口婆心，效果不大，反而是敌人和不相干的人，偶尔发语，才初期的振聋发聩。\n\n世界就是这样，年轻的时候难免流亡他乡。世界就是这样，年轻的时候难免颠沛流离。（此心安处即吾乡 -- << [定风波](https://baike.baidu.com/item/%E6%AD%A4%E5%BF%83%E5%AE%89%E5%A4%84%E6%98%AF%E5%90%BE%E4%B9%A1/19189793?fr=aladdin) >>，苏轼）\n\n贩夫走卒，市井小民，高官显贵，皇亲国戚，说到底都是一只只披着身份衣裳的阿猫阿狗，有些笨点，有些聪明点，每天喂养一下，总有物尽其用的一天。\n\n>人走茶凉是常态，可那个愿意陪冷宫的人喝冷茶的人，才会被当做朋友。\n\n>有些交情，太早粘上钱，不是好事。也许一开始看着是赚，其实是亏，会从头亏到尾。\n\n人情这两个字，就跟倒过来的“情人”，一词一个德行，得温火慢炖“日”久见人心。\n\n人情的火炉，是需要时不时“撩拨”一下的，不能一路冷却下去。\n\n>有些女人，是那种见到男人就拼命绽放的花朵，而有些女人，则矜持骄傲地只为一个男人娇艳摇曳。\n\n太完美的女人都容易红颜薄命，还是有点残缺美比较让人安稳 :)\n\n>能杀得人需先能救得人，能救得人却还需能活得己。\n>世上很多弱者，极少数是因为善良质朴，而主动选择退让。但更多的，可能是一种狡黠的处世智慧，处于劣势，却不是真的占据礼仪理义。相反，一旦有利可图，狰狞程度，可憎程度，丝毫不逊色任何人。**强者未必都在为恶，弱者未必都是心善**。","slug":"老子是癞蛤蟆书摘","published":1,"updated":"2019-07-08T06:16:07.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0sd005xzkgrxp1qp8l2","content":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>读<a href=\"https://baike.baidu.com/item/%E7%83%BD%E7%81%AB%E6%88%8F%E8%AF%B8%E4%BE%AF/9127348?fr=aladdin\" target=\"_blank\" rel=\"noopener\">烽火</a>的这本书《<a href=\"https://baike.baidu.com/item/%E8%80%81%E5%AD%90%E6%98%AF%E7%99%9E%E8%9B%A4%E8%9F%86/4871434?fr=aladdin\" target=\"_blank\" rel=\"noopener\">老子是癞蛤蟆</a>》，<br><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=e306f7ec0c33874488c8272e3066b29c/b03533fa828ba61ebdf161934134970a304e596a.jpg\" alt=\"\"></p>\n<p>总是能给予自己很多的触动，他总能鼓动风雨–<a href=\"https://baike.baidu.com/item/%E6%B3%A2%E6%BE%9C%E5%93%A5\" target=\"_blank\" rel=\"noopener\">波澜哥</a>：）。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=7a3962be72310a55d029d6a6d62c28cc/5243fbf2b21193133d7107fd6e380cd791238d49.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"1-执念\"><a href=\"#1-执念\" class=\"headerlink\" title=\"1. 执念\"></a>1. 执念</h2><p>人必有所执，方能有所成。</p>\n<p>不忘初心，方得始终。（<a href=\"https://baike.baidu.com/item/%E5%8D%8E%E4%B8%A5%E7%BB%8F/1930991?fr=aladdin\" target=\"_blank\" rel=\"noopener\">概括自《华严经》</a>，<a href=\"https://baike.baidu.com/item/%E9%9D%A1%E4%B8%8D%E6%9C%89%E5%88%9D%EF%BC%8C%E9%B2%9C%E5%85%8B%E6%9C%89%E7%BB%88/4433245?fr=aladdin\" target=\"_blank\" rel=\"noopener\">靡不有初，鲜克有终</a>）</p>\n<p>哪怕是一只癞蛤蟆，能够几十年如一日地充实自己，迟早都有跳出池塘吃上天鹅肉的一天，这个天鹅肉可以是桃李满天下，可以是抱得美人归，也可以是功成名就光耀门楣。</p>\n<p>像一头不知疲倦的狼，肚里咽着肉，嘴里叼着肉，还要弓着腰，咬着牙去搏杀。</p>\n<p>我看她的世界 就像是站在阴间看阳间。（陈靖）</p>\n<p>我就是穷人的孩子，能做的除了拼命还是拼命最后他妈的还是拼命，一定要让我的孩子，成为富人的孩子。</p>\n<p>就是被人踩得一滩烂泥，也要捏出狗尾巴花来。<br><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike220%2C5%2C5%2C220%2C73/sign=bb3d0303d0a20cf4529df68d17602053/ae51f3deb48f8c54765141ab3a292df5e1fe7fb0.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"2-UP-Myself\"><a href=\"#2-UP-Myself\" class=\"headerlink\" title=\"2. UP Myself\"></a>2. UP Myself</h2><h3 id=\"2-1-个人\"><a href=\"#2-1-个人\" class=\"headerlink\" title=\"2.1. 个人\"></a>2.1. 个人</h3><p>一个上升的态度比什么都重要。 </p>\n<p><strong>坚持去坚持</strong>。</p>\n<p>尽人事，听天命。</p>\n<p>生活中，所有人的角色定位都在改变，一些人在后退，一些则在前行，厉害的，则是奔跑，最牛的，当然是在冲刺的那一类。</p>\n<p>顺境能够看一个人的先天品性，逆境能够看一个人的后天品性。<br>品性，品行，一字之差，却悬殊千里，哪个更重，仁者见仁智者见智。</p>\n<p>一个男人平性如何，顺境时看他如何对待以前的朋友，这些人往往无益于他如今事业；逆境时看他如何对待自己的亲人，敢不敢承担责任，能不能放弃一些东西。</p>\n<p>熬一熬，说不定这道坎就熬过去了。</p>\n<p>总之别把简单问题复杂化，聪明孩子就要错减法，大智慧的孩子甚至会做除法。</p>\n<p>每逢大事有静气，就算做不到，也要假装做得到。等到习惯成自然，城府也就出来了。</p>\n<p>为学第一功夫，是<strong>降得浮躁之气定</strong>，做人第一紧要，是有<strong>慈悲心</strong>。</p>\n<p>下棋如做人，行错一步，不能摆在脸上，得放在心上。</p>\n<p>做错事，成小丑或者傻瓜了，从不怨恨谁，也不会悔自己的决定。</p>\n<h3 id=\"2-2-心态\"><a href=\"#2-2-心态\" class=\"headerlink\" title=\"2.2. 心态\"></a>2.2. 心态</h3><p>人生为棋我为卒，行动虽慢，命运多牟，可谁曾见我后退半步？</p>\n<blockquote>\n<p>是岐山凤雏，南阳卧龙，渭水飞熊？还是那五眼鸡，两头蛇，三脚猫？一退再退，风波恼我，我恼风波。逆水行舟，风波远我，我远风波。 – <a href=\"https://baike.baidu.com/item/%E6%B0%B4%E4%BB%99%E5%AD%90%C2%B7%E8%AE%A5%E6%97%B6/4075463?fr=aladdin\" target=\"_blank\" rel=\"noopener\">《水仙子·讥时》，张鸣善</a></p>\n</blockquote>\n<blockquote>\n<p>我不急不躁，心如磐石，若青松，八风不动，清风拂山岗，明月照大江……<br>虽千万人，虽黑云压城，虽遍地魑魅魍魉，我往矣…… </p>\n</blockquote>\n<p>走旁门，信左道，九次成功一次失败就败得一塌糊涂，再无东山再起。走正道，九次失败一次成功就能终生受益。</p>\n<p>岁月是一把牛B的屠龙刀，能让某些男人飞黄腾达。但岁月也是一把贱B的杀猪刀，能让某些女人明日黄花。</p>\n<p>人的一生只有一个终点，却有很多个起点。</p>\n<p>对的起自己，对自己负责，才能对得起别人，自己在乎的人。<br>一个爷们，想要爱人，必须先学会好好爱自己。</p>\n<h3 id=\"2-3-待人\"><a href=\"#2-3-待人\" class=\"headerlink\" title=\"2.3. 待人\"></a>2.3. 待人</h3><p><strong>学着感恩，学着理解，学着友善</strong>。<br>有些花花草草，自小生长在营养优渥的温室环境，不知道风雨，所以不懂得<strong>感恩</strong>。</p>\n<blockquote>\n<p><strong>争取不要错过谁，错过的，尽量去祝福.</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>人下人，要把自己当人；人上人，要把别人当人。</strong></p>\n</blockquote>\n<p>太精明了，所以不够聪明。</p>\n<p>被精明人占小便宜的，只要心里有数就行，被蒙一点钱无所谓，最重要的是不能蒙在鼓里，生意场上，退一小步，进几大步。</p>\n<h3 id=\"2-4-读书\"><a href=\"#2-4-读书\" class=\"headerlink\" title=\"2.4. 读书\"></a>2.4. 读书</h3><p>多读书，是腹有诗书气自华，看人待物能多几分透彻，多识人，是以人为镜，能够多自省自知。</p>\n<p><strong>一个人是不是井底之蛙，自己说了不算。假如有一天你能饱览井底甚至是井上的风光，真不是井底之蛙了，心存一点谦恭，总不是坏事。</strong><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/readbook.jpg\" alt=\"\"></p>\n<p>做学问要钻牛角尖，越死越好，但做人，要活络一些，不涉及原则性问题，总不是坏事。做学问做到家徒四壁，连带家人一起穷困潦倒，那不叫做学问，叫作孽。 – 国士陈平安与赵甲第对话</p>\n<hr>\n<h2 id=\"3-生活社会\"><a href=\"#3-生活社会\" class=\"headerlink\" title=\"3. 生活社会\"></a>3. 生活社会</h2><blockquote>\n<p>生活才是最荒诞的艺术。</p>\n</blockquote>\n<blockquote>\n<p>男孩子帅不帅，要看有没有理想，女孩子漂亮不漂亮，要看善不善良。</p>\n</blockquote>\n<p><strong>不惮以最大恶意揣度他人，这样才能最大限度的不去失望</strong></p>\n<p>很多人，光看是瞧不出厉害不厉害的。听其言不够，还得观其行，再揣度其心。</p>\n<p>就算自己不喜欢撒谎，在必须撒谎的时候，就尽量放烟幕弹打马虎眼，坚决不能做有一说一的实诚人。</p>\n<p>再好的木料，只要小时候长歪了，就废了。</p>\n<p>这才是真正到人生，每个人都按照惯性进步或者滑落，更多是在煮沸温水中逐渐死去的青蛙，愚昧无知到连跳出去的欲望都欠奉</p>\n<p>很多道理，越是亲近的人苦口婆心，效果不大，反而是敌人和不相干的人，偶尔发语，才初期的振聋发聩。</p>\n<p>世界就是这样，年轻的时候难免流亡他乡。世界就是这样，年轻的时候难免颠沛流离。（此心安处即吾乡 – &lt;&lt; <a href=\"https://baike.baidu.com/item/%E6%AD%A4%E5%BF%83%E5%AE%89%E5%A4%84%E6%98%AF%E5%90%BE%E4%B9%A1/19189793?fr=aladdin\" target=\"_blank\" rel=\"noopener\">定风波</a> &gt;&gt;，苏轼）</p>\n<p>贩夫走卒，市井小民，高官显贵，皇亲国戚，说到底都是一只只披着身份衣裳的阿猫阿狗，有些笨点，有些聪明点，每天喂养一下，总有物尽其用的一天。</p>\n<blockquote>\n<p>人走茶凉是常态，可那个愿意陪冷宫的人喝冷茶的人，才会被当做朋友。</p>\n</blockquote>\n<blockquote>\n<p>有些交情，太早粘上钱，不是好事。也许一开始看着是赚，其实是亏，会从头亏到尾。</p>\n</blockquote>\n<p>人情这两个字，就跟倒过来的“情人”，一词一个德行，得温火慢炖“日”久见人心。</p>\n<p>人情的火炉，是需要时不时“撩拨”一下的，不能一路冷却下去。</p>\n<blockquote>\n<p>有些女人，是那种见到男人就拼命绽放的花朵，而有些女人，则矜持骄傲地只为一个男人娇艳摇曳。</p>\n</blockquote>\n<p>太完美的女人都容易红颜薄命，还是有点残缺美比较让人安稳 :)</p>\n<blockquote>\n<p>能杀得人需先能救得人，能救得人却还需能活得己。<br>世上很多弱者，极少数是因为善良质朴，而主动选择退让。但更多的，可能是一种狡黠的处世智慧，处于劣势，却不是真的占据礼仪理义。相反，一旦有利可图，狰狞程度，可憎程度，丝毫不逊色任何人。<strong>强者未必都在为恶，弱者未必都是心善</strong>。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>读<a href=\"https://baike.baidu.com/item/%E7%83%BD%E7%81%AB%E6%88%8F%E8%AF%B8%E4%BE%AF/9127348?fr=aladdin\" target=\"_blank\" rel=\"noopener\">烽火</a>的这本书《<a href=\"https://baike.baidu.com/item/%E8%80%81%E5%AD%90%E6%98%AF%E7%99%9E%E8%9B%A4%E8%9F%86/4871434?fr=aladdin\" target=\"_blank\" rel=\"noopener\">老子是癞蛤蟆</a>》，<br><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=e306f7ec0c33874488c8272e3066b29c/b03533fa828ba61ebdf161934134970a304e596a.jpg\" alt=\"\"></p>\n<p>总是能给予自己很多的触动，他总能鼓动风雨–<a href=\"https://baike.baidu.com/item/%E6%B3%A2%E6%BE%9C%E5%93%A5\" target=\"_blank\" rel=\"noopener\">波澜哥</a>：）。</p>","more":"<p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=7a3962be72310a55d029d6a6d62c28cc/5243fbf2b21193133d7107fd6e380cd791238d49.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"1-执念\"><a href=\"#1-执念\" class=\"headerlink\" title=\"1. 执念\"></a>1. 执念</h2><p>人必有所执，方能有所成。</p>\n<p>不忘初心，方得始终。（<a href=\"https://baike.baidu.com/item/%E5%8D%8E%E4%B8%A5%E7%BB%8F/1930991?fr=aladdin\" target=\"_blank\" rel=\"noopener\">概括自《华严经》</a>，<a href=\"https://baike.baidu.com/item/%E9%9D%A1%E4%B8%8D%E6%9C%89%E5%88%9D%EF%BC%8C%E9%B2%9C%E5%85%8B%E6%9C%89%E7%BB%88/4433245?fr=aladdin\" target=\"_blank\" rel=\"noopener\">靡不有初，鲜克有终</a>）</p>\n<p>哪怕是一只癞蛤蟆，能够几十年如一日地充实自己，迟早都有跳出池塘吃上天鹅肉的一天，这个天鹅肉可以是桃李满天下，可以是抱得美人归，也可以是功成名就光耀门楣。</p>\n<p>像一头不知疲倦的狼，肚里咽着肉，嘴里叼着肉，还要弓着腰，咬着牙去搏杀。</p>\n<p>我看她的世界 就像是站在阴间看阳间。（陈靖）</p>\n<p>我就是穷人的孩子，能做的除了拼命还是拼命最后他妈的还是拼命，一定要让我的孩子，成为富人的孩子。</p>\n<p>就是被人踩得一滩烂泥，也要捏出狗尾巴花来。<br><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike220%2C5%2C5%2C220%2C73/sign=bb3d0303d0a20cf4529df68d17602053/ae51f3deb48f8c54765141ab3a292df5e1fe7fb0.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"2-UP-Myself\"><a href=\"#2-UP-Myself\" class=\"headerlink\" title=\"2. UP Myself\"></a>2. UP Myself</h2><h3 id=\"2-1-个人\"><a href=\"#2-1-个人\" class=\"headerlink\" title=\"2.1. 个人\"></a>2.1. 个人</h3><p>一个上升的态度比什么都重要。 </p>\n<p><strong>坚持去坚持</strong>。</p>\n<p>尽人事，听天命。</p>\n<p>生活中，所有人的角色定位都在改变，一些人在后退，一些则在前行，厉害的，则是奔跑，最牛的，当然是在冲刺的那一类。</p>\n<p>顺境能够看一个人的先天品性，逆境能够看一个人的后天品性。<br>品性，品行，一字之差，却悬殊千里，哪个更重，仁者见仁智者见智。</p>\n<p>一个男人平性如何，顺境时看他如何对待以前的朋友，这些人往往无益于他如今事业；逆境时看他如何对待自己的亲人，敢不敢承担责任，能不能放弃一些东西。</p>\n<p>熬一熬，说不定这道坎就熬过去了。</p>\n<p>总之别把简单问题复杂化，聪明孩子就要错减法，大智慧的孩子甚至会做除法。</p>\n<p>每逢大事有静气，就算做不到，也要假装做得到。等到习惯成自然，城府也就出来了。</p>\n<p>为学第一功夫，是<strong>降得浮躁之气定</strong>，做人第一紧要，是有<strong>慈悲心</strong>。</p>\n<p>下棋如做人，行错一步，不能摆在脸上，得放在心上。</p>\n<p>做错事，成小丑或者傻瓜了，从不怨恨谁，也不会悔自己的决定。</p>\n<h3 id=\"2-2-心态\"><a href=\"#2-2-心态\" class=\"headerlink\" title=\"2.2. 心态\"></a>2.2. 心态</h3><p>人生为棋我为卒，行动虽慢，命运多牟，可谁曾见我后退半步？</p>\n<blockquote>\n<p>是岐山凤雏，南阳卧龙，渭水飞熊？还是那五眼鸡，两头蛇，三脚猫？一退再退，风波恼我，我恼风波。逆水行舟，风波远我，我远风波。 – <a href=\"https://baike.baidu.com/item/%E6%B0%B4%E4%BB%99%E5%AD%90%C2%B7%E8%AE%A5%E6%97%B6/4075463?fr=aladdin\" target=\"_blank\" rel=\"noopener\">《水仙子·讥时》，张鸣善</a></p>\n</blockquote>\n<blockquote>\n<p>我不急不躁，心如磐石，若青松，八风不动，清风拂山岗，明月照大江……<br>虽千万人，虽黑云压城，虽遍地魑魅魍魉，我往矣…… </p>\n</blockquote>\n<p>走旁门，信左道，九次成功一次失败就败得一塌糊涂，再无东山再起。走正道，九次失败一次成功就能终生受益。</p>\n<p>岁月是一把牛B的屠龙刀，能让某些男人飞黄腾达。但岁月也是一把贱B的杀猪刀，能让某些女人明日黄花。</p>\n<p>人的一生只有一个终点，却有很多个起点。</p>\n<p>对的起自己，对自己负责，才能对得起别人，自己在乎的人。<br>一个爷们，想要爱人，必须先学会好好爱自己。</p>\n<h3 id=\"2-3-待人\"><a href=\"#2-3-待人\" class=\"headerlink\" title=\"2.3. 待人\"></a>2.3. 待人</h3><p><strong>学着感恩，学着理解，学着友善</strong>。<br>有些花花草草，自小生长在营养优渥的温室环境，不知道风雨，所以不懂得<strong>感恩</strong>。</p>\n<blockquote>\n<p><strong>争取不要错过谁，错过的，尽量去祝福.</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>人下人，要把自己当人；人上人，要把别人当人。</strong></p>\n</blockquote>\n<p>太精明了，所以不够聪明。</p>\n<p>被精明人占小便宜的，只要心里有数就行，被蒙一点钱无所谓，最重要的是不能蒙在鼓里，生意场上，退一小步，进几大步。</p>\n<h3 id=\"2-4-读书\"><a href=\"#2-4-读书\" class=\"headerlink\" title=\"2.4. 读书\"></a>2.4. 读书</h3><p>多读书，是腹有诗书气自华，看人待物能多几分透彻，多识人，是以人为镜，能够多自省自知。</p>\n<p><strong>一个人是不是井底之蛙，自己说了不算。假如有一天你能饱览井底甚至是井上的风光，真不是井底之蛙了，心存一点谦恭，总不是坏事。</strong><br><img src=\"https://raw.githubusercontent.com/JShell07/jshell07.github.io/master/images/readbook.jpg\" alt=\"\"></p>\n<p>做学问要钻牛角尖，越死越好，但做人，要活络一些，不涉及原则性问题，总不是坏事。做学问做到家徒四壁，连带家人一起穷困潦倒，那不叫做学问，叫作孽。 – 国士陈平安与赵甲第对话</p>\n<hr>\n<h2 id=\"3-生活社会\"><a href=\"#3-生活社会\" class=\"headerlink\" title=\"3. 生活社会\"></a>3. 生活社会</h2><blockquote>\n<p>生活才是最荒诞的艺术。</p>\n</blockquote>\n<blockquote>\n<p>男孩子帅不帅，要看有没有理想，女孩子漂亮不漂亮，要看善不善良。</p>\n</blockquote>\n<p><strong>不惮以最大恶意揣度他人，这样才能最大限度的不去失望</strong></p>\n<p>很多人，光看是瞧不出厉害不厉害的。听其言不够，还得观其行，再揣度其心。</p>\n<p>就算自己不喜欢撒谎，在必须撒谎的时候，就尽量放烟幕弹打马虎眼，坚决不能做有一说一的实诚人。</p>\n<p>再好的木料，只要小时候长歪了，就废了。</p>\n<p>这才是真正到人生，每个人都按照惯性进步或者滑落，更多是在煮沸温水中逐渐死去的青蛙，愚昧无知到连跳出去的欲望都欠奉</p>\n<p>很多道理，越是亲近的人苦口婆心，效果不大，反而是敌人和不相干的人，偶尔发语，才初期的振聋发聩。</p>\n<p>世界就是这样，年轻的时候难免流亡他乡。世界就是这样，年轻的时候难免颠沛流离。（此心安处即吾乡 – &lt;&lt; <a href=\"https://baike.baidu.com/item/%E6%AD%A4%E5%BF%83%E5%AE%89%E5%A4%84%E6%98%AF%E5%90%BE%E4%B9%A1/19189793?fr=aladdin\" target=\"_blank\" rel=\"noopener\">定风波</a> &gt;&gt;，苏轼）</p>\n<p>贩夫走卒，市井小民，高官显贵，皇亲国戚，说到底都是一只只披着身份衣裳的阿猫阿狗，有些笨点，有些聪明点，每天喂养一下，总有物尽其用的一天。</p>\n<blockquote>\n<p>人走茶凉是常态，可那个愿意陪冷宫的人喝冷茶的人，才会被当做朋友。</p>\n</blockquote>\n<blockquote>\n<p>有些交情，太早粘上钱，不是好事。也许一开始看着是赚，其实是亏，会从头亏到尾。</p>\n</blockquote>\n<p>人情这两个字，就跟倒过来的“情人”，一词一个德行，得温火慢炖“日”久见人心。</p>\n<p>人情的火炉，是需要时不时“撩拨”一下的，不能一路冷却下去。</p>\n<blockquote>\n<p>有些女人，是那种见到男人就拼命绽放的花朵，而有些女人，则矜持骄傲地只为一个男人娇艳摇曳。</p>\n</blockquote>\n<p>太完美的女人都容易红颜薄命，还是有点残缺美比较让人安稳 :)</p>\n<blockquote>\n<p>能杀得人需先能救得人，能救得人却还需能活得己。<br>世上很多弱者，极少数是因为善良质朴，而主动选择退让。但更多的，可能是一种狡黠的处世智慧，处于劣势，却不是真的占据礼仪理义。相反，一旦有利可图，狰狞程度，可憎程度，丝毫不逊色任何人。<strong>强者未必都在为恶，弱者未必都是心善</strong>。</p>\n</blockquote>"},{"title":"褚时健传","date":"2019-04-15T14:25:02.000Z","_content":"\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=633443a63ea85edfee81f671283d6246/f703738da97739126c1eaf97f2198618367ae208.jpg)\n\n[褚时健](https://baike.baidu.com/item/%E8%A4%9A%E6%97%B6%E5%81%A5/6173821?fr=aladdin)（1928年1月23日-2019年3月5日），云南红塔集团有限公司和玉溪红塔烟草（集团）有限责任公司原董事长，褚橙创始人，先后经历两次成功的创业人生，被誉为中国烟草大王、中国橙王。\n\n<!--more-->\n\n## 序言\n褚时健自我评价:  \n>我觉得我并没有做什么了不起的事情，我所做的，都是尊重规律，恪守本分。__做事讲求踏实和认真。__ 我从来不认为自己是个天才。我一直是个实实在在做事的人，而且有认真的态度，做哪一行就尊重哪一行的规律。__学习多，了解多，实践多，心里就有足够的底气。__\n\n__我自己做的最问心无愧的就是：没有庸庸碌碌地生活。__\n\n万科王石评价：  \n面对并不公平的命运，愤然一跃固然悲壮，有原则地隐忍更加可贵。\n\n作者评价：\n褚时健理解自己的生活很轻，他拥有一颗赤子之心，也有足够的钝感力，同时他对生活有着细节的热情，这些都是他淡定、执着的原动力。\n\n## 1.少年故事(1927-1948；矣[yi]则，昆明)\n1942年的滇越铁路，日本人进行了轰炸，将褚开运炸成重伤，随后父亲的早逝，导致褚时健少年酿酒帮贴家用，做什么事都琢磨一下。\n\n做事，把事做好，就会快乐，就会有成就感。\n\n死真的会改变很多东西，以前我没有体会到，死以为着永远离开，意味着你本来正在做，应该做的事情再也办法去做了。\n\n活着每一天，把每件事情做好，就不白白过这一生。__不要想太多死亡的事情，他来或不来，谁也控制不了。__\n\n做什么事都要学会观察，会总结，找到规律。在1955年部队评军衔的时候，怎么不给骡子评个军衔呢？打仗的时候骡子最辛苦了，井冈山的时候驮枪又驮炮，但它什么也评不到，为什么？它不进步嘛。\n\n“治大国如烹小鲜，小时料理地好，大事才有本事料理。”\n\n## 2.生活的断层(1959-1979;元江，新平)\n>一个人，别人把你打倒了不要紧，总有事情是自己控制不了的，但自己不要把自己打倒，不然就真的是测底倒了翻不了身。\n\n西南三大宝：云烟、贵酒、川妹子。\n\n## 3. 华彩人生(1979-1996；玉溪卷烟厂)\n做过了你就知道原来可以，你不做就永远都不进步。（勇于尝试，努力试错！）\n\n你怎么知道我不是机会？你敲了三次门，机会只敲一次。\n\n烟叶的生长，你尊重他的生长规律，按规律办事，认真对待，一定会有好回报。\n\n做事抓重点，不然你做的多费力也白做。\n\n## 4.种橙十年\n哪一行都是一样，你要做管理工作，首先生产业务就要熟悉，不然话说出来都不对路。","source":"_posts/褚时健传.md","raw":"---\ntitle: 褚时健传\ndate: 2019-04-15 22:25:02\ntags: bookmarks\ncategories: bookmarks\n---\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=633443a63ea85edfee81f671283d6246/f703738da97739126c1eaf97f2198618367ae208.jpg)\n\n[褚时健](https://baike.baidu.com/item/%E8%A4%9A%E6%97%B6%E5%81%A5/6173821?fr=aladdin)（1928年1月23日-2019年3月5日），云南红塔集团有限公司和玉溪红塔烟草（集团）有限责任公司原董事长，褚橙创始人，先后经历两次成功的创业人生，被誉为中国烟草大王、中国橙王。\n\n<!--more-->\n\n## 序言\n褚时健自我评价:  \n>我觉得我并没有做什么了不起的事情，我所做的，都是尊重规律，恪守本分。__做事讲求踏实和认真。__ 我从来不认为自己是个天才。我一直是个实实在在做事的人，而且有认真的态度，做哪一行就尊重哪一行的规律。__学习多，了解多，实践多，心里就有足够的底气。__\n\n__我自己做的最问心无愧的就是：没有庸庸碌碌地生活。__\n\n万科王石评价：  \n面对并不公平的命运，愤然一跃固然悲壮，有原则地隐忍更加可贵。\n\n作者评价：\n褚时健理解自己的生活很轻，他拥有一颗赤子之心，也有足够的钝感力，同时他对生活有着细节的热情，这些都是他淡定、执着的原动力。\n\n## 1.少年故事(1927-1948；矣[yi]则，昆明)\n1942年的滇越铁路，日本人进行了轰炸，将褚开运炸成重伤，随后父亲的早逝，导致褚时健少年酿酒帮贴家用，做什么事都琢磨一下。\n\n做事，把事做好，就会快乐，就会有成就感。\n\n死真的会改变很多东西，以前我没有体会到，死以为着永远离开，意味着你本来正在做，应该做的事情再也办法去做了。\n\n活着每一天，把每件事情做好，就不白白过这一生。__不要想太多死亡的事情，他来或不来，谁也控制不了。__\n\n做什么事都要学会观察，会总结，找到规律。在1955年部队评军衔的时候，怎么不给骡子评个军衔呢？打仗的时候骡子最辛苦了，井冈山的时候驮枪又驮炮，但它什么也评不到，为什么？它不进步嘛。\n\n“治大国如烹小鲜，小时料理地好，大事才有本事料理。”\n\n## 2.生活的断层(1959-1979;元江，新平)\n>一个人，别人把你打倒了不要紧，总有事情是自己控制不了的，但自己不要把自己打倒，不然就真的是测底倒了翻不了身。\n\n西南三大宝：云烟、贵酒、川妹子。\n\n## 3. 华彩人生(1979-1996；玉溪卷烟厂)\n做过了你就知道原来可以，你不做就永远都不进步。（勇于尝试，努力试错！）\n\n你怎么知道我不是机会？你敲了三次门，机会只敲一次。\n\n烟叶的生长，你尊重他的生长规律，按规律办事，认真对待，一定会有好回报。\n\n做事抓重点，不然你做的多费力也白做。\n\n## 4.种橙十年\n哪一行都是一样，你要做管理工作，首先生产业务就要熟悉，不然话说出来都不对路。","slug":"褚时健传","published":1,"updated":"2019-07-08T06:16:07.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0sf0060zkgr6kqvub10","content":"<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=633443a63ea85edfee81f671283d6246/f703738da97739126c1eaf97f2198618367ae208.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E8%A4%9A%E6%97%B6%E5%81%A5/6173821?fr=aladdin\" target=\"_blank\" rel=\"noopener\">褚时健</a>（1928年1月23日-2019年3月5日），云南红塔集团有限公司和玉溪红塔烟草（集团）有限责任公司原董事长，褚橙创始人，先后经历两次成功的创业人生，被誉为中国烟草大王、中国橙王。</p>\n<a id=\"more\"></a>\n<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>褚时健自我评价:  </p>\n<blockquote>\n<p>我觉得我并没有做什么了不起的事情，我所做的，都是尊重规律，恪守本分。<strong>做事讲求踏实和认真。</strong> 我从来不认为自己是个天才。我一直是个实实在在做事的人，而且有认真的态度，做哪一行就尊重哪一行的规律。<strong>学习多，了解多，实践多，心里就有足够的底气。</strong></p>\n</blockquote>\n<p><strong>我自己做的最问心无愧的就是：没有庸庸碌碌地生活。</strong></p>\n<p>万科王石评价：<br>面对并不公平的命运，愤然一跃固然悲壮，有原则地隐忍更加可贵。</p>\n<p>作者评价：<br>褚时健理解自己的生活很轻，他拥有一颗赤子之心，也有足够的钝感力，同时他对生活有着细节的热情，这些都是他淡定、执着的原动力。</p>\n<h2 id=\"1-少年故事-1927-1948；矣-yi-则，昆明\"><a href=\"#1-少年故事-1927-1948；矣-yi-则，昆明\" class=\"headerlink\" title=\"1.少年故事(1927-1948；矣[yi]则，昆明)\"></a>1.少年故事(1927-1948；矣[yi]则，昆明)</h2><p>1942年的滇越铁路，日本人进行了轰炸，将褚开运炸成重伤，随后父亲的早逝，导致褚时健少年酿酒帮贴家用，做什么事都琢磨一下。</p>\n<p>做事，把事做好，就会快乐，就会有成就感。</p>\n<p>死真的会改变很多东西，以前我没有体会到，死以为着永远离开，意味着你本来正在做，应该做的事情再也办法去做了。</p>\n<p>活着每一天，把每件事情做好，就不白白过这一生。<strong>不要想太多死亡的事情，他来或不来，谁也控制不了。</strong></p>\n<p>做什么事都要学会观察，会总结，找到规律。在1955年部队评军衔的时候，怎么不给骡子评个军衔呢？打仗的时候骡子最辛苦了，井冈山的时候驮枪又驮炮，但它什么也评不到，为什么？它不进步嘛。</p>\n<p>“治大国如烹小鲜，小时料理地好，大事才有本事料理。”</p>\n<h2 id=\"2-生活的断层-1959-1979-元江，新平\"><a href=\"#2-生活的断层-1959-1979-元江，新平\" class=\"headerlink\" title=\"2.生活的断层(1959-1979;元江，新平)\"></a>2.生活的断层(1959-1979;元江，新平)</h2><blockquote>\n<p>一个人，别人把你打倒了不要紧，总有事情是自己控制不了的，但自己不要把自己打倒，不然就真的是测底倒了翻不了身。</p>\n</blockquote>\n<p>西南三大宝：云烟、贵酒、川妹子。</p>\n<h2 id=\"3-华彩人生-1979-1996；玉溪卷烟厂\"><a href=\"#3-华彩人生-1979-1996；玉溪卷烟厂\" class=\"headerlink\" title=\"3. 华彩人生(1979-1996；玉溪卷烟厂)\"></a>3. 华彩人生(1979-1996；玉溪卷烟厂)</h2><p>做过了你就知道原来可以，你不做就永远都不进步。（勇于尝试，努力试错！）</p>\n<p>你怎么知道我不是机会？你敲了三次门，机会只敲一次。</p>\n<p>烟叶的生长，你尊重他的生长规律，按规律办事，认真对待，一定会有好回报。</p>\n<p>做事抓重点，不然你做的多费力也白做。</p>\n<h2 id=\"4-种橙十年\"><a href=\"#4-种橙十年\" class=\"headerlink\" title=\"4.种橙十年\"></a>4.种橙十年</h2><p>哪一行都是一样，你要做管理工作，首先生产业务就要熟悉，不然话说出来都不对路。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=633443a63ea85edfee81f671283d6246/f703738da97739126c1eaf97f2198618367ae208.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E8%A4%9A%E6%97%B6%E5%81%A5/6173821?fr=aladdin\" target=\"_blank\" rel=\"noopener\">褚时健</a>（1928年1月23日-2019年3月5日），云南红塔集团有限公司和玉溪红塔烟草（集团）有限责任公司原董事长，褚橙创始人，先后经历两次成功的创业人生，被誉为中国烟草大王、中国橙王。</p>","more":"<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>褚时健自我评价:  </p>\n<blockquote>\n<p>我觉得我并没有做什么了不起的事情，我所做的，都是尊重规律，恪守本分。<strong>做事讲求踏实和认真。</strong> 我从来不认为自己是个天才。我一直是个实实在在做事的人，而且有认真的态度，做哪一行就尊重哪一行的规律。<strong>学习多，了解多，实践多，心里就有足够的底气。</strong></p>\n</blockquote>\n<p><strong>我自己做的最问心无愧的就是：没有庸庸碌碌地生活。</strong></p>\n<p>万科王石评价：<br>面对并不公平的命运，愤然一跃固然悲壮，有原则地隐忍更加可贵。</p>\n<p>作者评价：<br>褚时健理解自己的生活很轻，他拥有一颗赤子之心，也有足够的钝感力，同时他对生活有着细节的热情，这些都是他淡定、执着的原动力。</p>\n<h2 id=\"1-少年故事-1927-1948；矣-yi-则，昆明\"><a href=\"#1-少年故事-1927-1948；矣-yi-则，昆明\" class=\"headerlink\" title=\"1.少年故事(1927-1948；矣[yi]则，昆明)\"></a>1.少年故事(1927-1948；矣[yi]则，昆明)</h2><p>1942年的滇越铁路，日本人进行了轰炸，将褚开运炸成重伤，随后父亲的早逝，导致褚时健少年酿酒帮贴家用，做什么事都琢磨一下。</p>\n<p>做事，把事做好，就会快乐，就会有成就感。</p>\n<p>死真的会改变很多东西，以前我没有体会到，死以为着永远离开，意味着你本来正在做，应该做的事情再也办法去做了。</p>\n<p>活着每一天，把每件事情做好，就不白白过这一生。<strong>不要想太多死亡的事情，他来或不来，谁也控制不了。</strong></p>\n<p>做什么事都要学会观察，会总结，找到规律。在1955年部队评军衔的时候，怎么不给骡子评个军衔呢？打仗的时候骡子最辛苦了，井冈山的时候驮枪又驮炮，但它什么也评不到，为什么？它不进步嘛。</p>\n<p>“治大国如烹小鲜，小时料理地好，大事才有本事料理。”</p>\n<h2 id=\"2-生活的断层-1959-1979-元江，新平\"><a href=\"#2-生活的断层-1959-1979-元江，新平\" class=\"headerlink\" title=\"2.生活的断层(1959-1979;元江，新平)\"></a>2.生活的断层(1959-1979;元江，新平)</h2><blockquote>\n<p>一个人，别人把你打倒了不要紧，总有事情是自己控制不了的，但自己不要把自己打倒，不然就真的是测底倒了翻不了身。</p>\n</blockquote>\n<p>西南三大宝：云烟、贵酒、川妹子。</p>\n<h2 id=\"3-华彩人生-1979-1996；玉溪卷烟厂\"><a href=\"#3-华彩人生-1979-1996；玉溪卷烟厂\" class=\"headerlink\" title=\"3. 华彩人生(1979-1996；玉溪卷烟厂)\"></a>3. 华彩人生(1979-1996；玉溪卷烟厂)</h2><p>做过了你就知道原来可以，你不做就永远都不进步。（勇于尝试，努力试错！）</p>\n<p>你怎么知道我不是机会？你敲了三次门，机会只敲一次。</p>\n<p>烟叶的生长，你尊重他的生长规律，按规律办事，认真对待，一定会有好回报。</p>\n<p>做事抓重点，不然你做的多费力也白做。</p>\n<h2 id=\"4-种橙十年\"><a href=\"#4-种橙十年\" class=\"headerlink\" title=\"4.种橙十年\"></a>4.种橙十年</h2><p>哪一行都是一样，你要做管理工作，首先生产业务就要熟悉，不然话说出来都不对路。</p>"},{"title":"财务自由之路","date":"2019-04-24T05:38:46.000Z","_content":"\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=f9668fd7aa86c9171c0e5a6ba8541baa/0ff41bd5ad6eddc43d76dfd434dbb6fd5266330f.jpg)\n\n[博多·舍费尔](https://baike.baidu.com/item/%E5%8D%9A%E5%A4%9A%C2%B7%E8%88%8D%E8%B4%B9%E5%B0%94)\n\n<!--more-->\n\n一旦金钱开始流动，它就会快速且大量地流入你的口袋，以至于你很惊讶以前你的钱都藏到哪儿去了。\n\n## 1. 了解自己\n乐观主义让你看到实物的积极面，而自信给你一种战胜实物黑暗面的信心。\n\n将自己的事业建立在自己最大的爱好之上。\n\n## 2. 怎样创造奇迹\n\n### 2.1. 五个层次\n- 意识到对现状的不满，为了改变，采取行动  \n- 以解决困难最为目标导向  \n- 学习新技能、技巧并起到帮助  \n- 与他人打交道时的世界观，许多人带着自身的有色眼镜，将美好的世界扭曲  \n- 改变自身认知 （将自己置于不同的角度、身份看待问题）  \n\n### 2.2. 学习 \n持续不断地学习和成长，例如书籍中学到的新词汇，都可能意味着一个新的思想。__思想是无价的。__\n\n>如果有机会结实有趣的人， 一定要好好利用，不要浪费时间在闲聊上，让此人推荐两三本他认为最好的书，并问问为什么觉得这些书好。\n\n将自己看作一个足够重要的人，开始记录关于自己的日记。\n\n讲座也可以有很好的效果。我们的感官接受的刺激越多，获得的学习效果越好。\n\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=cd36f2098944ebf8797c6c6db890bc4f/32fa828ba61ea8d35b49bf0e990a304e251f5855.jpg)\n\n至少为自己找到一个能模仿的榜样，在以下每个领域找到一个榜样：  \n- 健康  \n- 关系  \n- 财务  \n- 人生意义  \n- 情感  \n\n>绝对没有理由听从没有亲身经历过的人给出的建议。\n\n### 2.3. 勇气\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=9343a9363e4e251ff6faecaac6efa272/e824b899a9014c08bc7123a9047b02087bf4f470.jpg)\n\n__大多数人都高估了自己1年内能做到的事情，也低估了自己10年内能做到的事情。__（坚持是最好的策略）\n\n- 在这个星球上，没有“必胜”， 只有“机会”  \n- __立即采取行动，你永远不能为成功最好完美的准备__（现在就是开始的最好的时机，什么都不会迟，现在就行动） \n\n### 2.4. 运气\n__惊人的好运， 通常只是多年准备的结果。__\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=7d24e757d70735fa85fd46ebff3864d6/6a63f6246b600c3351789b84194c510fd9f9a17d.jpg)\n\n好运的组成成分：\n- 存储资本  \n- 识别机会  \n- 果断地作出决定并采取行动  \n\n### 2.5. 梦想\n__我们无法预测未来，但是我们能塑造自己的未来。__\n\n人在顺境的时候，很容易积极展望未来。\n>所有你给自己或他人描述的未来，都只是一个童话故事。因此，你最好给自己编织一个美好的童话。当童话故事实现时，你才会生活在美梦里，而不是生活在噩梦里。\n(给自己描绘一个美梦, 让自己也相信（潜意识的作用），积极展望，努力塑造未来。)\n\n![](https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=16d93d35bd51f819f1700b4cea8466d5/4610b912c8fcc3ceec36722d9f45d688d43f203d.jpg)\n\n\n\n\n## 3. 反思为什么不富有\n你有能力是你的目标成为绝对必须品。\n\n不实现这些目标你无法幸福，一成不变的生活对你是痛苦的，你一定要实现自己的目标，然后你便可以将自己要变得富裕的计划呈现在众人面前。（潜意识的重要性，自我洗脑。:) ）\n\n自我承担责任，不要让别人替你承担责任的情况出现。\n\n__许多人将100%看作自己的目标，但是只能做到80%。如果你将110%看作自己的目标，那么做到110%对你来说，就相对轻松一些。__\n- 当你为自己设立了极限，你就会设法达到你的极限。  \n- 一个付出110%努力，主动摒弃所有的借口必能成功。  \n- 将90%精力放在“为什么”， 只将10%的精力放在“怎么做”上。 （90% foucs on Why, 10% focus on How!）\n\n## 4. 第一个1000万\n### 4.1. 愚蠢的债务与明智的债务  \n负有消费债是一种非常危险的行为。\n__我们想要的东西并不等同于我们需要的东西.__ （最好的并不一定是好的，适合自己的才是对的。）\n\n### 4.2. 增加收入\n每个人获得东西都恰好是他值得获得的东西。（收入与你在市场中创造的价值有关, 如果你做的所有人都能做的事情，你将只会获得所有人都有的东西。)\n\n金钱和机遇并不会应需求而产生，而是应能力而产生。\n\n你的付出应该对于别人对你的期望，让你周围的人都感到惊讶吧。\n\n__完美意味着停滞不前，你需要的是最求卓越。__ \n\n### 4.3. 开源与节流\n生活的水平是随着收入的增加而提高的。(适当提升，度量的把控)\n\n没有人能仅仅通过挣很多钱就变得富有。\n\n>长期以来，有形资产一直都胜过货币资产投资。主要原因就是通货膨胀。\n>你的货币怎么贬值，有形资产就怎么升值\n\n__投资不是为了亏钱，而是为了赚钱。__ （内心观念的转换，潜意识告诉自己赚钱）\n\n投资公式：  \n__100 - <年龄> = <股票、基金最大份额百分比>__\n\n经济是有周期的，__在经济衰退期投资是最好的时期。__\n\n[康波周期理论简介](http://www.360doc.com/content/18/0722/08/40690128_772285077.shtml)\n\n### 4.4. 财务保障\n遭遇突如其来的经济变故，我们需要财务保障， 公司也是需要。（备用启动金，保证自己3~6个月暂时没有基本经济压力）\n\n计算基本情况：生活、房租、贷款 => (2000 + 1500 + 2500) * 6 = 3,6000 (至少有这么多的备用金并平时不动用他)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/财务自由之路.md","raw":"---\ntitle: 财务自由之路\ndate: 2019-04-24 13:38:46\ntags: bookmarks\ncategories: bookmarks\n---\n\n![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=f9668fd7aa86c9171c0e5a6ba8541baa/0ff41bd5ad6eddc43d76dfd434dbb6fd5266330f.jpg)\n\n[博多·舍费尔](https://baike.baidu.com/item/%E5%8D%9A%E5%A4%9A%C2%B7%E8%88%8D%E8%B4%B9%E5%B0%94)\n\n<!--more-->\n\n一旦金钱开始流动，它就会快速且大量地流入你的口袋，以至于你很惊讶以前你的钱都藏到哪儿去了。\n\n## 1. 了解自己\n乐观主义让你看到实物的积极面，而自信给你一种战胜实物黑暗面的信心。\n\n将自己的事业建立在自己最大的爱好之上。\n\n## 2. 怎样创造奇迹\n\n### 2.1. 五个层次\n- 意识到对现状的不满，为了改变，采取行动  \n- 以解决困难最为目标导向  \n- 学习新技能、技巧并起到帮助  \n- 与他人打交道时的世界观，许多人带着自身的有色眼镜，将美好的世界扭曲  \n- 改变自身认知 （将自己置于不同的角度、身份看待问题）  \n\n### 2.2. 学习 \n持续不断地学习和成长，例如书籍中学到的新词汇，都可能意味着一个新的思想。__思想是无价的。__\n\n>如果有机会结实有趣的人， 一定要好好利用，不要浪费时间在闲聊上，让此人推荐两三本他认为最好的书，并问问为什么觉得这些书好。\n\n将自己看作一个足够重要的人，开始记录关于自己的日记。\n\n讲座也可以有很好的效果。我们的感官接受的刺激越多，获得的学习效果越好。\n\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=cd36f2098944ebf8797c6c6db890bc4f/32fa828ba61ea8d35b49bf0e990a304e251f5855.jpg)\n\n至少为自己找到一个能模仿的榜样，在以下每个领域找到一个榜样：  \n- 健康  \n- 关系  \n- 财务  \n- 人生意义  \n- 情感  \n\n>绝对没有理由听从没有亲身经历过的人给出的建议。\n\n### 2.3. 勇气\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=9343a9363e4e251ff6faecaac6efa272/e824b899a9014c08bc7123a9047b02087bf4f470.jpg)\n\n__大多数人都高估了自己1年内能做到的事情，也低估了自己10年内能做到的事情。__（坚持是最好的策略）\n\n- 在这个星球上，没有“必胜”， 只有“机会”  \n- __立即采取行动，你永远不能为成功最好完美的准备__（现在就是开始的最好的时机，什么都不会迟，现在就行动） \n\n### 2.4. 运气\n__惊人的好运， 通常只是多年准备的结果。__\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=7d24e757d70735fa85fd46ebff3864d6/6a63f6246b600c3351789b84194c510fd9f9a17d.jpg)\n\n好运的组成成分：\n- 存储资本  \n- 识别机会  \n- 果断地作出决定并采取行动  \n\n### 2.5. 梦想\n__我们无法预测未来，但是我们能塑造自己的未来。__\n\n人在顺境的时候，很容易积极展望未来。\n>所有你给自己或他人描述的未来，都只是一个童话故事。因此，你最好给自己编织一个美好的童话。当童话故事实现时，你才会生活在美梦里，而不是生活在噩梦里。\n(给自己描绘一个美梦, 让自己也相信（潜意识的作用），积极展望，努力塑造未来。)\n\n![](https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=16d93d35bd51f819f1700b4cea8466d5/4610b912c8fcc3ceec36722d9f45d688d43f203d.jpg)\n\n\n\n\n## 3. 反思为什么不富有\n你有能力是你的目标成为绝对必须品。\n\n不实现这些目标你无法幸福，一成不变的生活对你是痛苦的，你一定要实现自己的目标，然后你便可以将自己要变得富裕的计划呈现在众人面前。（潜意识的重要性，自我洗脑。:) ）\n\n自我承担责任，不要让别人替你承担责任的情况出现。\n\n__许多人将100%看作自己的目标，但是只能做到80%。如果你将110%看作自己的目标，那么做到110%对你来说，就相对轻松一些。__\n- 当你为自己设立了极限，你就会设法达到你的极限。  \n- 一个付出110%努力，主动摒弃所有的借口必能成功。  \n- 将90%精力放在“为什么”， 只将10%的精力放在“怎么做”上。 （90% foucs on Why, 10% focus on How!）\n\n## 4. 第一个1000万\n### 4.1. 愚蠢的债务与明智的债务  \n负有消费债是一种非常危险的行为。\n__我们想要的东西并不等同于我们需要的东西.__ （最好的并不一定是好的，适合自己的才是对的。）\n\n### 4.2. 增加收入\n每个人获得东西都恰好是他值得获得的东西。（收入与你在市场中创造的价值有关, 如果你做的所有人都能做的事情，你将只会获得所有人都有的东西。)\n\n金钱和机遇并不会应需求而产生，而是应能力而产生。\n\n你的付出应该对于别人对你的期望，让你周围的人都感到惊讶吧。\n\n__完美意味着停滞不前，你需要的是最求卓越。__ \n\n### 4.3. 开源与节流\n生活的水平是随着收入的增加而提高的。(适当提升，度量的把控)\n\n没有人能仅仅通过挣很多钱就变得富有。\n\n>长期以来，有形资产一直都胜过货币资产投资。主要原因就是通货膨胀。\n>你的货币怎么贬值，有形资产就怎么升值\n\n__投资不是为了亏钱，而是为了赚钱。__ （内心观念的转换，潜意识告诉自己赚钱）\n\n投资公式：  \n__100 - <年龄> = <股票、基金最大份额百分比>__\n\n经济是有周期的，__在经济衰退期投资是最好的时期。__\n\n[康波周期理论简介](http://www.360doc.com/content/18/0722/08/40690128_772285077.shtml)\n\n### 4.4. 财务保障\n遭遇突如其来的经济变故，我们需要财务保障， 公司也是需要。（备用启动金，保证自己3~6个月暂时没有基本经济压力）\n\n计算基本情况：生活、房租、贷款 => (2000 + 1500 + 2500) * 6 = 3,6000 (至少有这么多的备用金并平时不动用他)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"财务自由之路","published":1,"updated":"2019-07-08T06:16:07.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0sg0063zkgr28y16oc0","content":"<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=f9668fd7aa86c9171c0e5a6ba8541baa/0ff41bd5ad6eddc43d76dfd434dbb6fd5266330f.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%8D%9A%E5%A4%9A%C2%B7%E8%88%8D%E8%B4%B9%E5%B0%94\" target=\"_blank\" rel=\"noopener\">博多·舍费尔</a></p>\n<a id=\"more\"></a>\n<p>一旦金钱开始流动，它就会快速且大量地流入你的口袋，以至于你很惊讶以前你的钱都藏到哪儿去了。</p>\n<h2 id=\"1-了解自己\"><a href=\"#1-了解自己\" class=\"headerlink\" title=\"1. 了解自己\"></a>1. 了解自己</h2><p>乐观主义让你看到实物的积极面，而自信给你一种战胜实物黑暗面的信心。</p>\n<p>将自己的事业建立在自己最大的爱好之上。</p>\n<h2 id=\"2-怎样创造奇迹\"><a href=\"#2-怎样创造奇迹\" class=\"headerlink\" title=\"2. 怎样创造奇迹\"></a>2. 怎样创造奇迹</h2><h3 id=\"2-1-五个层次\"><a href=\"#2-1-五个层次\" class=\"headerlink\" title=\"2.1. 五个层次\"></a>2.1. 五个层次</h3><ul>\n<li>意识到对现状的不满，为了改变，采取行动  </li>\n<li>以解决困难最为目标导向  </li>\n<li>学习新技能、技巧并起到帮助  </li>\n<li>与他人打交道时的世界观，许多人带着自身的有色眼镜，将美好的世界扭曲  </li>\n<li>改变自身认知 （将自己置于不同的角度、身份看待问题）  </li>\n</ul>\n<h3 id=\"2-2-学习\"><a href=\"#2-2-学习\" class=\"headerlink\" title=\"2.2. 学习\"></a>2.2. 学习</h3><p>持续不断地学习和成长，例如书籍中学到的新词汇，都可能意味着一个新的思想。<strong>思想是无价的。</strong></p>\n<blockquote>\n<p>如果有机会结实有趣的人， 一定要好好利用，不要浪费时间在闲聊上，让此人推荐两三本他认为最好的书，并问问为什么觉得这些书好。</p>\n</blockquote>\n<p>将自己看作一个足够重要的人，开始记录关于自己的日记。</p>\n<p>讲座也可以有很好的效果。我们的感官接受的刺激越多，获得的学习效果越好。</p>\n<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=cd36f2098944ebf8797c6c6db890bc4f/32fa828ba61ea8d35b49bf0e990a304e251f5855.jpg\" alt=\"\"></p>\n<p>至少为自己找到一个能模仿的榜样，在以下每个领域找到一个榜样：  </p>\n<ul>\n<li>健康  </li>\n<li>关系  </li>\n<li>财务  </li>\n<li>人生意义  </li>\n<li>情感  </li>\n</ul>\n<blockquote>\n<p>绝对没有理由听从没有亲身经历过的人给出的建议。</p>\n</blockquote>\n<h3 id=\"2-3-勇气\"><a href=\"#2-3-勇气\" class=\"headerlink\" title=\"2.3. 勇气\"></a>2.3. 勇气</h3><p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=9343a9363e4e251ff6faecaac6efa272/e824b899a9014c08bc7123a9047b02087bf4f470.jpg\" alt=\"\"></p>\n<p><strong>大多数人都高估了自己1年内能做到的事情，也低估了自己10年内能做到的事情。</strong>（坚持是最好的策略）</p>\n<ul>\n<li>在这个星球上，没有“必胜”， 只有“机会”  </li>\n<li><strong>立即采取行动，你永远不能为成功最好完美的准备</strong>（现在就是开始的最好的时机，什么都不会迟，现在就行动） </li>\n</ul>\n<h3 id=\"2-4-运气\"><a href=\"#2-4-运气\" class=\"headerlink\" title=\"2.4. 运气\"></a>2.4. 运气</h3><p><strong>惊人的好运， 通常只是多年准备的结果。</strong><br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=7d24e757d70735fa85fd46ebff3864d6/6a63f6246b600c3351789b84194c510fd9f9a17d.jpg\" alt=\"\"></p>\n<p>好运的组成成分：</p>\n<ul>\n<li>存储资本  </li>\n<li>识别机会  </li>\n<li>果断地作出决定并采取行动  </li>\n</ul>\n<h3 id=\"2-5-梦想\"><a href=\"#2-5-梦想\" class=\"headerlink\" title=\"2.5. 梦想\"></a>2.5. 梦想</h3><p><strong>我们无法预测未来，但是我们能塑造自己的未来。</strong></p>\n<p>人在顺境的时候，很容易积极展望未来。</p>\n<blockquote>\n<p>所有你给自己或他人描述的未来，都只是一个童话故事。因此，你最好给自己编织一个美好的童话。当童话故事实现时，你才会生活在美梦里，而不是生活在噩梦里。<br>(给自己描绘一个美梦, 让自己也相信（潜意识的作用），积极展望，努力塑造未来。)</p>\n</blockquote>\n<p><img src=\"https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=16d93d35bd51f819f1700b4cea8466d5/4610b912c8fcc3ceec36722d9f45d688d43f203d.jpg\" alt=\"\"></p>\n<h2 id=\"3-反思为什么不富有\"><a href=\"#3-反思为什么不富有\" class=\"headerlink\" title=\"3. 反思为什么不富有\"></a>3. 反思为什么不富有</h2><p>你有能力是你的目标成为绝对必须品。</p>\n<p>不实现这些目标你无法幸福，一成不变的生活对你是痛苦的，你一定要实现自己的目标，然后你便可以将自己要变得富裕的计划呈现在众人面前。（潜意识的重要性，自我洗脑。:) ）</p>\n<p>自我承担责任，不要让别人替你承担责任的情况出现。</p>\n<p><strong>许多人将100%看作自己的目标，但是只能做到80%。如果你将110%看作自己的目标，那么做到110%对你来说，就相对轻松一些。</strong></p>\n<ul>\n<li>当你为自己设立了极限，你就会设法达到你的极限。  </li>\n<li>一个付出110%努力，主动摒弃所有的借口必能成功。  </li>\n<li>将90%精力放在“为什么”， 只将10%的精力放在“怎么做”上。 （90% foucs on Why, 10% focus on How!）</li>\n</ul>\n<h2 id=\"4-第一个1000万\"><a href=\"#4-第一个1000万\" class=\"headerlink\" title=\"4. 第一个1000万\"></a>4. 第一个1000万</h2><h3 id=\"4-1-愚蠢的债务与明智的债务\"><a href=\"#4-1-愚蠢的债务与明智的债务\" class=\"headerlink\" title=\"4.1. 愚蠢的债务与明智的债务\"></a>4.1. 愚蠢的债务与明智的债务</h3><p>负有消费债是一种非常危险的行为。<br><strong>我们想要的东西并不等同于我们需要的东西.</strong> （最好的并不一定是好的，适合自己的才是对的。）</p>\n<h3 id=\"4-2-增加收入\"><a href=\"#4-2-增加收入\" class=\"headerlink\" title=\"4.2. 增加收入\"></a>4.2. 增加收入</h3><p>每个人获得东西都恰好是他值得获得的东西。（收入与你在市场中创造的价值有关, 如果你做的所有人都能做的事情，你将只会获得所有人都有的东西。)</p>\n<p>金钱和机遇并不会应需求而产生，而是应能力而产生。</p>\n<p>你的付出应该对于别人对你的期望，让你周围的人都感到惊讶吧。</p>\n<p><strong>完美意味着停滞不前，你需要的是最求卓越。</strong> </p>\n<h3 id=\"4-3-开源与节流\"><a href=\"#4-3-开源与节流\" class=\"headerlink\" title=\"4.3. 开源与节流\"></a>4.3. 开源与节流</h3><p>生活的水平是随着收入的增加而提高的。(适当提升，度量的把控)</p>\n<p>没有人能仅仅通过挣很多钱就变得富有。</p>\n<blockquote>\n<p>长期以来，有形资产一直都胜过货币资产投资。主要原因就是通货膨胀。<br>你的货币怎么贬值，有形资产就怎么升值</p>\n</blockquote>\n<p><strong>投资不是为了亏钱，而是为了赚钱。</strong> （内心观念的转换，潜意识告诉自己赚钱）</p>\n<p>投资公式：<br><strong>100 - &lt;年龄&gt; = &lt;股票、基金最大份额百分比&gt;</strong></p>\n<p>经济是有周期的，<strong>在经济衰退期投资是最好的时期。</strong></p>\n<p><a href=\"http://www.360doc.com/content/18/0722/08/40690128_772285077.shtml\" target=\"_blank\" rel=\"noopener\">康波周期理论简介</a></p>\n<h3 id=\"4-4-财务保障\"><a href=\"#4-4-财务保障\" class=\"headerlink\" title=\"4.4. 财务保障\"></a>4.4. 财务保障</h3><p>遭遇突如其来的经济变故，我们需要财务保障， 公司也是需要。（备用启动金，保证自己3~6个月暂时没有基本经济压力）</p>\n<p>计算基本情况：生活、房租、贷款 =&gt; (2000 + 1500 + 2500) * 6 = 3,6000 (至少有这么多的备用金并平时不动用他)</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=f9668fd7aa86c9171c0e5a6ba8541baa/0ff41bd5ad6eddc43d76dfd434dbb6fd5266330f.jpg\" alt=\"\"></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%8D%9A%E5%A4%9A%C2%B7%E8%88%8D%E8%B4%B9%E5%B0%94\" target=\"_blank\" rel=\"noopener\">博多·舍费尔</a></p>","more":"<p>一旦金钱开始流动，它就会快速且大量地流入你的口袋，以至于你很惊讶以前你的钱都藏到哪儿去了。</p>\n<h2 id=\"1-了解自己\"><a href=\"#1-了解自己\" class=\"headerlink\" title=\"1. 了解自己\"></a>1. 了解自己</h2><p>乐观主义让你看到实物的积极面，而自信给你一种战胜实物黑暗面的信心。</p>\n<p>将自己的事业建立在自己最大的爱好之上。</p>\n<h2 id=\"2-怎样创造奇迹\"><a href=\"#2-怎样创造奇迹\" class=\"headerlink\" title=\"2. 怎样创造奇迹\"></a>2. 怎样创造奇迹</h2><h3 id=\"2-1-五个层次\"><a href=\"#2-1-五个层次\" class=\"headerlink\" title=\"2.1. 五个层次\"></a>2.1. 五个层次</h3><ul>\n<li>意识到对现状的不满，为了改变，采取行动  </li>\n<li>以解决困难最为目标导向  </li>\n<li>学习新技能、技巧并起到帮助  </li>\n<li>与他人打交道时的世界观，许多人带着自身的有色眼镜，将美好的世界扭曲  </li>\n<li>改变自身认知 （将自己置于不同的角度、身份看待问题）  </li>\n</ul>\n<h3 id=\"2-2-学习\"><a href=\"#2-2-学习\" class=\"headerlink\" title=\"2.2. 学习\"></a>2.2. 学习</h3><p>持续不断地学习和成长，例如书籍中学到的新词汇，都可能意味着一个新的思想。<strong>思想是无价的。</strong></p>\n<blockquote>\n<p>如果有机会结实有趣的人， 一定要好好利用，不要浪费时间在闲聊上，让此人推荐两三本他认为最好的书，并问问为什么觉得这些书好。</p>\n</blockquote>\n<p>将自己看作一个足够重要的人，开始记录关于自己的日记。</p>\n<p>讲座也可以有很好的效果。我们的感官接受的刺激越多，获得的学习效果越好。</p>\n<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=cd36f2098944ebf8797c6c6db890bc4f/32fa828ba61ea8d35b49bf0e990a304e251f5855.jpg\" alt=\"\"></p>\n<p>至少为自己找到一个能模仿的榜样，在以下每个领域找到一个榜样：  </p>\n<ul>\n<li>健康  </li>\n<li>关系  </li>\n<li>财务  </li>\n<li>人生意义  </li>\n<li>情感  </li>\n</ul>\n<blockquote>\n<p>绝对没有理由听从没有亲身经历过的人给出的建议。</p>\n</blockquote>\n<h3 id=\"2-3-勇气\"><a href=\"#2-3-勇气\" class=\"headerlink\" title=\"2.3. 勇气\"></a>2.3. 勇气</h3><p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=9343a9363e4e251ff6faecaac6efa272/e824b899a9014c08bc7123a9047b02087bf4f470.jpg\" alt=\"\"></p>\n<p><strong>大多数人都高估了自己1年内能做到的事情，也低估了自己10年内能做到的事情。</strong>（坚持是最好的策略）</p>\n<ul>\n<li>在这个星球上，没有“必胜”， 只有“机会”  </li>\n<li><strong>立即采取行动，你永远不能为成功最好完美的准备</strong>（现在就是开始的最好的时机，什么都不会迟，现在就行动） </li>\n</ul>\n<h3 id=\"2-4-运气\"><a href=\"#2-4-运气\" class=\"headerlink\" title=\"2.4. 运气\"></a>2.4. 运气</h3><p><strong>惊人的好运， 通常只是多年准备的结果。</strong><br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=7d24e757d70735fa85fd46ebff3864d6/6a63f6246b600c3351789b84194c510fd9f9a17d.jpg\" alt=\"\"></p>\n<p>好运的组成成分：</p>\n<ul>\n<li>存储资本  </li>\n<li>识别机会  </li>\n<li>果断地作出决定并采取行动  </li>\n</ul>\n<h3 id=\"2-5-梦想\"><a href=\"#2-5-梦想\" class=\"headerlink\" title=\"2.5. 梦想\"></a>2.5. 梦想</h3><p><strong>我们无法预测未来，但是我们能塑造自己的未来。</strong></p>\n<p>人在顺境的时候，很容易积极展望未来。</p>\n<blockquote>\n<p>所有你给自己或他人描述的未来，都只是一个童话故事。因此，你最好给自己编织一个美好的童话。当童话故事实现时，你才会生活在美梦里，而不是生活在噩梦里。<br>(给自己描绘一个美梦, 让自己也相信（潜意识的作用），积极展望，努力塑造未来。)</p>\n</blockquote>\n<p><img src=\"https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=16d93d35bd51f819f1700b4cea8466d5/4610b912c8fcc3ceec36722d9f45d688d43f203d.jpg\" alt=\"\"></p>\n<h2 id=\"3-反思为什么不富有\"><a href=\"#3-反思为什么不富有\" class=\"headerlink\" title=\"3. 反思为什么不富有\"></a>3. 反思为什么不富有</h2><p>你有能力是你的目标成为绝对必须品。</p>\n<p>不实现这些目标你无法幸福，一成不变的生活对你是痛苦的，你一定要实现自己的目标，然后你便可以将自己要变得富裕的计划呈现在众人面前。（潜意识的重要性，自我洗脑。:) ）</p>\n<p>自我承担责任，不要让别人替你承担责任的情况出现。</p>\n<p><strong>许多人将100%看作自己的目标，但是只能做到80%。如果你将110%看作自己的目标，那么做到110%对你来说，就相对轻松一些。</strong></p>\n<ul>\n<li>当你为自己设立了极限，你就会设法达到你的极限。  </li>\n<li>一个付出110%努力，主动摒弃所有的借口必能成功。  </li>\n<li>将90%精力放在“为什么”， 只将10%的精力放在“怎么做”上。 （90% foucs on Why, 10% focus on How!）</li>\n</ul>\n<h2 id=\"4-第一个1000万\"><a href=\"#4-第一个1000万\" class=\"headerlink\" title=\"4. 第一个1000万\"></a>4. 第一个1000万</h2><h3 id=\"4-1-愚蠢的债务与明智的债务\"><a href=\"#4-1-愚蠢的债务与明智的债务\" class=\"headerlink\" title=\"4.1. 愚蠢的债务与明智的债务\"></a>4.1. 愚蠢的债务与明智的债务</h3><p>负有消费债是一种非常危险的行为。<br><strong>我们想要的东西并不等同于我们需要的东西.</strong> （最好的并不一定是好的，适合自己的才是对的。）</p>\n<h3 id=\"4-2-增加收入\"><a href=\"#4-2-增加收入\" class=\"headerlink\" title=\"4.2. 增加收入\"></a>4.2. 增加收入</h3><p>每个人获得东西都恰好是他值得获得的东西。（收入与你在市场中创造的价值有关, 如果你做的所有人都能做的事情，你将只会获得所有人都有的东西。)</p>\n<p>金钱和机遇并不会应需求而产生，而是应能力而产生。</p>\n<p>你的付出应该对于别人对你的期望，让你周围的人都感到惊讶吧。</p>\n<p><strong>完美意味着停滞不前，你需要的是最求卓越。</strong> </p>\n<h3 id=\"4-3-开源与节流\"><a href=\"#4-3-开源与节流\" class=\"headerlink\" title=\"4.3. 开源与节流\"></a>4.3. 开源与节流</h3><p>生活的水平是随着收入的增加而提高的。(适当提升，度量的把控)</p>\n<p>没有人能仅仅通过挣很多钱就变得富有。</p>\n<blockquote>\n<p>长期以来，有形资产一直都胜过货币资产投资。主要原因就是通货膨胀。<br>你的货币怎么贬值，有形资产就怎么升值</p>\n</blockquote>\n<p><strong>投资不是为了亏钱，而是为了赚钱。</strong> （内心观念的转换，潜意识告诉自己赚钱）</p>\n<p>投资公式：<br><strong>100 - &lt;年龄&gt; = &lt;股票、基金最大份额百分比&gt;</strong></p>\n<p>经济是有周期的，<strong>在经济衰退期投资是最好的时期。</strong></p>\n<p><a href=\"http://www.360doc.com/content/18/0722/08/40690128_772285077.shtml\" target=\"_blank\" rel=\"noopener\">康波周期理论简介</a></p>\n<h3 id=\"4-4-财务保障\"><a href=\"#4-4-财务保障\" class=\"headerlink\" title=\"4.4. 财务保障\"></a>4.4. 财务保障</h3><p>遭遇突如其来的经济变故，我们需要财务保障， 公司也是需要。（备用启动金，保证自己3~6个月暂时没有基本经济压力）</p>\n<p>计算基本情况：生活、房租、贷款 =&gt; (2000 + 1500 + 2500) * 6 = 3,6000 (至少有这么多的备用金并平时不动用他)</p>"},{"title":"钱:7步创造终生收入","date":"2019-05-12T05:55:46.000Z","_content":"\n[托尼·罗宾斯](https://baike.baidu.com/item/%E6%89%98%E5%B0%BC%C2%B7%E7%BD%97%E5%AE%BE%E6%96%AF/15163356?fr=aladdin)\n\n<!--more-->\n\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=b38cc163ad1ea8d39e2f7c56f6635b2b/c2fdfc039245d6885449c47cafc27d1ed31b249a.jpg)\n\n## 推荐\n理财是继健康、家庭、工作之后，我个人认为的第四件人生大事。\n\n为钱工作，你是钱的奴隶，为爱工作，钱是你的奴隶。\n\n你做投资理财，目的不是积累更多的钱，而是自由--为了财务自由、为了心灵自由、为了灵魂自由。\n\n__未来唯一确定的事是不确定。__ 最大的财富不在过去而在未来。\n\n对于我们每个人来说，最大的财富不是金钱，而是激情。感受到生命的激情，才是最大的财富。\n\n你活着不是为了钱，而是要用钱活的更好更幸福。(明确使用钱的目的，而不是刻意仅仅为了赚钱，变成葛朗台)\n\n## 1. 基本原理\n\n弗朗西斯.培根爵士：\n>钱做仆人很好，钱做主人很糟。\n\n\n__预测是终极力量。__ 预测前方的路是掌握人生获得财富和成功的最大秘诀。\n\n你必须掌握并利用复利让财富指数化增长的神奇力量。（山顶上的人不是从天上落到山顶上的。）\n\n>承诺遵守一个非常简单却十分坚定的存储原则，每一次拿到工资，先从中拿出一部分存储，这就是你首先付给自己最求未来梦想的投资寂静，利用复利让你的储蓄投资不断升值。\n(最困难的事是下决心行动，之后的事只要坚持就行了。__坚持就是最好的策略__)\n\n\n__终极目标__\n生命的意义不在于你得到了什么，而在于你给予了什么。\n\n另外，你会对什么充满感激？对谁充满感激？你会对自己一路尽力的那些问题和痛苦充满感激？__如果你有了新的信念，你相信自己生命中发生的每一件事，都是为了服务你，帮助你。\n\n## 2. 了解游戏规则\n__关键点事投资指数基金__，不用再付钱给专业投资者帮你选股了。例如[标准普尔公司](https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E6%99%AE%E5%B0%94/1194194?fromtitle=%E6%A0%87%E5%87%86%E6%99%AE%E5%B0%94%E5%85%AC%E5%8F%B8&fromid=9105625&fr=aladdin)选择的500只成分股，就已经选择了表现最好的500家上市公司。\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=c6816c4b1d950a7b613846966bb809bc/e61190ef76c6a7ef44929f5bfdfaaf51f3de6612.jpg)\n\n### 2.1. 基金公司的把戏\n基金公司的套路是设立多只新基金，看哪一只表现好就重点扶持，大力宣传，其他表现不佳的基金全部安乐死。\n\n投资内行都知道，追逐业绩排名很高的基金就像追逐风险一样，最后会落得一场空。但是羊群心里最终导致数百万的家庭的财富毁灭。\n\n__投资指数是一个很好的解决之道，但并非最佳策略，你不能把所有的寂静都投到指数基金上。大师的方法是投资多种不同的指数，让投资分散化、多元化。__\n\n### 2.2. 费用问题\n你需要弄清楚你付的费用是多少。\n\n主动管理型基金收取了我们超高的费用（平均每年超过了3%），我们选择低成本的指数基金就可以把投资费用减少80%。\n\n知识就是力量，但是执行力远远胜过知识的力量。（说一千万遍，不如踏踏实实做一次）\n\n### 2.3. 收益率\n你在基金公司看到的广告宣传册上投资收益率是时间加权收益率，而现实世界真实的业绩是资金加权收益率。\n\n## 3. 实现财务自由\n### 3.1. 心态\n生活重要的不是钱，而是心情。真正的目标是拥有你想要的生活方式，而不是你想要的东西。\n\n[奥普拉·温弗瑞](https://baike.baidu.com/item/%E5%A5%A5%E6%99%AE%E6%8B%89%C2%B7%E6%B8%A9%E5%BC%97%E7%91%9E/2736096?fr=aladdin)：\n>你都能得到，只是不能一下都能得到。\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=db3acebfbf1bb0519b29bb7a5713b1d1/30adcbef76094b36dee2d970afcc7cd98d109d3f.jpg)\n\n要给自己增加价值，先给别人增加价值。\n\n生活的关键是，__要相信最好的还在后面。__\n\n\n### 3.2. 减少费用，减少纳税\n留在你口袋你的钱，才是你赚到的钱。\n\n指数基金并不经常交易个股，而是长期持有这些股票。这样并不会像公墓基金经理每天，每个季度频繁交易，继而产生更多的交易税。\n\n- 省的钱更多，把多省出来的钱做投资，让你的投资本金更多  \n- 赚的钱更多（为别人增加更多价值），把多赚的钱拿去投资，让你的投资本金更多  \n- 减少费用和税收，把省下来的钱做投资，让你的投资本金更多。\n\n### 3.3. 投资策略\n#### 3.3.1. 风险-收益不对称\n上行空间（收益）明显大于下行空间（风险），风险-收益不对称。\n\n寻找并利用风险-收益不对称的机会不断的投资。（这种一般是市场的先机，信息或预测等得到）\n\n#### 3.3.2. 资产配置\n__做房地产的人一定知道：地段，地段，还是地段。__\n\n__做投资，要获得更高的投资收益率，同时又要降低风险，有一句神奇的魔咒是：分散，分散，还是分散。__\n\n要成为一个成功的投资者，你必须报投资组合定期再平衡。它能让你的利润最大化，它不能让你每次赢，但是再平衡意味着你赢的次数更多一些。\n\n大多数投资者每年一次或者每年两次进行再平衡。\n\n#### 3.3.3. 粗略的估计方法\n你的年龄有多大，投资债券的比例就有多大。换句话讲，用100减去你的年龄，就是你可以投资到股票上的资产比例。\n\n例如你现在40岁：\n- 60% 股票基金 —— 风险/成长水桶  \n- 40% 债券 —— 安全/安心水桶  \n  \n#### 3.3.4. 选时投资\n与其让暴跌吓呆，完全崩溃，不如跟自己的恐惧做斗争，多学学那些咋故事崩溃时期做的很好的大师。\n\n约翰.邓普顿爵士\n>好的机会来自悲观情绪最严重的时候\n\n巴菲特\n>在别人都贪婪的时候恐惧，在别人都恐惧的时候贪婪。","source":"_posts/钱：7步创造终生收入.md","raw":"---\ntitle: 钱:7步创造终生收入\ndate: 2019-05-12 13:55:46\ntags:\n    - bookmarks\ncategories: \n    - bookmarks\n---\n\n[托尼·罗宾斯](https://baike.baidu.com/item/%E6%89%98%E5%B0%BC%C2%B7%E7%BD%97%E5%AE%BE%E6%96%AF/15163356?fr=aladdin)\n\n<!--more-->\n\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=b38cc163ad1ea8d39e2f7c56f6635b2b/c2fdfc039245d6885449c47cafc27d1ed31b249a.jpg)\n\n## 推荐\n理财是继健康、家庭、工作之后，我个人认为的第四件人生大事。\n\n为钱工作，你是钱的奴隶，为爱工作，钱是你的奴隶。\n\n你做投资理财，目的不是积累更多的钱，而是自由--为了财务自由、为了心灵自由、为了灵魂自由。\n\n__未来唯一确定的事是不确定。__ 最大的财富不在过去而在未来。\n\n对于我们每个人来说，最大的财富不是金钱，而是激情。感受到生命的激情，才是最大的财富。\n\n你活着不是为了钱，而是要用钱活的更好更幸福。(明确使用钱的目的，而不是刻意仅仅为了赚钱，变成葛朗台)\n\n## 1. 基本原理\n\n弗朗西斯.培根爵士：\n>钱做仆人很好，钱做主人很糟。\n\n\n__预测是终极力量。__ 预测前方的路是掌握人生获得财富和成功的最大秘诀。\n\n你必须掌握并利用复利让财富指数化增长的神奇力量。（山顶上的人不是从天上落到山顶上的。）\n\n>承诺遵守一个非常简单却十分坚定的存储原则，每一次拿到工资，先从中拿出一部分存储，这就是你首先付给自己最求未来梦想的投资寂静，利用复利让你的储蓄投资不断升值。\n(最困难的事是下决心行动，之后的事只要坚持就行了。__坚持就是最好的策略__)\n\n\n__终极目标__\n生命的意义不在于你得到了什么，而在于你给予了什么。\n\n另外，你会对什么充满感激？对谁充满感激？你会对自己一路尽力的那些问题和痛苦充满感激？__如果你有了新的信念，你相信自己生命中发生的每一件事，都是为了服务你，帮助你。\n\n## 2. 了解游戏规则\n__关键点事投资指数基金__，不用再付钱给专业投资者帮你选股了。例如[标准普尔公司](https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E6%99%AE%E5%B0%94/1194194?fromtitle=%E6%A0%87%E5%87%86%E6%99%AE%E5%B0%94%E5%85%AC%E5%8F%B8&fromid=9105625&fr=aladdin)选择的500只成分股，就已经选择了表现最好的500家上市公司。\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=c6816c4b1d950a7b613846966bb809bc/e61190ef76c6a7ef44929f5bfdfaaf51f3de6612.jpg)\n\n### 2.1. 基金公司的把戏\n基金公司的套路是设立多只新基金，看哪一只表现好就重点扶持，大力宣传，其他表现不佳的基金全部安乐死。\n\n投资内行都知道，追逐业绩排名很高的基金就像追逐风险一样，最后会落得一场空。但是羊群心里最终导致数百万的家庭的财富毁灭。\n\n__投资指数是一个很好的解决之道，但并非最佳策略，你不能把所有的寂静都投到指数基金上。大师的方法是投资多种不同的指数，让投资分散化、多元化。__\n\n### 2.2. 费用问题\n你需要弄清楚你付的费用是多少。\n\n主动管理型基金收取了我们超高的费用（平均每年超过了3%），我们选择低成本的指数基金就可以把投资费用减少80%。\n\n知识就是力量，但是执行力远远胜过知识的力量。（说一千万遍，不如踏踏实实做一次）\n\n### 2.3. 收益率\n你在基金公司看到的广告宣传册上投资收益率是时间加权收益率，而现实世界真实的业绩是资金加权收益率。\n\n## 3. 实现财务自由\n### 3.1. 心态\n生活重要的不是钱，而是心情。真正的目标是拥有你想要的生活方式，而不是你想要的东西。\n\n[奥普拉·温弗瑞](https://baike.baidu.com/item/%E5%A5%A5%E6%99%AE%E6%8B%89%C2%B7%E6%B8%A9%E5%BC%97%E7%91%9E/2736096?fr=aladdin)：\n>你都能得到，只是不能一下都能得到。\n\n![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=db3acebfbf1bb0519b29bb7a5713b1d1/30adcbef76094b36dee2d970afcc7cd98d109d3f.jpg)\n\n要给自己增加价值，先给别人增加价值。\n\n生活的关键是，__要相信最好的还在后面。__\n\n\n### 3.2. 减少费用，减少纳税\n留在你口袋你的钱，才是你赚到的钱。\n\n指数基金并不经常交易个股，而是长期持有这些股票。这样并不会像公墓基金经理每天，每个季度频繁交易，继而产生更多的交易税。\n\n- 省的钱更多，把多省出来的钱做投资，让你的投资本金更多  \n- 赚的钱更多（为别人增加更多价值），把多赚的钱拿去投资，让你的投资本金更多  \n- 减少费用和税收，把省下来的钱做投资，让你的投资本金更多。\n\n### 3.3. 投资策略\n#### 3.3.1. 风险-收益不对称\n上行空间（收益）明显大于下行空间（风险），风险-收益不对称。\n\n寻找并利用风险-收益不对称的机会不断的投资。（这种一般是市场的先机，信息或预测等得到）\n\n#### 3.3.2. 资产配置\n__做房地产的人一定知道：地段，地段，还是地段。__\n\n__做投资，要获得更高的投资收益率，同时又要降低风险，有一句神奇的魔咒是：分散，分散，还是分散。__\n\n要成为一个成功的投资者，你必须报投资组合定期再平衡。它能让你的利润最大化，它不能让你每次赢，但是再平衡意味着你赢的次数更多一些。\n\n大多数投资者每年一次或者每年两次进行再平衡。\n\n#### 3.3.3. 粗略的估计方法\n你的年龄有多大，投资债券的比例就有多大。换句话讲，用100减去你的年龄，就是你可以投资到股票上的资产比例。\n\n例如你现在40岁：\n- 60% 股票基金 —— 风险/成长水桶  \n- 40% 债券 —— 安全/安心水桶  \n  \n#### 3.3.4. 选时投资\n与其让暴跌吓呆，完全崩溃，不如跟自己的恐惧做斗争，多学学那些咋故事崩溃时期做的很好的大师。\n\n约翰.邓普顿爵士\n>好的机会来自悲观情绪最严重的时候\n\n巴菲特\n>在别人都贪婪的时候恐惧，在别人都恐惧的时候贪婪。","slug":"钱：7步创造终生收入","published":1,"updated":"2019-07-08T06:16:07.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p0si0067zkgr65w320nh","content":"<p><a href=\"https://baike.baidu.com/item/%E6%89%98%E5%B0%BC%C2%B7%E7%BD%97%E5%AE%BE%E6%96%AF/15163356?fr=aladdin\" target=\"_blank\" rel=\"noopener\">托尼·罗宾斯</a></p>\n<a id=\"more\"></a>\n<p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=b38cc163ad1ea8d39e2f7c56f6635b2b/c2fdfc039245d6885449c47cafc27d1ed31b249a.jpg\" alt=\"\"></p>\n<h2 id=\"推荐\"><a href=\"#推荐\" class=\"headerlink\" title=\"推荐\"></a>推荐</h2><p>理财是继健康、家庭、工作之后，我个人认为的第四件人生大事。</p>\n<p>为钱工作，你是钱的奴隶，为爱工作，钱是你的奴隶。</p>\n<p>你做投资理财，目的不是积累更多的钱，而是自由–为了财务自由、为了心灵自由、为了灵魂自由。</p>\n<p><strong>未来唯一确定的事是不确定。</strong> 最大的财富不在过去而在未来。</p>\n<p>对于我们每个人来说，最大的财富不是金钱，而是激情。感受到生命的激情，才是最大的财富。</p>\n<p>你活着不是为了钱，而是要用钱活的更好更幸福。(明确使用钱的目的，而不是刻意仅仅为了赚钱，变成葛朗台)</p>\n<h2 id=\"1-基本原理\"><a href=\"#1-基本原理\" class=\"headerlink\" title=\"1. 基本原理\"></a>1. 基本原理</h2><p>弗朗西斯.培根爵士：</p>\n<blockquote>\n<p>钱做仆人很好，钱做主人很糟。</p>\n</blockquote>\n<p><strong>预测是终极力量。</strong> 预测前方的路是掌握人生获得财富和成功的最大秘诀。</p>\n<p>你必须掌握并利用复利让财富指数化增长的神奇力量。（山顶上的人不是从天上落到山顶上的。）</p>\n<blockquote>\n<p>承诺遵守一个非常简单却十分坚定的存储原则，每一次拿到工资，先从中拿出一部分存储，这就是你首先付给自己最求未来梦想的投资寂静，利用复利让你的储蓄投资不断升值。<br>(最困难的事是下决心行动，之后的事只要坚持就行了。<strong>坚持就是最好的策略</strong>)</p>\n</blockquote>\n<p><strong>终极目标</strong><br>生命的意义不在于你得到了什么，而在于你给予了什么。</p>\n<p>另外，你会对什么充满感激？对谁充满感激？你会对自己一路尽力的那些问题和痛苦充满感激？__如果你有了新的信念，你相信自己生命中发生的每一件事，都是为了服务你，帮助你。</p>\n<h2 id=\"2-了解游戏规则\"><a href=\"#2-了解游戏规则\" class=\"headerlink\" title=\"2. 了解游戏规则\"></a>2. 了解游戏规则</h2><p><strong>关键点事投资指数基金</strong>，不用再付钱给专业投资者帮你选股了。例如<a href=\"https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E6%99%AE%E5%B0%94/1194194?fromtitle=%E6%A0%87%E5%87%86%E6%99%AE%E5%B0%94%E5%85%AC%E5%8F%B8&amp;fromid=9105625&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">标准普尔公司</a>选择的500只成分股，就已经选择了表现最好的500家上市公司。</p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=c6816c4b1d950a7b613846966bb809bc/e61190ef76c6a7ef44929f5bfdfaaf51f3de6612.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-基金公司的把戏\"><a href=\"#2-1-基金公司的把戏\" class=\"headerlink\" title=\"2.1. 基金公司的把戏\"></a>2.1. 基金公司的把戏</h3><p>基金公司的套路是设立多只新基金，看哪一只表现好就重点扶持，大力宣传，其他表现不佳的基金全部安乐死。</p>\n<p>投资内行都知道，追逐业绩排名很高的基金就像追逐风险一样，最后会落得一场空。但是羊群心里最终导致数百万的家庭的财富毁灭。</p>\n<p><strong>投资指数是一个很好的解决之道，但并非最佳策略，你不能把所有的寂静都投到指数基金上。大师的方法是投资多种不同的指数，让投资分散化、多元化。</strong></p>\n<h3 id=\"2-2-费用问题\"><a href=\"#2-2-费用问题\" class=\"headerlink\" title=\"2.2. 费用问题\"></a>2.2. 费用问题</h3><p>你需要弄清楚你付的费用是多少。</p>\n<p>主动管理型基金收取了我们超高的费用（平均每年超过了3%），我们选择低成本的指数基金就可以把投资费用减少80%。</p>\n<p>知识就是力量，但是执行力远远胜过知识的力量。（说一千万遍，不如踏踏实实做一次）</p>\n<h3 id=\"2-3-收益率\"><a href=\"#2-3-收益率\" class=\"headerlink\" title=\"2.3. 收益率\"></a>2.3. 收益率</h3><p>你在基金公司看到的广告宣传册上投资收益率是时间加权收益率，而现实世界真实的业绩是资金加权收益率。</p>\n<h2 id=\"3-实现财务自由\"><a href=\"#3-实现财务自由\" class=\"headerlink\" title=\"3. 实现财务自由\"></a>3. 实现财务自由</h2><h3 id=\"3-1-心态\"><a href=\"#3-1-心态\" class=\"headerlink\" title=\"3.1. 心态\"></a>3.1. 心态</h3><p>生活重要的不是钱，而是心情。真正的目标是拥有你想要的生活方式，而不是你想要的东西。</p>\n<p><a href=\"https://baike.baidu.com/item/%E5%A5%A5%E6%99%AE%E6%8B%89%C2%B7%E6%B8%A9%E5%BC%97%E7%91%9E/2736096?fr=aladdin\" target=\"_blank\" rel=\"noopener\">奥普拉·温弗瑞</a>：</p>\n<blockquote>\n<p>你都能得到，只是不能一下都能得到。</p>\n</blockquote>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=db3acebfbf1bb0519b29bb7a5713b1d1/30adcbef76094b36dee2d970afcc7cd98d109d3f.jpg\" alt=\"\"></p>\n<p>要给自己增加价值，先给别人增加价值。</p>\n<p>生活的关键是，<strong>要相信最好的还在后面。</strong></p>\n<h3 id=\"3-2-减少费用，减少纳税\"><a href=\"#3-2-减少费用，减少纳税\" class=\"headerlink\" title=\"3.2. 减少费用，减少纳税\"></a>3.2. 减少费用，减少纳税</h3><p>留在你口袋你的钱，才是你赚到的钱。</p>\n<p>指数基金并不经常交易个股，而是长期持有这些股票。这样并不会像公墓基金经理每天，每个季度频繁交易，继而产生更多的交易税。</p>\n<ul>\n<li>省的钱更多，把多省出来的钱做投资，让你的投资本金更多  </li>\n<li>赚的钱更多（为别人增加更多价值），把多赚的钱拿去投资，让你的投资本金更多  </li>\n<li>减少费用和税收，把省下来的钱做投资，让你的投资本金更多。</li>\n</ul>\n<h3 id=\"3-3-投资策略\"><a href=\"#3-3-投资策略\" class=\"headerlink\" title=\"3.3. 投资策略\"></a>3.3. 投资策略</h3><h4 id=\"3-3-1-风险-收益不对称\"><a href=\"#3-3-1-风险-收益不对称\" class=\"headerlink\" title=\"3.3.1. 风险-收益不对称\"></a>3.3.1. 风险-收益不对称</h4><p>上行空间（收益）明显大于下行空间（风险），风险-收益不对称。</p>\n<p>寻找并利用风险-收益不对称的机会不断的投资。（这种一般是市场的先机，信息或预测等得到）</p>\n<h4 id=\"3-3-2-资产配置\"><a href=\"#3-3-2-资产配置\" class=\"headerlink\" title=\"3.3.2. 资产配置\"></a>3.3.2. 资产配置</h4><p><strong>做房地产的人一定知道：地段，地段，还是地段。</strong></p>\n<p><strong>做投资，要获得更高的投资收益率，同时又要降低风险，有一句神奇的魔咒是：分散，分散，还是分散。</strong></p>\n<p>要成为一个成功的投资者，你必须报投资组合定期再平衡。它能让你的利润最大化，它不能让你每次赢，但是再平衡意味着你赢的次数更多一些。</p>\n<p>大多数投资者每年一次或者每年两次进行再平衡。</p>\n<h4 id=\"3-3-3-粗略的估计方法\"><a href=\"#3-3-3-粗略的估计方法\" class=\"headerlink\" title=\"3.3.3. 粗略的估计方法\"></a>3.3.3. 粗略的估计方法</h4><p>你的年龄有多大，投资债券的比例就有多大。换句话讲，用100减去你的年龄，就是你可以投资到股票上的资产比例。</p>\n<p>例如你现在40岁：</p>\n<ul>\n<li>60% 股票基金 —— 风险/成长水桶  </li>\n<li>40% 债券 —— 安全/安心水桶  </li>\n</ul>\n<h4 id=\"3-3-4-选时投资\"><a href=\"#3-3-4-选时投资\" class=\"headerlink\" title=\"3.3.4. 选时投资\"></a>3.3.4. 选时投资</h4><p>与其让暴跌吓呆，完全崩溃，不如跟自己的恐惧做斗争，多学学那些咋故事崩溃时期做的很好的大师。</p>\n<p>约翰.邓普顿爵士</p>\n<blockquote>\n<p>好的机会来自悲观情绪最严重的时候</p>\n</blockquote>\n<p>巴菲特</p>\n<blockquote>\n<p>在别人都贪婪的时候恐惧，在别人都恐惧的时候贪婪。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://baike.baidu.com/item/%E6%89%98%E5%B0%BC%C2%B7%E7%BD%97%E5%AE%BE%E6%96%AF/15163356?fr=aladdin\" target=\"_blank\" rel=\"noopener\">托尼·罗宾斯</a></p>","more":"<p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=b38cc163ad1ea8d39e2f7c56f6635b2b/c2fdfc039245d6885449c47cafc27d1ed31b249a.jpg\" alt=\"\"></p>\n<h2 id=\"推荐\"><a href=\"#推荐\" class=\"headerlink\" title=\"推荐\"></a>推荐</h2><p>理财是继健康、家庭、工作之后，我个人认为的第四件人生大事。</p>\n<p>为钱工作，你是钱的奴隶，为爱工作，钱是你的奴隶。</p>\n<p>你做投资理财，目的不是积累更多的钱，而是自由–为了财务自由、为了心灵自由、为了灵魂自由。</p>\n<p><strong>未来唯一确定的事是不确定。</strong> 最大的财富不在过去而在未来。</p>\n<p>对于我们每个人来说，最大的财富不是金钱，而是激情。感受到生命的激情，才是最大的财富。</p>\n<p>你活着不是为了钱，而是要用钱活的更好更幸福。(明确使用钱的目的，而不是刻意仅仅为了赚钱，变成葛朗台)</p>\n<h2 id=\"1-基本原理\"><a href=\"#1-基本原理\" class=\"headerlink\" title=\"1. 基本原理\"></a>1. 基本原理</h2><p>弗朗西斯.培根爵士：</p>\n<blockquote>\n<p>钱做仆人很好，钱做主人很糟。</p>\n</blockquote>\n<p><strong>预测是终极力量。</strong> 预测前方的路是掌握人生获得财富和成功的最大秘诀。</p>\n<p>你必须掌握并利用复利让财富指数化增长的神奇力量。（山顶上的人不是从天上落到山顶上的。）</p>\n<blockquote>\n<p>承诺遵守一个非常简单却十分坚定的存储原则，每一次拿到工资，先从中拿出一部分存储，这就是你首先付给自己最求未来梦想的投资寂静，利用复利让你的储蓄投资不断升值。<br>(最困难的事是下决心行动，之后的事只要坚持就行了。<strong>坚持就是最好的策略</strong>)</p>\n</blockquote>\n<p><strong>终极目标</strong><br>生命的意义不在于你得到了什么，而在于你给予了什么。</p>\n<p>另外，你会对什么充满感激？对谁充满感激？你会对自己一路尽力的那些问题和痛苦充满感激？__如果你有了新的信念，你相信自己生命中发生的每一件事，都是为了服务你，帮助你。</p>\n<h2 id=\"2-了解游戏规则\"><a href=\"#2-了解游戏规则\" class=\"headerlink\" title=\"2. 了解游戏规则\"></a>2. 了解游戏规则</h2><p><strong>关键点事投资指数基金</strong>，不用再付钱给专业投资者帮你选股了。例如<a href=\"https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E6%99%AE%E5%B0%94/1194194?fromtitle=%E6%A0%87%E5%87%86%E6%99%AE%E5%B0%94%E5%85%AC%E5%8F%B8&amp;fromid=9105625&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">标准普尔公司</a>选择的500只成分股，就已经选择了表现最好的500家上市公司。</p>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=c6816c4b1d950a7b613846966bb809bc/e61190ef76c6a7ef44929f5bfdfaaf51f3de6612.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-基金公司的把戏\"><a href=\"#2-1-基金公司的把戏\" class=\"headerlink\" title=\"2.1. 基金公司的把戏\"></a>2.1. 基金公司的把戏</h3><p>基金公司的套路是设立多只新基金，看哪一只表现好就重点扶持，大力宣传，其他表现不佳的基金全部安乐死。</p>\n<p>投资内行都知道，追逐业绩排名很高的基金就像追逐风险一样，最后会落得一场空。但是羊群心里最终导致数百万的家庭的财富毁灭。</p>\n<p><strong>投资指数是一个很好的解决之道，但并非最佳策略，你不能把所有的寂静都投到指数基金上。大师的方法是投资多种不同的指数，让投资分散化、多元化。</strong></p>\n<h3 id=\"2-2-费用问题\"><a href=\"#2-2-费用问题\" class=\"headerlink\" title=\"2.2. 费用问题\"></a>2.2. 费用问题</h3><p>你需要弄清楚你付的费用是多少。</p>\n<p>主动管理型基金收取了我们超高的费用（平均每年超过了3%），我们选择低成本的指数基金就可以把投资费用减少80%。</p>\n<p>知识就是力量，但是执行力远远胜过知识的力量。（说一千万遍，不如踏踏实实做一次）</p>\n<h3 id=\"2-3-收益率\"><a href=\"#2-3-收益率\" class=\"headerlink\" title=\"2.3. 收益率\"></a>2.3. 收益率</h3><p>你在基金公司看到的广告宣传册上投资收益率是时间加权收益率，而现实世界真实的业绩是资金加权收益率。</p>\n<h2 id=\"3-实现财务自由\"><a href=\"#3-实现财务自由\" class=\"headerlink\" title=\"3. 实现财务自由\"></a>3. 实现财务自由</h2><h3 id=\"3-1-心态\"><a href=\"#3-1-心态\" class=\"headerlink\" title=\"3.1. 心态\"></a>3.1. 心态</h3><p>生活重要的不是钱，而是心情。真正的目标是拥有你想要的生活方式，而不是你想要的东西。</p>\n<p><a href=\"https://baike.baidu.com/item/%E5%A5%A5%E6%99%AE%E6%8B%89%C2%B7%E6%B8%A9%E5%BC%97%E7%91%9E/2736096?fr=aladdin\" target=\"_blank\" rel=\"noopener\">奥普拉·温弗瑞</a>：</p>\n<blockquote>\n<p>你都能得到，只是不能一下都能得到。</p>\n</blockquote>\n<p><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=db3acebfbf1bb0519b29bb7a5713b1d1/30adcbef76094b36dee2d970afcc7cd98d109d3f.jpg\" alt=\"\"></p>\n<p>要给自己增加价值，先给别人增加价值。</p>\n<p>生活的关键是，<strong>要相信最好的还在后面。</strong></p>\n<h3 id=\"3-2-减少费用，减少纳税\"><a href=\"#3-2-减少费用，减少纳税\" class=\"headerlink\" title=\"3.2. 减少费用，减少纳税\"></a>3.2. 减少费用，减少纳税</h3><p>留在你口袋你的钱，才是你赚到的钱。</p>\n<p>指数基金并不经常交易个股，而是长期持有这些股票。这样并不会像公墓基金经理每天，每个季度频繁交易，继而产生更多的交易税。</p>\n<ul>\n<li>省的钱更多，把多省出来的钱做投资，让你的投资本金更多  </li>\n<li>赚的钱更多（为别人增加更多价值），把多赚的钱拿去投资，让你的投资本金更多  </li>\n<li>减少费用和税收，把省下来的钱做投资，让你的投资本金更多。</li>\n</ul>\n<h3 id=\"3-3-投资策略\"><a href=\"#3-3-投资策略\" class=\"headerlink\" title=\"3.3. 投资策略\"></a>3.3. 投资策略</h3><h4 id=\"3-3-1-风险-收益不对称\"><a href=\"#3-3-1-风险-收益不对称\" class=\"headerlink\" title=\"3.3.1. 风险-收益不对称\"></a>3.3.1. 风险-收益不对称</h4><p>上行空间（收益）明显大于下行空间（风险），风险-收益不对称。</p>\n<p>寻找并利用风险-收益不对称的机会不断的投资。（这种一般是市场的先机，信息或预测等得到）</p>\n<h4 id=\"3-3-2-资产配置\"><a href=\"#3-3-2-资产配置\" class=\"headerlink\" title=\"3.3.2. 资产配置\"></a>3.3.2. 资产配置</h4><p><strong>做房地产的人一定知道：地段，地段，还是地段。</strong></p>\n<p><strong>做投资，要获得更高的投资收益率，同时又要降低风险，有一句神奇的魔咒是：分散，分散，还是分散。</strong></p>\n<p>要成为一个成功的投资者，你必须报投资组合定期再平衡。它能让你的利润最大化，它不能让你每次赢，但是再平衡意味着你赢的次数更多一些。</p>\n<p>大多数投资者每年一次或者每年两次进行再平衡。</p>\n<h4 id=\"3-3-3-粗略的估计方法\"><a href=\"#3-3-3-粗略的估计方法\" class=\"headerlink\" title=\"3.3.3. 粗略的估计方法\"></a>3.3.3. 粗略的估计方法</h4><p>你的年龄有多大，投资债券的比例就有多大。换句话讲，用100减去你的年龄，就是你可以投资到股票上的资产比例。</p>\n<p>例如你现在40岁：</p>\n<ul>\n<li>60% 股票基金 —— 风险/成长水桶  </li>\n<li>40% 债券 —— 安全/安心水桶  </li>\n</ul>\n<h4 id=\"3-3-4-选时投资\"><a href=\"#3-3-4-选时投资\" class=\"headerlink\" title=\"3.3.4. 选时投资\"></a>3.3.4. 选时投资</h4><p>与其让暴跌吓呆，完全崩溃，不如跟自己的恐惧做斗争，多学学那些咋故事崩溃时期做的很好的大师。</p>\n<p>约翰.邓普顿爵士</p>\n<blockquote>\n<p>好的机会来自悲观情绪最严重的时候</p>\n</blockquote>\n<p>巴菲特</p>\n<blockquote>\n<p>在别人都贪婪的时候恐惧，在别人都恐惧的时候贪婪。</p>\n</blockquote>"},{"title":"arm arm part B","date":"2019-05-30T05:55:44.000Z","_content":"\nReference: <<ARM ® Architecture Reference Manual -- ARMv7-A and ARMv7-R edition>> (ARM DDI 0406C.c (ID051414))\n<!--more-->\n## Part B System Level Architecture\n\n### B1 System Level Programmers’ Model\n#### B1.1 About the System level programmers’ model\n#### B1.2 System level concepts and terminology\n##### B1.2.1 Mode, state, and privilege level\n###### Mode\nThe ARM architecture A and R profiles provide a set of modes that support normal software execution and handle\nexceptions. The current mode determines:\n• the set of registers that are available to the processor\n• the privilege level of the executing software\n\n###### State\n- Instruction set state\n\n> one of ARM state, Thumb state, Jazelle state, or ThumbEE state.\n\n- Execution state\n\n> consists of the instruction set state and some control bits that modify how the\ninstruction stream is decoded. For details, see Execution state registers on page A2-50 and Program\nStatus Registers (PSRs) on page B1-1147.\n\n- Security state \n\n- Debug state\n\n###### Privilege level\n__Secure state__\nPL0 Software executed in User mode executes at PL0.\nPL1 Software executed in any mode other than User mode executes at PL1.\n\n__Non-secure state__\nPL0 Software executed in User mode executes at PL0.\nPL1 Software executed in any mode other than User or Hyp mode executes at PL1.\nPL2 In an implementation that includes the Virtualization Extensions, software executed in\nHyp mode executes at PL2.\n\n#### B1.3 ARM processor modes and ARM core registers\n##### B1.3.1 ARM processor modes\nFixme [Table B1-1 ARM processor modes] page1139\n###### System mode \nSoftware executing in System mode executes at PL1. System mode has the same registers available\nas User mode, and is not entered by any exception.\n\n###### Supervisor mode\nSupervisor mode is the default mode to which a Supervisor Call exception is taken.\nExecuting a SVC (Supervisor Call) instruction generates an Supervisor Call exception, that is taken\nto Supervisor mode.\n__A processor enters Supervisor mode on Reset__\n\n###### Hyp mode \nHyp mode is the Non-secure PL2 mode, implemented as part of the Virtualization Extensions. \nThe Hypervisor Call exception and Hyp Trap exception are exceptions that are implemented as part\nof the Virtualization Extensions, and that are always taken in Hyp mode.\n• __In Hyp mode, the only exception return is execution of an ERET instruction, see ERET on page B9-1982__\n• The instructions described in the following sections are UNDEFINED if executed in Hyp mode:\n\t— SRS (Thumb) on page B9-2004\n\t— SRS (ARM) on page B9-2006\n\t— RFE on page B9-2000\n\t— LDM (exception return) on page B9-1986\n\t— LDM (User registers) on page B9-1988\n\t— STM (User registers) on page B9-2008\n\t— SUBS PC, LR and related instructions (ARM) on page B9-2012.\n\t— SUBS PC, LR (Thumb) on page B9-2010, when executed with a nonzero constant.\n\n• In Hyp mode, the CPACR has no effect on the execution of coprocessor, floating-point, or Advanced SIMD\ninstructions. The HCPTR controls execution of these instructions in Hyp mode.\n\n• If software running in Hyp mode executes an SVC instruction, the Supervisor Call exception generated by the\ninstruction is taken to Hyp mode, see SVC (previously SWI) on page A8-720.\n\n###### Monitor mode\nMonitor mode is the mode to which a Secure Monitor Call exception is taken.\nMonitor mode is a Secure mode, meaning it is always in the Secure state, regardless of the value of\nthe SCR.NS bit. __Monitor mode provides the normal method of changing between the Secure and Non-secure security states.__\n\n\nFixme [Figure B1-1 Modes, privilege levels, and security states] page1141\n\n##### B1.3.2 ARM core registers\nFixme [Figure B1-2 ARM core registers, PSRs, and ELR_hyp, showing register banking] page1144\n\n##### B1.3.3 Program Status Registers (PSRs)\n###### The Current Program Status Register (CPSR)\nThe Current Program Status Register (CPSR) holds processor status and control information:\n• the APSR, see The Application Program Status Register (APSR) on page A2-49\n• the current instruction set state, see Instruction set state register, ISETSTATE on page A2-50\n• the execution state bits for the Thumb If-Then instruction, see IT block state register, ITSTATE on page A2-51\n• the current endianness, see Endianness mapping register, ENDIANSTATE on page A2-53\n• the current processor mode\n• interrupt and asynchronous abort disable bits.\n\n###### The Saved Program Status Registers (SPSRs)\nThe purpose of an SPSR is to record the pre-exception value of the CPSR. \n\nFixme [Format of the CPSR and SPSRs] Page1148\n\n##### B1.3.4 ELR_hyp\nHyp mode does not provide its own Banked copy of LR. Instead, on taking an exception to Hyp mode, the preferred\nreturn address is stored in ELR_hyp, a 32-bit Special register implemented for this purpose.\nELR_hyp is implemented only as part of the Virtualization Extensions.\n\nThe ERET instruction uses the value in ELR_hyp as the return address for the exception. For more information, see\nERET on page B9-1982.\n\n#### B1.4 Instruction set states\nIf an exception is taken to a PL1 mode, the SCTLR.TE bit for the security state the exception is taken to determines\nthe processor instruction set state that handles the exception, and if necessary, the processor changes to this\ninstruction set state on exception entry.\n\nIf the exception is taken to Hyp mode, the HSCTLR.TE bit determines the processor instruction set state that\nhandles the exception, and if necessary, the processor changes to this instruction set state on exception entry.\n\n#### B1.5 The Security Extensions\n##### B1.5.1 Security states\nThe Security Extensions define two security states, Secure state and Non-secure state. \n• Each security state operates in its own virtual memory address space, with its own translation regime. \n— in any implementation that includes the Security Extensions, Monitor mode is available only in Secure\nstate\n— in an implementation that also includes the Virtualization Extensions, Hyp mode is available only in\nNon-secure state.\n\nThe ARM core registers and the processor status registers are not Banked between the Secure and the Non-secure\nstates. ARM expects that, when switching execution between the Non-secure and Secure states, a kernel running\nmostly in Monitor mode will switch the values of these registers.\nThe registers LR_mon and SPSR_mon are UNKNOWN when executing in Non-secure state.\n\n###### Changing from Secure to Non-secure state\nExcept in Monitor mode and Hyp mode, the security state is controlled by the SCR.NS bit. Software executing in a Secure PL1 mode can change the SCR, but ARM strongly recommends that software obeys the following rules for changing SCR.NS:\n• To avoid security holes, software must not:\n\t— Change from Secure to Non-secure state by using an MSR or CPS instruction to switch from Monitor\n\tmode to some other mode while SCR.NS is 1.\n\t— Use an MCR instruction that writes SCR.NS to change from Secure to Non-secure state. This means\n\tARM recommends that software does not alter SCR.NS in any mode except Monitor mode. ARM\n\tdeprecates changing SCR.NS in any other mode.\n\n• __The usual mechanism for changing from Secure to Non-secure state is an exception return__.To return to\nNon-secure state, software executing in Monitor mode sets SCR.NS to 1 and then performs the exception\nreturn.\n\n#### B1.6 The Large Physical Address Extension\nThe Large Physical Address Extension is an OPTIONAL extension to the ARMv7-A architecture profile. Any\nimplementation that includes the Large Physical Address Extension must also include the Multiprocessing\nExtensions.\n\nThe Large Physical Address Extension adds a new translation table format:\n• the format used in an implementation that does not include the Large Physical Address Extension is now\ncalled the Short-descriptor format, see Short-descriptor translation table format on page B3-1324\n• the format added by the Large Physical Address Extension is the Long-descriptor format, see\nLong-descriptor translation table format on page B3-1338.\n\n__An implementation that includes the Large Physical Address Extension must support both translation table formats.__\n\n#### B1.7 The Virtualization Extensions\nThe Virtualization Extensions are an OPTIONAL extension to the ARMv7-A architecture profile. Any\nimplementation that includes the Virtualization Extensions must include the Security Extensions, the Large Physical\nAddress Extension, and the Multiprocessing Extensions.\n\nThe basic model of a virtualized system involves:\n• a hypervisor, running in Non-secure Hyp mode, that is responsible for switching Guest operating systems\n• a number of Guest operating systems, each of which runs in the Non-secure PL1 and PL0 modes\n• for each Guest operating system, applications, that usually run in User mode.\n\n__Each virtual machine is identified by a virtual machine identifier (VMID), assigned by the hypervisor.__\n• With the Security Extensions, the Virtualization Extensions control the routing of interrupts and\nasynchronous Data Abort exceptions to the appropriate one of:\n— the current Guest OS\n— a Guest OS that is not currently running\n— the hypervisor\n— the Secure monitor.\n\n• When an implementation includes the Virtualization Extensions, it provides independent translation regimes\nfor memory accesses from:\n\t— Secure modes, the Secure PL1&0 translation regime\n\t— Non-secure Hyp mode, the Non-secure PL2 translation regime\n\t— Non-secure PL1 and PL0 modes, the Non-secure PL1&0 translation regime\n\n• In the Non-secure PL1&0 translation regime, address translation occurs in two stages:\n— Stage 1 maps the Virtual Address (VA) to an Intermediate Physical Address (IPA). Typically, the Guest\nOS configures and controls this stage, and believes that the IPA is the Physical Address (PA)\n— Stage 2 maps the IPA to the PA. Typically, the hypervisor controls this stage, and a Guest OS is\ncompletely unaware of this translation.\n\n##### B1.7.1 Impact of the Virtualization Extensions on the modes and exception model\n• Implements new exceptions, see:\n\t— Hypervisor Call (HVC) exception on page B1-1212\n\t— Hyp Trap exception on page B1-1209\n\t— Virtual IRQ exception on page B1-1221\n\t— Virtual FIQ exception on page B1-1223\n\t— Virtual Abort exception on page B1-1218.\n\n• Implements a new register that holds the exception vector base address for exceptions taken to Hyp mode,\nthe HVBAR.\n\n• Implements a new exception return instruction, ERET, for return from Hyp mode\n\n• Provide mechanisms to trap processor functions to Hyp mode, using the Hyp Trap exception, see Traps to\nthe hypervisor on page B1-1248.\nWhen an operation is trapped to Hyp mode, the hypervisor typically either:\n\t— emulates the required operation, so the application running in the Guest OS is unaware of the trap to\n\tHyp mode\n\t— returns an error to the Guest OS.\n\n#### B1.8 Exception handling\n##### B1.8.1 Exception vectors and the exception base address\nWhen an exception is taken, processor execution is forced to an address that corresponds to the type of exception.\nThis address is called the exception vector for that exception.\n\n__A set of exception vectors comprises eight consecutive word-aligned memory addresses__, starting at an exception\nbase address. These eight vectors form a vector table. __For the IRQ and FIQ exceptions only__, when the exceptions\nare taken to IRQ mode and FIQ mode, software can change the exception vectors from the vector table values by\nsetting the SCTLR.VE bit to 1, see Vectored interrupt support on page B1-1168.\n\n###### Implementation that does not include the Security Extensions (1 pair interrupt vectors)\nThis section applied to all ARMv7-R implementations.\nAn implementation that does not include the Security Extensions has a single vector table, the base\naddress of which is selected by SCTLR.V, see SCTLR, System Control Register, VMSA on\npage B4-1707 or SCTLR, System Control Register, PMSA on page B6-1932:\n\tV == 0 Exception base address = 0x00000000. This setting is referred to as normal vectors, or as\n\tlow vectors.\n\tV == 1 Exception base address = 0xFFFF0000. This setting is referred to as high vectors, or\n\tHivecs.\n\n###### Implementation that includes the Security Extensions (3 pair interrupt vectors)\nAny implementation that includes the Security Extensions has the following vector tables:\n• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in\nthe address space of the Secure PL1&0 translation regime.\n• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure\nvector table, and is in the address space of the Secure PL1&0 translation regime.\n• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and\nis in the address space of the Non-secure PL1&0 translation regime.\n\n__For the Monitor vector table, MVBAR holds the exception base address.__\n\nFor the Secure vector table:\n• the Secure SCTLR.V bit determines the exception base address:\n\tV == 0 The Secure VBAR holds the exception base address.\n\tV == 1 Exception base address = 0xFFFF0000, the Hivecs setting.\n\nFor the Non-secure vector table:\n• the Non-secure SCTLR.V bit determines the exception base address:\n\tV == 0 The Non-secure VBAR holds the exception base address.\n\tV == 1 Exception base address = 0xFFFF0000, the Hivecs setting.\n\n\n###### Implementation that includes the Virtualization Extensions (4 pair interrupt vectors)\nAn implementation that includes the Virtualization Extensions must include the Security\nExtensions, and also includes an additional vector table. Therefore, it has the following vector\ntables:\n• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in\nthe address space of the Secure PL1&0 translation regime.\n• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure\nvector table, and is in the address space of the Secure PL1&0 translation regime.\n• One for exceptions taken to Hyp mode, the Non-secure PL2 mode. This is the Hyp vector\ntable, and is in the address space of the Non-secure PL2 translation regime.\n• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and\nis in the address space of the Non-secure PL1&0 translation regime.\n\nThe exception base addresses of the Monitor vector table, the Secure vector table, and the\nNon-secure vector table are determined in the same way as for an implementation that includes the\nSecurity extensions but not the Virtualization extensions.\n\n__For the Hyp vector table, HVBAR holds the exception base address.__\n\n###### The vector tables and exception offsets\nFixme [Table B1-3 The vector tables] page1167\n\n##### B1.8.4 Processor mode for taking exceptions\n###### Exceptions taken to Hyp mode\n• Any exception taken from Hyp mode, that is not routed to Secure Monitor Mode by the controls described\nin Asynchronous exception routing controls on page B1-1175, is taken to Hyp mode.\n\n• The following exceptions, if taken from Non-secure state, are taken to Hyp mode:\n\t— An abort that Routing of aborts on page B3-1396 identifies as taken to Hyp mode.\n\t— A Hyp Trap exception, see Traps to the hypervisor on page B1-1248.\n\t— A Hypervisor Call exception. This is generated by executing a HVC instruction in a Non-secure mode.\n\t— An asynchronous abort, IRQ exception or FIQ exception that is not routed to Secure Monitor mode\n\tbut is explicitly routed to Hyp mode, as described in Asynchronous exception routing controls on\n\tpage B1-1175.\n\t— A synchronous external abort, Alignment fault, Undefined Instruction exception, or Supervisor Call\n\texception taken from the Non-secure PL0 mode and explicitly routed to Hyp mode, as described in\n\tRouting general exceptions to Hyp mode on page B1-1192.\n\tNote\n\tA synchronous external abort can be routed to Hyp mode only if it not routed to Secure Monitor mode.\n\t— A debug exception that is explicitly routed to Hyp mode as described in Routing Debug exceptions to\n\tHyp mode on page B1-1194.\n\n###### Asynchronous exception routing controls\nIn an implementation that includes the Security Extensions, the following bits in the SCR control the routing of\nasynchronous exceptions:\nSCR.EA    When this bit is set to 1, any external abort is taken to Secure Monitor mode\nSCR.FIQ   When this bit is set to 1, any FIQ exception is taken to Secure Monitor mode.\nSCR.IRQ   When this bit is set to 1, any IRQ exception is taken to Secure Monitor mode.\n__Only Secure software can change the values of these bits.__\n\nIn an implementation that includes the Virtualization Extensions, the following bits in the HCR route asynchronous\nexceptions to Hyp mode:\nHCR.AMO   If SCR.EA is set to 0, when this bit is set to 1, an asynchronous external abort taken from a\n          Non-secure PL1 or PL0 mode is taken to Hyp mode, instead of to Non-secure Abort mode.\n\nHCR.FMO   If SCR.FIQ is set to 0, when this bit is set to 1, an FIQ exception taken from a Non-secure PL1 or\n          PL0 mode is taken to Hyp mode, instead of to Non-secure FIQ mode.\n\nHCR.IMO   If SCR.IRQ is set to 0, when this bit is set to 1, an IRQ exceptions taken from a Non-secure PL1 or\n          PL0 mode is taken to Hyp mode, instead of to Non-secure IRQ mode.\n\n__Only software executing in Hyp mode, or Secure software executing in Monitor mode when SCR.NS is set to 1, can change the values of these bits.__\n\n##### B1.8.5 Processor state on exception entry\n###### Instruction set state on exception entry\nOn exception entry, CPSR.{T, J} are set to the values shown, with the CPSR.T value determined by SCTLR.TE or HSCTLR.TE\n\nFixme [Table B1-8 CPSR.J and CPSR.T bit values on exception entry] page1182\n\n###### CPSR.E bit value on exception entr\nFixme [Table B1-9 CPSR.E bit value on exception entry] page1182\n\n##### B1.8.6 Asynchronous exception masking\nThe CPSR.{A, I, F} bits can mask the corresponding exceptions, as follows:\n• CPSR.A can mask asynchronous aborts\n• CPSR.I can mask IRQ exceptions\n• CPSR.F can mask FIQ exceptions.\n\nIn an ARMv7 implementation that does not include the Security Extensions, setting one of these bits to 1 masks the\ncorresponding exception, meaning the exception cannot be taken.\n\nIn an implementation that includes the Security Extensions, the SCR.{AW, FW} bits provide a mechanism to\nprevent use of the CPSR.{A, F} mask bits by Non-secure software. In an implementation that includes the\nVirtualization Extensions:\n• HCR.{AMO, FMO} modify this mechanism\n• HCR.IMO can prevent the masking, by CPSR.I, of IRQs taken from Non-secure state.\n\nWhen an SCR.{AW, FW} bit is set to 0, Non-secure software cannot update the corresponding\nCPSR bit.\n\nFixme [Table B1-11 Control of masking by CPSR.A] page1185\n\nFixme [Table B1-12 Control of masking by CPSR.I] page1185\n\nFixme [Table B1-13 Control of masking by CPSR.F] page1185\n\n##### B1.8.7 Summaries of asynchronous exception behavior\n###### Asynchronous exception behavior, Security Extensions only\nFixme [Table B1-14 Behavior of asynchronous aborts, Virtualization Extensions not implemented] page1187\n\nFixme [Table B1-15 Behavior of IRQ exceptions, Virtualization Extensions not implemented] page1188\n\nFixme [Table B1-16 Behavior of FIQ exceptions, Virtualization Extensions not implemented] page1188\n\n###### Asynchronous exception behavior, with the Virtualization Extensions\nFixme [Table B1-17 Behavior of asynchronous aborts, Virtualization Extensions implemented] page1189\n\nFixme [Table B1-18 Behavior of IRQ exceptions, Virtualization Extensions implemented] page1190\n\nFixme [Table B1-19 Behavior of FIQ exceptions, Virtualization Extensions implemented] page1191\n\n##### B1.8.8 Routing general exceptions to Hyp mode\nWhen HCR.TGE is set to 1, and the processor is in Non-secure User mode, the following exceptions are taken to\nHyp mode, instead of to the default Non-secure mode for handling the exception:\n• Undefined Instruction exceptions.\n• Supervisor Call exceptions.\n• Synchronous External aborts.\n• Any Alignment fault other than an alignment fault caused by the memory type when SCTLR.M is 1.\n\n##### B1.8.9 Routing Debug exceptions to Hyp mode\nWhen HDCR.TDE is set to 1, if the processor is executing in a Non-secure mode other than Hyp mode, any Debug\nexception is routed to Hyp mode. This means it generates a Hyp Trap exception\n\n##### B1.8.10 Exception return\nOn an exception return, the CPSR takes either:\n• the value loaded by the RFE instruction\n• if the exception return is not performed by executing an RFE instruction, the value of the current SPSR at the\ntime of the exception return\n\n###### Return from an exception taken to a PL1 mode\nFor an exception taken to a PL1 mode, the ARM architecture provides the following exception return instructions:\n• __Data-processing instructions with the S bit set and the PC as a destination__, see SUBS PC, LR (Thumb) on\npage B9-2010 and SUBS PC, LR and related instructions (ARM) on page B9-2012.\nTypically:\n\t— a return where no subtraction is required uses SUBS with an operand of 0, or the equivalent MOVS\n\tinstruction\n\t— a return requiring subtraction uses SUBS with a nonzero operand.\n\n• __From ARMv6, the RFE instruction, see RFE__ on page B9-2000. If a subtraction is required, typically it is\nperformed before saving the LR value to memory.\n\n• __In ARM state, a form of the LDM instruction__, see LDM (exception return) on page B9-1986. If a subtraction is\nrequired, typically it is performed before saving the LR value to memory.\n\n###### Return from an exception taken to a PL2 mode\nFor an exception taken to a PL2 mode, the ARM architecture provides the __ERET__ instruction, see ERET on\npage B9-1982. An exception handler executing in a PL2 mode must return using the ERET instruction.\nHyp mode is the only PL2 mode. Both Hyp mode and the ERET instruction are implemented only as part of the\nVirtualization Extensions.\n\n##### B1.8.11 Virtual exceptions in the Virtualization Extensions\n\nFixme [Table B1-20 HCR bits controlling asynchronous exceptions] page1198\n\n##### B1.8.12 Low interrupt latency configuration\nSetting SCTLR.FI to 1 enables the low interrupt latency configuration of an implementation. This configuration can\nreduce the interrupt latency of the processor. The mechanisms implemented to achieve low interrupt latency are\nIMPLEMENTATION DEFINED. For the description of the SCTLR see either:\n• SCTLR, System Control Register, VMSA on page B4-1707\n• SCTLR, System Control Register, PMSA on page B6-1932\n\n##### B1.8.13 Wait For Event and Send Event\nARMv7 and ARMv6K provide a mechanism, the Wait For Event mechanism, that permits a processor in a\nmultiprocessor system to request __entry to a low-power state__, and, if the request succeeds, to remain in that state until\nit receives an event generated by a Send Event operation on another processor in the system.\n__example using for spin-lock__\n\nThe Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a\nNon-secure PL1 or PL0 mode.\n\n###### WFE wake-up events\nThe following events are WFE wake-up events:\n• the execution of an SEV instruction on any processor in the multiprocessor system\n• a physical IRQ interrupt, unless masked by the CPSR.I bit\n• a physical FIQ interrupt, unless masked by the CPSR.F bit\n• a physical asynchronous abort, unless masked by the CPSR.A bit\n• in Non-secure state in any mode other than Hyp mode:\n\t— when HCR.IMO is set to 1, a virtual IRQ interrupt, unless masked by the CPSR.I bit\n\t— when HCR.FMO is set to 1, a virtual FIQ interrupt, unless masked by the CPSR.F bit\n\t— when HCR.AMO is set to 1, a virtual asynchronous abort, unless masked by the CPSR.A bit\n• an asynchronous debug event, if invasive debug is enabled and the debug event is permitted\n• an event sent by the timer event stream, see Event streams on page B8-1964\n• an event sent by some IMPLEMENTATION DEFINED mechanism.\n\n###### The Event Register\nThe Event Register is __a single bit register for each processor__. When set, an event register indicates that an event has\noccurred, since the register was last cleared\n\nThe Event Register is set by:\n• an SEV instruction\n• an event sent by some IMPLEMENTATION DEFINED mechanism\n• a debug event that causes entry into Debug state\n• an exception return.\n\n###### The Send Event instruction\n__The Send Event instruction, SEV, causes an event to be signaled to all processors in the multiprocessor system.__\n__ARM recommends that software includes a DSB instruction before an SEV instruction__\n\nExecution of the Send Event instruction sets the Event Register. The Send Event instruction is available at all privilege levels\n\n###### The Wait For Event instruction\nThe action of the Wait For Event instruction depends on the state of the Event Register:\n• If the Event Register is set, the instruction clears the register and completes immediately. Normally, if this\nhappens the software makes another attempt to claim the lock.\n\n• If the Event Register is clear the processor can suspend execution and enter a low-power state. It can remain\nin that state until the processor detects a WFE wake-up event or a reset. When the processor detects a WFE\nwake-up event, or earlier if the implementation chooses, the WFE instruction completes.\n\nThe Wait For Event instruction, WFE, is available at all privilege levels,\n\n##### B1.8.14 Wait For Interrupt\nWhen a processor issues a WFI instruction it can suspend execution and enter a low-power state.\n\nThe Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a\nNon-secure PL1 or PL0 mode.\n\nThe processor can remain in the WFI low-power state until it is reset, or it detects one of the following WFI wake-up\nevents:\n• a physical IRQ interrupt, regardless of the value of the CPSR.I bit\n• a physical FIQ interrupt, regardless of the value of the CPSR.F bit\n• a physical asynchronous abort, regardless of the value of the CPSR.A bit\n• in Non-secure state in any mode other than Hyp mode:\n\t— when HCR.IMO is set to 1, a virtual IRQ interrupt, regardless of the value of the CPSR.I bit\n\t— when HCR.FMO is set to 1, a virtual FIQ interrupt, regardless of the value of the CPSR.F bit\n\t— when HCR.AMO is set to 1, a virtual asynchronous abort, regardless of the value of the CPSR.A bit\n• an asynchronous debug event, when invasive debug is enabled and the debug event is permitted.\n\n__WFI wake-up events cannot be masked by the mask bits in the CPSR.__\n\n__Using WFI to indicate an idle state on bus interfaces__\n\n[Linux cpuidle framework(1)_概述和软件架构](http://www.wowotech.net/pm_subsystem/cpuidle_overview.html)\n\n#### B1.9 Exception descriptions\nskip\n\n#### B1.10 Coprocessors and system control\nThe ARM architecture supports sixteen coprocessors, usually referred to as CP0 to CP15.\nThe architecture reserves two of these coprocessors, CP14 and CP15,\nfor configuration and control related to the architecture:\n• CP14 is reserved for the configuration and control of:\n\t— debug features, see The CP14 debug register interface on page C6-2123\n\t— trace features, see the Embedded Trace Macrocell Architecture Specification and the CoreSight\n\tProgram Flow Trace Architecture Specification\n\t— the Thumb Execution Environment, see Thumb Execution Environment on page B1-1240\n\t— direct Java bytecode execution, see Jazelle direct bytecode execution on page B1-1241.\n• CP15 is called the System Control coprocessor, and is reserved for the control and configuration of the ARM\nprocessor system, including architecture and feature identification.\n\nThe implementation of the CP15 registers depends heavily on whether the ARMv7 implementation is:\n• an ARMv7-A implementation with a Virtual Memory System Architecture (VMSA)\n• an ARMv7-R implementation with a Protected Memory System Architecture (PMSA).\nThe implementation of the CP14 registers is generally similar in ARMv7-A and ARMv7-R implementation.\n\nMost CP14 and CP15 registers are accessible only from PL1 or higher. For possible accesses from PL0:\n• The register descriptions in Chapter B4 System Control Registers in a VMSA implementation and Chapter B6\nSystem Control Registers in a PMSA implementation indicate whether a register is accessible from PL0.\n• The descriptions of the CP14 interface in Chapter C6 Debug Register Interfaces include the permitted\naccesses to the debug registers from PL0.\n• The following sections summarize the permitted accesses to CP15 registers from PL0:\n\t— for a VMSA implementation, PL0 views of the CP15 registers on page B3-1488\n\t— for a PMSA implementation, PL0 views of the CP15 registers on page B5-1797.\n\n#### B1.11 Advanced SIMD and floating-point support\nskip\n\n#### B1.12 Thumb Execution Environment\t\nskip\n\n#### B1.13 Jazelle direct bytecode execution\nskip\n\n#### B1.14 Traps to the hypervisor\n##### B1.14.1 General information about traps to the hypervisor\nThe Hyp Trap exception provides the standard mechanism for trapping Guest OS functions to the hypervisor. \nand enters the exception handler using the vector at\noffset 0x14 from the Hyp vector base address. For more information see Exception handling on page B1-1165\n\nA Hyp Trap exception can be generated only when all of the following apply:\n• The processor is both:\n\t— not in Debug state\n\t— in a Non-secure PL1 or PL0 mode.\n• Traps to Hyp mode never apply in Secure state, regardless of the value of the SCR.NS bit.\t\n\nB1.14.2 Trapping ID mechanisms\nFor a small number of frequently-accessed ID registers, the Virtualization Extensions provide read/write aliases of\nthe registers, accessible only from Hyp mode, or from Secure state. A read of the original ID register from a\nNon-secure PL1 mode actually returns the value of the read/write alias register.\n\nFixme [Table B1-26 ID register substitution by the Virtualization Extensions] page1251\n\nFixme [Table B1-27 ID register groups for Hyp Trap exceptions] page1252\n\nB1.14.17 Summary of trap controls\n\nFixme [Table B1-29 Summary of Hyp trap controls] page1262\n\n### B2 Common Memory System Architecture Features\n\n#### B2.2 Caches and branch predictors\n\n##### B2.2.1 Cache identification\n\nThe ARMv7 cache identification consists of a set of registers that describe the implemented caches that are under\nthe control of the processor:\n• A single Cache Type Register defines:\n\t— the __minimum line length of any of the instruction caches__\n\t— the __minimum line length of any of the data or unified caches__\n\t— the __cache indexing and tagging policy of the Level 1 instruction cache.__\n\tFor more information, see:\n\t— CTR, Cache Type Register, VMSA on page B4-1556, for a VMSA implementation\n\t— CTR, Cache Type Register, PMSA on page B6-1835, for a PMSA implementation.\n\n• A single Cache Level ID Register defines:\n\t— the __type of cache implemented at a each cache level, up to the maximum of seven levels__\n\t— the Level of Coherence (LoC) for the caches\n\t— the Level of Unification (LoU) for the caches.\n\tFor more information, see:\n\t— CLIDR, Cache Level ID Register, VMSA on page B4-1530, for a VMSA implementation\n\t— CLIDR, Cache Level ID Register, PMSA on page B6-1816, for a PMSA implementation\n\n• A single Cache Size Selection Register selects the cache level and cache type of the current Cache Size\nIdentification Register, see:\n\t— CSSELR, Cache Size Selection Register, VMSA on page B4-1555, for a VMSA implementation\n\t— CSSELR, Cache Size Selection Register, PMSA on page B6-1834, for a PMSA implementation.\t\n\n• For each implemented cache, across all the levels of caching, a Cache Size Identification Register defines:\n\t— __whether the cache supports Write-Through, Write-Back, Read-Allocate and Write-Allocate__\n\t— __the number of sets, associativity and line length of the cache__\n\tFor more information, see:\n\t— CCSIDR, Cache Size ID Registers, VMSA on page B4-1528, for a VMSA implementation\n\t— CCSIDR, Cache Size ID Registers, PMSA on page B6-1814, for a PMSA implementation.\n\n###### Identifying the cache resources in ARMv7\t\nIn ARMv7 the architecture defines support for multiple levels of cache, up to a maximum of seven levels.\nsoftware must:\n1. __Read the Cache Type Register to find the indexing and tagging policy used for the Level 1 instruction cache.__\nThis register also provides the size of the smallest cache lines used for the instruction caches, and for the data\nand unified caches. These values are used in cache maintenance operations.\n\n2. __Read the Cache Level ID Register to find what caches are implemented__. The register includes seven Cache\ntype fields, for cache levels 1 to 7. Scanning these fields, starting from Level 1, identifies the instruction, data\nor unified caches implemented at each level. This scan ends when it reaches a level at which no caches are\ndefined. The Cache Level ID Register also provides the Level of Unification (LoU) and the Level of\nCoherence (LoC) for the cache implementation.\n\n3. For each cache identified at stage 2:\n• __Write to the Cache Size Selection Register to select the required cache.__ A cache is identified by its\nlevel, and whether it is:\n\t— an instruction cache\n\t— a data or unified cache.\n• Read the Cache Size ID Register to find details of the cache.\n\n##### B2.2.2 Cache behavior\n###### General behavior of the caches\nWhen a memory location is marked with a Normal Cacheable memory attribute, determining whether a copy of the\nmemory location is held in a cache still depends on many aspects of the implementation. The following\nnon-exhaustive list of factors might be involved:\n• the size, line length, and associativity of the cache\n• the cache allocation algorithm\n• activity by other elements of the system that can access the memory\n• speculative instruction fetching algorithms\n• speculative data fetching algorithms\n• interrupt behaviors.\n\nFor the purpose of these principles, a cache entry covers at least 16 bytes and no more than 2KB of contiguous\naddress space, aligned to its size.\n\n###### Behavior of the caches at reset\nIn ARMv7:\n• All caches are disabled at reset.\n• An implementation can require the use of a specific cache initialization routine to invalidate its storage array\nbefore it is enabled.\n\n\nB2.2.3 Cache enabling and disabling\nLevels of cache on page B2-1265 indicates that:\n• In ARMv7 the architecture defines the control of multiple levels of cache.\n• Before ARMv7 the architecture defines the control of only one level of cache.\n\nIn ARMv7:\n• SCTLR.C enables or disables all data and unified caches for data accesses, across all levels of cache visible\nto the processor. It is IMPLEMENTATION DEFINED whether it also enables or disables the use of unified caches\nfor instruction accesses.\n• SCTLR.I enables or disables all instruction caches, across all levels of cache visible to the processor.\n\t- SCTLR, System Control Register, VMSA on page B4-1707, for a VMSA implementation\n\t- SCTLR, System Control Register, PMSA on page B6-1932, for a PMSA implementation.\n\n\n##### B2.2.4 Branch predictors\nBranch predictor hardware typically uses a form of cache to hold branch information. The ARM architecture\npermits this branch predictor hardware to be visible to software, and so the branch predictor is not architecturally\ninvisible. This means that under some circumstances software must perform branch predictor maintenance to avoid\nincorrect execution caused by out-of-date entries in the branch predictor.\n\n###### Requirements for branch predictor maintenance operations\nthe instructions at the virtual addresses change:\n• enabling or disabling the MMU\n• writing new mappings to the translation tables\n• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,\nor a change to the VMID\n• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID.\n\nthen branch predictor maintenance operations must be performed to invalidate entries in the branch\npredictor, to ensure that the change is visible to subsequent execution.\n\n##### B2.2.6 About ARMv7 cache and branch predictor maintenance functionality\n\n###### Terms used in describing the maintenance operations\n• by the address of the memory location to be maintained, referred to as operating by MVA\n• by a mechanism that describes the location in the hardware of the cache, referred to as operating by set/way.\n\n\n###### Terminology for operations by MVA\nThe term Modified Virtual Address (MVA) relates to the Fast Context Switch Extension (FCSE) mechanism,described in Appendix D10 Fast Context Switch Extension (FCSE). When the FCSE is absent or disabled, the MVA and VA have the same value.\n\nVirtual addresses only exist in systems with a MMU. When no MMU is implemented, or all applicable MMUs are disabled, the MVA and VA are identical to the PA.\n\n###### Terminology for operations by set/way\nCache maintenance operations by set/way refer to the particular structures in a cache.\n\n__Level__\nThe cache level of the hierarchy.\n\n__Set__\nEach level of a cache is split up into a number of sets. Each set is a set of locations in a cache level to which an address can be assigned.\n\n__Way__\nThe Associativity of a cache defines the number of locations in a set to which an address can be assigned.\n\n##### B2.2.7 Cache and branch predictor maintenance operations\nCache and branch predictor maintenance operations are performed using accesses to CP15 c7. The following\nsections define the encodings for these operations:\n• Cache and branch predictor maintenance operations, VMSA on page B4-1743, for a VMSA implementation\n• Cache and branch predictor maintenance operations, PMSA on page B6-1943, for a PMSA implementation.\n\n###### Summary of cache and branch predictor maintenance operations\n__Data cache and unified cache operations__\nOperations by MVA\nThe data and unified cache operations by MVA are:\nDCIMVAC   Invalidate, to point of coherency.\nDCCMVAC   Clean, to point of coherency.\nDCCMVAU   Clean, to point of unification.\nDCCIMVAC  Clean and invalidate, to point of coherency.\n\nOperations by set/way\nThe data and unified cache operations by set/way are:\nDCISW     Invalidate.\nDCCSW     Clean.\nDCCISW    Clean and invalidate, to point of coherency.\n\n__Instruction cache operations__\nOperation by MVA\nICIMVAU \tInvalidate, to point of unification.\n\nOperations on all entries\nThe instruction cache operations that operate on all entries are:\nICIALLU \tInvalidate all, to point of unification.\nICIALLUIS \tInvalidate all, to point of unification, Inner Shareable.\n\n__Branch predictor operations__\nOperation by MVA\nBPIMVA \tInvalidate.\n\nOperations on all entries\nBPIALL \t\tInvalidate all.\nBPIALLIS \tInvalidate all, Inner Shareable.\n\n### B3 Virtual Memory System Architecture (VMSA)\n#### B3.1 About the VMSA\nIn VMSAv7, a Memory Management Unit (MMU) controls address translation, access permissions, and memory\nattribute determination and checking.\n\nEach supported stage of memory system control is provided by an MMU, with its own independent set of controls.\nTherefore, the Extended VMSAv7 provides the following MMUs:\n• Secure PL1&0 stage 1 MMU\n• Non-secure PL2 stage 1 MMU\n• Non-secure PL1&0 stage 1 MMU\n• Non-secure PL1&0 stage 2 MMU.\n\nFixme [Figure B3-1 VMSA translation regimes, and associated MMUs]page1309\n\n##### B3.1.1 Address types used in a VMSA description\n\n###### Virtual Address (VA)\nAn address used in an instruction, as a data or instruction address, is a Virtual Address (VA).\n__An address held in the PC, LR, or SP, is a VA.__\n\n###### Modified Virtual Address (MVA)\nOn an implementation that implements and uses the FCSE(Appendix D10 Fast Context Switch Extension (FCSE)), the FCSE takes a VA and transforms it to an MVA. \n\n###### Intermediate Physical Address (IPA)\nIn a translation regime that provides two stages of address translation, the IPA is the address after\nthe stage 1 translation, and is the input address for the stage 2 translation.\n\n###### Physical Address (PA)\n\n##### B3.1.2 Address spaces in a VMSA implementation\nThe ARMv7 architecture supports:\n• A VA address space of up to 32 bits. The actual width is IMPLEMENTATION DEFINED.\n• An IPA address space of up to 40 bits. The translation tables and associated system control registers define the width of the implemented address space.\n\nNote:\n>The Large Physical Address Extension defines two translation table formats. The Long-descriptor format gives access to the full 40-bit IPA or PA address space at a granularity of 4KB. The Short-descriptor format:\n• Gives access to a 32-bit PA address space at 4KB granularity.\n• Optionally, gives access to a 40-bit PA address space, but only at 16MB granularity.\n\nIf an implementation includes the Security Extensions, __the address maps are defined independently for Secure and Non-secure operation, providing two independent 40-bit address spaces__, where:\n• a VA accessed from Non-secure state can only be translated to the Non-secure address map\n• a VA accessed from Secure state can be translated to either the Secure or the Non-secure address map.\n\n##### B3.1.3 About address translation\n##### B3.1.3.1. VMSAv7 without the Security Extensions\nSupports only a single PL1&0 stage 1 MMU. Operation of this MMU can be split between two sets of translation tables, defined by TTBR0 and TTBR1, and controlled by TTBCR.\n\n##### B3.1.3.2. VMSAv7 with the Security Extensions but without the Virtualization Extensions\nSupports only the Secure PL1&0 stage 1 MMU and the Non-secure PL1&0 stage 1 MMU.\n\nOperation of each of these MMUs can be split between two sets of translation tables, __defined by the Secure and Non-secure copies of TTBR0 and TTBR1, and controlled by the Secure and Non-secure copies of TTBCR.__\n\n__Note__: Secure and Non-secure has copies of TTBR0 and TTBR1, TTBCR.\n\n##### B3.1.3.3. VMSAv7 with Virtualization Extensions\n__Secure PL1&0 stage 1 MMU__\nOperation of this MMU can be split between two sets of translation tables, defined by the Secure copies of TTBR0 and TTBR1, and controlled by the Secure copy of TTBCR.\n\n__Non-secure PL2 stage 1 MMU__\nThe HTTBR defines the translation table for this MMU, controlled by HTCR.\n\n__Non-secure PL1&0 stage 1 MMU__\nOperation of this MMU can be split between two sets of translation tables, defined by the Non-secure copies of TTBR0 and TTBR1 and controlled by the Non-secure copy of TTBCR.\n\n__Non-secure PL1&0 stage 2 control__\nThe VTTBR defines the translation table for this MMU, controlled by VTCR.\n\nFixme [Figure B3-2 Memory translation summary, with Virtualization Extensions]Page 1312\n\nA full translation table lookup is called a translation table walk.It is performed automatically by hardware.\n\n__Translation Lookaside Buffers (TLBs)__ reduce the average cost of a memory access by caching the results of translation table walks.\n\nTo reduce the software overhead of TLB maintenance, the VMSA distinguishes between Global pages and Process-specific pages. The __Address Space Identifier (ASID)__ identifies pages associated with __a specific process__ and provides a mechanism for changing process-specific tables without having to maintain the TLB tructures.\n\nIf an implementation includes the Virtualization Extensions, the __virtual machine identifier (VMID)__ identifies the current virtual machine, with its own independent ASID space.\n\n#### B3.2 The effects of disabling MMUs on VMSA behavior\nAbout the VMSA on page B3-1308 defines the translation regimes and the associated MMUs. The VMSA includes\nan enable bit for each MMU, as follows:\n• SCTLR.M, in the Secure copy of the register, controls Secure PL1&0 stage 1 MMU\n• SCTLR.M, in the Non-secure copy of the register, controls Non-secure PL1&0 stage 1 MMU\n• HCR.VM controls Non-secure PL1&0 stage 2 MMU\n• HSCTLR.M controls Non-secure PL2 stage 1 MMU.\n\n##### B3.2.1 VMSA behavior when a stage 1 MMU is disabled\n###### Non-secure PL1 and PL0 accesses when HCR.DC is set to 1, Virtualization Extensions\nIn an implementation that includes the Virtualization Extensions, for an access from a Non-secure PL1 or PL0 mode when HCR.DC is set to 1, the stage 1 translation assigns the Normal Non-shareable, Inner Write-Back Write-Allocate, Outer Write-Back Write-Allocate memory attributes.\n\n###### All other accesses\n__Data access__\nThe stage 1 translation assigns the Strongly-Ordered memory type.\n\nNote\nThis means the access is Non-cacheable. Unexpected data cache hit behavior is IMPLEMENTATION DEFINED.\n\n__Instruction access__\nThe stage 1 translation assigns Normal memory attribute, with the cacheability and\nshareability attributes determined by the value of:\n• the Secure copy of SCTLR.I for the Secure PL1&0 translation regime\n• the Non-secure copy of SCTLR.I for the Non-secure PL1&0 translation regime\n• HSCTLR.I for the Non-secure PL2 translation regime.\n\n##### B3.2.2 VMSA behavior when the stage 2 MMU is disabled\nWhen the stage 2 MMU is disabled:\n• the IPA output from the stage 1 translation maps __flat to the PA__\n• the memory attributes and permissions from the stage 1 translation apply to the PA.\n\nIf the stage 1 MMU and the stage 2 MMU are both disabled, see Behavior of instruction fetches when all associated\nMMUs are disabled.\n\n#### B3.3 Translation tables\nVMSAv7 defines two alternative translation table formats:\n\n__Short-descriptor format__\nThis is the original format defined in issue A of this Architecture Reference Manual, and is the only format supported on implementations that do not include the Large Physical Address Extension. It uses 32-bit descriptor entries in the translation tables, and provides:\n• __Up to two levels of address lookup.__\n• __32-bit input addresses.__\n• __Output addresses of up to 40 bits.__\n• Support for PAs of more than 32 bits by use of supersections, with 16MB granularity.\n• Support for No access, Client, and Manager domains.\n• __32-bit table entries.__\n\n__Long-descriptor format__\nThe Large Physical Address Extension adds support for this format. It uses 64-bit descriptor entries in the translation tables, and provides:\n• __Up to three levels of address lookup.__\n• __Input addresses of up to 40 bits, when used for stage 2 translations.__\n• __Output addresses of up to 40 bits.__\n• 4KB assignment granularity across the entire PA range.\n• No support for domains, all memory regions are treated as in a Client domain.\n• __64-bit table entries.__\n• Fixed 4KB table size, unless truncated by the size of the input address space.\n\nThe Large Physical Address Extension is an OPTIONAL extension, but an implementation that includes the Virtualization Extensions must also include the Large Physical Address Extension.\n\n##### B3.3.1 Translation table walks\nA translation table walk occurs as the result of a TLB miss, and starts with a read of the appropriate starting-level\ntranslation table.\n\nThe physical address of the base of the starting-level translation table is determined from the appropriate Translation\ntable base register (TTBR).\n\n##### B3.3.2 Information returned by a translation table lookup\nIf the required translation table descriptor is not held in a TLB, a translation table walk is performed to obtain the descriptor. A lookup, whether from the TLB or as the result of a translation table walk, returns both:\n• an output address that corresponds to the input address for the lookup\n• a set of properties that correspond to that output address.\n\nThe returned properties are classified as providing __address map control, access controls, or region attributes.__\n\n##### B3.3.3 Determining the translation table base address\n\nFixme[Figure B3-2 Memory translation summary, with Virtualization Extensions]page1312\n\n##### B3.3.4 Security Extensions control of translation table walks\nWhen an implementation includes the Security Extensions, two bits in the TTBCR for the current security state\ncontrol whether a translation table walk is performed on a TLB miss. These two bits are the:\n• PD0 and PD1 bits, on a processor using the Short-descriptor translation table format\n• EPD0 and EPD1 bits, on a processor using the Long-descriptor translation table format.\n\nThe effect of these bits is:\n{E}PDx == 0 If a TLB miss occurs based on TTBRx, a translation table walk is performed. The current security\nstate determines whether the memory access is Secure or Non-secure.\n{E}PDx == 1 If a TLB miss occurs based on TTBRx, a First level Translation fault is returned, and no translation\ntable walk is performed.\n\n##### B3.3.5 Access to the Secure or Non-secure physical address map\nAs stated in Address spaces in a VMSA implementation on page B3-1311, a processor that implements the Security\nExtensions implements independent Secure and Non-secure address maps. These are defined by the translation\ntables identified by the Secure TTBR0 and TTBR1. In both translation table formats:\n• In the Secure translation tables, the NS bit in a descriptor indicates whether the descriptor refers to the Secure\nor the Non-secure address map:\nNS == 0 Access the Secure physical address space.\nNS == 1 Access the Non-secure physical address space.\n\n#### B3.5 Short-descriptor translation table format\nThe Short-descriptor translation table format supports a memory map based on memory sections or pages:\n__Supersections__\nConsist of 16MB blocks of memory. Support for Supersections is optional, except that an\nimplementation that includes the Large Physical Address Extension and supports more that 32 bits\nof Physical Address must also support Supersections to provide access to the entire Physical\nAddress space.\n\n__Sections__\nConsist of 1MB blocks of memory.\n\n__Large pages__\nConsist of 64KB blocks of memory.\n\n__Small pages__\nConsist of 4KB blocks of memory.\n\nWhen using the Short-descriptor translation table format, two levels of translation tables are held in memory: \n- First-level table  \n- Second-level tables  \n\nIn the translation tables, in general, a descriptor is one of:\n• an invalid or fault entry\n• a page table entry, that points to a next-level translation table\n• a page or section entry, that defines the memory properties for the access\n• a reserved format.\nBits[1:0] of the descriptor give the primary indication of the descriptor type.\n\nFixme[Figure B3-3 General view of address translation using Short-descriptor format translation tables] Page 1325\n\n##### B3.5.1 Short-descriptor translation table format descriptors\n###### Short-descriptor translation table first-level descriptor formats\n\nFixme [Figure B3-4 Short-descriptor first-level descriptor formats] Page1326\n\nDescriptor bits[1:0] identify the descriptor type.\n\n###### Short-descriptor translation table second-level descriptor formats\nFixme [Figure B3-5 Short-descriptor second-level descriptor formats] Page1327\n\n##### B3.5.2 Memory attributes in the Short-descriptor translation table format descriptors\n\n__TEX[2:0], C, B__\nMemory region attribute bits, see Memory region attributes on page B3-1366.\nThese bits are not present in a Page table entry\n\n__XN bit__\nThe Execute-never bit. Determines whether the processor can execute software from the addressed\nregion, see Execute-never restrictions on instruction fetching on page B3-1359.\nThis bit is not present in a Page table entry.\n\n__PXN bit, when supported__\nThe Privileged execute-never bit:\n• On an implementation that does not include the Large Physical Address Extension, support\nfor the PXN bit in the Short-descriptor translation table format is OPTIONAL.\n• On an implementation that includes the Large Physical Address Extension, the\nShort-descriptor translation table format must include the PXN bit.\n\n__NS bit__\nNon-secure bit. If an implementation includes the Security Extensions, for memory accesses from\nSecure state, this bit specifies whether the translated PA is in the Secure or Non-secure address map\n\n__Domain__\nDomain field, see Domains, Short-descriptor format only on page B3-1362.\nPage table descriptor applies to all entries in the corresponding second-level translation table.\n\n__AP[2], AP[1:0]__\nAccess Permissions bits, see Memory access control on page B3-1356\n\n__S bit__\nThe Shareable bit.\n\n__nG bit__\nThe not global bit. Determines how the translation is marked in the TLB, see Global and\nprocess-specific translation table entries on page B3-1378.\n\n##### B3.5.4 Selecting between TTBR0 and TTBR1, Short-descriptor translation table format\nthe value of TTBCR.N indicates the number of most significant bits of the input VA that determine whether TTBR0 or TTBR1 :\n• If N == 0 then use TTBR0. Setting TTBCR.N to zero disables use of a second set of translation tables.\n• if N > 0 then:\n\t— if bits[31:32-N] of the input VA are all zero then use TTBR0\n\t— otherwise use TTBR1.\n\nFixme [Table B3-1 Effect of TTBCR.N on address translation, Short-descriptor format] page1330\nWhenever TTBCR.N is nonzero, the size of the translation table addressed by TTBR1 is 16KB.\n\nFixme [Figure B3-6 How TTBCR.N controls the boundary between the TTBRs, Short-descriptor format] page1331\n\n##### B3.5.5 Translation table walks, when using the Short-descriptor translation table format\n\n###### Reading a first-level translation table\nFixme [Figure B3-7 Accessing first-level translation table based on TTBR0, Short-descriptor format] page1332\n\n###### The full translation flow for Sections, Supersections, Small pages and Large pages\nFixme [Figure B3-11 Small page address translation] page1337\n\n#### B3.6 Long-descriptor translation table format\n\nFixme [Figure B3-12 General view of stage 1 address translation using Long-descriptor format]page1338\n\n##### B3.6.1 Long-descriptor translation table format descriptors\nIn general, a descriptor is one of:\n• an invalid or fault entry\n• a table entry, that points to the next-level translation table\n• a block entry, that defines the memory properties for the access\n• a reserved format.\n\n###### Long-descriptor translation table first-level and second-level descriptor formats\n\nFixme [Figure B3-14 Long-descriptor first-level and second-level descriptor formats]page1340\n\n###### Long-descriptor translation table third-level descriptor formats\nFixme [Figure B3-15 Long-descriptor third-level descriptor formats]page1341\n\n##### B3.6.3 Control of Secure or Non-secure memory access, Long-descriptor format\n\nIn the Long-descriptor format:\n• the NS bit relates only to the memory block or page at the output address defined by the descriptor\n• the descriptors also include an NSTable bit, see Hierarchical control of Secure or Non-secure memory\naccesses, Long-descriptor format.\n\nNSTable == 0 The defined table address is in the Secure physical address space. \nNSTable == 1 The defined table address is in the Non-secure physical address space.\n\n##### B3.6.4 Selecting between TTBR0 and TTBR1, Long-descriptor translation table format\nThe TTBCR.T0SZ and TTBCR.T1SZ size fields control the use of TTBR0 and TTBR1,\n\nFixme [Table B3-2 Use of TTBR0 and TTBR1, Long-descriptor format]page1345\n\nFixme [Figure B3-18 Control of TTBR boundary, when TTBCR.T1SZ is zero]page1346\n\n##### B3.6.5 Long-descriptor translation table format address lookup levels\n\nFixme [Table B3-3 Properties of the three levels of address lookup with Long-descriptor translation tables]page1348\n\n##### B3.6.6 Translation table walks, when using the Long-descriptor translation table format\nExample Full translation flow, starting at second-level lookup\nFixme [Figure B3-22 Complete Long-descriptor format stage 1 translation, starting at second level]page1355\n\n### B3.7 Memory access control\nIn addition to an output address, a translation table entry that refers to page or region of memory includes fields that\ndefine properties of the target memory region.\n\n##### B3.7.1 Access permissions\nAccess permission bits in a translation table descriptor control access to the corresponding memory region. The\nShort-descriptor translation table format supports two options for defining the access permissions:\n• three bits, AP[2:0], define the access permissions\n• two bits, AP[2:1], define the access permissions, and AP[0] can be used as an Access flag.\n\nSCTLR.AFE selects the access permissions option. Setting this bit to 1, to enable the Access flag, also selects use\nof AP[2:1] to define access permissions\n\nThe Long-descriptor translation table format uses only AP[2:1] to control the access permissions, and provides an\nAF bit for use as an Access flag\n\n###### AP[2:1] access permissions model\nFixme [Table B3-6 VMSAv7 AP[2:1] access permissions model]page1357\n\n###### AP[2:0] access permissions control, Short-descriptor format only\nFixme [Table B3-8 VMSAv7 MMU access permissions]page1358\n\n##### B3.7.2 Execute-never restrictions on instruction fetching\nExecute-never (XN) controls provide an additional level of control on memory accesses permitted by the access\npermissions settings. \n\n__XN, Execute-never__\nWhen the XN bit is 1, a Permission fault is generated if the processor attempts to execute an\ninstruction fetched from the corresponding memory region. \n\n__PXN, Privileged execute-never__\nWhen the PXN bit is 1, a Permission fault is generated if the processor is executing at PL1 and\nattempts to execute an instruction fetched from the corresponding memory region. \n\n##### B3.7.3 Domains, Short-descriptor format only\nA domain is a collection of memory regions. The Short-descriptor translation table format supports 16 domains, and\nrequires the software that defines a translation table to assign each VMSA memory region to a domain. \n\n##### B3.7.4 The Access flag\nThe Access flag indicates when a page or section of memory is accessed for the first time since the Access flag in\nthe corresponding translation table descriptor was set to 0\n\n##### B3.7.5 PL2 control of Non-secure access permissions\nNon-secure software executing at PL2 controls two sets of translation tables, both of which use the Long-descriptor\ntranslation table format:\n• The translation tables that control the Non-secure PL2 stage 1 translations. These map VAs to PAs, for\nmemory accesses made when executing in Non-secure state at PL2, and are indicated and controlled by the\nHTTBR and HTCR.\n\nThe HAP[2:1] field in the stage 2 descriptors define the stage 2 access permissions\nFixme [Table B3-9 Stage 2 control of access permissions]page1365\n\n#### B3.8 Memory region attributes\n\n##### B3.8.1 Overview of memory region attributes for stage 1 translations\n__Memory type and attributes__\nThese are described either:\n• Directly, by bits in the translation table descriptor.\n• Indirectly, by registers referenced by bits in the table descriptor. This is described as\nremapping the memory type and attribute description.\n\nThe Short-descriptor translation table format can use either of these approaches, selected by the\nSCTLR.TRE bit:\nTRE == 0 Remap disabled. The TEX[2:0], C, and B bits in the translation table descriptor define\nthe memory region attributes. \n\nTRE == 1 Remap enabled. The TEX[0], C, and B bits in the translation table descriptor are index\nbits to the MMU remap registers, that define the memory region attributes:\n• the Primary Region Remap Register, PRRR\n• the Normal Memory Remap Register, NMRR\n\nThe Long-descriptor translation table format always uses remapping. \n\n__Shareability__\nIn the Short-descriptor translation table format, the S bit in the translation table descriptor encodes\nwhether the region is shareable. \n\n##### B3.8.2 Short-descriptor format memory region attributes, without TEX remap\nFixme [Table B3-10 TEX, C, and B encodings when TRE == 0]page1367\n\nCacheable memory attributes, without TEX remap\nWhen TEX[2] == 1, the translation table entry describes Cacheable memory, and the rest of the encoding defines\nthe Inner and Outer cache attributes:\nTEX[1:0] Define the Outer cache attribute.\nC, B Define the Inner cache attribute.\n\nFixme [Table B3-11 Inner and Outer cache attribute encoding]page1368\n\n##### B3.8.3 Short-descriptor format memory region attributes, with TEX remap\n• The software that defines the translation tables must program the PRRR and NMRR to define seven possible\nmemory region attributes.\n• The TEX[0], C, and B bits of the translation table descriptors define the memory region attributes, by\nindexing PRRR and NMRR.\n\nFixme [Table B3-12 TEX, C, and B encodings when TRE == 1]page1369\n\n##### B3.8.4 Long-descriptor format memory region attributes\nthe AttrIndx[2:0] field in a block or page translation table descriptor for a stage 1 translation indicates the 8-bit field in the appropriate MAIR, that specifies\nthe attributes for the corresponding memory region:\n• AttrIndx[2] indicates the value of n in MAIRn:\nAttrIndx[2] == 0 Use MAIR0.\nAttrIndx[2] == 1 Use MAIR1\n\n• AttrIndx[2:0] indicates the required Attr field, Attrn, where n = AttrIndx[2:0].\nEach AttrIndx field defines, for the corresponding memory region:\n• The memory type, Strongly-ordered, Device, or Normal.\n• For Normal memory\n\t— the inner and outer cacheability, Non-cacheable, Write-Through, or Write-Back\n\t— for Write-Through Cacheable and Write-Back Cacheable regions, the Read-Allocate and\n\tWrite-Allocate policy hints, each of which is Allocate or Do not allocate\n\n###### Shareability, Long-descriptor format\nFixme [Table B3-14 SH[1:0] field encoding for Normal memory, Long-descriptor format]page1373\n\nFor a Device or Strongly-ordered memory region, the value of the SH[1:0] field of the translation table descriptor\nis ignored.\n\n#### B3.9 Translation Lookaside Buffers (TLBs)\nTranslation Lookaside Buffers (TLBs) are an implementation technique that caches translations or translation table entries.\nTLBs avoid the requirement for every memory access to perform a translation table walk in memory. \n\n##### B3.9.1  Global and process-specific translation table entries\nIn a VMSA implementation, system software can divide a virtual memory map used by memory accesses at PL1 and PL0 into global and non-global regions, indicated by the nG bit in the translation table descriptors:\nnG == 0 \nThe translation is global, meaning the region is available for all processes.\n\nnG == 1 \nThe translation is non-global, or process-specific, meaning it relates to the current ASID, as defined by the CONTEXTIDR.\n\n##### B3.9.2  TLB matching\n\n##### B3.9.3  TLB behavior at reset\nThe ARMv7 architecture does not require a reset to invalidate the TLB. All TLBs are disabled from reset. All MMUs are disabled from reset, and the contents of the TLBs have no effect on address translation.\n\n##### B3.9.5  TLB conflict aborts\nThe Large Physical Address Extension introduces the concept of a TLB conflict abort, and adds fault status encodings for such an abort.\n\nAn implementation can generate a TLB conflict abort if it detects that the address being looked up in the TLB hits multiple entries.\nIn some implementations, multiple hits in the TLB can generate a synchronous Data Abort or Prefetch Abort exception.\n\n#### B3.10 TLB maintenance requirements\n##### B3.10.1  General TLB maintenance requirements\n__The architecture defines CP15 c8 functions for TLB maintenance operations__, and supports the following operations:  \n- invalidate all unlocked entries in the TLB  \n- invalidate a single TLB entry, by MVA, or MVA and ASID for a non-global entry  \n- invalidate all TLB entries that match a specified ASID. \n  \nThe Multiprocessing Extensions add the following operations:\n• invalidate all TLB entries that match a specified MVA, regardless of the ASID\n\n###### Using break-before-make when updating translation table entries\n\nARM strongly recommends the use of a break-before-make when changing translation table entries whenever multiple threads of execution can use the same translation tables and the change to the translation entries involves any of:\n• A change of the memory type.\n• A change of the cacheability attributes.\n• A change of the output address (OA), if the OA of at least one of the old translation table entry and the new\ntranslation table entry is writable.\n\n__break-before-make__\n1.  Replace the old translation table entry, and execute DSB instruction.  \n2.  Invalidate the translation table entry with a broadcast TLB invalidation instruction, and execute a DSB instruction  \n3.  Write the new translation table entry, and execute a DSB instruction   \n\n##### B3.10.2 Maintenance requirements on changing system control register values\nThe TLB contents can be influenced by control bits in a number of system control registers. \n\nThe system control register changes that this applies to are:\n• any change to the NMRR, PRRR, MAIRn, or HMAIRn registers\n• any change to the SCTLR.AFE bit, see Changing the Access flag enable\n• any change to the SCTLR.TRE bit\n• any change to the translation table base address in TTBR0\n• any change to the translation table base address in TTBR1\n• in an implementation that includes the Virtualization Extensions:\n\t— any change to the SCTLR.{WXN, UWXN} bits\n\t— any change to the SCR.SIF bit\n\t— any change to the HCR.VM bit\n\t— any change to HCR.PTW bit, see Changing HCR.PTW\n\t— any change to the HTTBR.BADDR field\n\t— any change to the VTTBR.BADDR field\n• in an implementation that includes the Large Physical Address Extension, changing TTBCR.EAE, see\nChanging the current Translation table format on page B3-1386\n• when using the Short-descriptor translation table format:\n\t— any change to the RGN, IRGN, S, or NOS fields in TTBR0 or TTBR1\n\t— any change to the PD0 or PD1 fields in TTBCR\n• when using the Long-descriptor translation table format:\n\t— any change to the TnSZ, ORGNn, IRGNn, SHn, or EPDn fields in the TTBCR, where n is 0 or 1\n\t— any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the HTCR\n\t— any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the VTCR.\n\n##### B3.10.3 Atomicity of register changes on changing virtual machine\nFrom the viewpoint of software executing in a Non-secure PL1 or PL0 mode, when there is a switch from one virtual\nmachine to another, the registers that control or affect address translation must be changed atomically. \n\nThis applies to the registers for:\n• Non-secure PL1&0 stage 1 address translations. This means that all of the following registers must change  atomically:\n\t— PRRR and NMRR, if using the Short-descriptor translation table format\n\t— MAIR0 and MAIR1, if using the Long-descriptor translation table format\n\t— TTBR0, TTBR1, TTBCR, DACR, and CONTEXTIDR\n\t— the SCTLR.\n\n__These registers apply to execution in Non-secure PL1&0 modes. However, when updated as part of a switch of virtual machines they are updated by software executing in Hyp mode.__\n\n• Non-secure PL1&0 stage 2 address translations. This means that all of the following registers and register\nfields must change atomically:\n\t— VTTBR and VTCR\n\t— HMAIR0 and HMAIR1\n\t— the HSCTLR.\n\n##### B3.11 Caches in a VMSA implementation\nB3.11.1 Data and unified caches\n__The behavior of accesses from the same observer to different VAs, that are translated to the same PA with the same memory attributes, is fully coherent.__ This means these accesses behave as follows, regardless of\nwhich VA is accessed:\n• two writes to the same PA occur in program order\n• a read of a PA returns the value of the last successful write to that PA\n• a write to a PA that occurs, in program order, after a read of that PA, has no effect on the value returned by\nthat read.\nThe memory system behaves in this way without any requirement to use barrier or cache maintenance operations.\n\n#### B3.11.2 Instruction caches\nIn the ARM architecture, an instruction cache is a cache that is accessed only as a result of an instruction fetch.\nTherefore, __an instruction cache is never written to by any load or store instruction executed by the processor.__\n\nThe ARMv7 architecture supports three different behaviors for instruction caches:\n• Physically-indexed, physically-tagged(PIPT) instruction caches\n• Virtually-indexed, physically-tagged (VIPT) instruction caches\n• ASID and VMID tagged Virtually-indexed, virtually-tagged (VIVT) instruction caches.\n\n##### B3.11.2.1 PIPT instruction caches & VIPT instruction caches\nFor PIPT instruction caches, the use of memory address translation is entirely transparent to all instruction fetches\nthat are not UNPREDICTABLE.\n\nAn implementation that provides PIPT/VIPT instruction caches implements the IVIPT extension, see IVIPT architecture\nextension \n\n##### B3.11.2.2 IVIPT architecture extension\nIt reduces the instruction cache maintenance requirement to the following condition:\n• instruction cache maintenance is required only after writing new data to a physical address that holds an\ninstruction.\n\n##### B3.11.2.3 ASID and VMID tagged VIVT instruction caches\nInstruction maintenance can also be required as a result of any of the following situations:\n• enabling or disabling the MMU\n• writing new mappings to the translation tables\n• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,\nor a change to the VMID\n• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID\n\n#### B3.12 VMSA memory aborts\nIn a VMSAv7 implementation, the following mechanisms cause a processor to take an exception on a failed memory\naccess:\n__Debug exception__\nAn exception caused by the debug configuration, see About debug exceptions on\npage C4-2090.\n\n__Alignment fault__\nAn Alignment fault is generated if the address used for a memory access does not have the\nrequired alignment for the operation. For more information see Unaligned data access on\npage A3-108 and Alignment faults on page B3-1402.\n\n__MMU fault__\nAn MMU fault is a fault generated by the fault checking sequence for the current translation\nregime.\n\n__External abort__\nAny memory system fault other than a Debug exception, an Alignment fault, or an MMU\nfault\n\n##### B3.12.1 Routing of aborts\nA memory abort is either a Data Abort exception or a Prefetch Abort exception. The mode to which a memory abort\nis taken depends on the reason for the exception, the mode the processor is in when it takes the exception:\n\n__Memory aborts taken to Monitor mode__\nIf an implementation includes the Security Extensions, when SCR.EA is set to 1, all External aborts\nare taken to Monitor mode. This applies to aborts taken from Secure modes and from Non-secure\nmodes. \n\n__Memory aborts taken to Secure Abort mode__\nIf an implementation includes the Security Extensions, when the processor is executing in Secure\nstate, all memory aborts that are not routed to Monitor mode are taken to Secure Abort mode.\n\n__Memory aborts taken to Hyp mode__\n大致都发生在Hyp mode，Non-secure 时至少也是在stage 2 发生的错误（stage 1 VA -> IPA; stage2 IPA-> PA. 虚拟地址->中间地址->物理地址）\n\nincludes the Virtualization Extensions, the processor is executing in Non-secure state\n• Alignment faults taken:\n\t— When the processor is in Hyp mode.\n\t— When the processor is in a PL1 or PL0 mode and the exception is generated because\n\tthe Non-secure PL1&0 stage 2 translation identifies the target of an unaligned access\n\tas Device or Strongly-ordered memory.\n\t— When the processor is in the PL0 mode and HCR.TGE is set to 1. For more\n\tinformation see Synchronous external abort, when HCR.TGE is set to 1 on\n\tpage B1-1193.\n\n• When the processor is using the Non-secure PL1&0 translation regime:\n\t— MMU faults from stage 2 translations, for which the stage 1 translation did not cause\n\tan MMU fault.\n\t— Any abort taken during the stage 2 translation of an address accessed in a stage 1\n\ttranslation table walk that is not routed to Secure Monitor mode\n• When the processor is using the Non-secure PL2 translation regime, MMU faults from\nstage 1 translations.\n\n• External aborts, if SCR.EA is set to 0 and any of the following applies:\n\t— The processor was executing in Hyp mode when it took the exception.\n\t— The processor was executing in a Non-secure PL0 or PL1 mode when it took the\n\texception, the abort is asynchronous, and HCR.AMO is set to 1.\n\t— The processor was executing in the Non-secure PL0 mode when it took the exception,\n\tthe abort is synchronous, and HCR.TGE is set to 1. For more information see\n\tSynchronous external abort, when HCR.TGE is set to 1 on page B1-1193.\n\t— The abort occurred on a stage 2 translation table walk.\n\n• Debug exceptions, if HDCR.TDE is set to 1.\n\n__Memory aborts taken to Non-secure Abort mode__\nIn an implementation that does not include the Security Extensions, all memory aborts are taken to\nAbort mode.\nOtherwise, when the processor is executing in Non-secure state, the following aborts are taken to\nNon-secure Abort mode:\n• When the processor is in a Non-secure PL1 or PL0 mode, Alignment faults taken for any of\nthe following reasons:\n\t— SCTLR.A is set to 1.\n\t— An instruction that does not support unaligned accesses is committed for execution,\n\tand the instruction accesses an unaligned address.\n\t— The implementation includes the Virtualization Extensions, and the PL1&0 stage 1\n\ttranslation identifies the target of an unaligned access as Device or Strongly-ordered\n\tmemory.\n• When the processor is using the Non-secure PL1&0 translation regime, MMU faults from\nstage 1 translations.\n• External aborts, if all of the following apply:\n\t— the abort is not on a stage 2 translation table walk\n\t— the processor is not in Hyp mode\n\t— SCR.EA is set to 0\n\t— the abort is asynchronous, and HCR.AMO is set to 0\n\t— the abort is synchronous, and HCR.TGE is set to 0• When the processor is using the Non-secure PL1&0 translation regime, MMU faults from\nstage 1 translations.\n• External aborts, if all of the following apply:\n\t— the abort is not on a stage 2 translation table walk\n\t— the processor is not in Hyp mode\n\t— SCR.EA is set to 0\n\t— the abort is asynchronous, and HCR.AMO is set to 0\n\t— the abort is synchronous, and HCR.TGE is set to 0\n\n##### B3.12.3 The MMU fault-checking sequence\nIn a VMSA implementation, all memory accesses require VA to PA translation. Therefore, when a corresponding\nMMU is enabled, each access requires a lookup of the translation table descriptor for the accessed VA. \n\nWhen using the Short-descriptor format\n• There are one or two levels of lookup.\n• Lookup always starts at the first level.\n• The final level of lookup checks the Domain field of the descriptor and:\n\t— faults if there is no access to the Domain\n\t— checks the access permissions only for Client domains.\nWhen using the Long-descriptor format\n• There are one, two, or three levels of lookup.\n• Lookup starts at either the first level or the second level.\n• Domains are not supported. All accesses are treated as Client domain accesses.\n\nFixme [Figure B3-23 Fetching the descriptor in a translation table walk]Page1400\n\nFixme [Figure B3-24 VMSA fault checking sequence]Page1401\n\n__Stage 2 fault on a stage 1 translation table walk, Virtualization Extensions__\nWhen an implementation that includes the Virtualization Extensions is operating in a Non-secure PL1 or PL0 mode,\nany memory access goes through two stages of translation:\n• stage 1, from VA to IPA\n• stage 2, from IPA to PA\n\n##### B3.12.4 Alignment faults\nThe ARMv7 memory architecture requires support for strict alignment checking. This checking is controlled by\nSCTLR.A.\n\nAn Alignment fault can occur on an access for which the MMU is disabled.\n\n__In an implementation that includes the Virtualization Extensions, any unaligned access to memory region with the Device or Strongly-ordered memory type attribute generates an Alignment fault.__\n\n##### B3.12.5 MMU faults\nThis section describes the faults that might be detected during one of the fault-checking sequences described in The\nMMU fault-checking sequence.\n\nThe following subsections describe the MMU faults that might be detected during a fault checking sequence:\n• External abort on a translation table walk\n• Translation fault\n• Access flag fault on page B3-1404\n• Domain fault, Short-descriptor format translation tables only on page B3-1404\n• Permission fault on page B3-1405.\n\n__Translation fault__\nA Translation fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.\nA Translation fault is generated if bits[1:0] of a translation table descriptor identify the descriptor as either a Fault\nencoding or a reserved encoding.\n\nIn addition, if an implementation includes the Virtualization Extensions, then a Translation fault is generated if the\ninput address for a translation either does not map on to an address range of a Translation Table Base Register, or\nthe Translation Table Base Register range that it maps on to is disabled. \n\nThe architecture guarantees that any translation table entry that causes a Translation fault is not cached,\n\n__Access flag fault__\nAn Access flag fault can be generated at any level of lookup,\n• The translation tables support an Access flag bit:\n\t— the Short-descriptor format supports an Access flag only when SCTLR.AFE is set to 1\n\t— the Long-descriptor format always supports an Access flag.\n\nThe architecture guarantees that any translation table entry that causes an Access flag fault is not cached, meaning\nthe TLB never holds such an entry.\n\n__Domain fault, Short-descriptor format translation tables only__\nWhen using the Short-descriptor translation table format, a Domain fault can be generated at the first level or second\nlevel of lookup.\n\nWhen a first-level/second-level descriptor fetch returns a valid Section first-level descriptor, the domain field of\nthat descriptor is checked against the DACR. A first-level Domain fault is generated if this check\nfails.\n\nA TLB might hold a translation table entry that cause a Domain fault.\n\n__Permission fault__\nA Permission fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.\n\nA TLB might hold a translation table entry that cause a Permission fault. Therefore, if the handling of a Permission\nfault results in an update to the associated translation tables, the software that updates the translation tables must\ninvalidate the appropriate TLB entry.\n\nB3.12.6 External aborts\nThe ARM architecture defines external aborts as errors that occur in the memory system, other than those that are\ndetected by the MMU or Debug hardware.An external abort is one of:\n• synchronous\n• precise asynchronous\n• imprecise asynchronous.\n\nThe ARM architecture does not provide any method to distinguish between precise asynchronous and imprecise\nasynchronous aborts.\n\nNormally, external aborts are rare. An imprecise asynchronous external abort is likely to be fatal to the process that\nis running. \n\n##### B3.12.7 Prioritization of aborts\nprioritization decreasing in next order:\n1. Alignment fault\n2. an MMU fault, on either the stage 1 translation or the stage 2 translation\n3. a Watchpoint debug event.\n4. an external abort\n\n#### B3.13 Exception reporting in a VMSA implementation\n##### B3.13.1 About exception reporting\nIn an implementation that includes the Virtualization Extensions, exceptions can be taken to:\n• a Secure or Non-secure PL1 mode\n• the Non-secure PL2 mode, Hyp mode.\n\n##### B3.13.2 Reporting exceptions taken to PL1 modes\n__Registers used for reporting exceptions taken to a PL1 mode__\nARMv7 defines the following registers, and register encodings, for exceptions taken to PL1 modes:\n• the DFSR holds information about a Data Abort exception\n• the DFAR holds the faulting address for some synchronous Data Abort exceptions\n• the IFSR holds information about a Prefetch Abort exception\n• the IFAR holds the faulting address of a Prefetch Abort exception\n• on a Watchpoint debug exception, the DBGWFAR can hold fault information.\n\n__Auxiliary Fault Status Registers__\nThe ARMv7 architecture defines the following Auxiliary Fault Status Registers:\n• the Auxiliary Data Fault Status Register, ADFSR\n• the Auxiliary Instruction Fault Status Register, AIFSR.\n\n##### B3.13.3 Fault reporting in PL1 modes\nFixme [Table B3-23 Short-descriptor format FSR encodings] Page 1415\n\nFixme [Table B3-24 Long-descriptor format FSR encodings] Page 1416\n\n##### B3.13.5 Reporting exceptions taken to the Non-secure PL2 mode\n__Registers used for reporting exceptions taken to Hyp mode__\nThe Virtualization Extensions define the following registers for exceptions taken to Hyp mode:\n• the HSR holds syndrome information for the exception\n• the HDFAR holds the VA associated with a Data Abort exception\n• the HIFAR holds the VA associated with a Prefetch Abort exception\n• the HPFAR holds bits[39:12] of the IPA associated with some aborts on stage 2 address translations.\n\n__Hyp Auxiliary Fault Syndrome Registers__\nThe Virtualization Extensions define the following Hyp Auxiliary Fault Syndrome Registers:\n• the Hyp Auxiliary Data Fault Syndrome Register, HADFSR\n• the Hyp Auxiliary Instruction Fault Syndrome Register, HAIFSR.\n\nFixme [Table B3-28 HSR.EC encodings for aborts taken to Hyp mode] Page 1422\n\n##### B3.13.6 Use of the HSR\nThe HSR holds syndrome information for any synchronous exception taken to Hyp mode. Compared with the\nreporting of exceptions taken to PL1 modes, the HSR:\n• Always provides details of the fault. The DFSR and IFSR are not used.\n• Provides more extensive information, for a wider range of exceptions.\n\nFixme [Figure B3-25 Format of the HSR, with subdivision of the ISS field for specified EC encodings] Page 1425\n\nFixme [Table B3-29 HSR.EC field encoding] Page 1425\n\nMore detail ISS encoding see arm-arm pdf\n\n#### B3.14 Virtual Address to Physical Address translation operation\n__CP15 c7 includes operations for Virtual Address (VA) to Physical Address (PA) translation.__\n\n##### B3.14.1 Naming of the address translation operations, and operation summary\nFixme [Table B3-31 Naming of address translation operations] Page 1438\n\nIn the stage 1 current state and stages 1 and 2 Non-secure state only operations, the meanings of the last two letters\nof the names are:\n- PR PL1 mode, read operation.  \n- PW PL1 mode, write operation.  \n- UR PL0 mode, read operation.  \n- UW PL0 mode, write operation.\n\n##### B3.14.2 Encoding and availability of the address translation operations\nSoftware executing at PL0 never has any visibility of the address translation operations, but software executing at\nPL1 or higher can use the unprivileged address translation operations to find the address translations used for\nmemory accesses by software executing at PL0 and PL1.\n\nFixme [Table B3-32 CP15 c7 address translation operations] Page 1440\n\nThe result of an operation is always returned in the PAR. The PAR is a RW register and:\n• in all implementations, the 32-bit format PAR is accessed using an MCR or MRC instruction with CRn set to c7,\nCRm set to c4, and opc1 and opc2 both set to 0\n• in an implementation that includes the Large Physical Address Extension, the 64-bit format PAR is accessed\nusing an MCRR or MRRC instruction with CRm set to c7, and opc1 set to 0.\n\n##### B3.14.3 Determining the PAR format, Large Physical Address Extension\nThe Large Physical Address Extension extends the PAR to become a 64-bit register, and supports both 32-bit and\n64-bit PAR formats\n\n#### B3.15 About the system control registers for VMSA\nOn an ARMv7-A or ARMv7-R implementation, the system control registers comprise:\n• the registers accessed using the System Control Coprocessor, CP15\n• registers accessed using the CP14 coprocessor, including:\n\t— debug registers\n\t— trace registers\n\t— execution environment registers.\n\n##### B3.15.3 Classification of system control registers\n__Banked system control registers__\nFixme [Table B3-33 Banked CP15 registers] Page 1452\n\n__Restricted access system control registers__\nFixme [Table B3-34 Restricted access CP15 registers] Page 1453\n\n__PL2-mode system control registers__\nFixme [Table B3-35 Banked PL2-mode CP15 read/write registers] Page 1455\n\nFixme [Table B3-37 Banked PL2-mode CP15 write-only operations] Page 1457\n\n__Common system control registers__\nSome system control registers and operations are common to the Secure and Non-secure security states.\nFixme [Table B3-38 Common CP15 registers] Page 1457\n\n#### B3.16 Organization of the CP14 registers in a VMSA implementation\nThe CP14 registers provide a number of distinct control functions, covering:\n• Debug\n• Trace\n• Execution environment control, for the Jazelle and ThumbEE execution environments.\n\nThe CP14 register encodings are classified by the {CRn, opc1, CRm, opc2} values required to access them using\nan MCR or an MRC instruction. The opc1 value determines the primary allocation of these registers, as follows:\nopc1==0 Debug registers.\nopc1==1 Trace registers.\nopc1==6 ThumbEE registers.\nopc1==7 Jazelle registers. Can include Jazelle SUBARCHITECTURE DEFINED registers\n\n#### B3.17 Organization of the CP15 registers in a VMSA implementation\nMore precisely, the ordered set of values {CRn, opc1, CRm, opc2} determined the register order.\n\n##### B3.17.1 CP15 register summary by coprocessor register number\nFixme [Figure B3-26 CP15 register grouping by primary coprocessor register, CRn, VMSA implementation] Page 1470\n\n__VMSA CP15 c0 register summary, identification registers__\nFixme [Figure B3-27 CP15 c0 registers in a VMSA implementation] Page 1471\n\n__VMSA CP15 c1 register summary, system control registers__\nFixme [Figure B3-28 CP15 c1 registers in a VMSA implementation] Page 1472\n\n__VMSA CP15 c2 and c3 register summary, Memory protection and control registers__\nFixme [Figure B3-29 CP15 32-bit c2 and c3 registers] Page 1473\n\nFixme [Figure B3-30 CP15 64-bit c2 registers] Page 1473\n\n__VMSA CP15 c5 and c6 register summary, Memory system fault registers__\nFixme [Figure B3-31 CP15 c5 and c6 registers in a VMSA implementation] Page 1474\n\n__VMSA CP15 c7 register summary, Cache maintenance, address translation, and other functions__\nFixme [Figure B3-32 CP15 32-bit c7 registers in a VMSA implementation] Page 1475\n\n__VMSA CP15 c8 register summary, TLB maintenance operations__\nFixme [Figure B3-34 CP15 c8 registers in a VMSA implementation] Page 1476\n\n__VMSA CP15 c9 register summary, reserved for cache and TCM control and performance monitors__\nFixme [Figure B3-35 Reserved CP15 c9 encodings] Page 1477\n\n__VMSA CP15 c10 register summary, memory remapping and TLB control registers__\nFixme [Figure B3-36 CP15 c10 registers in a VMSA implementation] Page 1478\n\n__VMSA CP15 c11 register summary, reserved for TCM DMA registers__\nFixme [Figure B3-37 Reserved CP15 c11 encodings] Page 1478\n\n__VMSA CP15 c12 register summary, Security Extensions registers__\nFixme [Figure B3-38 Security Extensions CP15 c12 registers] Page 1479\n\n__VMSA CP15 c13 register summary, Process, context and thread ID registers__\nOn an ARMv7-A implementation, the CP15 c13 registers provide:\n• an FCSE Process ID Register, that indicates whether the implementation includes the FCSE\n• a Context ID Register\n• Software Thread ID Registers.\nFixme [Figure B3-39 CP15 c13 registers in a VMSA implementation] Page 1479\n\n__VMSA CP15 c14, reserved for Generic Timer Extension__\nFixme [Figure B3-40 CP15 32-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480\nFixme [Figure B3-41 CP15 64-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480\n\n__VMSA CP15 c15 register summary, IMPLEMENTATION DEFINED registers__\n\n##### B3.17.2 Full list of VMSA CP15 registers, by coprocessor register number\nFixme [Table B3-42 Summary of VMSA CP15 register descriptions, in coprocessor register number order] Page 1481\n\n#### B3.18 Functional grouping of VMSAv7 system control registers\n##### B3.18.1 Identification registers, functional group\nFixme [Table B3-44 Identification registers, VMSA] Page 1492\n\n##### B3.18.2 Virtual memory control registers, functional group\nFixme [Table B3-45 Virtual memory control registers, VMSA only] Page 1493\n\n##### B3.18.3 PL1 Fault handling registers, functional group\nFixme [Table B3-46 Fault handling registers, VMSA] Page 1494\n\n##### B3.18.4 Other system control registers, functional group\nFixme [Table B3-47 Other system control registers, VMSA] Page 1494\n\n##### B3.18.5 Lockdown, DMA, and TCM features, functional group, VMSA\nFixme [Table B3-48 Lockdown, DMA, and TCM features, VMSA] Page 1495\n\n##### B3.18.6 Cache maintenance operations, functional group, VMSA\nFixme [Table B3-49 Cache and branch predictor maintenance operations, VMSA] Page 1496\n\n##### B3.18.7 TLB maintenance operations, functional group\nFixme [Table B3-50 TLB maintenance operations, VMSA only] Page 1497\n\n##### B3.18.8 Address translation operations, functional group\nFixme [Table B3-51 Address translation operations, VMSA only] Page 1498\n\n##### B3.18.9 Miscellaneous operations, functional group\nFixme [Table B3-52 Miscellaneous system control operations, VMSA only] Page 1499\n\n##### B3.18.10 Performance Monitors, functional group\nFixme [Table B3-53 Performance monitors, VMSA] Page 1500\n\n##### B3.18.11 Security Extensions registers, functional group\nFixme [Table B3-54 Security Extensions registers, VMSA only] Page 1500\n\n##### B3.18.12 Virtualization Extensions registers, functional group\nFixme [Table B3-55 Virtualization Extensions registers, VMSA with Virtualization Extensions only] Page 1501\n\nFixme [Table B3-56 Hyp mode TLB maintenance operations, VMSA with Virtualization Extensions only] Page 1502\n\n##### B3.18.13 Generic Timer Extension registers\n\n##### B3.18.14 IMPLEMENTATION DEFINED registers, functional group\nTypically, an implementation uses CP15 c15 to provide test features, and any required configuration options that\nare not covered by this manual.\n\n### B4 System Control Registers in a VMSA implementation\nSkip\n\n### B5 Protected Memory System Architecture (PMSA)\nSkip\n\n### B6 System Control Registers in a PMSA implementation\nSkip\n\n### B7 The CPUID Identification Scheme\n#### B7.1 Introduction to the CPUID scheme\nBefore ARMv7, using Main ID Register:\n• MIDR, Main ID Register, VMSA on page B4-1649\n• MIDR, Main ID Register, PMSA on page B6-1894.\n\nThe ARMv7 architecture implements an extended processor, using a number of registers in CP15 c0.\n__ARMv7 requires the use of this scheme, and use of the scheme is indicated by a value of 0xF in the Architecture field of the Main ID Register.__\n\nThe CPUID scheme provides information about the implemented:\n• processor features\n• debug features\n• auxiliary features, in particular IMPLEMENTATION DEFINED features\n• memory model features\n• instruction set features.\n\n#### B7.2 The CPUID registers\n##### B7.2.1 Organization of the CPUID registers\nFixme[Figure B7-1 CPUID register encodings] Page 1951\n\nFixme[Table B7-1 CPUID register summary] Page 1952\n\n##### B7.2.2 About the Instruction Set Attribute registers\nFixme[Table B7-2 Alphabetic list of Instruction Set Attribute registers attribute fields] Page 1954\n\n### B8. The Generic Timer\n#### B8.1 About the Generic Timer\nFixme[Figure B8-1 Generic Timer example] page1960\n\n##### 8.1.1 System counter\nThe Generic Timer provides a system counter with the following specification:\n__Width__\nAt least 56 bits wide.\nThe value returned by any 64-bit read of the counter is zero-extended to 64 bits.\n\n__Frequency__\nIncrements at a fixed frequency, typically in the range 1-50MHz.\nCan support one or more alternative operating modes in which it increments by larger amounts at a\nlower frequency, typically for power-saving.\nRoll-over Roll-over time of not less than 40 years.\n\n__Accuracy__\nARM does not specify a required accuracy, but recommends that the counter does not gain or lose\nmore than ten seconds in a 24-hour period.\nUse of lower-frequency modes must not affect the implemented accuracy.\n\n__Start-up__\nStarts operating from zero.\n\nThe system counter must be implemented in an always-on power domain.\n\n###### Initializing and reading the system counter frequency\nTypically, the system drives the system counter at a fixed frequency and the CNTFRQ register must be programmed\nto this value during the system boot process. \n\nIn an implementation that supports the ARM Security Extensions, only\nsoftware executing in a Secure PL1 mode can write to CNTFRQ.\n\nSoftware can read the CNTFRQ register, to determine the current system counter frequency, in the following states\nand modes:\n• Non-secure PL2 mode.\n• Secure and Non-secure PL1 modes.\n• When CNTKCTL.PL0PCTEN is set to 1, Secure and Non-secure PL0 modes.\n\n##### 8.1.2 The physical counter\nThe processor provides a physical counter that contains the count value of the system counter. The CNTPCT register\nholds the current physical counter value.\n\nIn an implementation that includes the Virtualization Extensions, CNTPCT:\n• Is always accessible from Secure PL1 modes, and from Non-secure Hyp mode.\n• Is accessible from Non-secure PL1 modes only when CNTHCTL.PL1PCTEN is set to 1. When\nCNTHCTL.PL1PCTEN is set to 0, any attempt to access CNTPCT from a Non-secure PL1 mode generates\na Hyp Trap exception, see Hyp Trap exception on page B1-1209.\n\n##### 8.1.3 The virtual counter\nAn implementation of the Generic Timer always includes a virtual counter, that indicates virtual time:\n• In a processor implementation that does not include the Virtualization Extensions, virtual time is identical to\nphysical time, and the virtual counter contains the same value as the physical counter.\n• In a processor implementation that includes the Virtualization Extensions, the virtual counter contains the\nvalue of the physical counter minus a 64-bit virtual offset. When execu\n\nCNTVCT is always accessible from Secure PL1 modes, and from Non-secure PL1 and PL2 modes\n\n##### 8.1.5 Timers\nThe number of timers provided by an implementation of the Generic Timer depends on whether the implementation\nincludes the Security Extensions and the Virtualization Extensions, as follows:\n\n__Security Extensions not implemented__\nThe implementation provides a physical timer and a virtual timer.\n\n__Security Extensions implemented, Virtualization Extensions not implemented__\nThe implementation provides:  \n- A Non-secure physical timer.  \n- A Secure physical timer.  \n- A virtual timer.\n\n__Virtualization Extensions implemented__\nThe implementation provides:\n- A Non-secure PL1 physical timer.  \n- A Secure PL1 physical timer.  \n- A Non-secure PL2 physical timer.  \n- A virtual timer\n\nEach timer is implemented as three registers:  \n- A 64-bit CompareValue register, that provides a 64-bit unsigned upcounter.  \n- A 32-bit TimerValue register, that provides a 32-bit signed downcounter.  \n- A 32-bit Control register.\n\nFixme[Table B8-1 Timer registers summary for the Generic Timer] page1965\n\n#### 8.2 Generic Timer registers summary\nFixme[Table B8-2 Generic Timer registers] page1969\n","source":"_posts/arm_arm_part_B.md","raw":"---\ntitle: arm arm part B\ndate: 2019-05-30 13:55:44\ntags:\n    - arm\n    - spec\ncategories:\n    - arm\n---\n\nReference: <<ARM ® Architecture Reference Manual -- ARMv7-A and ARMv7-R edition>> (ARM DDI 0406C.c (ID051414))\n<!--more-->\n## Part B System Level Architecture\n\n### B1 System Level Programmers’ Model\n#### B1.1 About the System level programmers’ model\n#### B1.2 System level concepts and terminology\n##### B1.2.1 Mode, state, and privilege level\n###### Mode\nThe ARM architecture A and R profiles provide a set of modes that support normal software execution and handle\nexceptions. The current mode determines:\n• the set of registers that are available to the processor\n• the privilege level of the executing software\n\n###### State\n- Instruction set state\n\n> one of ARM state, Thumb state, Jazelle state, or ThumbEE state.\n\n- Execution state\n\n> consists of the instruction set state and some control bits that modify how the\ninstruction stream is decoded. For details, see Execution state registers on page A2-50 and Program\nStatus Registers (PSRs) on page B1-1147.\n\n- Security state \n\n- Debug state\n\n###### Privilege level\n__Secure state__\nPL0 Software executed in User mode executes at PL0.\nPL1 Software executed in any mode other than User mode executes at PL1.\n\n__Non-secure state__\nPL0 Software executed in User mode executes at PL0.\nPL1 Software executed in any mode other than User or Hyp mode executes at PL1.\nPL2 In an implementation that includes the Virtualization Extensions, software executed in\nHyp mode executes at PL2.\n\n#### B1.3 ARM processor modes and ARM core registers\n##### B1.3.1 ARM processor modes\nFixme [Table B1-1 ARM processor modes] page1139\n###### System mode \nSoftware executing in System mode executes at PL1. System mode has the same registers available\nas User mode, and is not entered by any exception.\n\n###### Supervisor mode\nSupervisor mode is the default mode to which a Supervisor Call exception is taken.\nExecuting a SVC (Supervisor Call) instruction generates an Supervisor Call exception, that is taken\nto Supervisor mode.\n__A processor enters Supervisor mode on Reset__\n\n###### Hyp mode \nHyp mode is the Non-secure PL2 mode, implemented as part of the Virtualization Extensions. \nThe Hypervisor Call exception and Hyp Trap exception are exceptions that are implemented as part\nof the Virtualization Extensions, and that are always taken in Hyp mode.\n• __In Hyp mode, the only exception return is execution of an ERET instruction, see ERET on page B9-1982__\n• The instructions described in the following sections are UNDEFINED if executed in Hyp mode:\n\t— SRS (Thumb) on page B9-2004\n\t— SRS (ARM) on page B9-2006\n\t— RFE on page B9-2000\n\t— LDM (exception return) on page B9-1986\n\t— LDM (User registers) on page B9-1988\n\t— STM (User registers) on page B9-2008\n\t— SUBS PC, LR and related instructions (ARM) on page B9-2012.\n\t— SUBS PC, LR (Thumb) on page B9-2010, when executed with a nonzero constant.\n\n• In Hyp mode, the CPACR has no effect on the execution of coprocessor, floating-point, or Advanced SIMD\ninstructions. The HCPTR controls execution of these instructions in Hyp mode.\n\n• If software running in Hyp mode executes an SVC instruction, the Supervisor Call exception generated by the\ninstruction is taken to Hyp mode, see SVC (previously SWI) on page A8-720.\n\n###### Monitor mode\nMonitor mode is the mode to which a Secure Monitor Call exception is taken.\nMonitor mode is a Secure mode, meaning it is always in the Secure state, regardless of the value of\nthe SCR.NS bit. __Monitor mode provides the normal method of changing between the Secure and Non-secure security states.__\n\n\nFixme [Figure B1-1 Modes, privilege levels, and security states] page1141\n\n##### B1.3.2 ARM core registers\nFixme [Figure B1-2 ARM core registers, PSRs, and ELR_hyp, showing register banking] page1144\n\n##### B1.3.3 Program Status Registers (PSRs)\n###### The Current Program Status Register (CPSR)\nThe Current Program Status Register (CPSR) holds processor status and control information:\n• the APSR, see The Application Program Status Register (APSR) on page A2-49\n• the current instruction set state, see Instruction set state register, ISETSTATE on page A2-50\n• the execution state bits for the Thumb If-Then instruction, see IT block state register, ITSTATE on page A2-51\n• the current endianness, see Endianness mapping register, ENDIANSTATE on page A2-53\n• the current processor mode\n• interrupt and asynchronous abort disable bits.\n\n###### The Saved Program Status Registers (SPSRs)\nThe purpose of an SPSR is to record the pre-exception value of the CPSR. \n\nFixme [Format of the CPSR and SPSRs] Page1148\n\n##### B1.3.4 ELR_hyp\nHyp mode does not provide its own Banked copy of LR. Instead, on taking an exception to Hyp mode, the preferred\nreturn address is stored in ELR_hyp, a 32-bit Special register implemented for this purpose.\nELR_hyp is implemented only as part of the Virtualization Extensions.\n\nThe ERET instruction uses the value in ELR_hyp as the return address for the exception. For more information, see\nERET on page B9-1982.\n\n#### B1.4 Instruction set states\nIf an exception is taken to a PL1 mode, the SCTLR.TE bit for the security state the exception is taken to determines\nthe processor instruction set state that handles the exception, and if necessary, the processor changes to this\ninstruction set state on exception entry.\n\nIf the exception is taken to Hyp mode, the HSCTLR.TE bit determines the processor instruction set state that\nhandles the exception, and if necessary, the processor changes to this instruction set state on exception entry.\n\n#### B1.5 The Security Extensions\n##### B1.5.1 Security states\nThe Security Extensions define two security states, Secure state and Non-secure state. \n• Each security state operates in its own virtual memory address space, with its own translation regime. \n— in any implementation that includes the Security Extensions, Monitor mode is available only in Secure\nstate\n— in an implementation that also includes the Virtualization Extensions, Hyp mode is available only in\nNon-secure state.\n\nThe ARM core registers and the processor status registers are not Banked between the Secure and the Non-secure\nstates. ARM expects that, when switching execution between the Non-secure and Secure states, a kernel running\nmostly in Monitor mode will switch the values of these registers.\nThe registers LR_mon and SPSR_mon are UNKNOWN when executing in Non-secure state.\n\n###### Changing from Secure to Non-secure state\nExcept in Monitor mode and Hyp mode, the security state is controlled by the SCR.NS bit. Software executing in a Secure PL1 mode can change the SCR, but ARM strongly recommends that software obeys the following rules for changing SCR.NS:\n• To avoid security holes, software must not:\n\t— Change from Secure to Non-secure state by using an MSR or CPS instruction to switch from Monitor\n\tmode to some other mode while SCR.NS is 1.\n\t— Use an MCR instruction that writes SCR.NS to change from Secure to Non-secure state. This means\n\tARM recommends that software does not alter SCR.NS in any mode except Monitor mode. ARM\n\tdeprecates changing SCR.NS in any other mode.\n\n• __The usual mechanism for changing from Secure to Non-secure state is an exception return__.To return to\nNon-secure state, software executing in Monitor mode sets SCR.NS to 1 and then performs the exception\nreturn.\n\n#### B1.6 The Large Physical Address Extension\nThe Large Physical Address Extension is an OPTIONAL extension to the ARMv7-A architecture profile. Any\nimplementation that includes the Large Physical Address Extension must also include the Multiprocessing\nExtensions.\n\nThe Large Physical Address Extension adds a new translation table format:\n• the format used in an implementation that does not include the Large Physical Address Extension is now\ncalled the Short-descriptor format, see Short-descriptor translation table format on page B3-1324\n• the format added by the Large Physical Address Extension is the Long-descriptor format, see\nLong-descriptor translation table format on page B3-1338.\n\n__An implementation that includes the Large Physical Address Extension must support both translation table formats.__\n\n#### B1.7 The Virtualization Extensions\nThe Virtualization Extensions are an OPTIONAL extension to the ARMv7-A architecture profile. Any\nimplementation that includes the Virtualization Extensions must include the Security Extensions, the Large Physical\nAddress Extension, and the Multiprocessing Extensions.\n\nThe basic model of a virtualized system involves:\n• a hypervisor, running in Non-secure Hyp mode, that is responsible for switching Guest operating systems\n• a number of Guest operating systems, each of which runs in the Non-secure PL1 and PL0 modes\n• for each Guest operating system, applications, that usually run in User mode.\n\n__Each virtual machine is identified by a virtual machine identifier (VMID), assigned by the hypervisor.__\n• With the Security Extensions, the Virtualization Extensions control the routing of interrupts and\nasynchronous Data Abort exceptions to the appropriate one of:\n— the current Guest OS\n— a Guest OS that is not currently running\n— the hypervisor\n— the Secure monitor.\n\n• When an implementation includes the Virtualization Extensions, it provides independent translation regimes\nfor memory accesses from:\n\t— Secure modes, the Secure PL1&0 translation regime\n\t— Non-secure Hyp mode, the Non-secure PL2 translation regime\n\t— Non-secure PL1 and PL0 modes, the Non-secure PL1&0 translation regime\n\n• In the Non-secure PL1&0 translation regime, address translation occurs in two stages:\n— Stage 1 maps the Virtual Address (VA) to an Intermediate Physical Address (IPA). Typically, the Guest\nOS configures and controls this stage, and believes that the IPA is the Physical Address (PA)\n— Stage 2 maps the IPA to the PA. Typically, the hypervisor controls this stage, and a Guest OS is\ncompletely unaware of this translation.\n\n##### B1.7.1 Impact of the Virtualization Extensions on the modes and exception model\n• Implements new exceptions, see:\n\t— Hypervisor Call (HVC) exception on page B1-1212\n\t— Hyp Trap exception on page B1-1209\n\t— Virtual IRQ exception on page B1-1221\n\t— Virtual FIQ exception on page B1-1223\n\t— Virtual Abort exception on page B1-1218.\n\n• Implements a new register that holds the exception vector base address for exceptions taken to Hyp mode,\nthe HVBAR.\n\n• Implements a new exception return instruction, ERET, for return from Hyp mode\n\n• Provide mechanisms to trap processor functions to Hyp mode, using the Hyp Trap exception, see Traps to\nthe hypervisor on page B1-1248.\nWhen an operation is trapped to Hyp mode, the hypervisor typically either:\n\t— emulates the required operation, so the application running in the Guest OS is unaware of the trap to\n\tHyp mode\n\t— returns an error to the Guest OS.\n\n#### B1.8 Exception handling\n##### B1.8.1 Exception vectors and the exception base address\nWhen an exception is taken, processor execution is forced to an address that corresponds to the type of exception.\nThis address is called the exception vector for that exception.\n\n__A set of exception vectors comprises eight consecutive word-aligned memory addresses__, starting at an exception\nbase address. These eight vectors form a vector table. __For the IRQ and FIQ exceptions only__, when the exceptions\nare taken to IRQ mode and FIQ mode, software can change the exception vectors from the vector table values by\nsetting the SCTLR.VE bit to 1, see Vectored interrupt support on page B1-1168.\n\n###### Implementation that does not include the Security Extensions (1 pair interrupt vectors)\nThis section applied to all ARMv7-R implementations.\nAn implementation that does not include the Security Extensions has a single vector table, the base\naddress of which is selected by SCTLR.V, see SCTLR, System Control Register, VMSA on\npage B4-1707 or SCTLR, System Control Register, PMSA on page B6-1932:\n\tV == 0 Exception base address = 0x00000000. This setting is referred to as normal vectors, or as\n\tlow vectors.\n\tV == 1 Exception base address = 0xFFFF0000. This setting is referred to as high vectors, or\n\tHivecs.\n\n###### Implementation that includes the Security Extensions (3 pair interrupt vectors)\nAny implementation that includes the Security Extensions has the following vector tables:\n• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in\nthe address space of the Secure PL1&0 translation regime.\n• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure\nvector table, and is in the address space of the Secure PL1&0 translation regime.\n• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and\nis in the address space of the Non-secure PL1&0 translation regime.\n\n__For the Monitor vector table, MVBAR holds the exception base address.__\n\nFor the Secure vector table:\n• the Secure SCTLR.V bit determines the exception base address:\n\tV == 0 The Secure VBAR holds the exception base address.\n\tV == 1 Exception base address = 0xFFFF0000, the Hivecs setting.\n\nFor the Non-secure vector table:\n• the Non-secure SCTLR.V bit determines the exception base address:\n\tV == 0 The Non-secure VBAR holds the exception base address.\n\tV == 1 Exception base address = 0xFFFF0000, the Hivecs setting.\n\n\n###### Implementation that includes the Virtualization Extensions (4 pair interrupt vectors)\nAn implementation that includes the Virtualization Extensions must include the Security\nExtensions, and also includes an additional vector table. Therefore, it has the following vector\ntables:\n• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in\nthe address space of the Secure PL1&0 translation regime.\n• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure\nvector table, and is in the address space of the Secure PL1&0 translation regime.\n• One for exceptions taken to Hyp mode, the Non-secure PL2 mode. This is the Hyp vector\ntable, and is in the address space of the Non-secure PL2 translation regime.\n• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and\nis in the address space of the Non-secure PL1&0 translation regime.\n\nThe exception base addresses of the Monitor vector table, the Secure vector table, and the\nNon-secure vector table are determined in the same way as for an implementation that includes the\nSecurity extensions but not the Virtualization extensions.\n\n__For the Hyp vector table, HVBAR holds the exception base address.__\n\n###### The vector tables and exception offsets\nFixme [Table B1-3 The vector tables] page1167\n\n##### B1.8.4 Processor mode for taking exceptions\n###### Exceptions taken to Hyp mode\n• Any exception taken from Hyp mode, that is not routed to Secure Monitor Mode by the controls described\nin Asynchronous exception routing controls on page B1-1175, is taken to Hyp mode.\n\n• The following exceptions, if taken from Non-secure state, are taken to Hyp mode:\n\t— An abort that Routing of aborts on page B3-1396 identifies as taken to Hyp mode.\n\t— A Hyp Trap exception, see Traps to the hypervisor on page B1-1248.\n\t— A Hypervisor Call exception. This is generated by executing a HVC instruction in a Non-secure mode.\n\t— An asynchronous abort, IRQ exception or FIQ exception that is not routed to Secure Monitor mode\n\tbut is explicitly routed to Hyp mode, as described in Asynchronous exception routing controls on\n\tpage B1-1175.\n\t— A synchronous external abort, Alignment fault, Undefined Instruction exception, or Supervisor Call\n\texception taken from the Non-secure PL0 mode and explicitly routed to Hyp mode, as described in\n\tRouting general exceptions to Hyp mode on page B1-1192.\n\tNote\n\tA synchronous external abort can be routed to Hyp mode only if it not routed to Secure Monitor mode.\n\t— A debug exception that is explicitly routed to Hyp mode as described in Routing Debug exceptions to\n\tHyp mode on page B1-1194.\n\n###### Asynchronous exception routing controls\nIn an implementation that includes the Security Extensions, the following bits in the SCR control the routing of\nasynchronous exceptions:\nSCR.EA    When this bit is set to 1, any external abort is taken to Secure Monitor mode\nSCR.FIQ   When this bit is set to 1, any FIQ exception is taken to Secure Monitor mode.\nSCR.IRQ   When this bit is set to 1, any IRQ exception is taken to Secure Monitor mode.\n__Only Secure software can change the values of these bits.__\n\nIn an implementation that includes the Virtualization Extensions, the following bits in the HCR route asynchronous\nexceptions to Hyp mode:\nHCR.AMO   If SCR.EA is set to 0, when this bit is set to 1, an asynchronous external abort taken from a\n          Non-secure PL1 or PL0 mode is taken to Hyp mode, instead of to Non-secure Abort mode.\n\nHCR.FMO   If SCR.FIQ is set to 0, when this bit is set to 1, an FIQ exception taken from a Non-secure PL1 or\n          PL0 mode is taken to Hyp mode, instead of to Non-secure FIQ mode.\n\nHCR.IMO   If SCR.IRQ is set to 0, when this bit is set to 1, an IRQ exceptions taken from a Non-secure PL1 or\n          PL0 mode is taken to Hyp mode, instead of to Non-secure IRQ mode.\n\n__Only software executing in Hyp mode, or Secure software executing in Monitor mode when SCR.NS is set to 1, can change the values of these bits.__\n\n##### B1.8.5 Processor state on exception entry\n###### Instruction set state on exception entry\nOn exception entry, CPSR.{T, J} are set to the values shown, with the CPSR.T value determined by SCTLR.TE or HSCTLR.TE\n\nFixme [Table B1-8 CPSR.J and CPSR.T bit values on exception entry] page1182\n\n###### CPSR.E bit value on exception entr\nFixme [Table B1-9 CPSR.E bit value on exception entry] page1182\n\n##### B1.8.6 Asynchronous exception masking\nThe CPSR.{A, I, F} bits can mask the corresponding exceptions, as follows:\n• CPSR.A can mask asynchronous aborts\n• CPSR.I can mask IRQ exceptions\n• CPSR.F can mask FIQ exceptions.\n\nIn an ARMv7 implementation that does not include the Security Extensions, setting one of these bits to 1 masks the\ncorresponding exception, meaning the exception cannot be taken.\n\nIn an implementation that includes the Security Extensions, the SCR.{AW, FW} bits provide a mechanism to\nprevent use of the CPSR.{A, F} mask bits by Non-secure software. In an implementation that includes the\nVirtualization Extensions:\n• HCR.{AMO, FMO} modify this mechanism\n• HCR.IMO can prevent the masking, by CPSR.I, of IRQs taken from Non-secure state.\n\nWhen an SCR.{AW, FW} bit is set to 0, Non-secure software cannot update the corresponding\nCPSR bit.\n\nFixme [Table B1-11 Control of masking by CPSR.A] page1185\n\nFixme [Table B1-12 Control of masking by CPSR.I] page1185\n\nFixme [Table B1-13 Control of masking by CPSR.F] page1185\n\n##### B1.8.7 Summaries of asynchronous exception behavior\n###### Asynchronous exception behavior, Security Extensions only\nFixme [Table B1-14 Behavior of asynchronous aborts, Virtualization Extensions not implemented] page1187\n\nFixme [Table B1-15 Behavior of IRQ exceptions, Virtualization Extensions not implemented] page1188\n\nFixme [Table B1-16 Behavior of FIQ exceptions, Virtualization Extensions not implemented] page1188\n\n###### Asynchronous exception behavior, with the Virtualization Extensions\nFixme [Table B1-17 Behavior of asynchronous aborts, Virtualization Extensions implemented] page1189\n\nFixme [Table B1-18 Behavior of IRQ exceptions, Virtualization Extensions implemented] page1190\n\nFixme [Table B1-19 Behavior of FIQ exceptions, Virtualization Extensions implemented] page1191\n\n##### B1.8.8 Routing general exceptions to Hyp mode\nWhen HCR.TGE is set to 1, and the processor is in Non-secure User mode, the following exceptions are taken to\nHyp mode, instead of to the default Non-secure mode for handling the exception:\n• Undefined Instruction exceptions.\n• Supervisor Call exceptions.\n• Synchronous External aborts.\n• Any Alignment fault other than an alignment fault caused by the memory type when SCTLR.M is 1.\n\n##### B1.8.9 Routing Debug exceptions to Hyp mode\nWhen HDCR.TDE is set to 1, if the processor is executing in a Non-secure mode other than Hyp mode, any Debug\nexception is routed to Hyp mode. This means it generates a Hyp Trap exception\n\n##### B1.8.10 Exception return\nOn an exception return, the CPSR takes either:\n• the value loaded by the RFE instruction\n• if the exception return is not performed by executing an RFE instruction, the value of the current SPSR at the\ntime of the exception return\n\n###### Return from an exception taken to a PL1 mode\nFor an exception taken to a PL1 mode, the ARM architecture provides the following exception return instructions:\n• __Data-processing instructions with the S bit set and the PC as a destination__, see SUBS PC, LR (Thumb) on\npage B9-2010 and SUBS PC, LR and related instructions (ARM) on page B9-2012.\nTypically:\n\t— a return where no subtraction is required uses SUBS with an operand of 0, or the equivalent MOVS\n\tinstruction\n\t— a return requiring subtraction uses SUBS with a nonzero operand.\n\n• __From ARMv6, the RFE instruction, see RFE__ on page B9-2000. If a subtraction is required, typically it is\nperformed before saving the LR value to memory.\n\n• __In ARM state, a form of the LDM instruction__, see LDM (exception return) on page B9-1986. If a subtraction is\nrequired, typically it is performed before saving the LR value to memory.\n\n###### Return from an exception taken to a PL2 mode\nFor an exception taken to a PL2 mode, the ARM architecture provides the __ERET__ instruction, see ERET on\npage B9-1982. An exception handler executing in a PL2 mode must return using the ERET instruction.\nHyp mode is the only PL2 mode. Both Hyp mode and the ERET instruction are implemented only as part of the\nVirtualization Extensions.\n\n##### B1.8.11 Virtual exceptions in the Virtualization Extensions\n\nFixme [Table B1-20 HCR bits controlling asynchronous exceptions] page1198\n\n##### B1.8.12 Low interrupt latency configuration\nSetting SCTLR.FI to 1 enables the low interrupt latency configuration of an implementation. This configuration can\nreduce the interrupt latency of the processor. The mechanisms implemented to achieve low interrupt latency are\nIMPLEMENTATION DEFINED. For the description of the SCTLR see either:\n• SCTLR, System Control Register, VMSA on page B4-1707\n• SCTLR, System Control Register, PMSA on page B6-1932\n\n##### B1.8.13 Wait For Event and Send Event\nARMv7 and ARMv6K provide a mechanism, the Wait For Event mechanism, that permits a processor in a\nmultiprocessor system to request __entry to a low-power state__, and, if the request succeeds, to remain in that state until\nit receives an event generated by a Send Event operation on another processor in the system.\n__example using for spin-lock__\n\nThe Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a\nNon-secure PL1 or PL0 mode.\n\n###### WFE wake-up events\nThe following events are WFE wake-up events:\n• the execution of an SEV instruction on any processor in the multiprocessor system\n• a physical IRQ interrupt, unless masked by the CPSR.I bit\n• a physical FIQ interrupt, unless masked by the CPSR.F bit\n• a physical asynchronous abort, unless masked by the CPSR.A bit\n• in Non-secure state in any mode other than Hyp mode:\n\t— when HCR.IMO is set to 1, a virtual IRQ interrupt, unless masked by the CPSR.I bit\n\t— when HCR.FMO is set to 1, a virtual FIQ interrupt, unless masked by the CPSR.F bit\n\t— when HCR.AMO is set to 1, a virtual asynchronous abort, unless masked by the CPSR.A bit\n• an asynchronous debug event, if invasive debug is enabled and the debug event is permitted\n• an event sent by the timer event stream, see Event streams on page B8-1964\n• an event sent by some IMPLEMENTATION DEFINED mechanism.\n\n###### The Event Register\nThe Event Register is __a single bit register for each processor__. When set, an event register indicates that an event has\noccurred, since the register was last cleared\n\nThe Event Register is set by:\n• an SEV instruction\n• an event sent by some IMPLEMENTATION DEFINED mechanism\n• a debug event that causes entry into Debug state\n• an exception return.\n\n###### The Send Event instruction\n__The Send Event instruction, SEV, causes an event to be signaled to all processors in the multiprocessor system.__\n__ARM recommends that software includes a DSB instruction before an SEV instruction__\n\nExecution of the Send Event instruction sets the Event Register. The Send Event instruction is available at all privilege levels\n\n###### The Wait For Event instruction\nThe action of the Wait For Event instruction depends on the state of the Event Register:\n• If the Event Register is set, the instruction clears the register and completes immediately. Normally, if this\nhappens the software makes another attempt to claim the lock.\n\n• If the Event Register is clear the processor can suspend execution and enter a low-power state. It can remain\nin that state until the processor detects a WFE wake-up event or a reset. When the processor detects a WFE\nwake-up event, or earlier if the implementation chooses, the WFE instruction completes.\n\nThe Wait For Event instruction, WFE, is available at all privilege levels,\n\n##### B1.8.14 Wait For Interrupt\nWhen a processor issues a WFI instruction it can suspend execution and enter a low-power state.\n\nThe Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a\nNon-secure PL1 or PL0 mode.\n\nThe processor can remain in the WFI low-power state until it is reset, or it detects one of the following WFI wake-up\nevents:\n• a physical IRQ interrupt, regardless of the value of the CPSR.I bit\n• a physical FIQ interrupt, regardless of the value of the CPSR.F bit\n• a physical asynchronous abort, regardless of the value of the CPSR.A bit\n• in Non-secure state in any mode other than Hyp mode:\n\t— when HCR.IMO is set to 1, a virtual IRQ interrupt, regardless of the value of the CPSR.I bit\n\t— when HCR.FMO is set to 1, a virtual FIQ interrupt, regardless of the value of the CPSR.F bit\n\t— when HCR.AMO is set to 1, a virtual asynchronous abort, regardless of the value of the CPSR.A bit\n• an asynchronous debug event, when invasive debug is enabled and the debug event is permitted.\n\n__WFI wake-up events cannot be masked by the mask bits in the CPSR.__\n\n__Using WFI to indicate an idle state on bus interfaces__\n\n[Linux cpuidle framework(1)_概述和软件架构](http://www.wowotech.net/pm_subsystem/cpuidle_overview.html)\n\n#### B1.9 Exception descriptions\nskip\n\n#### B1.10 Coprocessors and system control\nThe ARM architecture supports sixteen coprocessors, usually referred to as CP0 to CP15.\nThe architecture reserves two of these coprocessors, CP14 and CP15,\nfor configuration and control related to the architecture:\n• CP14 is reserved for the configuration and control of:\n\t— debug features, see The CP14 debug register interface on page C6-2123\n\t— trace features, see the Embedded Trace Macrocell Architecture Specification and the CoreSight\n\tProgram Flow Trace Architecture Specification\n\t— the Thumb Execution Environment, see Thumb Execution Environment on page B1-1240\n\t— direct Java bytecode execution, see Jazelle direct bytecode execution on page B1-1241.\n• CP15 is called the System Control coprocessor, and is reserved for the control and configuration of the ARM\nprocessor system, including architecture and feature identification.\n\nThe implementation of the CP15 registers depends heavily on whether the ARMv7 implementation is:\n• an ARMv7-A implementation with a Virtual Memory System Architecture (VMSA)\n• an ARMv7-R implementation with a Protected Memory System Architecture (PMSA).\nThe implementation of the CP14 registers is generally similar in ARMv7-A and ARMv7-R implementation.\n\nMost CP14 and CP15 registers are accessible only from PL1 or higher. For possible accesses from PL0:\n• The register descriptions in Chapter B4 System Control Registers in a VMSA implementation and Chapter B6\nSystem Control Registers in a PMSA implementation indicate whether a register is accessible from PL0.\n• The descriptions of the CP14 interface in Chapter C6 Debug Register Interfaces include the permitted\naccesses to the debug registers from PL0.\n• The following sections summarize the permitted accesses to CP15 registers from PL0:\n\t— for a VMSA implementation, PL0 views of the CP15 registers on page B3-1488\n\t— for a PMSA implementation, PL0 views of the CP15 registers on page B5-1797.\n\n#### B1.11 Advanced SIMD and floating-point support\nskip\n\n#### B1.12 Thumb Execution Environment\t\nskip\n\n#### B1.13 Jazelle direct bytecode execution\nskip\n\n#### B1.14 Traps to the hypervisor\n##### B1.14.1 General information about traps to the hypervisor\nThe Hyp Trap exception provides the standard mechanism for trapping Guest OS functions to the hypervisor. \nand enters the exception handler using the vector at\noffset 0x14 from the Hyp vector base address. For more information see Exception handling on page B1-1165\n\nA Hyp Trap exception can be generated only when all of the following apply:\n• The processor is both:\n\t— not in Debug state\n\t— in a Non-secure PL1 or PL0 mode.\n• Traps to Hyp mode never apply in Secure state, regardless of the value of the SCR.NS bit.\t\n\nB1.14.2 Trapping ID mechanisms\nFor a small number of frequently-accessed ID registers, the Virtualization Extensions provide read/write aliases of\nthe registers, accessible only from Hyp mode, or from Secure state. A read of the original ID register from a\nNon-secure PL1 mode actually returns the value of the read/write alias register.\n\nFixme [Table B1-26 ID register substitution by the Virtualization Extensions] page1251\n\nFixme [Table B1-27 ID register groups for Hyp Trap exceptions] page1252\n\nB1.14.17 Summary of trap controls\n\nFixme [Table B1-29 Summary of Hyp trap controls] page1262\n\n### B2 Common Memory System Architecture Features\n\n#### B2.2 Caches and branch predictors\n\n##### B2.2.1 Cache identification\n\nThe ARMv7 cache identification consists of a set of registers that describe the implemented caches that are under\nthe control of the processor:\n• A single Cache Type Register defines:\n\t— the __minimum line length of any of the instruction caches__\n\t— the __minimum line length of any of the data or unified caches__\n\t— the __cache indexing and tagging policy of the Level 1 instruction cache.__\n\tFor more information, see:\n\t— CTR, Cache Type Register, VMSA on page B4-1556, for a VMSA implementation\n\t— CTR, Cache Type Register, PMSA on page B6-1835, for a PMSA implementation.\n\n• A single Cache Level ID Register defines:\n\t— the __type of cache implemented at a each cache level, up to the maximum of seven levels__\n\t— the Level of Coherence (LoC) for the caches\n\t— the Level of Unification (LoU) for the caches.\n\tFor more information, see:\n\t— CLIDR, Cache Level ID Register, VMSA on page B4-1530, for a VMSA implementation\n\t— CLIDR, Cache Level ID Register, PMSA on page B6-1816, for a PMSA implementation\n\n• A single Cache Size Selection Register selects the cache level and cache type of the current Cache Size\nIdentification Register, see:\n\t— CSSELR, Cache Size Selection Register, VMSA on page B4-1555, for a VMSA implementation\n\t— CSSELR, Cache Size Selection Register, PMSA on page B6-1834, for a PMSA implementation.\t\n\n• For each implemented cache, across all the levels of caching, a Cache Size Identification Register defines:\n\t— __whether the cache supports Write-Through, Write-Back, Read-Allocate and Write-Allocate__\n\t— __the number of sets, associativity and line length of the cache__\n\tFor more information, see:\n\t— CCSIDR, Cache Size ID Registers, VMSA on page B4-1528, for a VMSA implementation\n\t— CCSIDR, Cache Size ID Registers, PMSA on page B6-1814, for a PMSA implementation.\n\n###### Identifying the cache resources in ARMv7\t\nIn ARMv7 the architecture defines support for multiple levels of cache, up to a maximum of seven levels.\nsoftware must:\n1. __Read the Cache Type Register to find the indexing and tagging policy used for the Level 1 instruction cache.__\nThis register also provides the size of the smallest cache lines used for the instruction caches, and for the data\nand unified caches. These values are used in cache maintenance operations.\n\n2. __Read the Cache Level ID Register to find what caches are implemented__. The register includes seven Cache\ntype fields, for cache levels 1 to 7. Scanning these fields, starting from Level 1, identifies the instruction, data\nor unified caches implemented at each level. This scan ends when it reaches a level at which no caches are\ndefined. The Cache Level ID Register also provides the Level of Unification (LoU) and the Level of\nCoherence (LoC) for the cache implementation.\n\n3. For each cache identified at stage 2:\n• __Write to the Cache Size Selection Register to select the required cache.__ A cache is identified by its\nlevel, and whether it is:\n\t— an instruction cache\n\t— a data or unified cache.\n• Read the Cache Size ID Register to find details of the cache.\n\n##### B2.2.2 Cache behavior\n###### General behavior of the caches\nWhen a memory location is marked with a Normal Cacheable memory attribute, determining whether a copy of the\nmemory location is held in a cache still depends on many aspects of the implementation. The following\nnon-exhaustive list of factors might be involved:\n• the size, line length, and associativity of the cache\n• the cache allocation algorithm\n• activity by other elements of the system that can access the memory\n• speculative instruction fetching algorithms\n• speculative data fetching algorithms\n• interrupt behaviors.\n\nFor the purpose of these principles, a cache entry covers at least 16 bytes and no more than 2KB of contiguous\naddress space, aligned to its size.\n\n###### Behavior of the caches at reset\nIn ARMv7:\n• All caches are disabled at reset.\n• An implementation can require the use of a specific cache initialization routine to invalidate its storage array\nbefore it is enabled.\n\n\nB2.2.3 Cache enabling and disabling\nLevels of cache on page B2-1265 indicates that:\n• In ARMv7 the architecture defines the control of multiple levels of cache.\n• Before ARMv7 the architecture defines the control of only one level of cache.\n\nIn ARMv7:\n• SCTLR.C enables or disables all data and unified caches for data accesses, across all levels of cache visible\nto the processor. It is IMPLEMENTATION DEFINED whether it also enables or disables the use of unified caches\nfor instruction accesses.\n• SCTLR.I enables or disables all instruction caches, across all levels of cache visible to the processor.\n\t- SCTLR, System Control Register, VMSA on page B4-1707, for a VMSA implementation\n\t- SCTLR, System Control Register, PMSA on page B6-1932, for a PMSA implementation.\n\n\n##### B2.2.4 Branch predictors\nBranch predictor hardware typically uses a form of cache to hold branch information. The ARM architecture\npermits this branch predictor hardware to be visible to software, and so the branch predictor is not architecturally\ninvisible. This means that under some circumstances software must perform branch predictor maintenance to avoid\nincorrect execution caused by out-of-date entries in the branch predictor.\n\n###### Requirements for branch predictor maintenance operations\nthe instructions at the virtual addresses change:\n• enabling or disabling the MMU\n• writing new mappings to the translation tables\n• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,\nor a change to the VMID\n• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID.\n\nthen branch predictor maintenance operations must be performed to invalidate entries in the branch\npredictor, to ensure that the change is visible to subsequent execution.\n\n##### B2.2.6 About ARMv7 cache and branch predictor maintenance functionality\n\n###### Terms used in describing the maintenance operations\n• by the address of the memory location to be maintained, referred to as operating by MVA\n• by a mechanism that describes the location in the hardware of the cache, referred to as operating by set/way.\n\n\n###### Terminology for operations by MVA\nThe term Modified Virtual Address (MVA) relates to the Fast Context Switch Extension (FCSE) mechanism,described in Appendix D10 Fast Context Switch Extension (FCSE). When the FCSE is absent or disabled, the MVA and VA have the same value.\n\nVirtual addresses only exist in systems with a MMU. When no MMU is implemented, or all applicable MMUs are disabled, the MVA and VA are identical to the PA.\n\n###### Terminology for operations by set/way\nCache maintenance operations by set/way refer to the particular structures in a cache.\n\n__Level__\nThe cache level of the hierarchy.\n\n__Set__\nEach level of a cache is split up into a number of sets. Each set is a set of locations in a cache level to which an address can be assigned.\n\n__Way__\nThe Associativity of a cache defines the number of locations in a set to which an address can be assigned.\n\n##### B2.2.7 Cache and branch predictor maintenance operations\nCache and branch predictor maintenance operations are performed using accesses to CP15 c7. The following\nsections define the encodings for these operations:\n• Cache and branch predictor maintenance operations, VMSA on page B4-1743, for a VMSA implementation\n• Cache and branch predictor maintenance operations, PMSA on page B6-1943, for a PMSA implementation.\n\n###### Summary of cache and branch predictor maintenance operations\n__Data cache and unified cache operations__\nOperations by MVA\nThe data and unified cache operations by MVA are:\nDCIMVAC   Invalidate, to point of coherency.\nDCCMVAC   Clean, to point of coherency.\nDCCMVAU   Clean, to point of unification.\nDCCIMVAC  Clean and invalidate, to point of coherency.\n\nOperations by set/way\nThe data and unified cache operations by set/way are:\nDCISW     Invalidate.\nDCCSW     Clean.\nDCCISW    Clean and invalidate, to point of coherency.\n\n__Instruction cache operations__\nOperation by MVA\nICIMVAU \tInvalidate, to point of unification.\n\nOperations on all entries\nThe instruction cache operations that operate on all entries are:\nICIALLU \tInvalidate all, to point of unification.\nICIALLUIS \tInvalidate all, to point of unification, Inner Shareable.\n\n__Branch predictor operations__\nOperation by MVA\nBPIMVA \tInvalidate.\n\nOperations on all entries\nBPIALL \t\tInvalidate all.\nBPIALLIS \tInvalidate all, Inner Shareable.\n\n### B3 Virtual Memory System Architecture (VMSA)\n#### B3.1 About the VMSA\nIn VMSAv7, a Memory Management Unit (MMU) controls address translation, access permissions, and memory\nattribute determination and checking.\n\nEach supported stage of memory system control is provided by an MMU, with its own independent set of controls.\nTherefore, the Extended VMSAv7 provides the following MMUs:\n• Secure PL1&0 stage 1 MMU\n• Non-secure PL2 stage 1 MMU\n• Non-secure PL1&0 stage 1 MMU\n• Non-secure PL1&0 stage 2 MMU.\n\nFixme [Figure B3-1 VMSA translation regimes, and associated MMUs]page1309\n\n##### B3.1.1 Address types used in a VMSA description\n\n###### Virtual Address (VA)\nAn address used in an instruction, as a data or instruction address, is a Virtual Address (VA).\n__An address held in the PC, LR, or SP, is a VA.__\n\n###### Modified Virtual Address (MVA)\nOn an implementation that implements and uses the FCSE(Appendix D10 Fast Context Switch Extension (FCSE)), the FCSE takes a VA and transforms it to an MVA. \n\n###### Intermediate Physical Address (IPA)\nIn a translation regime that provides two stages of address translation, the IPA is the address after\nthe stage 1 translation, and is the input address for the stage 2 translation.\n\n###### Physical Address (PA)\n\n##### B3.1.2 Address spaces in a VMSA implementation\nThe ARMv7 architecture supports:\n• A VA address space of up to 32 bits. The actual width is IMPLEMENTATION DEFINED.\n• An IPA address space of up to 40 bits. The translation tables and associated system control registers define the width of the implemented address space.\n\nNote:\n>The Large Physical Address Extension defines two translation table formats. The Long-descriptor format gives access to the full 40-bit IPA or PA address space at a granularity of 4KB. The Short-descriptor format:\n• Gives access to a 32-bit PA address space at 4KB granularity.\n• Optionally, gives access to a 40-bit PA address space, but only at 16MB granularity.\n\nIf an implementation includes the Security Extensions, __the address maps are defined independently for Secure and Non-secure operation, providing two independent 40-bit address spaces__, where:\n• a VA accessed from Non-secure state can only be translated to the Non-secure address map\n• a VA accessed from Secure state can be translated to either the Secure or the Non-secure address map.\n\n##### B3.1.3 About address translation\n##### B3.1.3.1. VMSAv7 without the Security Extensions\nSupports only a single PL1&0 stage 1 MMU. Operation of this MMU can be split between two sets of translation tables, defined by TTBR0 and TTBR1, and controlled by TTBCR.\n\n##### B3.1.3.2. VMSAv7 with the Security Extensions but without the Virtualization Extensions\nSupports only the Secure PL1&0 stage 1 MMU and the Non-secure PL1&0 stage 1 MMU.\n\nOperation of each of these MMUs can be split between two sets of translation tables, __defined by the Secure and Non-secure copies of TTBR0 and TTBR1, and controlled by the Secure and Non-secure copies of TTBCR.__\n\n__Note__: Secure and Non-secure has copies of TTBR0 and TTBR1, TTBCR.\n\n##### B3.1.3.3. VMSAv7 with Virtualization Extensions\n__Secure PL1&0 stage 1 MMU__\nOperation of this MMU can be split between two sets of translation tables, defined by the Secure copies of TTBR0 and TTBR1, and controlled by the Secure copy of TTBCR.\n\n__Non-secure PL2 stage 1 MMU__\nThe HTTBR defines the translation table for this MMU, controlled by HTCR.\n\n__Non-secure PL1&0 stage 1 MMU__\nOperation of this MMU can be split between two sets of translation tables, defined by the Non-secure copies of TTBR0 and TTBR1 and controlled by the Non-secure copy of TTBCR.\n\n__Non-secure PL1&0 stage 2 control__\nThe VTTBR defines the translation table for this MMU, controlled by VTCR.\n\nFixme [Figure B3-2 Memory translation summary, with Virtualization Extensions]Page 1312\n\nA full translation table lookup is called a translation table walk.It is performed automatically by hardware.\n\n__Translation Lookaside Buffers (TLBs)__ reduce the average cost of a memory access by caching the results of translation table walks.\n\nTo reduce the software overhead of TLB maintenance, the VMSA distinguishes between Global pages and Process-specific pages. The __Address Space Identifier (ASID)__ identifies pages associated with __a specific process__ and provides a mechanism for changing process-specific tables without having to maintain the TLB tructures.\n\nIf an implementation includes the Virtualization Extensions, the __virtual machine identifier (VMID)__ identifies the current virtual machine, with its own independent ASID space.\n\n#### B3.2 The effects of disabling MMUs on VMSA behavior\nAbout the VMSA on page B3-1308 defines the translation regimes and the associated MMUs. The VMSA includes\nan enable bit for each MMU, as follows:\n• SCTLR.M, in the Secure copy of the register, controls Secure PL1&0 stage 1 MMU\n• SCTLR.M, in the Non-secure copy of the register, controls Non-secure PL1&0 stage 1 MMU\n• HCR.VM controls Non-secure PL1&0 stage 2 MMU\n• HSCTLR.M controls Non-secure PL2 stage 1 MMU.\n\n##### B3.2.1 VMSA behavior when a stage 1 MMU is disabled\n###### Non-secure PL1 and PL0 accesses when HCR.DC is set to 1, Virtualization Extensions\nIn an implementation that includes the Virtualization Extensions, for an access from a Non-secure PL1 or PL0 mode when HCR.DC is set to 1, the stage 1 translation assigns the Normal Non-shareable, Inner Write-Back Write-Allocate, Outer Write-Back Write-Allocate memory attributes.\n\n###### All other accesses\n__Data access__\nThe stage 1 translation assigns the Strongly-Ordered memory type.\n\nNote\nThis means the access is Non-cacheable. Unexpected data cache hit behavior is IMPLEMENTATION DEFINED.\n\n__Instruction access__\nThe stage 1 translation assigns Normal memory attribute, with the cacheability and\nshareability attributes determined by the value of:\n• the Secure copy of SCTLR.I for the Secure PL1&0 translation regime\n• the Non-secure copy of SCTLR.I for the Non-secure PL1&0 translation regime\n• HSCTLR.I for the Non-secure PL2 translation regime.\n\n##### B3.2.2 VMSA behavior when the stage 2 MMU is disabled\nWhen the stage 2 MMU is disabled:\n• the IPA output from the stage 1 translation maps __flat to the PA__\n• the memory attributes and permissions from the stage 1 translation apply to the PA.\n\nIf the stage 1 MMU and the stage 2 MMU are both disabled, see Behavior of instruction fetches when all associated\nMMUs are disabled.\n\n#### B3.3 Translation tables\nVMSAv7 defines two alternative translation table formats:\n\n__Short-descriptor format__\nThis is the original format defined in issue A of this Architecture Reference Manual, and is the only format supported on implementations that do not include the Large Physical Address Extension. It uses 32-bit descriptor entries in the translation tables, and provides:\n• __Up to two levels of address lookup.__\n• __32-bit input addresses.__\n• __Output addresses of up to 40 bits.__\n• Support for PAs of more than 32 bits by use of supersections, with 16MB granularity.\n• Support for No access, Client, and Manager domains.\n• __32-bit table entries.__\n\n__Long-descriptor format__\nThe Large Physical Address Extension adds support for this format. It uses 64-bit descriptor entries in the translation tables, and provides:\n• __Up to three levels of address lookup.__\n• __Input addresses of up to 40 bits, when used for stage 2 translations.__\n• __Output addresses of up to 40 bits.__\n• 4KB assignment granularity across the entire PA range.\n• No support for domains, all memory regions are treated as in a Client domain.\n• __64-bit table entries.__\n• Fixed 4KB table size, unless truncated by the size of the input address space.\n\nThe Large Physical Address Extension is an OPTIONAL extension, but an implementation that includes the Virtualization Extensions must also include the Large Physical Address Extension.\n\n##### B3.3.1 Translation table walks\nA translation table walk occurs as the result of a TLB miss, and starts with a read of the appropriate starting-level\ntranslation table.\n\nThe physical address of the base of the starting-level translation table is determined from the appropriate Translation\ntable base register (TTBR).\n\n##### B3.3.2 Information returned by a translation table lookup\nIf the required translation table descriptor is not held in a TLB, a translation table walk is performed to obtain the descriptor. A lookup, whether from the TLB or as the result of a translation table walk, returns both:\n• an output address that corresponds to the input address for the lookup\n• a set of properties that correspond to that output address.\n\nThe returned properties are classified as providing __address map control, access controls, or region attributes.__\n\n##### B3.3.3 Determining the translation table base address\n\nFixme[Figure B3-2 Memory translation summary, with Virtualization Extensions]page1312\n\n##### B3.3.4 Security Extensions control of translation table walks\nWhen an implementation includes the Security Extensions, two bits in the TTBCR for the current security state\ncontrol whether a translation table walk is performed on a TLB miss. These two bits are the:\n• PD0 and PD1 bits, on a processor using the Short-descriptor translation table format\n• EPD0 and EPD1 bits, on a processor using the Long-descriptor translation table format.\n\nThe effect of these bits is:\n{E}PDx == 0 If a TLB miss occurs based on TTBRx, a translation table walk is performed. The current security\nstate determines whether the memory access is Secure or Non-secure.\n{E}PDx == 1 If a TLB miss occurs based on TTBRx, a First level Translation fault is returned, and no translation\ntable walk is performed.\n\n##### B3.3.5 Access to the Secure or Non-secure physical address map\nAs stated in Address spaces in a VMSA implementation on page B3-1311, a processor that implements the Security\nExtensions implements independent Secure and Non-secure address maps. These are defined by the translation\ntables identified by the Secure TTBR0 and TTBR1. In both translation table formats:\n• In the Secure translation tables, the NS bit in a descriptor indicates whether the descriptor refers to the Secure\nor the Non-secure address map:\nNS == 0 Access the Secure physical address space.\nNS == 1 Access the Non-secure physical address space.\n\n#### B3.5 Short-descriptor translation table format\nThe Short-descriptor translation table format supports a memory map based on memory sections or pages:\n__Supersections__\nConsist of 16MB blocks of memory. Support for Supersections is optional, except that an\nimplementation that includes the Large Physical Address Extension and supports more that 32 bits\nof Physical Address must also support Supersections to provide access to the entire Physical\nAddress space.\n\n__Sections__\nConsist of 1MB blocks of memory.\n\n__Large pages__\nConsist of 64KB blocks of memory.\n\n__Small pages__\nConsist of 4KB blocks of memory.\n\nWhen using the Short-descriptor translation table format, two levels of translation tables are held in memory: \n- First-level table  \n- Second-level tables  \n\nIn the translation tables, in general, a descriptor is one of:\n• an invalid or fault entry\n• a page table entry, that points to a next-level translation table\n• a page or section entry, that defines the memory properties for the access\n• a reserved format.\nBits[1:0] of the descriptor give the primary indication of the descriptor type.\n\nFixme[Figure B3-3 General view of address translation using Short-descriptor format translation tables] Page 1325\n\n##### B3.5.1 Short-descriptor translation table format descriptors\n###### Short-descriptor translation table first-level descriptor formats\n\nFixme [Figure B3-4 Short-descriptor first-level descriptor formats] Page1326\n\nDescriptor bits[1:0] identify the descriptor type.\n\n###### Short-descriptor translation table second-level descriptor formats\nFixme [Figure B3-5 Short-descriptor second-level descriptor formats] Page1327\n\n##### B3.5.2 Memory attributes in the Short-descriptor translation table format descriptors\n\n__TEX[2:0], C, B__\nMemory region attribute bits, see Memory region attributes on page B3-1366.\nThese bits are not present in a Page table entry\n\n__XN bit__\nThe Execute-never bit. Determines whether the processor can execute software from the addressed\nregion, see Execute-never restrictions on instruction fetching on page B3-1359.\nThis bit is not present in a Page table entry.\n\n__PXN bit, when supported__\nThe Privileged execute-never bit:\n• On an implementation that does not include the Large Physical Address Extension, support\nfor the PXN bit in the Short-descriptor translation table format is OPTIONAL.\n• On an implementation that includes the Large Physical Address Extension, the\nShort-descriptor translation table format must include the PXN bit.\n\n__NS bit__\nNon-secure bit. If an implementation includes the Security Extensions, for memory accesses from\nSecure state, this bit specifies whether the translated PA is in the Secure or Non-secure address map\n\n__Domain__\nDomain field, see Domains, Short-descriptor format only on page B3-1362.\nPage table descriptor applies to all entries in the corresponding second-level translation table.\n\n__AP[2], AP[1:0]__\nAccess Permissions bits, see Memory access control on page B3-1356\n\n__S bit__\nThe Shareable bit.\n\n__nG bit__\nThe not global bit. Determines how the translation is marked in the TLB, see Global and\nprocess-specific translation table entries on page B3-1378.\n\n##### B3.5.4 Selecting between TTBR0 and TTBR1, Short-descriptor translation table format\nthe value of TTBCR.N indicates the number of most significant bits of the input VA that determine whether TTBR0 or TTBR1 :\n• If N == 0 then use TTBR0. Setting TTBCR.N to zero disables use of a second set of translation tables.\n• if N > 0 then:\n\t— if bits[31:32-N] of the input VA are all zero then use TTBR0\n\t— otherwise use TTBR1.\n\nFixme [Table B3-1 Effect of TTBCR.N on address translation, Short-descriptor format] page1330\nWhenever TTBCR.N is nonzero, the size of the translation table addressed by TTBR1 is 16KB.\n\nFixme [Figure B3-6 How TTBCR.N controls the boundary between the TTBRs, Short-descriptor format] page1331\n\n##### B3.5.5 Translation table walks, when using the Short-descriptor translation table format\n\n###### Reading a first-level translation table\nFixme [Figure B3-7 Accessing first-level translation table based on TTBR0, Short-descriptor format] page1332\n\n###### The full translation flow for Sections, Supersections, Small pages and Large pages\nFixme [Figure B3-11 Small page address translation] page1337\n\n#### B3.6 Long-descriptor translation table format\n\nFixme [Figure B3-12 General view of stage 1 address translation using Long-descriptor format]page1338\n\n##### B3.6.1 Long-descriptor translation table format descriptors\nIn general, a descriptor is one of:\n• an invalid or fault entry\n• a table entry, that points to the next-level translation table\n• a block entry, that defines the memory properties for the access\n• a reserved format.\n\n###### Long-descriptor translation table first-level and second-level descriptor formats\n\nFixme [Figure B3-14 Long-descriptor first-level and second-level descriptor formats]page1340\n\n###### Long-descriptor translation table third-level descriptor formats\nFixme [Figure B3-15 Long-descriptor third-level descriptor formats]page1341\n\n##### B3.6.3 Control of Secure or Non-secure memory access, Long-descriptor format\n\nIn the Long-descriptor format:\n• the NS bit relates only to the memory block or page at the output address defined by the descriptor\n• the descriptors also include an NSTable bit, see Hierarchical control of Secure or Non-secure memory\naccesses, Long-descriptor format.\n\nNSTable == 0 The defined table address is in the Secure physical address space. \nNSTable == 1 The defined table address is in the Non-secure physical address space.\n\n##### B3.6.4 Selecting between TTBR0 and TTBR1, Long-descriptor translation table format\nThe TTBCR.T0SZ and TTBCR.T1SZ size fields control the use of TTBR0 and TTBR1,\n\nFixme [Table B3-2 Use of TTBR0 and TTBR1, Long-descriptor format]page1345\n\nFixme [Figure B3-18 Control of TTBR boundary, when TTBCR.T1SZ is zero]page1346\n\n##### B3.6.5 Long-descriptor translation table format address lookup levels\n\nFixme [Table B3-3 Properties of the three levels of address lookup with Long-descriptor translation tables]page1348\n\n##### B3.6.6 Translation table walks, when using the Long-descriptor translation table format\nExample Full translation flow, starting at second-level lookup\nFixme [Figure B3-22 Complete Long-descriptor format stage 1 translation, starting at second level]page1355\n\n### B3.7 Memory access control\nIn addition to an output address, a translation table entry that refers to page or region of memory includes fields that\ndefine properties of the target memory region.\n\n##### B3.7.1 Access permissions\nAccess permission bits in a translation table descriptor control access to the corresponding memory region. The\nShort-descriptor translation table format supports two options for defining the access permissions:\n• three bits, AP[2:0], define the access permissions\n• two bits, AP[2:1], define the access permissions, and AP[0] can be used as an Access flag.\n\nSCTLR.AFE selects the access permissions option. Setting this bit to 1, to enable the Access flag, also selects use\nof AP[2:1] to define access permissions\n\nThe Long-descriptor translation table format uses only AP[2:1] to control the access permissions, and provides an\nAF bit for use as an Access flag\n\n###### AP[2:1] access permissions model\nFixme [Table B3-6 VMSAv7 AP[2:1] access permissions model]page1357\n\n###### AP[2:0] access permissions control, Short-descriptor format only\nFixme [Table B3-8 VMSAv7 MMU access permissions]page1358\n\n##### B3.7.2 Execute-never restrictions on instruction fetching\nExecute-never (XN) controls provide an additional level of control on memory accesses permitted by the access\npermissions settings. \n\n__XN, Execute-never__\nWhen the XN bit is 1, a Permission fault is generated if the processor attempts to execute an\ninstruction fetched from the corresponding memory region. \n\n__PXN, Privileged execute-never__\nWhen the PXN bit is 1, a Permission fault is generated if the processor is executing at PL1 and\nattempts to execute an instruction fetched from the corresponding memory region. \n\n##### B3.7.3 Domains, Short-descriptor format only\nA domain is a collection of memory regions. The Short-descriptor translation table format supports 16 domains, and\nrequires the software that defines a translation table to assign each VMSA memory region to a domain. \n\n##### B3.7.4 The Access flag\nThe Access flag indicates when a page or section of memory is accessed for the first time since the Access flag in\nthe corresponding translation table descriptor was set to 0\n\n##### B3.7.5 PL2 control of Non-secure access permissions\nNon-secure software executing at PL2 controls two sets of translation tables, both of which use the Long-descriptor\ntranslation table format:\n• The translation tables that control the Non-secure PL2 stage 1 translations. These map VAs to PAs, for\nmemory accesses made when executing in Non-secure state at PL2, and are indicated and controlled by the\nHTTBR and HTCR.\n\nThe HAP[2:1] field in the stage 2 descriptors define the stage 2 access permissions\nFixme [Table B3-9 Stage 2 control of access permissions]page1365\n\n#### B3.8 Memory region attributes\n\n##### B3.8.1 Overview of memory region attributes for stage 1 translations\n__Memory type and attributes__\nThese are described either:\n• Directly, by bits in the translation table descriptor.\n• Indirectly, by registers referenced by bits in the table descriptor. This is described as\nremapping the memory type and attribute description.\n\nThe Short-descriptor translation table format can use either of these approaches, selected by the\nSCTLR.TRE bit:\nTRE == 0 Remap disabled. The TEX[2:0], C, and B bits in the translation table descriptor define\nthe memory region attributes. \n\nTRE == 1 Remap enabled. The TEX[0], C, and B bits in the translation table descriptor are index\nbits to the MMU remap registers, that define the memory region attributes:\n• the Primary Region Remap Register, PRRR\n• the Normal Memory Remap Register, NMRR\n\nThe Long-descriptor translation table format always uses remapping. \n\n__Shareability__\nIn the Short-descriptor translation table format, the S bit in the translation table descriptor encodes\nwhether the region is shareable. \n\n##### B3.8.2 Short-descriptor format memory region attributes, without TEX remap\nFixme [Table B3-10 TEX, C, and B encodings when TRE == 0]page1367\n\nCacheable memory attributes, without TEX remap\nWhen TEX[2] == 1, the translation table entry describes Cacheable memory, and the rest of the encoding defines\nthe Inner and Outer cache attributes:\nTEX[1:0] Define the Outer cache attribute.\nC, B Define the Inner cache attribute.\n\nFixme [Table B3-11 Inner and Outer cache attribute encoding]page1368\n\n##### B3.8.3 Short-descriptor format memory region attributes, with TEX remap\n• The software that defines the translation tables must program the PRRR and NMRR to define seven possible\nmemory region attributes.\n• The TEX[0], C, and B bits of the translation table descriptors define the memory region attributes, by\nindexing PRRR and NMRR.\n\nFixme [Table B3-12 TEX, C, and B encodings when TRE == 1]page1369\n\n##### B3.8.4 Long-descriptor format memory region attributes\nthe AttrIndx[2:0] field in a block or page translation table descriptor for a stage 1 translation indicates the 8-bit field in the appropriate MAIR, that specifies\nthe attributes for the corresponding memory region:\n• AttrIndx[2] indicates the value of n in MAIRn:\nAttrIndx[2] == 0 Use MAIR0.\nAttrIndx[2] == 1 Use MAIR1\n\n• AttrIndx[2:0] indicates the required Attr field, Attrn, where n = AttrIndx[2:0].\nEach AttrIndx field defines, for the corresponding memory region:\n• The memory type, Strongly-ordered, Device, or Normal.\n• For Normal memory\n\t— the inner and outer cacheability, Non-cacheable, Write-Through, or Write-Back\n\t— for Write-Through Cacheable and Write-Back Cacheable regions, the Read-Allocate and\n\tWrite-Allocate policy hints, each of which is Allocate or Do not allocate\n\n###### Shareability, Long-descriptor format\nFixme [Table B3-14 SH[1:0] field encoding for Normal memory, Long-descriptor format]page1373\n\nFor a Device or Strongly-ordered memory region, the value of the SH[1:0] field of the translation table descriptor\nis ignored.\n\n#### B3.9 Translation Lookaside Buffers (TLBs)\nTranslation Lookaside Buffers (TLBs) are an implementation technique that caches translations or translation table entries.\nTLBs avoid the requirement for every memory access to perform a translation table walk in memory. \n\n##### B3.9.1  Global and process-specific translation table entries\nIn a VMSA implementation, system software can divide a virtual memory map used by memory accesses at PL1 and PL0 into global and non-global regions, indicated by the nG bit in the translation table descriptors:\nnG == 0 \nThe translation is global, meaning the region is available for all processes.\n\nnG == 1 \nThe translation is non-global, or process-specific, meaning it relates to the current ASID, as defined by the CONTEXTIDR.\n\n##### B3.9.2  TLB matching\n\n##### B3.9.3  TLB behavior at reset\nThe ARMv7 architecture does not require a reset to invalidate the TLB. All TLBs are disabled from reset. All MMUs are disabled from reset, and the contents of the TLBs have no effect on address translation.\n\n##### B3.9.5  TLB conflict aborts\nThe Large Physical Address Extension introduces the concept of a TLB conflict abort, and adds fault status encodings for such an abort.\n\nAn implementation can generate a TLB conflict abort if it detects that the address being looked up in the TLB hits multiple entries.\nIn some implementations, multiple hits in the TLB can generate a synchronous Data Abort or Prefetch Abort exception.\n\n#### B3.10 TLB maintenance requirements\n##### B3.10.1  General TLB maintenance requirements\n__The architecture defines CP15 c8 functions for TLB maintenance operations__, and supports the following operations:  \n- invalidate all unlocked entries in the TLB  \n- invalidate a single TLB entry, by MVA, or MVA and ASID for a non-global entry  \n- invalidate all TLB entries that match a specified ASID. \n  \nThe Multiprocessing Extensions add the following operations:\n• invalidate all TLB entries that match a specified MVA, regardless of the ASID\n\n###### Using break-before-make when updating translation table entries\n\nARM strongly recommends the use of a break-before-make when changing translation table entries whenever multiple threads of execution can use the same translation tables and the change to the translation entries involves any of:\n• A change of the memory type.\n• A change of the cacheability attributes.\n• A change of the output address (OA), if the OA of at least one of the old translation table entry and the new\ntranslation table entry is writable.\n\n__break-before-make__\n1.  Replace the old translation table entry, and execute DSB instruction.  \n2.  Invalidate the translation table entry with a broadcast TLB invalidation instruction, and execute a DSB instruction  \n3.  Write the new translation table entry, and execute a DSB instruction   \n\n##### B3.10.2 Maintenance requirements on changing system control register values\nThe TLB contents can be influenced by control bits in a number of system control registers. \n\nThe system control register changes that this applies to are:\n• any change to the NMRR, PRRR, MAIRn, or HMAIRn registers\n• any change to the SCTLR.AFE bit, see Changing the Access flag enable\n• any change to the SCTLR.TRE bit\n• any change to the translation table base address in TTBR0\n• any change to the translation table base address in TTBR1\n• in an implementation that includes the Virtualization Extensions:\n\t— any change to the SCTLR.{WXN, UWXN} bits\n\t— any change to the SCR.SIF bit\n\t— any change to the HCR.VM bit\n\t— any change to HCR.PTW bit, see Changing HCR.PTW\n\t— any change to the HTTBR.BADDR field\n\t— any change to the VTTBR.BADDR field\n• in an implementation that includes the Large Physical Address Extension, changing TTBCR.EAE, see\nChanging the current Translation table format on page B3-1386\n• when using the Short-descriptor translation table format:\n\t— any change to the RGN, IRGN, S, or NOS fields in TTBR0 or TTBR1\n\t— any change to the PD0 or PD1 fields in TTBCR\n• when using the Long-descriptor translation table format:\n\t— any change to the TnSZ, ORGNn, IRGNn, SHn, or EPDn fields in the TTBCR, where n is 0 or 1\n\t— any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the HTCR\n\t— any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the VTCR.\n\n##### B3.10.3 Atomicity of register changes on changing virtual machine\nFrom the viewpoint of software executing in a Non-secure PL1 or PL0 mode, when there is a switch from one virtual\nmachine to another, the registers that control or affect address translation must be changed atomically. \n\nThis applies to the registers for:\n• Non-secure PL1&0 stage 1 address translations. This means that all of the following registers must change  atomically:\n\t— PRRR and NMRR, if using the Short-descriptor translation table format\n\t— MAIR0 and MAIR1, if using the Long-descriptor translation table format\n\t— TTBR0, TTBR1, TTBCR, DACR, and CONTEXTIDR\n\t— the SCTLR.\n\n__These registers apply to execution in Non-secure PL1&0 modes. However, when updated as part of a switch of virtual machines they are updated by software executing in Hyp mode.__\n\n• Non-secure PL1&0 stage 2 address translations. This means that all of the following registers and register\nfields must change atomically:\n\t— VTTBR and VTCR\n\t— HMAIR0 and HMAIR1\n\t— the HSCTLR.\n\n##### B3.11 Caches in a VMSA implementation\nB3.11.1 Data and unified caches\n__The behavior of accesses from the same observer to different VAs, that are translated to the same PA with the same memory attributes, is fully coherent.__ This means these accesses behave as follows, regardless of\nwhich VA is accessed:\n• two writes to the same PA occur in program order\n• a read of a PA returns the value of the last successful write to that PA\n• a write to a PA that occurs, in program order, after a read of that PA, has no effect on the value returned by\nthat read.\nThe memory system behaves in this way without any requirement to use barrier or cache maintenance operations.\n\n#### B3.11.2 Instruction caches\nIn the ARM architecture, an instruction cache is a cache that is accessed only as a result of an instruction fetch.\nTherefore, __an instruction cache is never written to by any load or store instruction executed by the processor.__\n\nThe ARMv7 architecture supports three different behaviors for instruction caches:\n• Physically-indexed, physically-tagged(PIPT) instruction caches\n• Virtually-indexed, physically-tagged (VIPT) instruction caches\n• ASID and VMID tagged Virtually-indexed, virtually-tagged (VIVT) instruction caches.\n\n##### B3.11.2.1 PIPT instruction caches & VIPT instruction caches\nFor PIPT instruction caches, the use of memory address translation is entirely transparent to all instruction fetches\nthat are not UNPREDICTABLE.\n\nAn implementation that provides PIPT/VIPT instruction caches implements the IVIPT extension, see IVIPT architecture\nextension \n\n##### B3.11.2.2 IVIPT architecture extension\nIt reduces the instruction cache maintenance requirement to the following condition:\n• instruction cache maintenance is required only after writing new data to a physical address that holds an\ninstruction.\n\n##### B3.11.2.3 ASID and VMID tagged VIVT instruction caches\nInstruction maintenance can also be required as a result of any of the following situations:\n• enabling or disabling the MMU\n• writing new mappings to the translation tables\n• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,\nor a change to the VMID\n• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID\n\n#### B3.12 VMSA memory aborts\nIn a VMSAv7 implementation, the following mechanisms cause a processor to take an exception on a failed memory\naccess:\n__Debug exception__\nAn exception caused by the debug configuration, see About debug exceptions on\npage C4-2090.\n\n__Alignment fault__\nAn Alignment fault is generated if the address used for a memory access does not have the\nrequired alignment for the operation. For more information see Unaligned data access on\npage A3-108 and Alignment faults on page B3-1402.\n\n__MMU fault__\nAn MMU fault is a fault generated by the fault checking sequence for the current translation\nregime.\n\n__External abort__\nAny memory system fault other than a Debug exception, an Alignment fault, or an MMU\nfault\n\n##### B3.12.1 Routing of aborts\nA memory abort is either a Data Abort exception or a Prefetch Abort exception. The mode to which a memory abort\nis taken depends on the reason for the exception, the mode the processor is in when it takes the exception:\n\n__Memory aborts taken to Monitor mode__\nIf an implementation includes the Security Extensions, when SCR.EA is set to 1, all External aborts\nare taken to Monitor mode. This applies to aborts taken from Secure modes and from Non-secure\nmodes. \n\n__Memory aborts taken to Secure Abort mode__\nIf an implementation includes the Security Extensions, when the processor is executing in Secure\nstate, all memory aborts that are not routed to Monitor mode are taken to Secure Abort mode.\n\n__Memory aborts taken to Hyp mode__\n大致都发生在Hyp mode，Non-secure 时至少也是在stage 2 发生的错误（stage 1 VA -> IPA; stage2 IPA-> PA. 虚拟地址->中间地址->物理地址）\n\nincludes the Virtualization Extensions, the processor is executing in Non-secure state\n• Alignment faults taken:\n\t— When the processor is in Hyp mode.\n\t— When the processor is in a PL1 or PL0 mode and the exception is generated because\n\tthe Non-secure PL1&0 stage 2 translation identifies the target of an unaligned access\n\tas Device or Strongly-ordered memory.\n\t— When the processor is in the PL0 mode and HCR.TGE is set to 1. For more\n\tinformation see Synchronous external abort, when HCR.TGE is set to 1 on\n\tpage B1-1193.\n\n• When the processor is using the Non-secure PL1&0 translation regime:\n\t— MMU faults from stage 2 translations, for which the stage 1 translation did not cause\n\tan MMU fault.\n\t— Any abort taken during the stage 2 translation of an address accessed in a stage 1\n\ttranslation table walk that is not routed to Secure Monitor mode\n• When the processor is using the Non-secure PL2 translation regime, MMU faults from\nstage 1 translations.\n\n• External aborts, if SCR.EA is set to 0 and any of the following applies:\n\t— The processor was executing in Hyp mode when it took the exception.\n\t— The processor was executing in a Non-secure PL0 or PL1 mode when it took the\n\texception, the abort is asynchronous, and HCR.AMO is set to 1.\n\t— The processor was executing in the Non-secure PL0 mode when it took the exception,\n\tthe abort is synchronous, and HCR.TGE is set to 1. For more information see\n\tSynchronous external abort, when HCR.TGE is set to 1 on page B1-1193.\n\t— The abort occurred on a stage 2 translation table walk.\n\n• Debug exceptions, if HDCR.TDE is set to 1.\n\n__Memory aborts taken to Non-secure Abort mode__\nIn an implementation that does not include the Security Extensions, all memory aborts are taken to\nAbort mode.\nOtherwise, when the processor is executing in Non-secure state, the following aborts are taken to\nNon-secure Abort mode:\n• When the processor is in a Non-secure PL1 or PL0 mode, Alignment faults taken for any of\nthe following reasons:\n\t— SCTLR.A is set to 1.\n\t— An instruction that does not support unaligned accesses is committed for execution,\n\tand the instruction accesses an unaligned address.\n\t— The implementation includes the Virtualization Extensions, and the PL1&0 stage 1\n\ttranslation identifies the target of an unaligned access as Device or Strongly-ordered\n\tmemory.\n• When the processor is using the Non-secure PL1&0 translation regime, MMU faults from\nstage 1 translations.\n• External aborts, if all of the following apply:\n\t— the abort is not on a stage 2 translation table walk\n\t— the processor is not in Hyp mode\n\t— SCR.EA is set to 0\n\t— the abort is asynchronous, and HCR.AMO is set to 0\n\t— the abort is synchronous, and HCR.TGE is set to 0• When the processor is using the Non-secure PL1&0 translation regime, MMU faults from\nstage 1 translations.\n• External aborts, if all of the following apply:\n\t— the abort is not on a stage 2 translation table walk\n\t— the processor is not in Hyp mode\n\t— SCR.EA is set to 0\n\t— the abort is asynchronous, and HCR.AMO is set to 0\n\t— the abort is synchronous, and HCR.TGE is set to 0\n\n##### B3.12.3 The MMU fault-checking sequence\nIn a VMSA implementation, all memory accesses require VA to PA translation. Therefore, when a corresponding\nMMU is enabled, each access requires a lookup of the translation table descriptor for the accessed VA. \n\nWhen using the Short-descriptor format\n• There are one or two levels of lookup.\n• Lookup always starts at the first level.\n• The final level of lookup checks the Domain field of the descriptor and:\n\t— faults if there is no access to the Domain\n\t— checks the access permissions only for Client domains.\nWhen using the Long-descriptor format\n• There are one, two, or three levels of lookup.\n• Lookup starts at either the first level or the second level.\n• Domains are not supported. All accesses are treated as Client domain accesses.\n\nFixme [Figure B3-23 Fetching the descriptor in a translation table walk]Page1400\n\nFixme [Figure B3-24 VMSA fault checking sequence]Page1401\n\n__Stage 2 fault on a stage 1 translation table walk, Virtualization Extensions__\nWhen an implementation that includes the Virtualization Extensions is operating in a Non-secure PL1 or PL0 mode,\nany memory access goes through two stages of translation:\n• stage 1, from VA to IPA\n• stage 2, from IPA to PA\n\n##### B3.12.4 Alignment faults\nThe ARMv7 memory architecture requires support for strict alignment checking. This checking is controlled by\nSCTLR.A.\n\nAn Alignment fault can occur on an access for which the MMU is disabled.\n\n__In an implementation that includes the Virtualization Extensions, any unaligned access to memory region with the Device or Strongly-ordered memory type attribute generates an Alignment fault.__\n\n##### B3.12.5 MMU faults\nThis section describes the faults that might be detected during one of the fault-checking sequences described in The\nMMU fault-checking sequence.\n\nThe following subsections describe the MMU faults that might be detected during a fault checking sequence:\n• External abort on a translation table walk\n• Translation fault\n• Access flag fault on page B3-1404\n• Domain fault, Short-descriptor format translation tables only on page B3-1404\n• Permission fault on page B3-1405.\n\n__Translation fault__\nA Translation fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.\nA Translation fault is generated if bits[1:0] of a translation table descriptor identify the descriptor as either a Fault\nencoding or a reserved encoding.\n\nIn addition, if an implementation includes the Virtualization Extensions, then a Translation fault is generated if the\ninput address for a translation either does not map on to an address range of a Translation Table Base Register, or\nthe Translation Table Base Register range that it maps on to is disabled. \n\nThe architecture guarantees that any translation table entry that causes a Translation fault is not cached,\n\n__Access flag fault__\nAn Access flag fault can be generated at any level of lookup,\n• The translation tables support an Access flag bit:\n\t— the Short-descriptor format supports an Access flag only when SCTLR.AFE is set to 1\n\t— the Long-descriptor format always supports an Access flag.\n\nThe architecture guarantees that any translation table entry that causes an Access flag fault is not cached, meaning\nthe TLB never holds such an entry.\n\n__Domain fault, Short-descriptor format translation tables only__\nWhen using the Short-descriptor translation table format, a Domain fault can be generated at the first level or second\nlevel of lookup.\n\nWhen a first-level/second-level descriptor fetch returns a valid Section first-level descriptor, the domain field of\nthat descriptor is checked against the DACR. A first-level Domain fault is generated if this check\nfails.\n\nA TLB might hold a translation table entry that cause a Domain fault.\n\n__Permission fault__\nA Permission fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.\n\nA TLB might hold a translation table entry that cause a Permission fault. Therefore, if the handling of a Permission\nfault results in an update to the associated translation tables, the software that updates the translation tables must\ninvalidate the appropriate TLB entry.\n\nB3.12.6 External aborts\nThe ARM architecture defines external aborts as errors that occur in the memory system, other than those that are\ndetected by the MMU or Debug hardware.An external abort is one of:\n• synchronous\n• precise asynchronous\n• imprecise asynchronous.\n\nThe ARM architecture does not provide any method to distinguish between precise asynchronous and imprecise\nasynchronous aborts.\n\nNormally, external aborts are rare. An imprecise asynchronous external abort is likely to be fatal to the process that\nis running. \n\n##### B3.12.7 Prioritization of aborts\nprioritization decreasing in next order:\n1. Alignment fault\n2. an MMU fault, on either the stage 1 translation or the stage 2 translation\n3. a Watchpoint debug event.\n4. an external abort\n\n#### B3.13 Exception reporting in a VMSA implementation\n##### B3.13.1 About exception reporting\nIn an implementation that includes the Virtualization Extensions, exceptions can be taken to:\n• a Secure or Non-secure PL1 mode\n• the Non-secure PL2 mode, Hyp mode.\n\n##### B3.13.2 Reporting exceptions taken to PL1 modes\n__Registers used for reporting exceptions taken to a PL1 mode__\nARMv7 defines the following registers, and register encodings, for exceptions taken to PL1 modes:\n• the DFSR holds information about a Data Abort exception\n• the DFAR holds the faulting address for some synchronous Data Abort exceptions\n• the IFSR holds information about a Prefetch Abort exception\n• the IFAR holds the faulting address of a Prefetch Abort exception\n• on a Watchpoint debug exception, the DBGWFAR can hold fault information.\n\n__Auxiliary Fault Status Registers__\nThe ARMv7 architecture defines the following Auxiliary Fault Status Registers:\n• the Auxiliary Data Fault Status Register, ADFSR\n• the Auxiliary Instruction Fault Status Register, AIFSR.\n\n##### B3.13.3 Fault reporting in PL1 modes\nFixme [Table B3-23 Short-descriptor format FSR encodings] Page 1415\n\nFixme [Table B3-24 Long-descriptor format FSR encodings] Page 1416\n\n##### B3.13.5 Reporting exceptions taken to the Non-secure PL2 mode\n__Registers used for reporting exceptions taken to Hyp mode__\nThe Virtualization Extensions define the following registers for exceptions taken to Hyp mode:\n• the HSR holds syndrome information for the exception\n• the HDFAR holds the VA associated with a Data Abort exception\n• the HIFAR holds the VA associated with a Prefetch Abort exception\n• the HPFAR holds bits[39:12] of the IPA associated with some aborts on stage 2 address translations.\n\n__Hyp Auxiliary Fault Syndrome Registers__\nThe Virtualization Extensions define the following Hyp Auxiliary Fault Syndrome Registers:\n• the Hyp Auxiliary Data Fault Syndrome Register, HADFSR\n• the Hyp Auxiliary Instruction Fault Syndrome Register, HAIFSR.\n\nFixme [Table B3-28 HSR.EC encodings for aborts taken to Hyp mode] Page 1422\n\n##### B3.13.6 Use of the HSR\nThe HSR holds syndrome information for any synchronous exception taken to Hyp mode. Compared with the\nreporting of exceptions taken to PL1 modes, the HSR:\n• Always provides details of the fault. The DFSR and IFSR are not used.\n• Provides more extensive information, for a wider range of exceptions.\n\nFixme [Figure B3-25 Format of the HSR, with subdivision of the ISS field for specified EC encodings] Page 1425\n\nFixme [Table B3-29 HSR.EC field encoding] Page 1425\n\nMore detail ISS encoding see arm-arm pdf\n\n#### B3.14 Virtual Address to Physical Address translation operation\n__CP15 c7 includes operations for Virtual Address (VA) to Physical Address (PA) translation.__\n\n##### B3.14.1 Naming of the address translation operations, and operation summary\nFixme [Table B3-31 Naming of address translation operations] Page 1438\n\nIn the stage 1 current state and stages 1 and 2 Non-secure state only operations, the meanings of the last two letters\nof the names are:\n- PR PL1 mode, read operation.  \n- PW PL1 mode, write operation.  \n- UR PL0 mode, read operation.  \n- UW PL0 mode, write operation.\n\n##### B3.14.2 Encoding and availability of the address translation operations\nSoftware executing at PL0 never has any visibility of the address translation operations, but software executing at\nPL1 or higher can use the unprivileged address translation operations to find the address translations used for\nmemory accesses by software executing at PL0 and PL1.\n\nFixme [Table B3-32 CP15 c7 address translation operations] Page 1440\n\nThe result of an operation is always returned in the PAR. The PAR is a RW register and:\n• in all implementations, the 32-bit format PAR is accessed using an MCR or MRC instruction with CRn set to c7,\nCRm set to c4, and opc1 and opc2 both set to 0\n• in an implementation that includes the Large Physical Address Extension, the 64-bit format PAR is accessed\nusing an MCRR or MRRC instruction with CRm set to c7, and opc1 set to 0.\n\n##### B3.14.3 Determining the PAR format, Large Physical Address Extension\nThe Large Physical Address Extension extends the PAR to become a 64-bit register, and supports both 32-bit and\n64-bit PAR formats\n\n#### B3.15 About the system control registers for VMSA\nOn an ARMv7-A or ARMv7-R implementation, the system control registers comprise:\n• the registers accessed using the System Control Coprocessor, CP15\n• registers accessed using the CP14 coprocessor, including:\n\t— debug registers\n\t— trace registers\n\t— execution environment registers.\n\n##### B3.15.3 Classification of system control registers\n__Banked system control registers__\nFixme [Table B3-33 Banked CP15 registers] Page 1452\n\n__Restricted access system control registers__\nFixme [Table B3-34 Restricted access CP15 registers] Page 1453\n\n__PL2-mode system control registers__\nFixme [Table B3-35 Banked PL2-mode CP15 read/write registers] Page 1455\n\nFixme [Table B3-37 Banked PL2-mode CP15 write-only operations] Page 1457\n\n__Common system control registers__\nSome system control registers and operations are common to the Secure and Non-secure security states.\nFixme [Table B3-38 Common CP15 registers] Page 1457\n\n#### B3.16 Organization of the CP14 registers in a VMSA implementation\nThe CP14 registers provide a number of distinct control functions, covering:\n• Debug\n• Trace\n• Execution environment control, for the Jazelle and ThumbEE execution environments.\n\nThe CP14 register encodings are classified by the {CRn, opc1, CRm, opc2} values required to access them using\nan MCR or an MRC instruction. The opc1 value determines the primary allocation of these registers, as follows:\nopc1==0 Debug registers.\nopc1==1 Trace registers.\nopc1==6 ThumbEE registers.\nopc1==7 Jazelle registers. Can include Jazelle SUBARCHITECTURE DEFINED registers\n\n#### B3.17 Organization of the CP15 registers in a VMSA implementation\nMore precisely, the ordered set of values {CRn, opc1, CRm, opc2} determined the register order.\n\n##### B3.17.1 CP15 register summary by coprocessor register number\nFixme [Figure B3-26 CP15 register grouping by primary coprocessor register, CRn, VMSA implementation] Page 1470\n\n__VMSA CP15 c0 register summary, identification registers__\nFixme [Figure B3-27 CP15 c0 registers in a VMSA implementation] Page 1471\n\n__VMSA CP15 c1 register summary, system control registers__\nFixme [Figure B3-28 CP15 c1 registers in a VMSA implementation] Page 1472\n\n__VMSA CP15 c2 and c3 register summary, Memory protection and control registers__\nFixme [Figure B3-29 CP15 32-bit c2 and c3 registers] Page 1473\n\nFixme [Figure B3-30 CP15 64-bit c2 registers] Page 1473\n\n__VMSA CP15 c5 and c6 register summary, Memory system fault registers__\nFixme [Figure B3-31 CP15 c5 and c6 registers in a VMSA implementation] Page 1474\n\n__VMSA CP15 c7 register summary, Cache maintenance, address translation, and other functions__\nFixme [Figure B3-32 CP15 32-bit c7 registers in a VMSA implementation] Page 1475\n\n__VMSA CP15 c8 register summary, TLB maintenance operations__\nFixme [Figure B3-34 CP15 c8 registers in a VMSA implementation] Page 1476\n\n__VMSA CP15 c9 register summary, reserved for cache and TCM control and performance monitors__\nFixme [Figure B3-35 Reserved CP15 c9 encodings] Page 1477\n\n__VMSA CP15 c10 register summary, memory remapping and TLB control registers__\nFixme [Figure B3-36 CP15 c10 registers in a VMSA implementation] Page 1478\n\n__VMSA CP15 c11 register summary, reserved for TCM DMA registers__\nFixme [Figure B3-37 Reserved CP15 c11 encodings] Page 1478\n\n__VMSA CP15 c12 register summary, Security Extensions registers__\nFixme [Figure B3-38 Security Extensions CP15 c12 registers] Page 1479\n\n__VMSA CP15 c13 register summary, Process, context and thread ID registers__\nOn an ARMv7-A implementation, the CP15 c13 registers provide:\n• an FCSE Process ID Register, that indicates whether the implementation includes the FCSE\n• a Context ID Register\n• Software Thread ID Registers.\nFixme [Figure B3-39 CP15 c13 registers in a VMSA implementation] Page 1479\n\n__VMSA CP15 c14, reserved for Generic Timer Extension__\nFixme [Figure B3-40 CP15 32-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480\nFixme [Figure B3-41 CP15 64-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480\n\n__VMSA CP15 c15 register summary, IMPLEMENTATION DEFINED registers__\n\n##### B3.17.2 Full list of VMSA CP15 registers, by coprocessor register number\nFixme [Table B3-42 Summary of VMSA CP15 register descriptions, in coprocessor register number order] Page 1481\n\n#### B3.18 Functional grouping of VMSAv7 system control registers\n##### B3.18.1 Identification registers, functional group\nFixme [Table B3-44 Identification registers, VMSA] Page 1492\n\n##### B3.18.2 Virtual memory control registers, functional group\nFixme [Table B3-45 Virtual memory control registers, VMSA only] Page 1493\n\n##### B3.18.3 PL1 Fault handling registers, functional group\nFixme [Table B3-46 Fault handling registers, VMSA] Page 1494\n\n##### B3.18.4 Other system control registers, functional group\nFixme [Table B3-47 Other system control registers, VMSA] Page 1494\n\n##### B3.18.5 Lockdown, DMA, and TCM features, functional group, VMSA\nFixme [Table B3-48 Lockdown, DMA, and TCM features, VMSA] Page 1495\n\n##### B3.18.6 Cache maintenance operations, functional group, VMSA\nFixme [Table B3-49 Cache and branch predictor maintenance operations, VMSA] Page 1496\n\n##### B3.18.7 TLB maintenance operations, functional group\nFixme [Table B3-50 TLB maintenance operations, VMSA only] Page 1497\n\n##### B3.18.8 Address translation operations, functional group\nFixme [Table B3-51 Address translation operations, VMSA only] Page 1498\n\n##### B3.18.9 Miscellaneous operations, functional group\nFixme [Table B3-52 Miscellaneous system control operations, VMSA only] Page 1499\n\n##### B3.18.10 Performance Monitors, functional group\nFixme [Table B3-53 Performance monitors, VMSA] Page 1500\n\n##### B3.18.11 Security Extensions registers, functional group\nFixme [Table B3-54 Security Extensions registers, VMSA only] Page 1500\n\n##### B3.18.12 Virtualization Extensions registers, functional group\nFixme [Table B3-55 Virtualization Extensions registers, VMSA with Virtualization Extensions only] Page 1501\n\nFixme [Table B3-56 Hyp mode TLB maintenance operations, VMSA with Virtualization Extensions only] Page 1502\n\n##### B3.18.13 Generic Timer Extension registers\n\n##### B3.18.14 IMPLEMENTATION DEFINED registers, functional group\nTypically, an implementation uses CP15 c15 to provide test features, and any required configuration options that\nare not covered by this manual.\n\n### B4 System Control Registers in a VMSA implementation\nSkip\n\n### B5 Protected Memory System Architecture (PMSA)\nSkip\n\n### B6 System Control Registers in a PMSA implementation\nSkip\n\n### B7 The CPUID Identification Scheme\n#### B7.1 Introduction to the CPUID scheme\nBefore ARMv7, using Main ID Register:\n• MIDR, Main ID Register, VMSA on page B4-1649\n• MIDR, Main ID Register, PMSA on page B6-1894.\n\nThe ARMv7 architecture implements an extended processor, using a number of registers in CP15 c0.\n__ARMv7 requires the use of this scheme, and use of the scheme is indicated by a value of 0xF in the Architecture field of the Main ID Register.__\n\nThe CPUID scheme provides information about the implemented:\n• processor features\n• debug features\n• auxiliary features, in particular IMPLEMENTATION DEFINED features\n• memory model features\n• instruction set features.\n\n#### B7.2 The CPUID registers\n##### B7.2.1 Organization of the CPUID registers\nFixme[Figure B7-1 CPUID register encodings] Page 1951\n\nFixme[Table B7-1 CPUID register summary] Page 1952\n\n##### B7.2.2 About the Instruction Set Attribute registers\nFixme[Table B7-2 Alphabetic list of Instruction Set Attribute registers attribute fields] Page 1954\n\n### B8. The Generic Timer\n#### B8.1 About the Generic Timer\nFixme[Figure B8-1 Generic Timer example] page1960\n\n##### 8.1.1 System counter\nThe Generic Timer provides a system counter with the following specification:\n__Width__\nAt least 56 bits wide.\nThe value returned by any 64-bit read of the counter is zero-extended to 64 bits.\n\n__Frequency__\nIncrements at a fixed frequency, typically in the range 1-50MHz.\nCan support one or more alternative operating modes in which it increments by larger amounts at a\nlower frequency, typically for power-saving.\nRoll-over Roll-over time of not less than 40 years.\n\n__Accuracy__\nARM does not specify a required accuracy, but recommends that the counter does not gain or lose\nmore than ten seconds in a 24-hour period.\nUse of lower-frequency modes must not affect the implemented accuracy.\n\n__Start-up__\nStarts operating from zero.\n\nThe system counter must be implemented in an always-on power domain.\n\n###### Initializing and reading the system counter frequency\nTypically, the system drives the system counter at a fixed frequency and the CNTFRQ register must be programmed\nto this value during the system boot process. \n\nIn an implementation that supports the ARM Security Extensions, only\nsoftware executing in a Secure PL1 mode can write to CNTFRQ.\n\nSoftware can read the CNTFRQ register, to determine the current system counter frequency, in the following states\nand modes:\n• Non-secure PL2 mode.\n• Secure and Non-secure PL1 modes.\n• When CNTKCTL.PL0PCTEN is set to 1, Secure and Non-secure PL0 modes.\n\n##### 8.1.2 The physical counter\nThe processor provides a physical counter that contains the count value of the system counter. The CNTPCT register\nholds the current physical counter value.\n\nIn an implementation that includes the Virtualization Extensions, CNTPCT:\n• Is always accessible from Secure PL1 modes, and from Non-secure Hyp mode.\n• Is accessible from Non-secure PL1 modes only when CNTHCTL.PL1PCTEN is set to 1. When\nCNTHCTL.PL1PCTEN is set to 0, any attempt to access CNTPCT from a Non-secure PL1 mode generates\na Hyp Trap exception, see Hyp Trap exception on page B1-1209.\n\n##### 8.1.3 The virtual counter\nAn implementation of the Generic Timer always includes a virtual counter, that indicates virtual time:\n• In a processor implementation that does not include the Virtualization Extensions, virtual time is identical to\nphysical time, and the virtual counter contains the same value as the physical counter.\n• In a processor implementation that includes the Virtualization Extensions, the virtual counter contains the\nvalue of the physical counter minus a 64-bit virtual offset. When execu\n\nCNTVCT is always accessible from Secure PL1 modes, and from Non-secure PL1 and PL2 modes\n\n##### 8.1.5 Timers\nThe number of timers provided by an implementation of the Generic Timer depends on whether the implementation\nincludes the Security Extensions and the Virtualization Extensions, as follows:\n\n__Security Extensions not implemented__\nThe implementation provides a physical timer and a virtual timer.\n\n__Security Extensions implemented, Virtualization Extensions not implemented__\nThe implementation provides:  \n- A Non-secure physical timer.  \n- A Secure physical timer.  \n- A virtual timer.\n\n__Virtualization Extensions implemented__\nThe implementation provides:\n- A Non-secure PL1 physical timer.  \n- A Secure PL1 physical timer.  \n- A Non-secure PL2 physical timer.  \n- A virtual timer\n\nEach timer is implemented as three registers:  \n- A 64-bit CompareValue register, that provides a 64-bit unsigned upcounter.  \n- A 32-bit TimerValue register, that provides a 32-bit signed downcounter.  \n- A 32-bit Control register.\n\nFixme[Table B8-1 Timer registers summary for the Generic Timer] page1965\n\n#### 8.2 Generic Timer registers summary\nFixme[Table B8-2 Generic Timer registers] page1969\n","slug":"arm_arm_part_B","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p101008rzkgrp45b5f4j","content":"<p>Reference: &lt;<arm ®=\"\" architecture=\"\" reference=\"\" manual=\"\" --=\"\" armv7-a=\"\" and=\"\" armv7-r=\"\" edition=\"\">&gt; (ARM DDI 0406C.c (ID051414))<br><a id=\"more\"></a></arm></p>\n<h2 id=\"Part-B-System-Level-Architecture\"><a href=\"#Part-B-System-Level-Architecture\" class=\"headerlink\" title=\"Part B System Level Architecture\"></a>Part B System Level Architecture</h2><h3 id=\"B1-System-Level-Programmers’-Model\"><a href=\"#B1-System-Level-Programmers’-Model\" class=\"headerlink\" title=\"B1 System Level Programmers’ Model\"></a>B1 System Level Programmers’ Model</h3><h4 id=\"B1-1-About-the-System-level-programmers’-model\"><a href=\"#B1-1-About-the-System-level-programmers’-model\" class=\"headerlink\" title=\"B1.1 About the System level programmers’ model\"></a>B1.1 About the System level programmers’ model</h4><h4 id=\"B1-2-System-level-concepts-and-terminology\"><a href=\"#B1-2-System-level-concepts-and-terminology\" class=\"headerlink\" title=\"B1.2 System level concepts and terminology\"></a>B1.2 System level concepts and terminology</h4><h5 id=\"B1-2-1-Mode-state-and-privilege-level\"><a href=\"#B1-2-1-Mode-state-and-privilege-level\" class=\"headerlink\" title=\"B1.2.1 Mode, state, and privilege level\"></a>B1.2.1 Mode, state, and privilege level</h5><h6 id=\"Mode\"><a href=\"#Mode\" class=\"headerlink\" title=\"Mode\"></a>Mode</h6><p>The ARM architecture A and R profiles provide a set of modes that support normal software execution and handle<br>exceptions. The current mode determines:<br>• the set of registers that are available to the processor<br>• the privilege level of the executing software</p>\n<h6 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h6><ul>\n<li>Instruction set state</li>\n</ul>\n<blockquote>\n<p>one of ARM state, Thumb state, Jazelle state, or ThumbEE state.</p>\n</blockquote>\n<ul>\n<li>Execution state</li>\n</ul>\n<blockquote>\n<p>consists of the instruction set state and some control bits that modify how the<br>instruction stream is decoded. For details, see Execution state registers on page A2-50 and Program<br>Status Registers (PSRs) on page B1-1147.</p>\n</blockquote>\n<ul>\n<li><p>Security state </p>\n</li>\n<li><p>Debug state</p>\n</li>\n</ul>\n<h6 id=\"Privilege-level\"><a href=\"#Privilege-level\" class=\"headerlink\" title=\"Privilege level\"></a>Privilege level</h6><p><strong>Secure state</strong><br>PL0 Software executed in User mode executes at PL0.<br>PL1 Software executed in any mode other than User mode executes at PL1.</p>\n<p><strong>Non-secure state</strong><br>PL0 Software executed in User mode executes at PL0.<br>PL1 Software executed in any mode other than User or Hyp mode executes at PL1.<br>PL2 In an implementation that includes the Virtualization Extensions, software executed in<br>Hyp mode executes at PL2.</p>\n<h4 id=\"B1-3-ARM-processor-modes-and-ARM-core-registers\"><a href=\"#B1-3-ARM-processor-modes-and-ARM-core-registers\" class=\"headerlink\" title=\"B1.3 ARM processor modes and ARM core registers\"></a>B1.3 ARM processor modes and ARM core registers</h4><h5 id=\"B1-3-1-ARM-processor-modes\"><a href=\"#B1-3-1-ARM-processor-modes\" class=\"headerlink\" title=\"B1.3.1 ARM processor modes\"></a>B1.3.1 ARM processor modes</h5><p>Fixme [Table B1-1 ARM processor modes] page1139</p>\n<h6 id=\"System-mode\"><a href=\"#System-mode\" class=\"headerlink\" title=\"System mode\"></a>System mode</h6><p>Software executing in System mode executes at PL1. System mode has the same registers available<br>as User mode, and is not entered by any exception.</p>\n<h6 id=\"Supervisor-mode\"><a href=\"#Supervisor-mode\" class=\"headerlink\" title=\"Supervisor mode\"></a>Supervisor mode</h6><p>Supervisor mode is the default mode to which a Supervisor Call exception is taken.<br>Executing a SVC (Supervisor Call) instruction generates an Supervisor Call exception, that is taken<br>to Supervisor mode.<br><strong>A processor enters Supervisor mode on Reset</strong></p>\n<h6 id=\"Hyp-mode\"><a href=\"#Hyp-mode\" class=\"headerlink\" title=\"Hyp mode\"></a>Hyp mode</h6><p>Hyp mode is the Non-secure PL2 mode, implemented as part of the Virtualization Extensions.<br>The Hypervisor Call exception and Hyp Trap exception are exceptions that are implemented as part<br>of the Virtualization Extensions, and that are always taken in Hyp mode.<br>• <strong>In Hyp mode, the only exception return is execution of an ERET instruction, see ERET on page B9-1982</strong><br>• The instructions described in the following sections are UNDEFINED if executed in Hyp mode:<br>    — SRS (Thumb) on page B9-2004<br>    — SRS (ARM) on page B9-2006<br>    — RFE on page B9-2000<br>    — LDM (exception return) on page B9-1986<br>    — LDM (User registers) on page B9-1988<br>    — STM (User registers) on page B9-2008<br>    — SUBS PC, LR and related instructions (ARM) on page B9-2012.<br>    — SUBS PC, LR (Thumb) on page B9-2010, when executed with a nonzero constant.</p>\n<p>• In Hyp mode, the CPACR has no effect on the execution of coprocessor, floating-point, or Advanced SIMD<br>instructions. The HCPTR controls execution of these instructions in Hyp mode.</p>\n<p>• If software running in Hyp mode executes an SVC instruction, the Supervisor Call exception generated by the<br>instruction is taken to Hyp mode, see SVC (previously SWI) on page A8-720.</p>\n<h6 id=\"Monitor-mode\"><a href=\"#Monitor-mode\" class=\"headerlink\" title=\"Monitor mode\"></a>Monitor mode</h6><p>Monitor mode is the mode to which a Secure Monitor Call exception is taken.<br>Monitor mode is a Secure mode, meaning it is always in the Secure state, regardless of the value of<br>the SCR.NS bit. <strong>Monitor mode provides the normal method of changing between the Secure and Non-secure security states.</strong></p>\n<p>Fixme [Figure B1-1 Modes, privilege levels, and security states] page1141</p>\n<h5 id=\"B1-3-2-ARM-core-registers\"><a href=\"#B1-3-2-ARM-core-registers\" class=\"headerlink\" title=\"B1.3.2 ARM core registers\"></a>B1.3.2 ARM core registers</h5><p>Fixme [Figure B1-2 ARM core registers, PSRs, and ELR_hyp, showing register banking] page1144</p>\n<h5 id=\"B1-3-3-Program-Status-Registers-PSRs\"><a href=\"#B1-3-3-Program-Status-Registers-PSRs\" class=\"headerlink\" title=\"B1.3.3 Program Status Registers (PSRs)\"></a>B1.3.3 Program Status Registers (PSRs)</h5><h6 id=\"The-Current-Program-Status-Register-CPSR\"><a href=\"#The-Current-Program-Status-Register-CPSR\" class=\"headerlink\" title=\"The Current Program Status Register (CPSR)\"></a>The Current Program Status Register (CPSR)</h6><p>The Current Program Status Register (CPSR) holds processor status and control information:<br>• the APSR, see The Application Program Status Register (APSR) on page A2-49<br>• the current instruction set state, see Instruction set state register, ISETSTATE on page A2-50<br>• the execution state bits for the Thumb If-Then instruction, see IT block state register, ITSTATE on page A2-51<br>• the current endianness, see Endianness mapping register, ENDIANSTATE on page A2-53<br>• the current processor mode<br>• interrupt and asynchronous abort disable bits.</p>\n<h6 id=\"The-Saved-Program-Status-Registers-SPSRs\"><a href=\"#The-Saved-Program-Status-Registers-SPSRs\" class=\"headerlink\" title=\"The Saved Program Status Registers (SPSRs)\"></a>The Saved Program Status Registers (SPSRs)</h6><p>The purpose of an SPSR is to record the pre-exception value of the CPSR. </p>\n<p>Fixme [Format of the CPSR and SPSRs] Page1148</p>\n<h5 id=\"B1-3-4-ELR-hyp\"><a href=\"#B1-3-4-ELR-hyp\" class=\"headerlink\" title=\"B1.3.4 ELR_hyp\"></a>B1.3.4 ELR_hyp</h5><p>Hyp mode does not provide its own Banked copy of LR. Instead, on taking an exception to Hyp mode, the preferred<br>return address is stored in ELR_hyp, a 32-bit Special register implemented for this purpose.<br>ELR_hyp is implemented only as part of the Virtualization Extensions.</p>\n<p>The ERET instruction uses the value in ELR_hyp as the return address for the exception. For more information, see<br>ERET on page B9-1982.</p>\n<h4 id=\"B1-4-Instruction-set-states\"><a href=\"#B1-4-Instruction-set-states\" class=\"headerlink\" title=\"B1.4 Instruction set states\"></a>B1.4 Instruction set states</h4><p>If an exception is taken to a PL1 mode, the SCTLR.TE bit for the security state the exception is taken to determines<br>the processor instruction set state that handles the exception, and if necessary, the processor changes to this<br>instruction set state on exception entry.</p>\n<p>If the exception is taken to Hyp mode, the HSCTLR.TE bit determines the processor instruction set state that<br>handles the exception, and if necessary, the processor changes to this instruction set state on exception entry.</p>\n<h4 id=\"B1-5-The-Security-Extensions\"><a href=\"#B1-5-The-Security-Extensions\" class=\"headerlink\" title=\"B1.5 The Security Extensions\"></a>B1.5 The Security Extensions</h4><h5 id=\"B1-5-1-Security-states\"><a href=\"#B1-5-1-Security-states\" class=\"headerlink\" title=\"B1.5.1 Security states\"></a>B1.5.1 Security states</h5><p>The Security Extensions define two security states, Secure state and Non-secure state.<br>• Each security state operates in its own virtual memory address space, with its own translation regime.<br>— in any implementation that includes the Security Extensions, Monitor mode is available only in Secure<br>state<br>— in an implementation that also includes the Virtualization Extensions, Hyp mode is available only in<br>Non-secure state.</p>\n<p>The ARM core registers and the processor status registers are not Banked between the Secure and the Non-secure<br>states. ARM expects that, when switching execution between the Non-secure and Secure states, a kernel running<br>mostly in Monitor mode will switch the values of these registers.<br>The registers LR_mon and SPSR_mon are UNKNOWN when executing in Non-secure state.</p>\n<h6 id=\"Changing-from-Secure-to-Non-secure-state\"><a href=\"#Changing-from-Secure-to-Non-secure-state\" class=\"headerlink\" title=\"Changing from Secure to Non-secure state\"></a>Changing from Secure to Non-secure state</h6><p>Except in Monitor mode and Hyp mode, the security state is controlled by the SCR.NS bit. Software executing in a Secure PL1 mode can change the SCR, but ARM strongly recommends that software obeys the following rules for changing SCR.NS:<br>• To avoid security holes, software must not:<br>    — Change from Secure to Non-secure state by using an MSR or CPS instruction to switch from Monitor<br>    mode to some other mode while SCR.NS is 1.<br>    — Use an MCR instruction that writes SCR.NS to change from Secure to Non-secure state. This means<br>    ARM recommends that software does not alter SCR.NS in any mode except Monitor mode. ARM<br>    deprecates changing SCR.NS in any other mode.</p>\n<p>• <strong>The usual mechanism for changing from Secure to Non-secure state is an exception return</strong>.To return to<br>Non-secure state, software executing in Monitor mode sets SCR.NS to 1 and then performs the exception<br>return.</p>\n<h4 id=\"B1-6-The-Large-Physical-Address-Extension\"><a href=\"#B1-6-The-Large-Physical-Address-Extension\" class=\"headerlink\" title=\"B1.6 The Large Physical Address Extension\"></a>B1.6 The Large Physical Address Extension</h4><p>The Large Physical Address Extension is an OPTIONAL extension to the ARMv7-A architecture profile. Any<br>implementation that includes the Large Physical Address Extension must also include the Multiprocessing<br>Extensions.</p>\n<p>The Large Physical Address Extension adds a new translation table format:<br>• the format used in an implementation that does not include the Large Physical Address Extension is now<br>called the Short-descriptor format, see Short-descriptor translation table format on page B3-1324<br>• the format added by the Large Physical Address Extension is the Long-descriptor format, see<br>Long-descriptor translation table format on page B3-1338.</p>\n<p><strong>An implementation that includes the Large Physical Address Extension must support both translation table formats.</strong></p>\n<h4 id=\"B1-7-The-Virtualization-Extensions\"><a href=\"#B1-7-The-Virtualization-Extensions\" class=\"headerlink\" title=\"B1.7 The Virtualization Extensions\"></a>B1.7 The Virtualization Extensions</h4><p>The Virtualization Extensions are an OPTIONAL extension to the ARMv7-A architecture profile. Any<br>implementation that includes the Virtualization Extensions must include the Security Extensions, the Large Physical<br>Address Extension, and the Multiprocessing Extensions.</p>\n<p>The basic model of a virtualized system involves:<br>• a hypervisor, running in Non-secure Hyp mode, that is responsible for switching Guest operating systems<br>• a number of Guest operating systems, each of which runs in the Non-secure PL1 and PL0 modes<br>• for each Guest operating system, applications, that usually run in User mode.</p>\n<p><strong>Each virtual machine is identified by a virtual machine identifier (VMID), assigned by the hypervisor.</strong><br>• With the Security Extensions, the Virtualization Extensions control the routing of interrupts and<br>asynchronous Data Abort exceptions to the appropriate one of:<br>— the current Guest OS<br>— a Guest OS that is not currently running<br>— the hypervisor<br>— the Secure monitor.</p>\n<p>• When an implementation includes the Virtualization Extensions, it provides independent translation regimes<br>for memory accesses from:<br>    — Secure modes, the Secure PL1&amp;0 translation regime<br>    — Non-secure Hyp mode, the Non-secure PL2 translation regime<br>    — Non-secure PL1 and PL0 modes, the Non-secure PL1&amp;0 translation regime</p>\n<p>• In the Non-secure PL1&amp;0 translation regime, address translation occurs in two stages:<br>— Stage 1 maps the Virtual Address (VA) to an Intermediate Physical Address (IPA). Typically, the Guest<br>OS configures and controls this stage, and believes that the IPA is the Physical Address (PA)<br>— Stage 2 maps the IPA to the PA. Typically, the hypervisor controls this stage, and a Guest OS is<br>completely unaware of this translation.</p>\n<h5 id=\"B1-7-1-Impact-of-the-Virtualization-Extensions-on-the-modes-and-exception-model\"><a href=\"#B1-7-1-Impact-of-the-Virtualization-Extensions-on-the-modes-and-exception-model\" class=\"headerlink\" title=\"B1.7.1 Impact of the Virtualization Extensions on the modes and exception model\"></a>B1.7.1 Impact of the Virtualization Extensions on the modes and exception model</h5><p>• Implements new exceptions, see:<br>    — Hypervisor Call (HVC) exception on page B1-1212<br>    — Hyp Trap exception on page B1-1209<br>    — Virtual IRQ exception on page B1-1221<br>    — Virtual FIQ exception on page B1-1223<br>    — Virtual Abort exception on page B1-1218.</p>\n<p>• Implements a new register that holds the exception vector base address for exceptions taken to Hyp mode,<br>the HVBAR.</p>\n<p>• Implements a new exception return instruction, ERET, for return from Hyp mode</p>\n<p>• Provide mechanisms to trap processor functions to Hyp mode, using the Hyp Trap exception, see Traps to<br>the hypervisor on page B1-1248.<br>When an operation is trapped to Hyp mode, the hypervisor typically either:<br>    — emulates the required operation, so the application running in the Guest OS is unaware of the trap to<br>    Hyp mode<br>    — returns an error to the Guest OS.</p>\n<h4 id=\"B1-8-Exception-handling\"><a href=\"#B1-8-Exception-handling\" class=\"headerlink\" title=\"B1.8 Exception handling\"></a>B1.8 Exception handling</h4><h5 id=\"B1-8-1-Exception-vectors-and-the-exception-base-address\"><a href=\"#B1-8-1-Exception-vectors-and-the-exception-base-address\" class=\"headerlink\" title=\"B1.8.1 Exception vectors and the exception base address\"></a>B1.8.1 Exception vectors and the exception base address</h5><p>When an exception is taken, processor execution is forced to an address that corresponds to the type of exception.<br>This address is called the exception vector for that exception.</p>\n<p><strong>A set of exception vectors comprises eight consecutive word-aligned memory addresses</strong>, starting at an exception<br>base address. These eight vectors form a vector table. <strong>For the IRQ and FIQ exceptions only</strong>, when the exceptions<br>are taken to IRQ mode and FIQ mode, software can change the exception vectors from the vector table values by<br>setting the SCTLR.VE bit to 1, see Vectored interrupt support on page B1-1168.</p>\n<h6 id=\"Implementation-that-does-not-include-the-Security-Extensions-1-pair-interrupt-vectors\"><a href=\"#Implementation-that-does-not-include-the-Security-Extensions-1-pair-interrupt-vectors\" class=\"headerlink\" title=\"Implementation that does not include the Security Extensions (1 pair interrupt vectors)\"></a>Implementation that does not include the Security Extensions (1 pair interrupt vectors)</h6><p>This section applied to all ARMv7-R implementations.<br>An implementation that does not include the Security Extensions has a single vector table, the base<br>address of which is selected by SCTLR.V, see SCTLR, System Control Register, VMSA on<br>page B4-1707 or SCTLR, System Control Register, PMSA on page B6-1932:<br>    V == 0 Exception base address = 0x00000000. This setting is referred to as normal vectors, or as<br>    low vectors.<br>    V == 1 Exception base address = 0xFFFF0000. This setting is referred to as high vectors, or<br>    Hivecs.</p>\n<h6 id=\"Implementation-that-includes-the-Security-Extensions-3-pair-interrupt-vectors\"><a href=\"#Implementation-that-includes-the-Security-Extensions-3-pair-interrupt-vectors\" class=\"headerlink\" title=\"Implementation that includes the Security Extensions (3 pair interrupt vectors)\"></a>Implementation that includes the Security Extensions (3 pair interrupt vectors)</h6><p>Any implementation that includes the Security Extensions has the following vector tables:<br>• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in<br>the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure<br>vector table, and is in the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and<br>is in the address space of the Non-secure PL1&amp;0 translation regime.</p>\n<p><strong>For the Monitor vector table, MVBAR holds the exception base address.</strong></p>\n<p>For the Secure vector table:<br>• the Secure SCTLR.V bit determines the exception base address:<br>    V == 0 The Secure VBAR holds the exception base address.<br>    V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.</p>\n<p>For the Non-secure vector table:<br>• the Non-secure SCTLR.V bit determines the exception base address:<br>    V == 0 The Non-secure VBAR holds the exception base address.<br>    V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.</p>\n<h6 id=\"Implementation-that-includes-the-Virtualization-Extensions-4-pair-interrupt-vectors\"><a href=\"#Implementation-that-includes-the-Virtualization-Extensions-4-pair-interrupt-vectors\" class=\"headerlink\" title=\"Implementation that includes the Virtualization Extensions (4 pair interrupt vectors)\"></a>Implementation that includes the Virtualization Extensions (4 pair interrupt vectors)</h6><p>An implementation that includes the Virtualization Extensions must include the Security<br>Extensions, and also includes an additional vector table. Therefore, it has the following vector<br>tables:<br>• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in<br>the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure<br>vector table, and is in the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Hyp mode, the Non-secure PL2 mode. This is the Hyp vector<br>table, and is in the address space of the Non-secure PL2 translation regime.<br>• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and<br>is in the address space of the Non-secure PL1&amp;0 translation regime.</p>\n<p>The exception base addresses of the Monitor vector table, the Secure vector table, and the<br>Non-secure vector table are determined in the same way as for an implementation that includes the<br>Security extensions but not the Virtualization extensions.</p>\n<p><strong>For the Hyp vector table, HVBAR holds the exception base address.</strong></p>\n<h6 id=\"The-vector-tables-and-exception-offsets\"><a href=\"#The-vector-tables-and-exception-offsets\" class=\"headerlink\" title=\"The vector tables and exception offsets\"></a>The vector tables and exception offsets</h6><p>Fixme [Table B1-3 The vector tables] page1167</p>\n<h5 id=\"B1-8-4-Processor-mode-for-taking-exceptions\"><a href=\"#B1-8-4-Processor-mode-for-taking-exceptions\" class=\"headerlink\" title=\"B1.8.4 Processor mode for taking exceptions\"></a>B1.8.4 Processor mode for taking exceptions</h5><h6 id=\"Exceptions-taken-to-Hyp-mode\"><a href=\"#Exceptions-taken-to-Hyp-mode\" class=\"headerlink\" title=\"Exceptions taken to Hyp mode\"></a>Exceptions taken to Hyp mode</h6><p>• Any exception taken from Hyp mode, that is not routed to Secure Monitor Mode by the controls described<br>in Asynchronous exception routing controls on page B1-1175, is taken to Hyp mode.</p>\n<p>• The following exceptions, if taken from Non-secure state, are taken to Hyp mode:<br>    — An abort that Routing of aborts on page B3-1396 identifies as taken to Hyp mode.<br>    — A Hyp Trap exception, see Traps to the hypervisor on page B1-1248.<br>    — A Hypervisor Call exception. This is generated by executing a HVC instruction in a Non-secure mode.<br>    — An asynchronous abort, IRQ exception or FIQ exception that is not routed to Secure Monitor mode<br>    but is explicitly routed to Hyp mode, as described in Asynchronous exception routing controls on<br>    page B1-1175.<br>    — A synchronous external abort, Alignment fault, Undefined Instruction exception, or Supervisor Call<br>    exception taken from the Non-secure PL0 mode and explicitly routed to Hyp mode, as described in<br>    Routing general exceptions to Hyp mode on page B1-1192.<br>    Note<br>    A synchronous external abort can be routed to Hyp mode only if it not routed to Secure Monitor mode.<br>    — A debug exception that is explicitly routed to Hyp mode as described in Routing Debug exceptions to<br>    Hyp mode on page B1-1194.</p>\n<h6 id=\"Asynchronous-exception-routing-controls\"><a href=\"#Asynchronous-exception-routing-controls\" class=\"headerlink\" title=\"Asynchronous exception routing controls\"></a>Asynchronous exception routing controls</h6><p>In an implementation that includes the Security Extensions, the following bits in the SCR control the routing of<br>asynchronous exceptions:<br>SCR.EA    When this bit is set to 1, any external abort is taken to Secure Monitor mode<br>SCR.FIQ   When this bit is set to 1, any FIQ exception is taken to Secure Monitor mode.<br>SCR.IRQ   When this bit is set to 1, any IRQ exception is taken to Secure Monitor mode.<br><strong>Only Secure software can change the values of these bits.</strong></p>\n<p>In an implementation that includes the Virtualization Extensions, the following bits in the HCR route asynchronous<br>exceptions to Hyp mode:<br>HCR.AMO   If SCR.EA is set to 0, when this bit is set to 1, an asynchronous external abort taken from a<br>          Non-secure PL1 or PL0 mode is taken to Hyp mode, instead of to Non-secure Abort mode.</p>\n<p>HCR.FMO   If SCR.FIQ is set to 0, when this bit is set to 1, an FIQ exception taken from a Non-secure PL1 or<br>          PL0 mode is taken to Hyp mode, instead of to Non-secure FIQ mode.</p>\n<p>HCR.IMO   If SCR.IRQ is set to 0, when this bit is set to 1, an IRQ exceptions taken from a Non-secure PL1 or<br>          PL0 mode is taken to Hyp mode, instead of to Non-secure IRQ mode.</p>\n<p><strong>Only software executing in Hyp mode, or Secure software executing in Monitor mode when SCR.NS is set to 1, can change the values of these bits.</strong></p>\n<h5 id=\"B1-8-5-Processor-state-on-exception-entry\"><a href=\"#B1-8-5-Processor-state-on-exception-entry\" class=\"headerlink\" title=\"B1.8.5 Processor state on exception entry\"></a>B1.8.5 Processor state on exception entry</h5><h6 id=\"Instruction-set-state-on-exception-entry\"><a href=\"#Instruction-set-state-on-exception-entry\" class=\"headerlink\" title=\"Instruction set state on exception entry\"></a>Instruction set state on exception entry</h6><p>On exception entry, CPSR.{T, J} are set to the values shown, with the CPSR.T value determined by SCTLR.TE or HSCTLR.TE</p>\n<p>Fixme [Table B1-8 CPSR.J and CPSR.T bit values on exception entry] page1182</p>\n<h6 id=\"CPSR-E-bit-value-on-exception-entr\"><a href=\"#CPSR-E-bit-value-on-exception-entr\" class=\"headerlink\" title=\"CPSR.E bit value on exception entr\"></a>CPSR.E bit value on exception entr</h6><p>Fixme [Table B1-9 CPSR.E bit value on exception entry] page1182</p>\n<h5 id=\"B1-8-6-Asynchronous-exception-masking\"><a href=\"#B1-8-6-Asynchronous-exception-masking\" class=\"headerlink\" title=\"B1.8.6 Asynchronous exception masking\"></a>B1.8.6 Asynchronous exception masking</h5><p>The CPSR.{A, I, F} bits can mask the corresponding exceptions, as follows:<br>• CPSR.A can mask asynchronous aborts<br>• CPSR.I can mask IRQ exceptions<br>• CPSR.F can mask FIQ exceptions.</p>\n<p>In an ARMv7 implementation that does not include the Security Extensions, setting one of these bits to 1 masks the<br>corresponding exception, meaning the exception cannot be taken.</p>\n<p>In an implementation that includes the Security Extensions, the SCR.{AW, FW} bits provide a mechanism to<br>prevent use of the CPSR.{A, F} mask bits by Non-secure software. In an implementation that includes the<br>Virtualization Extensions:<br>• HCR.{AMO, FMO} modify this mechanism<br>• HCR.IMO can prevent the masking, by CPSR.I, of IRQs taken from Non-secure state.</p>\n<p>When an SCR.{AW, FW} bit is set to 0, Non-secure software cannot update the corresponding<br>CPSR bit.</p>\n<p>Fixme [Table B1-11 Control of masking by CPSR.A] page1185</p>\n<p>Fixme [Table B1-12 Control of masking by CPSR.I] page1185</p>\n<p>Fixme [Table B1-13 Control of masking by CPSR.F] page1185</p>\n<h5 id=\"B1-8-7-Summaries-of-asynchronous-exception-behavior\"><a href=\"#B1-8-7-Summaries-of-asynchronous-exception-behavior\" class=\"headerlink\" title=\"B1.8.7 Summaries of asynchronous exception behavior\"></a>B1.8.7 Summaries of asynchronous exception behavior</h5><h6 id=\"Asynchronous-exception-behavior-Security-Extensions-only\"><a href=\"#Asynchronous-exception-behavior-Security-Extensions-only\" class=\"headerlink\" title=\"Asynchronous exception behavior, Security Extensions only\"></a>Asynchronous exception behavior, Security Extensions only</h6><p>Fixme [Table B1-14 Behavior of asynchronous aborts, Virtualization Extensions not implemented] page1187</p>\n<p>Fixme [Table B1-15 Behavior of IRQ exceptions, Virtualization Extensions not implemented] page1188</p>\n<p>Fixme [Table B1-16 Behavior of FIQ exceptions, Virtualization Extensions not implemented] page1188</p>\n<h6 id=\"Asynchronous-exception-behavior-with-the-Virtualization-Extensions\"><a href=\"#Asynchronous-exception-behavior-with-the-Virtualization-Extensions\" class=\"headerlink\" title=\"Asynchronous exception behavior, with the Virtualization Extensions\"></a>Asynchronous exception behavior, with the Virtualization Extensions</h6><p>Fixme [Table B1-17 Behavior of asynchronous aborts, Virtualization Extensions implemented] page1189</p>\n<p>Fixme [Table B1-18 Behavior of IRQ exceptions, Virtualization Extensions implemented] page1190</p>\n<p>Fixme [Table B1-19 Behavior of FIQ exceptions, Virtualization Extensions implemented] page1191</p>\n<h5 id=\"B1-8-8-Routing-general-exceptions-to-Hyp-mode\"><a href=\"#B1-8-8-Routing-general-exceptions-to-Hyp-mode\" class=\"headerlink\" title=\"B1.8.8 Routing general exceptions to Hyp mode\"></a>B1.8.8 Routing general exceptions to Hyp mode</h5><p>When HCR.TGE is set to 1, and the processor is in Non-secure User mode, the following exceptions are taken to<br>Hyp mode, instead of to the default Non-secure mode for handling the exception:<br>• Undefined Instruction exceptions.<br>• Supervisor Call exceptions.<br>• Synchronous External aborts.<br>• Any Alignment fault other than an alignment fault caused by the memory type when SCTLR.M is 1.</p>\n<h5 id=\"B1-8-9-Routing-Debug-exceptions-to-Hyp-mode\"><a href=\"#B1-8-9-Routing-Debug-exceptions-to-Hyp-mode\" class=\"headerlink\" title=\"B1.8.9 Routing Debug exceptions to Hyp mode\"></a>B1.8.9 Routing Debug exceptions to Hyp mode</h5><p>When HDCR.TDE is set to 1, if the processor is executing in a Non-secure mode other than Hyp mode, any Debug<br>exception is routed to Hyp mode. This means it generates a Hyp Trap exception</p>\n<h5 id=\"B1-8-10-Exception-return\"><a href=\"#B1-8-10-Exception-return\" class=\"headerlink\" title=\"B1.8.10 Exception return\"></a>B1.8.10 Exception return</h5><p>On an exception return, the CPSR takes either:<br>• the value loaded by the RFE instruction<br>• if the exception return is not performed by executing an RFE instruction, the value of the current SPSR at the<br>time of the exception return</p>\n<h6 id=\"Return-from-an-exception-taken-to-a-PL1-mode\"><a href=\"#Return-from-an-exception-taken-to-a-PL1-mode\" class=\"headerlink\" title=\"Return from an exception taken to a PL1 mode\"></a>Return from an exception taken to a PL1 mode</h6><p>For an exception taken to a PL1 mode, the ARM architecture provides the following exception return instructions:<br>• <strong>Data-processing instructions with the S bit set and the PC as a destination</strong>, see SUBS PC, LR (Thumb) on<br>page B9-2010 and SUBS PC, LR and related instructions (ARM) on page B9-2012.<br>Typically:<br>    — a return where no subtraction is required uses SUBS with an operand of 0, or the equivalent MOVS<br>    instruction<br>    — a return requiring subtraction uses SUBS with a nonzero operand.</p>\n<p>• <strong>From ARMv6, the RFE instruction, see RFE</strong> on page B9-2000. If a subtraction is required, typically it is<br>performed before saving the LR value to memory.</p>\n<p>• <strong>In ARM state, a form of the LDM instruction</strong>, see LDM (exception return) on page B9-1986. If a subtraction is<br>required, typically it is performed before saving the LR value to memory.</p>\n<h6 id=\"Return-from-an-exception-taken-to-a-PL2-mode\"><a href=\"#Return-from-an-exception-taken-to-a-PL2-mode\" class=\"headerlink\" title=\"Return from an exception taken to a PL2 mode\"></a>Return from an exception taken to a PL2 mode</h6><p>For an exception taken to a PL2 mode, the ARM architecture provides the <strong>ERET</strong> instruction, see ERET on<br>page B9-1982. An exception handler executing in a PL2 mode must return using the ERET instruction.<br>Hyp mode is the only PL2 mode. Both Hyp mode and the ERET instruction are implemented only as part of the<br>Virtualization Extensions.</p>\n<h5 id=\"B1-8-11-Virtual-exceptions-in-the-Virtualization-Extensions\"><a href=\"#B1-8-11-Virtual-exceptions-in-the-Virtualization-Extensions\" class=\"headerlink\" title=\"B1.8.11 Virtual exceptions in the Virtualization Extensions\"></a>B1.8.11 Virtual exceptions in the Virtualization Extensions</h5><p>Fixme [Table B1-20 HCR bits controlling asynchronous exceptions] page1198</p>\n<h5 id=\"B1-8-12-Low-interrupt-latency-configuration\"><a href=\"#B1-8-12-Low-interrupt-latency-configuration\" class=\"headerlink\" title=\"B1.8.12 Low interrupt latency configuration\"></a>B1.8.12 Low interrupt latency configuration</h5><p>Setting SCTLR.FI to 1 enables the low interrupt latency configuration of an implementation. This configuration can<br>reduce the interrupt latency of the processor. The mechanisms implemented to achieve low interrupt latency are<br>IMPLEMENTATION DEFINED. For the description of the SCTLR see either:<br>• SCTLR, System Control Register, VMSA on page B4-1707<br>• SCTLR, System Control Register, PMSA on page B6-1932</p>\n<h5 id=\"B1-8-13-Wait-For-Event-and-Send-Event\"><a href=\"#B1-8-13-Wait-For-Event-and-Send-Event\" class=\"headerlink\" title=\"B1.8.13 Wait For Event and Send Event\"></a>B1.8.13 Wait For Event and Send Event</h5><p>ARMv7 and ARMv6K provide a mechanism, the Wait For Event mechanism, that permits a processor in a<br>multiprocessor system to request <strong>entry to a low-power state</strong>, and, if the request succeeds, to remain in that state until<br>it receives an event generated by a Send Event operation on another processor in the system.<br><strong>example using for spin-lock</strong></p>\n<p>The Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a<br>Non-secure PL1 or PL0 mode.</p>\n<h6 id=\"WFE-wake-up-events\"><a href=\"#WFE-wake-up-events\" class=\"headerlink\" title=\"WFE wake-up events\"></a>WFE wake-up events</h6><p>The following events are WFE wake-up events:<br>• the execution of an SEV instruction on any processor in the multiprocessor system<br>• a physical IRQ interrupt, unless masked by the CPSR.I bit<br>• a physical FIQ interrupt, unless masked by the CPSR.F bit<br>• a physical asynchronous abort, unless masked by the CPSR.A bit<br>• in Non-secure state in any mode other than Hyp mode:<br>    — when HCR.IMO is set to 1, a virtual IRQ interrupt, unless masked by the CPSR.I bit<br>    — when HCR.FMO is set to 1, a virtual FIQ interrupt, unless masked by the CPSR.F bit<br>    — when HCR.AMO is set to 1, a virtual asynchronous abort, unless masked by the CPSR.A bit<br>• an asynchronous debug event, if invasive debug is enabled and the debug event is permitted<br>• an event sent by the timer event stream, see Event streams on page B8-1964<br>• an event sent by some IMPLEMENTATION DEFINED mechanism.</p>\n<h6 id=\"The-Event-Register\"><a href=\"#The-Event-Register\" class=\"headerlink\" title=\"The Event Register\"></a>The Event Register</h6><p>The Event Register is <strong>a single bit register for each processor</strong>. When set, an event register indicates that an event has<br>occurred, since the register was last cleared</p>\n<p>The Event Register is set by:<br>• an SEV instruction<br>• an event sent by some IMPLEMENTATION DEFINED mechanism<br>• a debug event that causes entry into Debug state<br>• an exception return.</p>\n<h6 id=\"The-Send-Event-instruction\"><a href=\"#The-Send-Event-instruction\" class=\"headerlink\" title=\"The Send Event instruction\"></a>The Send Event instruction</h6><p><strong>The Send Event instruction, SEV, causes an event to be signaled to all processors in the multiprocessor system.</strong><br><strong>ARM recommends that software includes a DSB instruction before an SEV instruction</strong></p>\n<p>Execution of the Send Event instruction sets the Event Register. The Send Event instruction is available at all privilege levels</p>\n<h6 id=\"The-Wait-For-Event-instruction\"><a href=\"#The-Wait-For-Event-instruction\" class=\"headerlink\" title=\"The Wait For Event instruction\"></a>The Wait For Event instruction</h6><p>The action of the Wait For Event instruction depends on the state of the Event Register:<br>• If the Event Register is set, the instruction clears the register and completes immediately. Normally, if this<br>happens the software makes another attempt to claim the lock.</p>\n<p>• If the Event Register is clear the processor can suspend execution and enter a low-power state. It can remain<br>in that state until the processor detects a WFE wake-up event or a reset. When the processor detects a WFE<br>wake-up event, or earlier if the implementation chooses, the WFE instruction completes.</p>\n<p>The Wait For Event instruction, WFE, is available at all privilege levels,</p>\n<h5 id=\"B1-8-14-Wait-For-Interrupt\"><a href=\"#B1-8-14-Wait-For-Interrupt\" class=\"headerlink\" title=\"B1.8.14 Wait For Interrupt\"></a>B1.8.14 Wait For Interrupt</h5><p>When a processor issues a WFI instruction it can suspend execution and enter a low-power state.</p>\n<p>The Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a<br>Non-secure PL1 or PL0 mode.</p>\n<p>The processor can remain in the WFI low-power state until it is reset, or it detects one of the following WFI wake-up<br>events:<br>• a physical IRQ interrupt, regardless of the value of the CPSR.I bit<br>• a physical FIQ interrupt, regardless of the value of the CPSR.F bit<br>• a physical asynchronous abort, regardless of the value of the CPSR.A bit<br>• in Non-secure state in any mode other than Hyp mode:<br>    — when HCR.IMO is set to 1, a virtual IRQ interrupt, regardless of the value of the CPSR.I bit<br>    — when HCR.FMO is set to 1, a virtual FIQ interrupt, regardless of the value of the CPSR.F bit<br>    — when HCR.AMO is set to 1, a virtual asynchronous abort, regardless of the value of the CPSR.A bit<br>• an asynchronous debug event, when invasive debug is enabled and the debug event is permitted.</p>\n<p><strong>WFI wake-up events cannot be masked by the mask bits in the CPSR.</strong></p>\n<p><strong>Using WFI to indicate an idle state on bus interfaces</strong></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpuidle_overview.html\" target=\"_blank\" rel=\"noopener\">Linux cpuidle framework(1)_概述和软件架构</a></p>\n<h4 id=\"B1-9-Exception-descriptions\"><a href=\"#B1-9-Exception-descriptions\" class=\"headerlink\" title=\"B1.9 Exception descriptions\"></a>B1.9 Exception descriptions</h4><p>skip</p>\n<h4 id=\"B1-10-Coprocessors-and-system-control\"><a href=\"#B1-10-Coprocessors-and-system-control\" class=\"headerlink\" title=\"B1.10 Coprocessors and system control\"></a>B1.10 Coprocessors and system control</h4><p>The ARM architecture supports sixteen coprocessors, usually referred to as CP0 to CP15.<br>The architecture reserves two of these coprocessors, CP14 and CP15,<br>for configuration and control related to the architecture:<br>• CP14 is reserved for the configuration and control of:<br>    — debug features, see The CP14 debug register interface on page C6-2123<br>    — trace features, see the Embedded Trace Macrocell Architecture Specification and the CoreSight<br>    Program Flow Trace Architecture Specification<br>    — the Thumb Execution Environment, see Thumb Execution Environment on page B1-1240<br>    — direct Java bytecode execution, see Jazelle direct bytecode execution on page B1-1241.<br>• CP15 is called the System Control coprocessor, and is reserved for the control and configuration of the ARM<br>processor system, including architecture and feature identification.</p>\n<p>The implementation of the CP15 registers depends heavily on whether the ARMv7 implementation is:<br>• an ARMv7-A implementation with a Virtual Memory System Architecture (VMSA)<br>• an ARMv7-R implementation with a Protected Memory System Architecture (PMSA).<br>The implementation of the CP14 registers is generally similar in ARMv7-A and ARMv7-R implementation.</p>\n<p>Most CP14 and CP15 registers are accessible only from PL1 or higher. For possible accesses from PL0:<br>• The register descriptions in Chapter B4 System Control Registers in a VMSA implementation and Chapter B6<br>System Control Registers in a PMSA implementation indicate whether a register is accessible from PL0.<br>• The descriptions of the CP14 interface in Chapter C6 Debug Register Interfaces include the permitted<br>accesses to the debug registers from PL0.<br>• The following sections summarize the permitted accesses to CP15 registers from PL0:<br>    — for a VMSA implementation, PL0 views of the CP15 registers on page B3-1488<br>    — for a PMSA implementation, PL0 views of the CP15 registers on page B5-1797.</p>\n<h4 id=\"B1-11-Advanced-SIMD-and-floating-point-support\"><a href=\"#B1-11-Advanced-SIMD-and-floating-point-support\" class=\"headerlink\" title=\"B1.11 Advanced SIMD and floating-point support\"></a>B1.11 Advanced SIMD and floating-point support</h4><p>skip</p>\n<h4 id=\"B1-12-Thumb-Execution-Environment\"><a href=\"#B1-12-Thumb-Execution-Environment\" class=\"headerlink\" title=\"B1.12 Thumb Execution Environment\"></a>B1.12 Thumb Execution Environment</h4><p>skip</p>\n<h4 id=\"B1-13-Jazelle-direct-bytecode-execution\"><a href=\"#B1-13-Jazelle-direct-bytecode-execution\" class=\"headerlink\" title=\"B1.13 Jazelle direct bytecode execution\"></a>B1.13 Jazelle direct bytecode execution</h4><p>skip</p>\n<h4 id=\"B1-14-Traps-to-the-hypervisor\"><a href=\"#B1-14-Traps-to-the-hypervisor\" class=\"headerlink\" title=\"B1.14 Traps to the hypervisor\"></a>B1.14 Traps to the hypervisor</h4><h5 id=\"B1-14-1-General-information-about-traps-to-the-hypervisor\"><a href=\"#B1-14-1-General-information-about-traps-to-the-hypervisor\" class=\"headerlink\" title=\"B1.14.1 General information about traps to the hypervisor\"></a>B1.14.1 General information about traps to the hypervisor</h5><p>The Hyp Trap exception provides the standard mechanism for trapping Guest OS functions to the hypervisor.<br>and enters the exception handler using the vector at<br>offset 0x14 from the Hyp vector base address. For more information see Exception handling on page B1-1165</p>\n<p>A Hyp Trap exception can be generated only when all of the following apply:<br>• The processor is both:<br>    — not in Debug state<br>    — in a Non-secure PL1 or PL0 mode.<br>• Traps to Hyp mode never apply in Secure state, regardless of the value of the SCR.NS bit.    </p>\n<p>B1.14.2 Trapping ID mechanisms<br>For a small number of frequently-accessed ID registers, the Virtualization Extensions provide read/write aliases of<br>the registers, accessible only from Hyp mode, or from Secure state. A read of the original ID register from a<br>Non-secure PL1 mode actually returns the value of the read/write alias register.</p>\n<p>Fixme [Table B1-26 ID register substitution by the Virtualization Extensions] page1251</p>\n<p>Fixme [Table B1-27 ID register groups for Hyp Trap exceptions] page1252</p>\n<p>B1.14.17 Summary of trap controls</p>\n<p>Fixme [Table B1-29 Summary of Hyp trap controls] page1262</p>\n<h3 id=\"B2-Common-Memory-System-Architecture-Features\"><a href=\"#B2-Common-Memory-System-Architecture-Features\" class=\"headerlink\" title=\"B2 Common Memory System Architecture Features\"></a>B2 Common Memory System Architecture Features</h3><h4 id=\"B2-2-Caches-and-branch-predictors\"><a href=\"#B2-2-Caches-and-branch-predictors\" class=\"headerlink\" title=\"B2.2 Caches and branch predictors\"></a>B2.2 Caches and branch predictors</h4><h5 id=\"B2-2-1-Cache-identification\"><a href=\"#B2-2-1-Cache-identification\" class=\"headerlink\" title=\"B2.2.1 Cache identification\"></a>B2.2.1 Cache identification</h5><p>The ARMv7 cache identification consists of a set of registers that describe the implemented caches that are under<br>the control of the processor:<br>• A single Cache Type Register defines:<br>    — the <strong>minimum line length of any of the instruction caches</strong><br>    — the <strong>minimum line length of any of the data or unified caches</strong><br>    — the <strong>cache indexing and tagging policy of the Level 1 instruction cache.</strong><br>    For more information, see:<br>    — CTR, Cache Type Register, VMSA on page B4-1556, for a VMSA implementation<br>    — CTR, Cache Type Register, PMSA on page B6-1835, for a PMSA implementation.</p>\n<p>• A single Cache Level ID Register defines:<br>    — the <strong>type of cache implemented at a each cache level, up to the maximum of seven levels</strong><br>    — the Level of Coherence (LoC) for the caches<br>    — the Level of Unification (LoU) for the caches.<br>    For more information, see:<br>    — CLIDR, Cache Level ID Register, VMSA on page B4-1530, for a VMSA implementation<br>    — CLIDR, Cache Level ID Register, PMSA on page B6-1816, for a PMSA implementation</p>\n<p>• A single Cache Size Selection Register selects the cache level and cache type of the current Cache Size<br>Identification Register, see:<br>    — CSSELR, Cache Size Selection Register, VMSA on page B4-1555, for a VMSA implementation<br>    — CSSELR, Cache Size Selection Register, PMSA on page B6-1834, for a PMSA implementation.    </p>\n<p>• For each implemented cache, across all the levels of caching, a Cache Size Identification Register defines:<br>    — <strong>whether the cache supports Write-Through, Write-Back, Read-Allocate and Write-Allocate</strong><br>    — <strong>the number of sets, associativity and line length of the cache</strong><br>    For more information, see:<br>    — CCSIDR, Cache Size ID Registers, VMSA on page B4-1528, for a VMSA implementation<br>    — CCSIDR, Cache Size ID Registers, PMSA on page B6-1814, for a PMSA implementation.</p>\n<h6 id=\"Identifying-the-cache-resources-in-ARMv7\"><a href=\"#Identifying-the-cache-resources-in-ARMv7\" class=\"headerlink\" title=\"Identifying the cache resources in ARMv7\"></a>Identifying the cache resources in ARMv7</h6><p>In ARMv7 the architecture defines support for multiple levels of cache, up to a maximum of seven levels.<br>software must:</p>\n<ol>\n<li><p><strong>Read the Cache Type Register to find the indexing and tagging policy used for the Level 1 instruction cache.</strong><br>This register also provides the size of the smallest cache lines used for the instruction caches, and for the data<br>and unified caches. These values are used in cache maintenance operations.</p>\n</li>\n<li><p><strong>Read the Cache Level ID Register to find what caches are implemented</strong>. The register includes seven Cache<br>type fields, for cache levels 1 to 7. Scanning these fields, starting from Level 1, identifies the instruction, data<br>or unified caches implemented at each level. This scan ends when it reaches a level at which no caches are<br>defined. The Cache Level ID Register also provides the Level of Unification (LoU) and the Level of<br>Coherence (LoC) for the cache implementation.</p>\n</li>\n<li><p>For each cache identified at stage 2:<br>• <strong>Write to the Cache Size Selection Register to select the required cache.</strong> A cache is identified by its<br>level, and whether it is:<br> — an instruction cache<br> — a data or unified cache.<br>• Read the Cache Size ID Register to find details of the cache.</p>\n</li>\n</ol>\n<h5 id=\"B2-2-2-Cache-behavior\"><a href=\"#B2-2-2-Cache-behavior\" class=\"headerlink\" title=\"B2.2.2 Cache behavior\"></a>B2.2.2 Cache behavior</h5><h6 id=\"General-behavior-of-the-caches\"><a href=\"#General-behavior-of-the-caches\" class=\"headerlink\" title=\"General behavior of the caches\"></a>General behavior of the caches</h6><p>When a memory location is marked with a Normal Cacheable memory attribute, determining whether a copy of the<br>memory location is held in a cache still depends on many aspects of the implementation. The following<br>non-exhaustive list of factors might be involved:<br>• the size, line length, and associativity of the cache<br>• the cache allocation algorithm<br>• activity by other elements of the system that can access the memory<br>• speculative instruction fetching algorithms<br>• speculative data fetching algorithms<br>• interrupt behaviors.</p>\n<p>For the purpose of these principles, a cache entry covers at least 16 bytes and no more than 2KB of contiguous<br>address space, aligned to its size.</p>\n<h6 id=\"Behavior-of-the-caches-at-reset\"><a href=\"#Behavior-of-the-caches-at-reset\" class=\"headerlink\" title=\"Behavior of the caches at reset\"></a>Behavior of the caches at reset</h6><p>In ARMv7:<br>• All caches are disabled at reset.<br>• An implementation can require the use of a specific cache initialization routine to invalidate its storage array<br>before it is enabled.</p>\n<p>B2.2.3 Cache enabling and disabling<br>Levels of cache on page B2-1265 indicates that:<br>• In ARMv7 the architecture defines the control of multiple levels of cache.<br>• Before ARMv7 the architecture defines the control of only one level of cache.</p>\n<p>In ARMv7:<br>• SCTLR.C enables or disables all data and unified caches for data accesses, across all levels of cache visible<br>to the processor. It is IMPLEMENTATION DEFINED whether it also enables or disables the use of unified caches<br>for instruction accesses.<br>• SCTLR.I enables or disables all instruction caches, across all levels of cache visible to the processor.</p>\n<pre><code>- SCTLR, System Control Register, VMSA on page B4-1707, for a VMSA implementation\n- SCTLR, System Control Register, PMSA on page B6-1932, for a PMSA implementation.\n</code></pre><h5 id=\"B2-2-4-Branch-predictors\"><a href=\"#B2-2-4-Branch-predictors\" class=\"headerlink\" title=\"B2.2.4 Branch predictors\"></a>B2.2.4 Branch predictors</h5><p>Branch predictor hardware typically uses a form of cache to hold branch information. The ARM architecture<br>permits this branch predictor hardware to be visible to software, and so the branch predictor is not architecturally<br>invisible. This means that under some circumstances software must perform branch predictor maintenance to avoid<br>incorrect execution caused by out-of-date entries in the branch predictor.</p>\n<h6 id=\"Requirements-for-branch-predictor-maintenance-operations\"><a href=\"#Requirements-for-branch-predictor-maintenance-operations\" class=\"headerlink\" title=\"Requirements for branch predictor maintenance operations\"></a>Requirements for branch predictor maintenance operations</h6><p>the instructions at the virtual addresses change:<br>• enabling or disabling the MMU<br>• writing new mappings to the translation tables<br>• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,<br>or a change to the VMID<br>• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID.</p>\n<p>then branch predictor maintenance operations must be performed to invalidate entries in the branch<br>predictor, to ensure that the change is visible to subsequent execution.</p>\n<h5 id=\"B2-2-6-About-ARMv7-cache-and-branch-predictor-maintenance-functionality\"><a href=\"#B2-2-6-About-ARMv7-cache-and-branch-predictor-maintenance-functionality\" class=\"headerlink\" title=\"B2.2.6 About ARMv7 cache and branch predictor maintenance functionality\"></a>B2.2.6 About ARMv7 cache and branch predictor maintenance functionality</h5><h6 id=\"Terms-used-in-describing-the-maintenance-operations\"><a href=\"#Terms-used-in-describing-the-maintenance-operations\" class=\"headerlink\" title=\"Terms used in describing the maintenance operations\"></a>Terms used in describing the maintenance operations</h6><p>• by the address of the memory location to be maintained, referred to as operating by MVA<br>• by a mechanism that describes the location in the hardware of the cache, referred to as operating by set/way.</p>\n<h6 id=\"Terminology-for-operations-by-MVA\"><a href=\"#Terminology-for-operations-by-MVA\" class=\"headerlink\" title=\"Terminology for operations by MVA\"></a>Terminology for operations by MVA</h6><p>The term Modified Virtual Address (MVA) relates to the Fast Context Switch Extension (FCSE) mechanism,described in Appendix D10 Fast Context Switch Extension (FCSE). When the FCSE is absent or disabled, the MVA and VA have the same value.</p>\n<p>Virtual addresses only exist in systems with a MMU. When no MMU is implemented, or all applicable MMUs are disabled, the MVA and VA are identical to the PA.</p>\n<h6 id=\"Terminology-for-operations-by-set-way\"><a href=\"#Terminology-for-operations-by-set-way\" class=\"headerlink\" title=\"Terminology for operations by set/way\"></a>Terminology for operations by set/way</h6><p>Cache maintenance operations by set/way refer to the particular structures in a cache.</p>\n<p><strong>Level</strong><br>The cache level of the hierarchy.</p>\n<p><strong>Set</strong><br>Each level of a cache is split up into a number of sets. Each set is a set of locations in a cache level to which an address can be assigned.</p>\n<p><strong>Way</strong><br>The Associativity of a cache defines the number of locations in a set to which an address can be assigned.</p>\n<h5 id=\"B2-2-7-Cache-and-branch-predictor-maintenance-operations\"><a href=\"#B2-2-7-Cache-and-branch-predictor-maintenance-operations\" class=\"headerlink\" title=\"B2.2.7 Cache and branch predictor maintenance operations\"></a>B2.2.7 Cache and branch predictor maintenance operations</h5><p>Cache and branch predictor maintenance operations are performed using accesses to CP15 c7. The following<br>sections define the encodings for these operations:<br>• Cache and branch predictor maintenance operations, VMSA on page B4-1743, for a VMSA implementation<br>• Cache and branch predictor maintenance operations, PMSA on page B6-1943, for a PMSA implementation.</p>\n<h6 id=\"Summary-of-cache-and-branch-predictor-maintenance-operations\"><a href=\"#Summary-of-cache-and-branch-predictor-maintenance-operations\" class=\"headerlink\" title=\"Summary of cache and branch predictor maintenance operations\"></a>Summary of cache and branch predictor maintenance operations</h6><p><strong>Data cache and unified cache operations</strong><br>Operations by MVA<br>The data and unified cache operations by MVA are:<br>DCIMVAC   Invalidate, to point of coherency.<br>DCCMVAC   Clean, to point of coherency.<br>DCCMVAU   Clean, to point of unification.<br>DCCIMVAC  Clean and invalidate, to point of coherency.</p>\n<p>Operations by set/way<br>The data and unified cache operations by set/way are:<br>DCISW     Invalidate.<br>DCCSW     Clean.<br>DCCISW    Clean and invalidate, to point of coherency.</p>\n<p><strong>Instruction cache operations</strong><br>Operation by MVA<br>ICIMVAU     Invalidate, to point of unification.</p>\n<p>Operations on all entries<br>The instruction cache operations that operate on all entries are:<br>ICIALLU     Invalidate all, to point of unification.<br>ICIALLUIS     Invalidate all, to point of unification, Inner Shareable.</p>\n<p><strong>Branch predictor operations</strong><br>Operation by MVA<br>BPIMVA     Invalidate.</p>\n<p>Operations on all entries<br>BPIALL         Invalidate all.<br>BPIALLIS     Invalidate all, Inner Shareable.</p>\n<h3 id=\"B3-Virtual-Memory-System-Architecture-VMSA\"><a href=\"#B3-Virtual-Memory-System-Architecture-VMSA\" class=\"headerlink\" title=\"B3 Virtual Memory System Architecture (VMSA)\"></a>B3 Virtual Memory System Architecture (VMSA)</h3><h4 id=\"B3-1-About-the-VMSA\"><a href=\"#B3-1-About-the-VMSA\" class=\"headerlink\" title=\"B3.1 About the VMSA\"></a>B3.1 About the VMSA</h4><p>In VMSAv7, a Memory Management Unit (MMU) controls address translation, access permissions, and memory<br>attribute determination and checking.</p>\n<p>Each supported stage of memory system control is provided by an MMU, with its own independent set of controls.<br>Therefore, the Extended VMSAv7 provides the following MMUs:<br>• Secure PL1&amp;0 stage 1 MMU<br>• Non-secure PL2 stage 1 MMU<br>• Non-secure PL1&amp;0 stage 1 MMU<br>• Non-secure PL1&amp;0 stage 2 MMU.</p>\n<p>Fixme [Figure B3-1 VMSA translation regimes, and associated MMUs]page1309</p>\n<h5 id=\"B3-1-1-Address-types-used-in-a-VMSA-description\"><a href=\"#B3-1-1-Address-types-used-in-a-VMSA-description\" class=\"headerlink\" title=\"B3.1.1 Address types used in a VMSA description\"></a>B3.1.1 Address types used in a VMSA description</h5><h6 id=\"Virtual-Address-VA\"><a href=\"#Virtual-Address-VA\" class=\"headerlink\" title=\"Virtual Address (VA)\"></a>Virtual Address (VA)</h6><p>An address used in an instruction, as a data or instruction address, is a Virtual Address (VA).<br><strong>An address held in the PC, LR, or SP, is a VA.</strong></p>\n<h6 id=\"Modified-Virtual-Address-MVA\"><a href=\"#Modified-Virtual-Address-MVA\" class=\"headerlink\" title=\"Modified Virtual Address (MVA)\"></a>Modified Virtual Address (MVA)</h6><p>On an implementation that implements and uses the FCSE(Appendix D10 Fast Context Switch Extension (FCSE)), the FCSE takes a VA and transforms it to an MVA. </p>\n<h6 id=\"Intermediate-Physical-Address-IPA\"><a href=\"#Intermediate-Physical-Address-IPA\" class=\"headerlink\" title=\"Intermediate Physical Address (IPA)\"></a>Intermediate Physical Address (IPA)</h6><p>In a translation regime that provides two stages of address translation, the IPA is the address after<br>the stage 1 translation, and is the input address for the stage 2 translation.</p>\n<h6 id=\"Physical-Address-PA\"><a href=\"#Physical-Address-PA\" class=\"headerlink\" title=\"Physical Address (PA)\"></a>Physical Address (PA)</h6><h5 id=\"B3-1-2-Address-spaces-in-a-VMSA-implementation\"><a href=\"#B3-1-2-Address-spaces-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.1.2 Address spaces in a VMSA implementation\"></a>B3.1.2 Address spaces in a VMSA implementation</h5><p>The ARMv7 architecture supports:<br>• A VA address space of up to 32 bits. The actual width is IMPLEMENTATION DEFINED.<br>• An IPA address space of up to 40 bits. The translation tables and associated system control registers define the width of the implemented address space.</p>\n<p>Note:</p>\n<blockquote>\n<p>The Large Physical Address Extension defines two translation table formats. The Long-descriptor format gives access to the full 40-bit IPA or PA address space at a granularity of 4KB. The Short-descriptor format:<br>• Gives access to a 32-bit PA address space at 4KB granularity.<br>• Optionally, gives access to a 40-bit PA address space, but only at 16MB granularity.</p>\n</blockquote>\n<p>If an implementation includes the Security Extensions, <strong>the address maps are defined independently for Secure and Non-secure operation, providing two independent 40-bit address spaces</strong>, where:<br>• a VA accessed from Non-secure state can only be translated to the Non-secure address map<br>• a VA accessed from Secure state can be translated to either the Secure or the Non-secure address map.</p>\n<h5 id=\"B3-1-3-About-address-translation\"><a href=\"#B3-1-3-About-address-translation\" class=\"headerlink\" title=\"B3.1.3 About address translation\"></a>B3.1.3 About address translation</h5><h5 id=\"B3-1-3-1-VMSAv7-without-the-Security-Extensions\"><a href=\"#B3-1-3-1-VMSAv7-without-the-Security-Extensions\" class=\"headerlink\" title=\"B3.1.3.1. VMSAv7 without the Security Extensions\"></a>B3.1.3.1. VMSAv7 without the Security Extensions</h5><p>Supports only a single PL1&amp;0 stage 1 MMU. Operation of this MMU can be split between two sets of translation tables, defined by TTBR0 and TTBR1, and controlled by TTBCR.</p>\n<h5 id=\"B3-1-3-2-VMSAv7-with-the-Security-Extensions-but-without-the-Virtualization-Extensions\"><a href=\"#B3-1-3-2-VMSAv7-with-the-Security-Extensions-but-without-the-Virtualization-Extensions\" class=\"headerlink\" title=\"B3.1.3.2. VMSAv7 with the Security Extensions but without the Virtualization Extensions\"></a>B3.1.3.2. VMSAv7 with the Security Extensions but without the Virtualization Extensions</h5><p>Supports only the Secure PL1&amp;0 stage 1 MMU and the Non-secure PL1&amp;0 stage 1 MMU.</p>\n<p>Operation of each of these MMUs can be split between two sets of translation tables, <strong>defined by the Secure and Non-secure copies of TTBR0 and TTBR1, and controlled by the Secure and Non-secure copies of TTBCR.</strong></p>\n<p><strong>Note</strong>: Secure and Non-secure has copies of TTBR0 and TTBR1, TTBCR.</p>\n<h5 id=\"B3-1-3-3-VMSAv7-with-Virtualization-Extensions\"><a href=\"#B3-1-3-3-VMSAv7-with-Virtualization-Extensions\" class=\"headerlink\" title=\"B3.1.3.3. VMSAv7 with Virtualization Extensions\"></a>B3.1.3.3. VMSAv7 with Virtualization Extensions</h5><p><strong>Secure PL1&amp;0 stage 1 MMU</strong><br>Operation of this MMU can be split between two sets of translation tables, defined by the Secure copies of TTBR0 and TTBR1, and controlled by the Secure copy of TTBCR.</p>\n<p><strong>Non-secure PL2 stage 1 MMU</strong><br>The HTTBR defines the translation table for this MMU, controlled by HTCR.</p>\n<p><strong>Non-secure PL1&amp;0 stage 1 MMU</strong><br>Operation of this MMU can be split between two sets of translation tables, defined by the Non-secure copies of TTBR0 and TTBR1 and controlled by the Non-secure copy of TTBCR.</p>\n<p><strong>Non-secure PL1&amp;0 stage 2 control</strong><br>The VTTBR defines the translation table for this MMU, controlled by VTCR.</p>\n<p>Fixme [Figure B3-2 Memory translation summary, with Virtualization Extensions]Page 1312</p>\n<p>A full translation table lookup is called a translation table walk.It is performed automatically by hardware.</p>\n<p><strong>Translation Lookaside Buffers (TLBs)</strong> reduce the average cost of a memory access by caching the results of translation table walks.</p>\n<p>To reduce the software overhead of TLB maintenance, the VMSA distinguishes between Global pages and Process-specific pages. The <strong>Address Space Identifier (ASID)</strong> identifies pages associated with <strong>a specific process</strong> and provides a mechanism for changing process-specific tables without having to maintain the TLB tructures.</p>\n<p>If an implementation includes the Virtualization Extensions, the <strong>virtual machine identifier (VMID)</strong> identifies the current virtual machine, with its own independent ASID space.</p>\n<h4 id=\"B3-2-The-effects-of-disabling-MMUs-on-VMSA-behavior\"><a href=\"#B3-2-The-effects-of-disabling-MMUs-on-VMSA-behavior\" class=\"headerlink\" title=\"B3.2 The effects of disabling MMUs on VMSA behavior\"></a>B3.2 The effects of disabling MMUs on VMSA behavior</h4><p>About the VMSA on page B3-1308 defines the translation regimes and the associated MMUs. The VMSA includes<br>an enable bit for each MMU, as follows:<br>• SCTLR.M, in the Secure copy of the register, controls Secure PL1&amp;0 stage 1 MMU<br>• SCTLR.M, in the Non-secure copy of the register, controls Non-secure PL1&amp;0 stage 1 MMU<br>• HCR.VM controls Non-secure PL1&amp;0 stage 2 MMU<br>• HSCTLR.M controls Non-secure PL2 stage 1 MMU.</p>\n<h5 id=\"B3-2-1-VMSA-behavior-when-a-stage-1-MMU-is-disabled\"><a href=\"#B3-2-1-VMSA-behavior-when-a-stage-1-MMU-is-disabled\" class=\"headerlink\" title=\"B3.2.1 VMSA behavior when a stage 1 MMU is disabled\"></a>B3.2.1 VMSA behavior when a stage 1 MMU is disabled</h5><h6 id=\"Non-secure-PL1-and-PL0-accesses-when-HCR-DC-is-set-to-1-Virtualization-Extensions\"><a href=\"#Non-secure-PL1-and-PL0-accesses-when-HCR-DC-is-set-to-1-Virtualization-Extensions\" class=\"headerlink\" title=\"Non-secure PL1 and PL0 accesses when HCR.DC is set to 1, Virtualization Extensions\"></a>Non-secure PL1 and PL0 accesses when HCR.DC is set to 1, Virtualization Extensions</h6><p>In an implementation that includes the Virtualization Extensions, for an access from a Non-secure PL1 or PL0 mode when HCR.DC is set to 1, the stage 1 translation assigns the Normal Non-shareable, Inner Write-Back Write-Allocate, Outer Write-Back Write-Allocate memory attributes.</p>\n<h6 id=\"All-other-accesses\"><a href=\"#All-other-accesses\" class=\"headerlink\" title=\"All other accesses\"></a>All other accesses</h6><p><strong>Data access</strong><br>The stage 1 translation assigns the Strongly-Ordered memory type.</p>\n<p>Note<br>This means the access is Non-cacheable. Unexpected data cache hit behavior is IMPLEMENTATION DEFINED.</p>\n<p><strong>Instruction access</strong><br>The stage 1 translation assigns Normal memory attribute, with the cacheability and<br>shareability attributes determined by the value of:<br>• the Secure copy of SCTLR.I for the Secure PL1&amp;0 translation regime<br>• the Non-secure copy of SCTLR.I for the Non-secure PL1&amp;0 translation regime<br>• HSCTLR.I for the Non-secure PL2 translation regime.</p>\n<h5 id=\"B3-2-2-VMSA-behavior-when-the-stage-2-MMU-is-disabled\"><a href=\"#B3-2-2-VMSA-behavior-when-the-stage-2-MMU-is-disabled\" class=\"headerlink\" title=\"B3.2.2 VMSA behavior when the stage 2 MMU is disabled\"></a>B3.2.2 VMSA behavior when the stage 2 MMU is disabled</h5><p>When the stage 2 MMU is disabled:<br>• the IPA output from the stage 1 translation maps <strong>flat to the PA</strong><br>• the memory attributes and permissions from the stage 1 translation apply to the PA.</p>\n<p>If the stage 1 MMU and the stage 2 MMU are both disabled, see Behavior of instruction fetches when all associated<br>MMUs are disabled.</p>\n<h4 id=\"B3-3-Translation-tables\"><a href=\"#B3-3-Translation-tables\" class=\"headerlink\" title=\"B3.3 Translation tables\"></a>B3.3 Translation tables</h4><p>VMSAv7 defines two alternative translation table formats:</p>\n<p><strong>Short-descriptor format</strong><br>This is the original format defined in issue A of this Architecture Reference Manual, and is the only format supported on implementations that do not include the Large Physical Address Extension. It uses 32-bit descriptor entries in the translation tables, and provides:<br>• <strong>Up to two levels of address lookup.</strong><br>• <strong>32-bit input addresses.</strong><br>• <strong>Output addresses of up to 40 bits.</strong><br>• Support for PAs of more than 32 bits by use of supersections, with 16MB granularity.<br>• Support for No access, Client, and Manager domains.<br>• <strong>32-bit table entries.</strong></p>\n<p><strong>Long-descriptor format</strong><br>The Large Physical Address Extension adds support for this format. It uses 64-bit descriptor entries in the translation tables, and provides:<br>• <strong>Up to three levels of address lookup.</strong><br>• <strong>Input addresses of up to 40 bits, when used for stage 2 translations.</strong><br>• <strong>Output addresses of up to 40 bits.</strong><br>• 4KB assignment granularity across the entire PA range.<br>• No support for domains, all memory regions are treated as in a Client domain.<br>• <strong>64-bit table entries.</strong><br>• Fixed 4KB table size, unless truncated by the size of the input address space.</p>\n<p>The Large Physical Address Extension is an OPTIONAL extension, but an implementation that includes the Virtualization Extensions must also include the Large Physical Address Extension.</p>\n<h5 id=\"B3-3-1-Translation-table-walks\"><a href=\"#B3-3-1-Translation-table-walks\" class=\"headerlink\" title=\"B3.3.1 Translation table walks\"></a>B3.3.1 Translation table walks</h5><p>A translation table walk occurs as the result of a TLB miss, and starts with a read of the appropriate starting-level<br>translation table.</p>\n<p>The physical address of the base of the starting-level translation table is determined from the appropriate Translation<br>table base register (TTBR).</p>\n<h5 id=\"B3-3-2-Information-returned-by-a-translation-table-lookup\"><a href=\"#B3-3-2-Information-returned-by-a-translation-table-lookup\" class=\"headerlink\" title=\"B3.3.2 Information returned by a translation table lookup\"></a>B3.3.2 Information returned by a translation table lookup</h5><p>If the required translation table descriptor is not held in a TLB, a translation table walk is performed to obtain the descriptor. A lookup, whether from the TLB or as the result of a translation table walk, returns both:<br>• an output address that corresponds to the input address for the lookup<br>• a set of properties that correspond to that output address.</p>\n<p>The returned properties are classified as providing <strong>address map control, access controls, or region attributes.</strong></p>\n<h5 id=\"B3-3-3-Determining-the-translation-table-base-address\"><a href=\"#B3-3-3-Determining-the-translation-table-base-address\" class=\"headerlink\" title=\"B3.3.3 Determining the translation table base address\"></a>B3.3.3 Determining the translation table base address</h5><p>Fixme[Figure B3-2 Memory translation summary, with Virtualization Extensions]page1312</p>\n<h5 id=\"B3-3-4-Security-Extensions-control-of-translation-table-walks\"><a href=\"#B3-3-4-Security-Extensions-control-of-translation-table-walks\" class=\"headerlink\" title=\"B3.3.4 Security Extensions control of translation table walks\"></a>B3.3.4 Security Extensions control of translation table walks</h5><p>When an implementation includes the Security Extensions, two bits in the TTBCR for the current security state<br>control whether a translation table walk is performed on a TLB miss. These two bits are the:<br>• PD0 and PD1 bits, on a processor using the Short-descriptor translation table format<br>• EPD0 and EPD1 bits, on a processor using the Long-descriptor translation table format.</p>\n<p>The effect of these bits is:<br>{E}PDx == 0 If a TLB miss occurs based on TTBRx, a translation table walk is performed. The current security<br>state determines whether the memory access is Secure or Non-secure.<br>{E}PDx == 1 If a TLB miss occurs based on TTBRx, a First level Translation fault is returned, and no translation<br>table walk is performed.</p>\n<h5 id=\"B3-3-5-Access-to-the-Secure-or-Non-secure-physical-address-map\"><a href=\"#B3-3-5-Access-to-the-Secure-or-Non-secure-physical-address-map\" class=\"headerlink\" title=\"B3.3.5 Access to the Secure or Non-secure physical address map\"></a>B3.3.5 Access to the Secure or Non-secure physical address map</h5><p>As stated in Address spaces in a VMSA implementation on page B3-1311, a processor that implements the Security<br>Extensions implements independent Secure and Non-secure address maps. These are defined by the translation<br>tables identified by the Secure TTBR0 and TTBR1. In both translation table formats:<br>• In the Secure translation tables, the NS bit in a descriptor indicates whether the descriptor refers to the Secure<br>or the Non-secure address map:<br>NS == 0 Access the Secure physical address space.<br>NS == 1 Access the Non-secure physical address space.</p>\n<h4 id=\"B3-5-Short-descriptor-translation-table-format\"><a href=\"#B3-5-Short-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.5 Short-descriptor translation table format\"></a>B3.5 Short-descriptor translation table format</h4><p>The Short-descriptor translation table format supports a memory map based on memory sections or pages:<br><strong>Supersections</strong><br>Consist of 16MB blocks of memory. Support for Supersections is optional, except that an<br>implementation that includes the Large Physical Address Extension and supports more that 32 bits<br>of Physical Address must also support Supersections to provide access to the entire Physical<br>Address space.</p>\n<p><strong>Sections</strong><br>Consist of 1MB blocks of memory.</p>\n<p><strong>Large pages</strong><br>Consist of 64KB blocks of memory.</p>\n<p><strong>Small pages</strong><br>Consist of 4KB blocks of memory.</p>\n<p>When using the Short-descriptor translation table format, two levels of translation tables are held in memory: </p>\n<ul>\n<li>First-level table  </li>\n<li>Second-level tables  </li>\n</ul>\n<p>In the translation tables, in general, a descriptor is one of:<br>• an invalid or fault entry<br>• a page table entry, that points to a next-level translation table<br>• a page or section entry, that defines the memory properties for the access<br>• a reserved format.<br>Bits[1:0] of the descriptor give the primary indication of the descriptor type.</p>\n<p>Fixme[Figure B3-3 General view of address translation using Short-descriptor format translation tables] Page 1325</p>\n<h5 id=\"B3-5-1-Short-descriptor-translation-table-format-descriptors\"><a href=\"#B3-5-1-Short-descriptor-translation-table-format-descriptors\" class=\"headerlink\" title=\"B3.5.1 Short-descriptor translation table format descriptors\"></a>B3.5.1 Short-descriptor translation table format descriptors</h5><h6 id=\"Short-descriptor-translation-table-first-level-descriptor-formats\"><a href=\"#Short-descriptor-translation-table-first-level-descriptor-formats\" class=\"headerlink\" title=\"Short-descriptor translation table first-level descriptor formats\"></a>Short-descriptor translation table first-level descriptor formats</h6><p>Fixme [Figure B3-4 Short-descriptor first-level descriptor formats] Page1326</p>\n<p>Descriptor bits[1:0] identify the descriptor type.</p>\n<h6 id=\"Short-descriptor-translation-table-second-level-descriptor-formats\"><a href=\"#Short-descriptor-translation-table-second-level-descriptor-formats\" class=\"headerlink\" title=\"Short-descriptor translation table second-level descriptor formats\"></a>Short-descriptor translation table second-level descriptor formats</h6><p>Fixme [Figure B3-5 Short-descriptor second-level descriptor formats] Page1327</p>\n<h5 id=\"B3-5-2-Memory-attributes-in-the-Short-descriptor-translation-table-format-descriptors\"><a href=\"#B3-5-2-Memory-attributes-in-the-Short-descriptor-translation-table-format-descriptors\" class=\"headerlink\" title=\"B3.5.2 Memory attributes in the Short-descriptor translation table format descriptors\"></a>B3.5.2 Memory attributes in the Short-descriptor translation table format descriptors</h5><p><strong>TEX[2:0], C, B</strong><br>Memory region attribute bits, see Memory region attributes on page B3-1366.<br>These bits are not present in a Page table entry</p>\n<p><strong>XN bit</strong><br>The Execute-never bit. Determines whether the processor can execute software from the addressed<br>region, see Execute-never restrictions on instruction fetching on page B3-1359.<br>This bit is not present in a Page table entry.</p>\n<p><strong>PXN bit, when supported</strong><br>The Privileged execute-never bit:<br>• On an implementation that does not include the Large Physical Address Extension, support<br>for the PXN bit in the Short-descriptor translation table format is OPTIONAL.<br>• On an implementation that includes the Large Physical Address Extension, the<br>Short-descriptor translation table format must include the PXN bit.</p>\n<p><strong>NS bit</strong><br>Non-secure bit. If an implementation includes the Security Extensions, for memory accesses from<br>Secure state, this bit specifies whether the translated PA is in the Secure or Non-secure address map</p>\n<p><strong>Domain</strong><br>Domain field, see Domains, Short-descriptor format only on page B3-1362.<br>Page table descriptor applies to all entries in the corresponding second-level translation table.</p>\n<p><strong>AP[2], AP[1:0]</strong><br>Access Permissions bits, see Memory access control on page B3-1356</p>\n<p><strong>S bit</strong><br>The Shareable bit.</p>\n<p><strong>nG bit</strong><br>The not global bit. Determines how the translation is marked in the TLB, see Global and<br>process-specific translation table entries on page B3-1378.</p>\n<h5 id=\"B3-5-4-Selecting-between-TTBR0-and-TTBR1-Short-descriptor-translation-table-format\"><a href=\"#B3-5-4-Selecting-between-TTBR0-and-TTBR1-Short-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.5.4 Selecting between TTBR0 and TTBR1, Short-descriptor translation table format\"></a>B3.5.4 Selecting between TTBR0 and TTBR1, Short-descriptor translation table format</h5><p>the value of TTBCR.N indicates the number of most significant bits of the input VA that determine whether TTBR0 or TTBR1 :<br>• If N == 0 then use TTBR0. Setting TTBCR.N to zero disables use of a second set of translation tables.<br>• if N &gt; 0 then:<br>    — if bits[31:32-N] of the input VA are all zero then use TTBR0<br>    — otherwise use TTBR1.</p>\n<p>Fixme [Table B3-1 Effect of TTBCR.N on address translation, Short-descriptor format] page1330<br>Whenever TTBCR.N is nonzero, the size of the translation table addressed by TTBR1 is 16KB.</p>\n<p>Fixme [Figure B3-6 How TTBCR.N controls the boundary between the TTBRs, Short-descriptor format] page1331</p>\n<h5 id=\"B3-5-5-Translation-table-walks-when-using-the-Short-descriptor-translation-table-format\"><a href=\"#B3-5-5-Translation-table-walks-when-using-the-Short-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.5.5 Translation table walks, when using the Short-descriptor translation table format\"></a>B3.5.5 Translation table walks, when using the Short-descriptor translation table format</h5><h6 id=\"Reading-a-first-level-translation-table\"><a href=\"#Reading-a-first-level-translation-table\" class=\"headerlink\" title=\"Reading a first-level translation table\"></a>Reading a first-level translation table</h6><p>Fixme [Figure B3-7 Accessing first-level translation table based on TTBR0, Short-descriptor format] page1332</p>\n<h6 id=\"The-full-translation-flow-for-Sections-Supersections-Small-pages-and-Large-pages\"><a href=\"#The-full-translation-flow-for-Sections-Supersections-Small-pages-and-Large-pages\" class=\"headerlink\" title=\"The full translation flow for Sections, Supersections, Small pages and Large pages\"></a>The full translation flow for Sections, Supersections, Small pages and Large pages</h6><p>Fixme [Figure B3-11 Small page address translation] page1337</p>\n<h4 id=\"B3-6-Long-descriptor-translation-table-format\"><a href=\"#B3-6-Long-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.6 Long-descriptor translation table format\"></a>B3.6 Long-descriptor translation table format</h4><p>Fixme [Figure B3-12 General view of stage 1 address translation using Long-descriptor format]page1338</p>\n<h5 id=\"B3-6-1-Long-descriptor-translation-table-format-descriptors\"><a href=\"#B3-6-1-Long-descriptor-translation-table-format-descriptors\" class=\"headerlink\" title=\"B3.6.1 Long-descriptor translation table format descriptors\"></a>B3.6.1 Long-descriptor translation table format descriptors</h5><p>In general, a descriptor is one of:<br>• an invalid or fault entry<br>• a table entry, that points to the next-level translation table<br>• a block entry, that defines the memory properties for the access<br>• a reserved format.</p>\n<h6 id=\"Long-descriptor-translation-table-first-level-and-second-level-descriptor-formats\"><a href=\"#Long-descriptor-translation-table-first-level-and-second-level-descriptor-formats\" class=\"headerlink\" title=\"Long-descriptor translation table first-level and second-level descriptor formats\"></a>Long-descriptor translation table first-level and second-level descriptor formats</h6><p>Fixme [Figure B3-14 Long-descriptor first-level and second-level descriptor formats]page1340</p>\n<h6 id=\"Long-descriptor-translation-table-third-level-descriptor-formats\"><a href=\"#Long-descriptor-translation-table-third-level-descriptor-formats\" class=\"headerlink\" title=\"Long-descriptor translation table third-level descriptor formats\"></a>Long-descriptor translation table third-level descriptor formats</h6><p>Fixme [Figure B3-15 Long-descriptor third-level descriptor formats]page1341</p>\n<h5 id=\"B3-6-3-Control-of-Secure-or-Non-secure-memory-access-Long-descriptor-format\"><a href=\"#B3-6-3-Control-of-Secure-or-Non-secure-memory-access-Long-descriptor-format\" class=\"headerlink\" title=\"B3.6.3 Control of Secure or Non-secure memory access, Long-descriptor format\"></a>B3.6.3 Control of Secure or Non-secure memory access, Long-descriptor format</h5><p>In the Long-descriptor format:<br>• the NS bit relates only to the memory block or page at the output address defined by the descriptor<br>• the descriptors also include an NSTable bit, see Hierarchical control of Secure or Non-secure memory<br>accesses, Long-descriptor format.</p>\n<p>NSTable == 0 The defined table address is in the Secure physical address space.<br>NSTable == 1 The defined table address is in the Non-secure physical address space.</p>\n<h5 id=\"B3-6-4-Selecting-between-TTBR0-and-TTBR1-Long-descriptor-translation-table-format\"><a href=\"#B3-6-4-Selecting-between-TTBR0-and-TTBR1-Long-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.6.4 Selecting between TTBR0 and TTBR1, Long-descriptor translation table format\"></a>B3.6.4 Selecting between TTBR0 and TTBR1, Long-descriptor translation table format</h5><p>The TTBCR.T0SZ and TTBCR.T1SZ size fields control the use of TTBR0 and TTBR1,</p>\n<p>Fixme [Table B3-2 Use of TTBR0 and TTBR1, Long-descriptor format]page1345</p>\n<p>Fixme [Figure B3-18 Control of TTBR boundary, when TTBCR.T1SZ is zero]page1346</p>\n<h5 id=\"B3-6-5-Long-descriptor-translation-table-format-address-lookup-levels\"><a href=\"#B3-6-5-Long-descriptor-translation-table-format-address-lookup-levels\" class=\"headerlink\" title=\"B3.6.5 Long-descriptor translation table format address lookup levels\"></a>B3.6.5 Long-descriptor translation table format address lookup levels</h5><p>Fixme [Table B3-3 Properties of the three levels of address lookup with Long-descriptor translation tables]page1348</p>\n<h5 id=\"B3-6-6-Translation-table-walks-when-using-the-Long-descriptor-translation-table-format\"><a href=\"#B3-6-6-Translation-table-walks-when-using-the-Long-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.6.6 Translation table walks, when using the Long-descriptor translation table format\"></a>B3.6.6 Translation table walks, when using the Long-descriptor translation table format</h5><p>Example Full translation flow, starting at second-level lookup<br>Fixme [Figure B3-22 Complete Long-descriptor format stage 1 translation, starting at second level]page1355</p>\n<h3 id=\"B3-7-Memory-access-control\"><a href=\"#B3-7-Memory-access-control\" class=\"headerlink\" title=\"B3.7 Memory access control\"></a>B3.7 Memory access control</h3><p>In addition to an output address, a translation table entry that refers to page or region of memory includes fields that<br>define properties of the target memory region.</p>\n<h5 id=\"B3-7-1-Access-permissions\"><a href=\"#B3-7-1-Access-permissions\" class=\"headerlink\" title=\"B3.7.1 Access permissions\"></a>B3.7.1 Access permissions</h5><p>Access permission bits in a translation table descriptor control access to the corresponding memory region. The<br>Short-descriptor translation table format supports two options for defining the access permissions:<br>• three bits, AP[2:0], define the access permissions<br>• two bits, AP[2:1], define the access permissions, and AP[0] can be used as an Access flag.</p>\n<p>SCTLR.AFE selects the access permissions option. Setting this bit to 1, to enable the Access flag, also selects use<br>of AP[2:1] to define access permissions</p>\n<p>The Long-descriptor translation table format uses only AP[2:1] to control the access permissions, and provides an<br>AF bit for use as an Access flag</p>\n<h6 id=\"AP-2-1-access-permissions-model\"><a href=\"#AP-2-1-access-permissions-model\" class=\"headerlink\" title=\"AP[2:1] access permissions model\"></a>AP[2:1] access permissions model</h6><p>Fixme [Table B3-6 VMSAv7 AP[2:1] access permissions model]page1357</p>\n<h6 id=\"AP-2-0-access-permissions-control-Short-descriptor-format-only\"><a href=\"#AP-2-0-access-permissions-control-Short-descriptor-format-only\" class=\"headerlink\" title=\"AP[2:0] access permissions control, Short-descriptor format only\"></a>AP[2:0] access permissions control, Short-descriptor format only</h6><p>Fixme [Table B3-8 VMSAv7 MMU access permissions]page1358</p>\n<h5 id=\"B3-7-2-Execute-never-restrictions-on-instruction-fetching\"><a href=\"#B3-7-2-Execute-never-restrictions-on-instruction-fetching\" class=\"headerlink\" title=\"B3.7.2 Execute-never restrictions on instruction fetching\"></a>B3.7.2 Execute-never restrictions on instruction fetching</h5><p>Execute-never (XN) controls provide an additional level of control on memory accesses permitted by the access<br>permissions settings. </p>\n<p><strong>XN, Execute-never</strong><br>When the XN bit is 1, a Permission fault is generated if the processor attempts to execute an<br>instruction fetched from the corresponding memory region. </p>\n<p><strong>PXN, Privileged execute-never</strong><br>When the PXN bit is 1, a Permission fault is generated if the processor is executing at PL1 and<br>attempts to execute an instruction fetched from the corresponding memory region. </p>\n<h5 id=\"B3-7-3-Domains-Short-descriptor-format-only\"><a href=\"#B3-7-3-Domains-Short-descriptor-format-only\" class=\"headerlink\" title=\"B3.7.3 Domains, Short-descriptor format only\"></a>B3.7.3 Domains, Short-descriptor format only</h5><p>A domain is a collection of memory regions. The Short-descriptor translation table format supports 16 domains, and<br>requires the software that defines a translation table to assign each VMSA memory region to a domain. </p>\n<h5 id=\"B3-7-4-The-Access-flag\"><a href=\"#B3-7-4-The-Access-flag\" class=\"headerlink\" title=\"B3.7.4 The Access flag\"></a>B3.7.4 The Access flag</h5><p>The Access flag indicates when a page or section of memory is accessed for the first time since the Access flag in<br>the corresponding translation table descriptor was set to 0</p>\n<h5 id=\"B3-7-5-PL2-control-of-Non-secure-access-permissions\"><a href=\"#B3-7-5-PL2-control-of-Non-secure-access-permissions\" class=\"headerlink\" title=\"B3.7.5 PL2 control of Non-secure access permissions\"></a>B3.7.5 PL2 control of Non-secure access permissions</h5><p>Non-secure software executing at PL2 controls two sets of translation tables, both of which use the Long-descriptor<br>translation table format:<br>• The translation tables that control the Non-secure PL2 stage 1 translations. These map VAs to PAs, for<br>memory accesses made when executing in Non-secure state at PL2, and are indicated and controlled by the<br>HTTBR and HTCR.</p>\n<p>The HAP[2:1] field in the stage 2 descriptors define the stage 2 access permissions<br>Fixme [Table B3-9 Stage 2 control of access permissions]page1365</p>\n<h4 id=\"B3-8-Memory-region-attributes\"><a href=\"#B3-8-Memory-region-attributes\" class=\"headerlink\" title=\"B3.8 Memory region attributes\"></a>B3.8 Memory region attributes</h4><h5 id=\"B3-8-1-Overview-of-memory-region-attributes-for-stage-1-translations\"><a href=\"#B3-8-1-Overview-of-memory-region-attributes-for-stage-1-translations\" class=\"headerlink\" title=\"B3.8.1 Overview of memory region attributes for stage 1 translations\"></a>B3.8.1 Overview of memory region attributes for stage 1 translations</h5><p><strong>Memory type and attributes</strong><br>These are described either:<br>• Directly, by bits in the translation table descriptor.<br>• Indirectly, by registers referenced by bits in the table descriptor. This is described as<br>remapping the memory type and attribute description.</p>\n<p>The Short-descriptor translation table format can use either of these approaches, selected by the<br>SCTLR.TRE bit:<br>TRE == 0 Remap disabled. The TEX[2:0], C, and B bits in the translation table descriptor define<br>the memory region attributes. </p>\n<p>TRE == 1 Remap enabled. The TEX[0], C, and B bits in the translation table descriptor are index<br>bits to the MMU remap registers, that define the memory region attributes:<br>• the Primary Region Remap Register, PRRR<br>• the Normal Memory Remap Register, NMRR</p>\n<p>The Long-descriptor translation table format always uses remapping. </p>\n<p><strong>Shareability</strong><br>In the Short-descriptor translation table format, the S bit in the translation table descriptor encodes<br>whether the region is shareable. </p>\n<h5 id=\"B3-8-2-Short-descriptor-format-memory-region-attributes-without-TEX-remap\"><a href=\"#B3-8-2-Short-descriptor-format-memory-region-attributes-without-TEX-remap\" class=\"headerlink\" title=\"B3.8.2 Short-descriptor format memory region attributes, without TEX remap\"></a>B3.8.2 Short-descriptor format memory region attributes, without TEX remap</h5><p>Fixme [Table B3-10 TEX, C, and B encodings when TRE == 0]page1367</p>\n<p>Cacheable memory attributes, without TEX remap<br>When TEX[2] == 1, the translation table entry describes Cacheable memory, and the rest of the encoding defines<br>the Inner and Outer cache attributes:<br>TEX[1:0] Define the Outer cache attribute.<br>C, B Define the Inner cache attribute.</p>\n<p>Fixme [Table B3-11 Inner and Outer cache attribute encoding]page1368</p>\n<h5 id=\"B3-8-3-Short-descriptor-format-memory-region-attributes-with-TEX-remap\"><a href=\"#B3-8-3-Short-descriptor-format-memory-region-attributes-with-TEX-remap\" class=\"headerlink\" title=\"B3.8.3 Short-descriptor format memory region attributes, with TEX remap\"></a>B3.8.3 Short-descriptor format memory region attributes, with TEX remap</h5><p>• The software that defines the translation tables must program the PRRR and NMRR to define seven possible<br>memory region attributes.<br>• The TEX[0], C, and B bits of the translation table descriptors define the memory region attributes, by<br>indexing PRRR and NMRR.</p>\n<p>Fixme [Table B3-12 TEX, C, and B encodings when TRE == 1]page1369</p>\n<h5 id=\"B3-8-4-Long-descriptor-format-memory-region-attributes\"><a href=\"#B3-8-4-Long-descriptor-format-memory-region-attributes\" class=\"headerlink\" title=\"B3.8.4 Long-descriptor format memory region attributes\"></a>B3.8.4 Long-descriptor format memory region attributes</h5><p>the AttrIndx[2:0] field in a block or page translation table descriptor for a stage 1 translation indicates the 8-bit field in the appropriate MAIR, that specifies<br>the attributes for the corresponding memory region:<br>• AttrIndx[2] indicates the value of n in MAIRn:<br>AttrIndx[2] == 0 Use MAIR0.<br>AttrIndx[2] == 1 Use MAIR1</p>\n<p>• AttrIndx[2:0] indicates the required Attr field, Attrn, where n = AttrIndx[2:0].<br>Each AttrIndx field defines, for the corresponding memory region:<br>• The memory type, Strongly-ordered, Device, or Normal.<br>• For Normal memory<br>    — the inner and outer cacheability, Non-cacheable, Write-Through, or Write-Back<br>    — for Write-Through Cacheable and Write-Back Cacheable regions, the Read-Allocate and<br>    Write-Allocate policy hints, each of which is Allocate or Do not allocate</p>\n<h6 id=\"Shareability-Long-descriptor-format\"><a href=\"#Shareability-Long-descriptor-format\" class=\"headerlink\" title=\"Shareability, Long-descriptor format\"></a>Shareability, Long-descriptor format</h6><p>Fixme [Table B3-14 SH[1:0] field encoding for Normal memory, Long-descriptor format]page1373</p>\n<p>For a Device or Strongly-ordered memory region, the value of the SH[1:0] field of the translation table descriptor<br>is ignored.</p>\n<h4 id=\"B3-9-Translation-Lookaside-Buffers-TLBs\"><a href=\"#B3-9-Translation-Lookaside-Buffers-TLBs\" class=\"headerlink\" title=\"B3.9 Translation Lookaside Buffers (TLBs)\"></a>B3.9 Translation Lookaside Buffers (TLBs)</h4><p>Translation Lookaside Buffers (TLBs) are an implementation technique that caches translations or translation table entries.<br>TLBs avoid the requirement for every memory access to perform a translation table walk in memory. </p>\n<h5 id=\"B3-9-1-Global-and-process-specific-translation-table-entries\"><a href=\"#B3-9-1-Global-and-process-specific-translation-table-entries\" class=\"headerlink\" title=\"B3.9.1  Global and process-specific translation table entries\"></a>B3.9.1  Global and process-specific translation table entries</h5><p>In a VMSA implementation, system software can divide a virtual memory map used by memory accesses at PL1 and PL0 into global and non-global regions, indicated by the nG bit in the translation table descriptors:<br>nG == 0<br>The translation is global, meaning the region is available for all processes.</p>\n<p>nG == 1<br>The translation is non-global, or process-specific, meaning it relates to the current ASID, as defined by the CONTEXTIDR.</p>\n<h5 id=\"B3-9-2-TLB-matching\"><a href=\"#B3-9-2-TLB-matching\" class=\"headerlink\" title=\"B3.9.2  TLB matching\"></a>B3.9.2  TLB matching</h5><h5 id=\"B3-9-3-TLB-behavior-at-reset\"><a href=\"#B3-9-3-TLB-behavior-at-reset\" class=\"headerlink\" title=\"B3.9.3  TLB behavior at reset\"></a>B3.9.3  TLB behavior at reset</h5><p>The ARMv7 architecture does not require a reset to invalidate the TLB. All TLBs are disabled from reset. All MMUs are disabled from reset, and the contents of the TLBs have no effect on address translation.</p>\n<h5 id=\"B3-9-5-TLB-conflict-aborts\"><a href=\"#B3-9-5-TLB-conflict-aborts\" class=\"headerlink\" title=\"B3.9.5  TLB conflict aborts\"></a>B3.9.5  TLB conflict aborts</h5><p>The Large Physical Address Extension introduces the concept of a TLB conflict abort, and adds fault status encodings for such an abort.</p>\n<p>An implementation can generate a TLB conflict abort if it detects that the address being looked up in the TLB hits multiple entries.<br>In some implementations, multiple hits in the TLB can generate a synchronous Data Abort or Prefetch Abort exception.</p>\n<h4 id=\"B3-10-TLB-maintenance-requirements\"><a href=\"#B3-10-TLB-maintenance-requirements\" class=\"headerlink\" title=\"B3.10 TLB maintenance requirements\"></a>B3.10 TLB maintenance requirements</h4><h5 id=\"B3-10-1-General-TLB-maintenance-requirements\"><a href=\"#B3-10-1-General-TLB-maintenance-requirements\" class=\"headerlink\" title=\"B3.10.1  General TLB maintenance requirements\"></a>B3.10.1  General TLB maintenance requirements</h5><p><strong>The architecture defines CP15 c8 functions for TLB maintenance operations</strong>, and supports the following operations:  </p>\n<ul>\n<li>invalidate all unlocked entries in the TLB  </li>\n<li>invalidate a single TLB entry, by MVA, or MVA and ASID for a non-global entry  </li>\n<li>invalidate all TLB entries that match a specified ASID. </li>\n</ul>\n<p>The Multiprocessing Extensions add the following operations:<br>• invalidate all TLB entries that match a specified MVA, regardless of the ASID</p>\n<h6 id=\"Using-break-before-make-when-updating-translation-table-entries\"><a href=\"#Using-break-before-make-when-updating-translation-table-entries\" class=\"headerlink\" title=\"Using break-before-make when updating translation table entries\"></a>Using break-before-make when updating translation table entries</h6><p>ARM strongly recommends the use of a break-before-make when changing translation table entries whenever multiple threads of execution can use the same translation tables and the change to the translation entries involves any of:<br>• A change of the memory type.<br>• A change of the cacheability attributes.<br>• A change of the output address (OA), if the OA of at least one of the old translation table entry and the new<br>translation table entry is writable.</p>\n<p><strong>break-before-make</strong></p>\n<ol>\n<li>Replace the old translation table entry, and execute DSB instruction.  </li>\n<li>Invalidate the translation table entry with a broadcast TLB invalidation instruction, and execute a DSB instruction  </li>\n<li>Write the new translation table entry, and execute a DSB instruction   </li>\n</ol>\n<h5 id=\"B3-10-2-Maintenance-requirements-on-changing-system-control-register-values\"><a href=\"#B3-10-2-Maintenance-requirements-on-changing-system-control-register-values\" class=\"headerlink\" title=\"B3.10.2 Maintenance requirements on changing system control register values\"></a>B3.10.2 Maintenance requirements on changing system control register values</h5><p>The TLB contents can be influenced by control bits in a number of system control registers. </p>\n<p>The system control register changes that this applies to are:<br>• any change to the NMRR, PRRR, MAIRn, or HMAIRn registers<br>• any change to the SCTLR.AFE bit, see Changing the Access flag enable<br>• any change to the SCTLR.TRE bit<br>• any change to the translation table base address in TTBR0<br>• any change to the translation table base address in TTBR1<br>• in an implementation that includes the Virtualization Extensions:<br>    — any change to the SCTLR.{WXN, UWXN} bits<br>    — any change to the SCR.SIF bit<br>    — any change to the HCR.VM bit<br>    — any change to HCR.PTW bit, see Changing HCR.PTW<br>    — any change to the HTTBR.BADDR field<br>    — any change to the VTTBR.BADDR field<br>• in an implementation that includes the Large Physical Address Extension, changing TTBCR.EAE, see<br>Changing the current Translation table format on page B3-1386<br>• when using the Short-descriptor translation table format:<br>    — any change to the RGN, IRGN, S, or NOS fields in TTBR0 or TTBR1<br>    — any change to the PD0 or PD1 fields in TTBCR<br>• when using the Long-descriptor translation table format:<br>    — any change to the TnSZ, ORGNn, IRGNn, SHn, or EPDn fields in the TTBCR, where n is 0 or 1<br>    — any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the HTCR<br>    — any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the VTCR.</p>\n<h5 id=\"B3-10-3-Atomicity-of-register-changes-on-changing-virtual-machine\"><a href=\"#B3-10-3-Atomicity-of-register-changes-on-changing-virtual-machine\" class=\"headerlink\" title=\"B3.10.3 Atomicity of register changes on changing virtual machine\"></a>B3.10.3 Atomicity of register changes on changing virtual machine</h5><p>From the viewpoint of software executing in a Non-secure PL1 or PL0 mode, when there is a switch from one virtual<br>machine to another, the registers that control or affect address translation must be changed atomically. </p>\n<p>This applies to the registers for:<br>• Non-secure PL1&amp;0 stage 1 address translations. This means that all of the following registers must change  atomically:<br>    — PRRR and NMRR, if using the Short-descriptor translation table format<br>    — MAIR0 and MAIR1, if using the Long-descriptor translation table format<br>    — TTBR0, TTBR1, TTBCR, DACR, and CONTEXTIDR<br>    — the SCTLR.</p>\n<p><strong>These registers apply to execution in Non-secure PL1&amp;0 modes. However, when updated as part of a switch of virtual machines they are updated by software executing in Hyp mode.</strong></p>\n<p>• Non-secure PL1&amp;0 stage 2 address translations. This means that all of the following registers and register<br>fields must change atomically:<br>    — VTTBR and VTCR<br>    — HMAIR0 and HMAIR1<br>    — the HSCTLR.</p>\n<h5 id=\"B3-11-Caches-in-a-VMSA-implementation\"><a href=\"#B3-11-Caches-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.11 Caches in a VMSA implementation\"></a>B3.11 Caches in a VMSA implementation</h5><p>B3.11.1 Data and unified caches<br><strong>The behavior of accesses from the same observer to different VAs, that are translated to the same PA with the same memory attributes, is fully coherent.</strong> This means these accesses behave as follows, regardless of<br>which VA is accessed:<br>• two writes to the same PA occur in program order<br>• a read of a PA returns the value of the last successful write to that PA<br>• a write to a PA that occurs, in program order, after a read of that PA, has no effect on the value returned by<br>that read.<br>The memory system behaves in this way without any requirement to use barrier or cache maintenance operations.</p>\n<h4 id=\"B3-11-2-Instruction-caches\"><a href=\"#B3-11-2-Instruction-caches\" class=\"headerlink\" title=\"B3.11.2 Instruction caches\"></a>B3.11.2 Instruction caches</h4><p>In the ARM architecture, an instruction cache is a cache that is accessed only as a result of an instruction fetch.<br>Therefore, <strong>an instruction cache is never written to by any load or store instruction executed by the processor.</strong></p>\n<p>The ARMv7 architecture supports three different behaviors for instruction caches:<br>• Physically-indexed, physically-tagged(PIPT) instruction caches<br>• Virtually-indexed, physically-tagged (VIPT) instruction caches<br>• ASID and VMID tagged Virtually-indexed, virtually-tagged (VIVT) instruction caches.</p>\n<h5 id=\"B3-11-2-1-PIPT-instruction-caches-amp-VIPT-instruction-caches\"><a href=\"#B3-11-2-1-PIPT-instruction-caches-amp-VIPT-instruction-caches\" class=\"headerlink\" title=\"B3.11.2.1 PIPT instruction caches &amp; VIPT instruction caches\"></a>B3.11.2.1 PIPT instruction caches &amp; VIPT instruction caches</h5><p>For PIPT instruction caches, the use of memory address translation is entirely transparent to all instruction fetches<br>that are not UNPREDICTABLE.</p>\n<p>An implementation that provides PIPT/VIPT instruction caches implements the IVIPT extension, see IVIPT architecture<br>extension </p>\n<h5 id=\"B3-11-2-2-IVIPT-architecture-extension\"><a href=\"#B3-11-2-2-IVIPT-architecture-extension\" class=\"headerlink\" title=\"B3.11.2.2 IVIPT architecture extension\"></a>B3.11.2.2 IVIPT architecture extension</h5><p>It reduces the instruction cache maintenance requirement to the following condition:<br>• instruction cache maintenance is required only after writing new data to a physical address that holds an<br>instruction.</p>\n<h5 id=\"B3-11-2-3-ASID-and-VMID-tagged-VIVT-instruction-caches\"><a href=\"#B3-11-2-3-ASID-and-VMID-tagged-VIVT-instruction-caches\" class=\"headerlink\" title=\"B3.11.2.3 ASID and VMID tagged VIVT instruction caches\"></a>B3.11.2.3 ASID and VMID tagged VIVT instruction caches</h5><p>Instruction maintenance can also be required as a result of any of the following situations:<br>• enabling or disabling the MMU<br>• writing new mappings to the translation tables<br>• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,<br>or a change to the VMID<br>• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID</p>\n<h4 id=\"B3-12-VMSA-memory-aborts\"><a href=\"#B3-12-VMSA-memory-aborts\" class=\"headerlink\" title=\"B3.12 VMSA memory aborts\"></a>B3.12 VMSA memory aborts</h4><p>In a VMSAv7 implementation, the following mechanisms cause a processor to take an exception on a failed memory<br>access:<br><strong>Debug exception</strong><br>An exception caused by the debug configuration, see About debug exceptions on<br>page C4-2090.</p>\n<p><strong>Alignment fault</strong><br>An Alignment fault is generated if the address used for a memory access does not have the<br>required alignment for the operation. For more information see Unaligned data access on<br>page A3-108 and Alignment faults on page B3-1402.</p>\n<p><strong>MMU fault</strong><br>An MMU fault is a fault generated by the fault checking sequence for the current translation<br>regime.</p>\n<p><strong>External abort</strong><br>Any memory system fault other than a Debug exception, an Alignment fault, or an MMU<br>fault</p>\n<h5 id=\"B3-12-1-Routing-of-aborts\"><a href=\"#B3-12-1-Routing-of-aborts\" class=\"headerlink\" title=\"B3.12.1 Routing of aborts\"></a>B3.12.1 Routing of aborts</h5><p>A memory abort is either a Data Abort exception or a Prefetch Abort exception. The mode to which a memory abort<br>is taken depends on the reason for the exception, the mode the processor is in when it takes the exception:</p>\n<p><strong>Memory aborts taken to Monitor mode</strong><br>If an implementation includes the Security Extensions, when SCR.EA is set to 1, all External aborts<br>are taken to Monitor mode. This applies to aborts taken from Secure modes and from Non-secure<br>modes. </p>\n<p><strong>Memory aborts taken to Secure Abort mode</strong><br>If an implementation includes the Security Extensions, when the processor is executing in Secure<br>state, all memory aborts that are not routed to Monitor mode are taken to Secure Abort mode.</p>\n<p><strong>Memory aborts taken to Hyp mode</strong><br>大致都发生在Hyp mode，Non-secure 时至少也是在stage 2 发生的错误（stage 1 VA -&gt; IPA; stage2 IPA-&gt; PA. 虚拟地址-&gt;中间地址-&gt;物理地址）</p>\n<p>includes the Virtualization Extensions, the processor is executing in Non-secure state<br>• Alignment faults taken:<br>    — When the processor is in Hyp mode.<br>    — When the processor is in a PL1 or PL0 mode and the exception is generated because<br>    the Non-secure PL1&amp;0 stage 2 translation identifies the target of an unaligned access<br>    as Device or Strongly-ordered memory.<br>    — When the processor is in the PL0 mode and HCR.TGE is set to 1. For more<br>    information see Synchronous external abort, when HCR.TGE is set to 1 on<br>    page B1-1193.</p>\n<p>• When the processor is using the Non-secure PL1&amp;0 translation regime:<br>    — MMU faults from stage 2 translations, for which the stage 1 translation did not cause<br>    an MMU fault.<br>    — Any abort taken during the stage 2 translation of an address accessed in a stage 1<br>    translation table walk that is not routed to Secure Monitor mode<br>• When the processor is using the Non-secure PL2 translation regime, MMU faults from<br>stage 1 translations.</p>\n<p>• External aborts, if SCR.EA is set to 0 and any of the following applies:<br>    — The processor was executing in Hyp mode when it took the exception.<br>    — The processor was executing in a Non-secure PL0 or PL1 mode when it took the<br>    exception, the abort is asynchronous, and HCR.AMO is set to 1.<br>    — The processor was executing in the Non-secure PL0 mode when it took the exception,<br>    the abort is synchronous, and HCR.TGE is set to 1. For more information see<br>    Synchronous external abort, when HCR.TGE is set to 1 on page B1-1193.<br>    — The abort occurred on a stage 2 translation table walk.</p>\n<p>• Debug exceptions, if HDCR.TDE is set to 1.</p>\n<p><strong>Memory aborts taken to Non-secure Abort mode</strong><br>In an implementation that does not include the Security Extensions, all memory aborts are taken to<br>Abort mode.<br>Otherwise, when the processor is executing in Non-secure state, the following aborts are taken to<br>Non-secure Abort mode:<br>• When the processor is in a Non-secure PL1 or PL0 mode, Alignment faults taken for any of<br>the following reasons:<br>    — SCTLR.A is set to 1.<br>    — An instruction that does not support unaligned accesses is committed for execution,<br>    and the instruction accesses an unaligned address.<br>    — The implementation includes the Virtualization Extensions, and the PL1&amp;0 stage 1<br>    translation identifies the target of an unaligned access as Device or Strongly-ordered<br>    memory.<br>• When the processor is using the Non-secure PL1&amp;0 translation regime, MMU faults from<br>stage 1 translations.<br>• External aborts, if all of the following apply:<br>    — the abort is not on a stage 2 translation table walk<br>    — the processor is not in Hyp mode<br>    — SCR.EA is set to 0<br>    — the abort is asynchronous, and HCR.AMO is set to 0<br>    — the abort is synchronous, and HCR.TGE is set to 0• When the processor is using the Non-secure PL1&amp;0 translation regime, MMU faults from<br>stage 1 translations.<br>• External aborts, if all of the following apply:<br>    — the abort is not on a stage 2 translation table walk<br>    — the processor is not in Hyp mode<br>    — SCR.EA is set to 0<br>    — the abort is asynchronous, and HCR.AMO is set to 0<br>    — the abort is synchronous, and HCR.TGE is set to 0</p>\n<h5 id=\"B3-12-3-The-MMU-fault-checking-sequence\"><a href=\"#B3-12-3-The-MMU-fault-checking-sequence\" class=\"headerlink\" title=\"B3.12.3 The MMU fault-checking sequence\"></a>B3.12.3 The MMU fault-checking sequence</h5><p>In a VMSA implementation, all memory accesses require VA to PA translation. Therefore, when a corresponding<br>MMU is enabled, each access requires a lookup of the translation table descriptor for the accessed VA. </p>\n<p>When using the Short-descriptor format<br>• There are one or two levels of lookup.<br>• Lookup always starts at the first level.<br>• The final level of lookup checks the Domain field of the descriptor and:<br>    — faults if there is no access to the Domain<br>    — checks the access permissions only for Client domains.<br>When using the Long-descriptor format<br>• There are one, two, or three levels of lookup.<br>• Lookup starts at either the first level or the second level.<br>• Domains are not supported. All accesses are treated as Client domain accesses.</p>\n<p>Fixme [Figure B3-23 Fetching the descriptor in a translation table walk]Page1400</p>\n<p>Fixme [Figure B3-24 VMSA fault checking sequence]Page1401</p>\n<p><strong>Stage 2 fault on a stage 1 translation table walk, Virtualization Extensions</strong><br>When an implementation that includes the Virtualization Extensions is operating in a Non-secure PL1 or PL0 mode,<br>any memory access goes through two stages of translation:<br>• stage 1, from VA to IPA<br>• stage 2, from IPA to PA</p>\n<h5 id=\"B3-12-4-Alignment-faults\"><a href=\"#B3-12-4-Alignment-faults\" class=\"headerlink\" title=\"B3.12.4 Alignment faults\"></a>B3.12.4 Alignment faults</h5><p>The ARMv7 memory architecture requires support for strict alignment checking. This checking is controlled by<br>SCTLR.A.</p>\n<p>An Alignment fault can occur on an access for which the MMU is disabled.</p>\n<p><strong>In an implementation that includes the Virtualization Extensions, any unaligned access to memory region with the Device or Strongly-ordered memory type attribute generates an Alignment fault.</strong></p>\n<h5 id=\"B3-12-5-MMU-faults\"><a href=\"#B3-12-5-MMU-faults\" class=\"headerlink\" title=\"B3.12.5 MMU faults\"></a>B3.12.5 MMU faults</h5><p>This section describes the faults that might be detected during one of the fault-checking sequences described in The<br>MMU fault-checking sequence.</p>\n<p>The following subsections describe the MMU faults that might be detected during a fault checking sequence:<br>• External abort on a translation table walk<br>• Translation fault<br>• Access flag fault on page B3-1404<br>• Domain fault, Short-descriptor format translation tables only on page B3-1404<br>• Permission fault on page B3-1405.</p>\n<p><strong>Translation fault</strong><br>A Translation fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.<br>A Translation fault is generated if bits[1:0] of a translation table descriptor identify the descriptor as either a Fault<br>encoding or a reserved encoding.</p>\n<p>In addition, if an implementation includes the Virtualization Extensions, then a Translation fault is generated if the<br>input address for a translation either does not map on to an address range of a Translation Table Base Register, or<br>the Translation Table Base Register range that it maps on to is disabled. </p>\n<p>The architecture guarantees that any translation table entry that causes a Translation fault is not cached,</p>\n<p><strong>Access flag fault</strong><br>An Access flag fault can be generated at any level of lookup,<br>• The translation tables support an Access flag bit:<br>    — the Short-descriptor format supports an Access flag only when SCTLR.AFE is set to 1<br>    — the Long-descriptor format always supports an Access flag.</p>\n<p>The architecture guarantees that any translation table entry that causes an Access flag fault is not cached, meaning<br>the TLB never holds such an entry.</p>\n<p><strong>Domain fault, Short-descriptor format translation tables only</strong><br>When using the Short-descriptor translation table format, a Domain fault can be generated at the first level or second<br>level of lookup.</p>\n<p>When a first-level/second-level descriptor fetch returns a valid Section first-level descriptor, the domain field of<br>that descriptor is checked against the DACR. A first-level Domain fault is generated if this check<br>fails.</p>\n<p>A TLB might hold a translation table entry that cause a Domain fault.</p>\n<p><strong>Permission fault</strong><br>A Permission fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.</p>\n<p>A TLB might hold a translation table entry that cause a Permission fault. Therefore, if the handling of a Permission<br>fault results in an update to the associated translation tables, the software that updates the translation tables must<br>invalidate the appropriate TLB entry.</p>\n<p>B3.12.6 External aborts<br>The ARM architecture defines external aborts as errors that occur in the memory system, other than those that are<br>detected by the MMU or Debug hardware.An external abort is one of:<br>• synchronous<br>• precise asynchronous<br>• imprecise asynchronous.</p>\n<p>The ARM architecture does not provide any method to distinguish between precise asynchronous and imprecise<br>asynchronous aborts.</p>\n<p>Normally, external aborts are rare. An imprecise asynchronous external abort is likely to be fatal to the process that<br>is running. </p>\n<h5 id=\"B3-12-7-Prioritization-of-aborts\"><a href=\"#B3-12-7-Prioritization-of-aborts\" class=\"headerlink\" title=\"B3.12.7 Prioritization of aborts\"></a>B3.12.7 Prioritization of aborts</h5><p>prioritization decreasing in next order:</p>\n<ol>\n<li>Alignment fault</li>\n<li>an MMU fault, on either the stage 1 translation or the stage 2 translation</li>\n<li>a Watchpoint debug event.</li>\n<li>an external abort</li>\n</ol>\n<h4 id=\"B3-13-Exception-reporting-in-a-VMSA-implementation\"><a href=\"#B3-13-Exception-reporting-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.13 Exception reporting in a VMSA implementation\"></a>B3.13 Exception reporting in a VMSA implementation</h4><h5 id=\"B3-13-1-About-exception-reporting\"><a href=\"#B3-13-1-About-exception-reporting\" class=\"headerlink\" title=\"B3.13.1 About exception reporting\"></a>B3.13.1 About exception reporting</h5><p>In an implementation that includes the Virtualization Extensions, exceptions can be taken to:<br>• a Secure or Non-secure PL1 mode<br>• the Non-secure PL2 mode, Hyp mode.</p>\n<h5 id=\"B3-13-2-Reporting-exceptions-taken-to-PL1-modes\"><a href=\"#B3-13-2-Reporting-exceptions-taken-to-PL1-modes\" class=\"headerlink\" title=\"B3.13.2 Reporting exceptions taken to PL1 modes\"></a>B3.13.2 Reporting exceptions taken to PL1 modes</h5><p><strong>Registers used for reporting exceptions taken to a PL1 mode</strong><br>ARMv7 defines the following registers, and register encodings, for exceptions taken to PL1 modes:<br>• the DFSR holds information about a Data Abort exception<br>• the DFAR holds the faulting address for some synchronous Data Abort exceptions<br>• the IFSR holds information about a Prefetch Abort exception<br>• the IFAR holds the faulting address of a Prefetch Abort exception<br>• on a Watchpoint debug exception, the DBGWFAR can hold fault information.</p>\n<p><strong>Auxiliary Fault Status Registers</strong><br>The ARMv7 architecture defines the following Auxiliary Fault Status Registers:<br>• the Auxiliary Data Fault Status Register, ADFSR<br>• the Auxiliary Instruction Fault Status Register, AIFSR.</p>\n<h5 id=\"B3-13-3-Fault-reporting-in-PL1-modes\"><a href=\"#B3-13-3-Fault-reporting-in-PL1-modes\" class=\"headerlink\" title=\"B3.13.3 Fault reporting in PL1 modes\"></a>B3.13.3 Fault reporting in PL1 modes</h5><p>Fixme [Table B3-23 Short-descriptor format FSR encodings] Page 1415</p>\n<p>Fixme [Table B3-24 Long-descriptor format FSR encodings] Page 1416</p>\n<h5 id=\"B3-13-5-Reporting-exceptions-taken-to-the-Non-secure-PL2-mode\"><a href=\"#B3-13-5-Reporting-exceptions-taken-to-the-Non-secure-PL2-mode\" class=\"headerlink\" title=\"B3.13.5 Reporting exceptions taken to the Non-secure PL2 mode\"></a>B3.13.5 Reporting exceptions taken to the Non-secure PL2 mode</h5><p><strong>Registers used for reporting exceptions taken to Hyp mode</strong><br>The Virtualization Extensions define the following registers for exceptions taken to Hyp mode:<br>• the HSR holds syndrome information for the exception<br>• the HDFAR holds the VA associated with a Data Abort exception<br>• the HIFAR holds the VA associated with a Prefetch Abort exception<br>• the HPFAR holds bits[39:12] of the IPA associated with some aborts on stage 2 address translations.</p>\n<p><strong>Hyp Auxiliary Fault Syndrome Registers</strong><br>The Virtualization Extensions define the following Hyp Auxiliary Fault Syndrome Registers:<br>• the Hyp Auxiliary Data Fault Syndrome Register, HADFSR<br>• the Hyp Auxiliary Instruction Fault Syndrome Register, HAIFSR.</p>\n<p>Fixme [Table B3-28 HSR.EC encodings for aborts taken to Hyp mode] Page 1422</p>\n<h5 id=\"B3-13-6-Use-of-the-HSR\"><a href=\"#B3-13-6-Use-of-the-HSR\" class=\"headerlink\" title=\"B3.13.6 Use of the HSR\"></a>B3.13.6 Use of the HSR</h5><p>The HSR holds syndrome information for any synchronous exception taken to Hyp mode. Compared with the<br>reporting of exceptions taken to PL1 modes, the HSR:<br>• Always provides details of the fault. The DFSR and IFSR are not used.<br>• Provides more extensive information, for a wider range of exceptions.</p>\n<p>Fixme [Figure B3-25 Format of the HSR, with subdivision of the ISS field for specified EC encodings] Page 1425</p>\n<p>Fixme [Table B3-29 HSR.EC field encoding] Page 1425</p>\n<p>More detail ISS encoding see arm-arm pdf</p>\n<h4 id=\"B3-14-Virtual-Address-to-Physical-Address-translation-operation\"><a href=\"#B3-14-Virtual-Address-to-Physical-Address-translation-operation\" class=\"headerlink\" title=\"B3.14 Virtual Address to Physical Address translation operation\"></a>B3.14 Virtual Address to Physical Address translation operation</h4><p><strong>CP15 c7 includes operations for Virtual Address (VA) to Physical Address (PA) translation.</strong></p>\n<h5 id=\"B3-14-1-Naming-of-the-address-translation-operations-and-operation-summary\"><a href=\"#B3-14-1-Naming-of-the-address-translation-operations-and-operation-summary\" class=\"headerlink\" title=\"B3.14.1 Naming of the address translation operations, and operation summary\"></a>B3.14.1 Naming of the address translation operations, and operation summary</h5><p>Fixme [Table B3-31 Naming of address translation operations] Page 1438</p>\n<p>In the stage 1 current state and stages 1 and 2 Non-secure state only operations, the meanings of the last two letters<br>of the names are:</p>\n<ul>\n<li>PR PL1 mode, read operation.  </li>\n<li>PW PL1 mode, write operation.  </li>\n<li>UR PL0 mode, read operation.  </li>\n<li>UW PL0 mode, write operation.</li>\n</ul>\n<h5 id=\"B3-14-2-Encoding-and-availability-of-the-address-translation-operations\"><a href=\"#B3-14-2-Encoding-and-availability-of-the-address-translation-operations\" class=\"headerlink\" title=\"B3.14.2 Encoding and availability of the address translation operations\"></a>B3.14.2 Encoding and availability of the address translation operations</h5><p>Software executing at PL0 never has any visibility of the address translation operations, but software executing at<br>PL1 or higher can use the unprivileged address translation operations to find the address translations used for<br>memory accesses by software executing at PL0 and PL1.</p>\n<p>Fixme [Table B3-32 CP15 c7 address translation operations] Page 1440</p>\n<p>The result of an operation is always returned in the PAR. The PAR is a RW register and:<br>• in all implementations, the 32-bit format PAR is accessed using an MCR or MRC instruction with CRn set to c7,<br>CRm set to c4, and opc1 and opc2 both set to 0<br>• in an implementation that includes the Large Physical Address Extension, the 64-bit format PAR is accessed<br>using an MCRR or MRRC instruction with CRm set to c7, and opc1 set to 0.</p>\n<h5 id=\"B3-14-3-Determining-the-PAR-format-Large-Physical-Address-Extension\"><a href=\"#B3-14-3-Determining-the-PAR-format-Large-Physical-Address-Extension\" class=\"headerlink\" title=\"B3.14.3 Determining the PAR format, Large Physical Address Extension\"></a>B3.14.3 Determining the PAR format, Large Physical Address Extension</h5><p>The Large Physical Address Extension extends the PAR to become a 64-bit register, and supports both 32-bit and<br>64-bit PAR formats</p>\n<h4 id=\"B3-15-About-the-system-control-registers-for-VMSA\"><a href=\"#B3-15-About-the-system-control-registers-for-VMSA\" class=\"headerlink\" title=\"B3.15 About the system control registers for VMSA\"></a>B3.15 About the system control registers for VMSA</h4><p>On an ARMv7-A or ARMv7-R implementation, the system control registers comprise:<br>• the registers accessed using the System Control Coprocessor, CP15<br>• registers accessed using the CP14 coprocessor, including:<br>    — debug registers<br>    — trace registers<br>    — execution environment registers.</p>\n<h5 id=\"B3-15-3-Classification-of-system-control-registers\"><a href=\"#B3-15-3-Classification-of-system-control-registers\" class=\"headerlink\" title=\"B3.15.3 Classification of system control registers\"></a>B3.15.3 Classification of system control registers</h5><p><strong>Banked system control registers</strong><br>Fixme [Table B3-33 Banked CP15 registers] Page 1452</p>\n<p><strong>Restricted access system control registers</strong><br>Fixme [Table B3-34 Restricted access CP15 registers] Page 1453</p>\n<p><strong>PL2-mode system control registers</strong><br>Fixme [Table B3-35 Banked PL2-mode CP15 read/write registers] Page 1455</p>\n<p>Fixme [Table B3-37 Banked PL2-mode CP15 write-only operations] Page 1457</p>\n<p><strong>Common system control registers</strong><br>Some system control registers and operations are common to the Secure and Non-secure security states.<br>Fixme [Table B3-38 Common CP15 registers] Page 1457</p>\n<h4 id=\"B3-16-Organization-of-the-CP14-registers-in-a-VMSA-implementation\"><a href=\"#B3-16-Organization-of-the-CP14-registers-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.16 Organization of the CP14 registers in a VMSA implementation\"></a>B3.16 Organization of the CP14 registers in a VMSA implementation</h4><p>The CP14 registers provide a number of distinct control functions, covering:<br>• Debug<br>• Trace<br>• Execution environment control, for the Jazelle and ThumbEE execution environments.</p>\n<p>The CP14 register encodings are classified by the {CRn, opc1, CRm, opc2} values required to access them using<br>an MCR or an MRC instruction. The opc1 value determines the primary allocation of these registers, as follows:<br>opc1==0 Debug registers.<br>opc1==1 Trace registers.<br>opc1==6 ThumbEE registers.<br>opc1==7 Jazelle registers. Can include Jazelle SUBARCHITECTURE DEFINED registers</p>\n<h4 id=\"B3-17-Organization-of-the-CP15-registers-in-a-VMSA-implementation\"><a href=\"#B3-17-Organization-of-the-CP15-registers-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.17 Organization of the CP15 registers in a VMSA implementation\"></a>B3.17 Organization of the CP15 registers in a VMSA implementation</h4><p>More precisely, the ordered set of values {CRn, opc1, CRm, opc2} determined the register order.</p>\n<h5 id=\"B3-17-1-CP15-register-summary-by-coprocessor-register-number\"><a href=\"#B3-17-1-CP15-register-summary-by-coprocessor-register-number\" class=\"headerlink\" title=\"B3.17.1 CP15 register summary by coprocessor register number\"></a>B3.17.1 CP15 register summary by coprocessor register number</h5><p>Fixme [Figure B3-26 CP15 register grouping by primary coprocessor register, CRn, VMSA implementation] Page 1470</p>\n<p><strong>VMSA CP15 c0 register summary, identification registers</strong><br>Fixme [Figure B3-27 CP15 c0 registers in a VMSA implementation] Page 1471</p>\n<p><strong>VMSA CP15 c1 register summary, system control registers</strong><br>Fixme [Figure B3-28 CP15 c1 registers in a VMSA implementation] Page 1472</p>\n<p><strong>VMSA CP15 c2 and c3 register summary, Memory protection and control registers</strong><br>Fixme [Figure B3-29 CP15 32-bit c2 and c3 registers] Page 1473</p>\n<p>Fixme [Figure B3-30 CP15 64-bit c2 registers] Page 1473</p>\n<p><strong>VMSA CP15 c5 and c6 register summary, Memory system fault registers</strong><br>Fixme [Figure B3-31 CP15 c5 and c6 registers in a VMSA implementation] Page 1474</p>\n<p><strong>VMSA CP15 c7 register summary, Cache maintenance, address translation, and other functions</strong><br>Fixme [Figure B3-32 CP15 32-bit c7 registers in a VMSA implementation] Page 1475</p>\n<p><strong>VMSA CP15 c8 register summary, TLB maintenance operations</strong><br>Fixme [Figure B3-34 CP15 c8 registers in a VMSA implementation] Page 1476</p>\n<p><strong>VMSA CP15 c9 register summary, reserved for cache and TCM control and performance monitors</strong><br>Fixme [Figure B3-35 Reserved CP15 c9 encodings] Page 1477</p>\n<p><strong>VMSA CP15 c10 register summary, memory remapping and TLB control registers</strong><br>Fixme [Figure B3-36 CP15 c10 registers in a VMSA implementation] Page 1478</p>\n<p><strong>VMSA CP15 c11 register summary, reserved for TCM DMA registers</strong><br>Fixme [Figure B3-37 Reserved CP15 c11 encodings] Page 1478</p>\n<p><strong>VMSA CP15 c12 register summary, Security Extensions registers</strong><br>Fixme [Figure B3-38 Security Extensions CP15 c12 registers] Page 1479</p>\n<p><strong>VMSA CP15 c13 register summary, Process, context and thread ID registers</strong><br>On an ARMv7-A implementation, the CP15 c13 registers provide:<br>• an FCSE Process ID Register, that indicates whether the implementation includes the FCSE<br>• a Context ID Register<br>• Software Thread ID Registers.<br>Fixme [Figure B3-39 CP15 c13 registers in a VMSA implementation] Page 1479</p>\n<p><strong>VMSA CP15 c14, reserved for Generic Timer Extension</strong><br>Fixme [Figure B3-40 CP15 32-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480<br>Fixme [Figure B3-41 CP15 64-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480</p>\n<p><strong>VMSA CP15 c15 register summary, IMPLEMENTATION DEFINED registers</strong></p>\n<h5 id=\"B3-17-2-Full-list-of-VMSA-CP15-registers-by-coprocessor-register-number\"><a href=\"#B3-17-2-Full-list-of-VMSA-CP15-registers-by-coprocessor-register-number\" class=\"headerlink\" title=\"B3.17.2 Full list of VMSA CP15 registers, by coprocessor register number\"></a>B3.17.2 Full list of VMSA CP15 registers, by coprocessor register number</h5><p>Fixme [Table B3-42 Summary of VMSA CP15 register descriptions, in coprocessor register number order] Page 1481</p>\n<h4 id=\"B3-18-Functional-grouping-of-VMSAv7-system-control-registers\"><a href=\"#B3-18-Functional-grouping-of-VMSAv7-system-control-registers\" class=\"headerlink\" title=\"B3.18 Functional grouping of VMSAv7 system control registers\"></a>B3.18 Functional grouping of VMSAv7 system control registers</h4><h5 id=\"B3-18-1-Identification-registers-functional-group\"><a href=\"#B3-18-1-Identification-registers-functional-group\" class=\"headerlink\" title=\"B3.18.1 Identification registers, functional group\"></a>B3.18.1 Identification registers, functional group</h5><p>Fixme [Table B3-44 Identification registers, VMSA] Page 1492</p>\n<h5 id=\"B3-18-2-Virtual-memory-control-registers-functional-group\"><a href=\"#B3-18-2-Virtual-memory-control-registers-functional-group\" class=\"headerlink\" title=\"B3.18.2 Virtual memory control registers, functional group\"></a>B3.18.2 Virtual memory control registers, functional group</h5><p>Fixme [Table B3-45 Virtual memory control registers, VMSA only] Page 1493</p>\n<h5 id=\"B3-18-3-PL1-Fault-handling-registers-functional-group\"><a href=\"#B3-18-3-PL1-Fault-handling-registers-functional-group\" class=\"headerlink\" title=\"B3.18.3 PL1 Fault handling registers, functional group\"></a>B3.18.3 PL1 Fault handling registers, functional group</h5><p>Fixme [Table B3-46 Fault handling registers, VMSA] Page 1494</p>\n<h5 id=\"B3-18-4-Other-system-control-registers-functional-group\"><a href=\"#B3-18-4-Other-system-control-registers-functional-group\" class=\"headerlink\" title=\"B3.18.4 Other system control registers, functional group\"></a>B3.18.4 Other system control registers, functional group</h5><p>Fixme [Table B3-47 Other system control registers, VMSA] Page 1494</p>\n<h5 id=\"B3-18-5-Lockdown-DMA-and-TCM-features-functional-group-VMSA\"><a href=\"#B3-18-5-Lockdown-DMA-and-TCM-features-functional-group-VMSA\" class=\"headerlink\" title=\"B3.18.5 Lockdown, DMA, and TCM features, functional group, VMSA\"></a>B3.18.5 Lockdown, DMA, and TCM features, functional group, VMSA</h5><p>Fixme [Table B3-48 Lockdown, DMA, and TCM features, VMSA] Page 1495</p>\n<h5 id=\"B3-18-6-Cache-maintenance-operations-functional-group-VMSA\"><a href=\"#B3-18-6-Cache-maintenance-operations-functional-group-VMSA\" class=\"headerlink\" title=\"B3.18.6 Cache maintenance operations, functional group, VMSA\"></a>B3.18.6 Cache maintenance operations, functional group, VMSA</h5><p>Fixme [Table B3-49 Cache and branch predictor maintenance operations, VMSA] Page 1496</p>\n<h5 id=\"B3-18-7-TLB-maintenance-operations-functional-group\"><a href=\"#B3-18-7-TLB-maintenance-operations-functional-group\" class=\"headerlink\" title=\"B3.18.7 TLB maintenance operations, functional group\"></a>B3.18.7 TLB maintenance operations, functional group</h5><p>Fixme [Table B3-50 TLB maintenance operations, VMSA only] Page 1497</p>\n<h5 id=\"B3-18-8-Address-translation-operations-functional-group\"><a href=\"#B3-18-8-Address-translation-operations-functional-group\" class=\"headerlink\" title=\"B3.18.8 Address translation operations, functional group\"></a>B3.18.8 Address translation operations, functional group</h5><p>Fixme [Table B3-51 Address translation operations, VMSA only] Page 1498</p>\n<h5 id=\"B3-18-9-Miscellaneous-operations-functional-group\"><a href=\"#B3-18-9-Miscellaneous-operations-functional-group\" class=\"headerlink\" title=\"B3.18.9 Miscellaneous operations, functional group\"></a>B3.18.9 Miscellaneous operations, functional group</h5><p>Fixme [Table B3-52 Miscellaneous system control operations, VMSA only] Page 1499</p>\n<h5 id=\"B3-18-10-Performance-Monitors-functional-group\"><a href=\"#B3-18-10-Performance-Monitors-functional-group\" class=\"headerlink\" title=\"B3.18.10 Performance Monitors, functional group\"></a>B3.18.10 Performance Monitors, functional group</h5><p>Fixme [Table B3-53 Performance monitors, VMSA] Page 1500</p>\n<h5 id=\"B3-18-11-Security-Extensions-registers-functional-group\"><a href=\"#B3-18-11-Security-Extensions-registers-functional-group\" class=\"headerlink\" title=\"B3.18.11 Security Extensions registers, functional group\"></a>B3.18.11 Security Extensions registers, functional group</h5><p>Fixme [Table B3-54 Security Extensions registers, VMSA only] Page 1500</p>\n<h5 id=\"B3-18-12-Virtualization-Extensions-registers-functional-group\"><a href=\"#B3-18-12-Virtualization-Extensions-registers-functional-group\" class=\"headerlink\" title=\"B3.18.12 Virtualization Extensions registers, functional group\"></a>B3.18.12 Virtualization Extensions registers, functional group</h5><p>Fixme [Table B3-55 Virtualization Extensions registers, VMSA with Virtualization Extensions only] Page 1501</p>\n<p>Fixme [Table B3-56 Hyp mode TLB maintenance operations, VMSA with Virtualization Extensions only] Page 1502</p>\n<h5 id=\"B3-18-13-Generic-Timer-Extension-registers\"><a href=\"#B3-18-13-Generic-Timer-Extension-registers\" class=\"headerlink\" title=\"B3.18.13 Generic Timer Extension registers\"></a>B3.18.13 Generic Timer Extension registers</h5><h5 id=\"B3-18-14-IMPLEMENTATION-DEFINED-registers-functional-group\"><a href=\"#B3-18-14-IMPLEMENTATION-DEFINED-registers-functional-group\" class=\"headerlink\" title=\"B3.18.14 IMPLEMENTATION DEFINED registers, functional group\"></a>B3.18.14 IMPLEMENTATION DEFINED registers, functional group</h5><p>Typically, an implementation uses CP15 c15 to provide test features, and any required configuration options that<br>are not covered by this manual.</p>\n<h3 id=\"B4-System-Control-Registers-in-a-VMSA-implementation\"><a href=\"#B4-System-Control-Registers-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B4 System Control Registers in a VMSA implementation\"></a>B4 System Control Registers in a VMSA implementation</h3><p>Skip</p>\n<h3 id=\"B5-Protected-Memory-System-Architecture-PMSA\"><a href=\"#B5-Protected-Memory-System-Architecture-PMSA\" class=\"headerlink\" title=\"B5 Protected Memory System Architecture (PMSA)\"></a>B5 Protected Memory System Architecture (PMSA)</h3><p>Skip</p>\n<h3 id=\"B6-System-Control-Registers-in-a-PMSA-implementation\"><a href=\"#B6-System-Control-Registers-in-a-PMSA-implementation\" class=\"headerlink\" title=\"B6 System Control Registers in a PMSA implementation\"></a>B6 System Control Registers in a PMSA implementation</h3><p>Skip</p>\n<h3 id=\"B7-The-CPUID-Identification-Scheme\"><a href=\"#B7-The-CPUID-Identification-Scheme\" class=\"headerlink\" title=\"B7 The CPUID Identification Scheme\"></a>B7 The CPUID Identification Scheme</h3><h4 id=\"B7-1-Introduction-to-the-CPUID-scheme\"><a href=\"#B7-1-Introduction-to-the-CPUID-scheme\" class=\"headerlink\" title=\"B7.1 Introduction to the CPUID scheme\"></a>B7.1 Introduction to the CPUID scheme</h4><p>Before ARMv7, using Main ID Register:<br>• MIDR, Main ID Register, VMSA on page B4-1649<br>• MIDR, Main ID Register, PMSA on page B6-1894.</p>\n<p>The ARMv7 architecture implements an extended processor, using a number of registers in CP15 c0.<br><strong>ARMv7 requires the use of this scheme, and use of the scheme is indicated by a value of 0xF in the Architecture field of the Main ID Register.</strong></p>\n<p>The CPUID scheme provides information about the implemented:<br>• processor features<br>• debug features<br>• auxiliary features, in particular IMPLEMENTATION DEFINED features<br>• memory model features<br>• instruction set features.</p>\n<h4 id=\"B7-2-The-CPUID-registers\"><a href=\"#B7-2-The-CPUID-registers\" class=\"headerlink\" title=\"B7.2 The CPUID registers\"></a>B7.2 The CPUID registers</h4><h5 id=\"B7-2-1-Organization-of-the-CPUID-registers\"><a href=\"#B7-2-1-Organization-of-the-CPUID-registers\" class=\"headerlink\" title=\"B7.2.1 Organization of the CPUID registers\"></a>B7.2.1 Organization of the CPUID registers</h5><p>Fixme[Figure B7-1 CPUID register encodings] Page 1951</p>\n<p>Fixme[Table B7-1 CPUID register summary] Page 1952</p>\n<h5 id=\"B7-2-2-About-the-Instruction-Set-Attribute-registers\"><a href=\"#B7-2-2-About-the-Instruction-Set-Attribute-registers\" class=\"headerlink\" title=\"B7.2.2 About the Instruction Set Attribute registers\"></a>B7.2.2 About the Instruction Set Attribute registers</h5><p>Fixme[Table B7-2 Alphabetic list of Instruction Set Attribute registers attribute fields] Page 1954</p>\n<h3 id=\"B8-The-Generic-Timer\"><a href=\"#B8-The-Generic-Timer\" class=\"headerlink\" title=\"B8. The Generic Timer\"></a>B8. The Generic Timer</h3><h4 id=\"B8-1-About-the-Generic-Timer\"><a href=\"#B8-1-About-the-Generic-Timer\" class=\"headerlink\" title=\"B8.1 About the Generic Timer\"></a>B8.1 About the Generic Timer</h4><p>Fixme[Figure B8-1 Generic Timer example] page1960</p>\n<h5 id=\"8-1-1-System-counter\"><a href=\"#8-1-1-System-counter\" class=\"headerlink\" title=\"8.1.1 System counter\"></a>8.1.1 System counter</h5><p>The Generic Timer provides a system counter with the following specification:<br><strong>Width</strong><br>At least 56 bits wide.<br>The value returned by any 64-bit read of the counter is zero-extended to 64 bits.</p>\n<p><strong>Frequency</strong><br>Increments at a fixed frequency, typically in the range 1-50MHz.<br>Can support one or more alternative operating modes in which it increments by larger amounts at a<br>lower frequency, typically for power-saving.<br>Roll-over Roll-over time of not less than 40 years.</p>\n<p><strong>Accuracy</strong><br>ARM does not specify a required accuracy, but recommends that the counter does not gain or lose<br>more than ten seconds in a 24-hour period.<br>Use of lower-frequency modes must not affect the implemented accuracy.</p>\n<p><strong>Start-up</strong><br>Starts operating from zero.</p>\n<p>The system counter must be implemented in an always-on power domain.</p>\n<h6 id=\"Initializing-and-reading-the-system-counter-frequency\"><a href=\"#Initializing-and-reading-the-system-counter-frequency\" class=\"headerlink\" title=\"Initializing and reading the system counter frequency\"></a>Initializing and reading the system counter frequency</h6><p>Typically, the system drives the system counter at a fixed frequency and the CNTFRQ register must be programmed<br>to this value during the system boot process. </p>\n<p>In an implementation that supports the ARM Security Extensions, only<br>software executing in a Secure PL1 mode can write to CNTFRQ.</p>\n<p>Software can read the CNTFRQ register, to determine the current system counter frequency, in the following states<br>and modes:<br>• Non-secure PL2 mode.<br>• Secure and Non-secure PL1 modes.<br>• When CNTKCTL.PL0PCTEN is set to 1, Secure and Non-secure PL0 modes.</p>\n<h5 id=\"8-1-2-The-physical-counter\"><a href=\"#8-1-2-The-physical-counter\" class=\"headerlink\" title=\"8.1.2 The physical counter\"></a>8.1.2 The physical counter</h5><p>The processor provides a physical counter that contains the count value of the system counter. The CNTPCT register<br>holds the current physical counter value.</p>\n<p>In an implementation that includes the Virtualization Extensions, CNTPCT:<br>• Is always accessible from Secure PL1 modes, and from Non-secure Hyp mode.<br>• Is accessible from Non-secure PL1 modes only when CNTHCTL.PL1PCTEN is set to 1. When<br>CNTHCTL.PL1PCTEN is set to 0, any attempt to access CNTPCT from a Non-secure PL1 mode generates<br>a Hyp Trap exception, see Hyp Trap exception on page B1-1209.</p>\n<h5 id=\"8-1-3-The-virtual-counter\"><a href=\"#8-1-3-The-virtual-counter\" class=\"headerlink\" title=\"8.1.3 The virtual counter\"></a>8.1.3 The virtual counter</h5><p>An implementation of the Generic Timer always includes a virtual counter, that indicates virtual time:<br>• In a processor implementation that does not include the Virtualization Extensions, virtual time is identical to<br>physical time, and the virtual counter contains the same value as the physical counter.<br>• In a processor implementation that includes the Virtualization Extensions, the virtual counter contains the<br>value of the physical counter minus a 64-bit virtual offset. When execu</p>\n<p>CNTVCT is always accessible from Secure PL1 modes, and from Non-secure PL1 and PL2 modes</p>\n<h5 id=\"8-1-5-Timers\"><a href=\"#8-1-5-Timers\" class=\"headerlink\" title=\"8.1.5 Timers\"></a>8.1.5 Timers</h5><p>The number of timers provided by an implementation of the Generic Timer depends on whether the implementation<br>includes the Security Extensions and the Virtualization Extensions, as follows:</p>\n<p><strong>Security Extensions not implemented</strong><br>The implementation provides a physical timer and a virtual timer.</p>\n<p><strong>Security Extensions implemented, Virtualization Extensions not implemented</strong><br>The implementation provides:  </p>\n<ul>\n<li>A Non-secure physical timer.  </li>\n<li>A Secure physical timer.  </li>\n<li>A virtual timer.</li>\n</ul>\n<p><strong>Virtualization Extensions implemented</strong><br>The implementation provides:</p>\n<ul>\n<li>A Non-secure PL1 physical timer.  </li>\n<li>A Secure PL1 physical timer.  </li>\n<li>A Non-secure PL2 physical timer.  </li>\n<li>A virtual timer</li>\n</ul>\n<p>Each timer is implemented as three registers:  </p>\n<ul>\n<li>A 64-bit CompareValue register, that provides a 64-bit unsigned upcounter.  </li>\n<li>A 32-bit TimerValue register, that provides a 32-bit signed downcounter.  </li>\n<li>A 32-bit Control register.</li>\n</ul>\n<p>Fixme[Table B8-1 Timer registers summary for the Generic Timer] page1965</p>\n<h4 id=\"8-2-Generic-Timer-registers-summary\"><a href=\"#8-2-Generic-Timer-registers-summary\" class=\"headerlink\" title=\"8.2 Generic Timer registers summary\"></a>8.2 Generic Timer registers summary</h4><p>Fixme[Table B8-2 Generic Timer registers] page1969</p>\n","site":{"data":{}},"excerpt":"<p>Reference: &lt;<arm ®=\"\" architecture=\"\" reference=\"\" manual=\"\" --=\"\" armv7-a=\"\" and=\"\" armv7-r=\"\" edition=\"\">&gt; (ARM DDI 0406C.c (ID051414))<br>","more":"</arm></p>\n<h2 id=\"Part-B-System-Level-Architecture\"><a href=\"#Part-B-System-Level-Architecture\" class=\"headerlink\" title=\"Part B System Level Architecture\"></a>Part B System Level Architecture</h2><h3 id=\"B1-System-Level-Programmers’-Model\"><a href=\"#B1-System-Level-Programmers’-Model\" class=\"headerlink\" title=\"B1 System Level Programmers’ Model\"></a>B1 System Level Programmers’ Model</h3><h4 id=\"B1-1-About-the-System-level-programmers’-model\"><a href=\"#B1-1-About-the-System-level-programmers’-model\" class=\"headerlink\" title=\"B1.1 About the System level programmers’ model\"></a>B1.1 About the System level programmers’ model</h4><h4 id=\"B1-2-System-level-concepts-and-terminology\"><a href=\"#B1-2-System-level-concepts-and-terminology\" class=\"headerlink\" title=\"B1.2 System level concepts and terminology\"></a>B1.2 System level concepts and terminology</h4><h5 id=\"B1-2-1-Mode-state-and-privilege-level\"><a href=\"#B1-2-1-Mode-state-and-privilege-level\" class=\"headerlink\" title=\"B1.2.1 Mode, state, and privilege level\"></a>B1.2.1 Mode, state, and privilege level</h5><h6 id=\"Mode\"><a href=\"#Mode\" class=\"headerlink\" title=\"Mode\"></a>Mode</h6><p>The ARM architecture A and R profiles provide a set of modes that support normal software execution and handle<br>exceptions. The current mode determines:<br>• the set of registers that are available to the processor<br>• the privilege level of the executing software</p>\n<h6 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h6><ul>\n<li>Instruction set state</li>\n</ul>\n<blockquote>\n<p>one of ARM state, Thumb state, Jazelle state, or ThumbEE state.</p>\n</blockquote>\n<ul>\n<li>Execution state</li>\n</ul>\n<blockquote>\n<p>consists of the instruction set state and some control bits that modify how the<br>instruction stream is decoded. For details, see Execution state registers on page A2-50 and Program<br>Status Registers (PSRs) on page B1-1147.</p>\n</blockquote>\n<ul>\n<li><p>Security state </p>\n</li>\n<li><p>Debug state</p>\n</li>\n</ul>\n<h6 id=\"Privilege-level\"><a href=\"#Privilege-level\" class=\"headerlink\" title=\"Privilege level\"></a>Privilege level</h6><p><strong>Secure state</strong><br>PL0 Software executed in User mode executes at PL0.<br>PL1 Software executed in any mode other than User mode executes at PL1.</p>\n<p><strong>Non-secure state</strong><br>PL0 Software executed in User mode executes at PL0.<br>PL1 Software executed in any mode other than User or Hyp mode executes at PL1.<br>PL2 In an implementation that includes the Virtualization Extensions, software executed in<br>Hyp mode executes at PL2.</p>\n<h4 id=\"B1-3-ARM-processor-modes-and-ARM-core-registers\"><a href=\"#B1-3-ARM-processor-modes-and-ARM-core-registers\" class=\"headerlink\" title=\"B1.3 ARM processor modes and ARM core registers\"></a>B1.3 ARM processor modes and ARM core registers</h4><h5 id=\"B1-3-1-ARM-processor-modes\"><a href=\"#B1-3-1-ARM-processor-modes\" class=\"headerlink\" title=\"B1.3.1 ARM processor modes\"></a>B1.3.1 ARM processor modes</h5><p>Fixme [Table B1-1 ARM processor modes] page1139</p>\n<h6 id=\"System-mode\"><a href=\"#System-mode\" class=\"headerlink\" title=\"System mode\"></a>System mode</h6><p>Software executing in System mode executes at PL1. System mode has the same registers available<br>as User mode, and is not entered by any exception.</p>\n<h6 id=\"Supervisor-mode\"><a href=\"#Supervisor-mode\" class=\"headerlink\" title=\"Supervisor mode\"></a>Supervisor mode</h6><p>Supervisor mode is the default mode to which a Supervisor Call exception is taken.<br>Executing a SVC (Supervisor Call) instruction generates an Supervisor Call exception, that is taken<br>to Supervisor mode.<br><strong>A processor enters Supervisor mode on Reset</strong></p>\n<h6 id=\"Hyp-mode\"><a href=\"#Hyp-mode\" class=\"headerlink\" title=\"Hyp mode\"></a>Hyp mode</h6><p>Hyp mode is the Non-secure PL2 mode, implemented as part of the Virtualization Extensions.<br>The Hypervisor Call exception and Hyp Trap exception are exceptions that are implemented as part<br>of the Virtualization Extensions, and that are always taken in Hyp mode.<br>• <strong>In Hyp mode, the only exception return is execution of an ERET instruction, see ERET on page B9-1982</strong><br>• The instructions described in the following sections are UNDEFINED if executed in Hyp mode:<br>    — SRS (Thumb) on page B9-2004<br>    — SRS (ARM) on page B9-2006<br>    — RFE on page B9-2000<br>    — LDM (exception return) on page B9-1986<br>    — LDM (User registers) on page B9-1988<br>    — STM (User registers) on page B9-2008<br>    — SUBS PC, LR and related instructions (ARM) on page B9-2012.<br>    — SUBS PC, LR (Thumb) on page B9-2010, when executed with a nonzero constant.</p>\n<p>• In Hyp mode, the CPACR has no effect on the execution of coprocessor, floating-point, or Advanced SIMD<br>instructions. The HCPTR controls execution of these instructions in Hyp mode.</p>\n<p>• If software running in Hyp mode executes an SVC instruction, the Supervisor Call exception generated by the<br>instruction is taken to Hyp mode, see SVC (previously SWI) on page A8-720.</p>\n<h6 id=\"Monitor-mode\"><a href=\"#Monitor-mode\" class=\"headerlink\" title=\"Monitor mode\"></a>Monitor mode</h6><p>Monitor mode is the mode to which a Secure Monitor Call exception is taken.<br>Monitor mode is a Secure mode, meaning it is always in the Secure state, regardless of the value of<br>the SCR.NS bit. <strong>Monitor mode provides the normal method of changing between the Secure and Non-secure security states.</strong></p>\n<p>Fixme [Figure B1-1 Modes, privilege levels, and security states] page1141</p>\n<h5 id=\"B1-3-2-ARM-core-registers\"><a href=\"#B1-3-2-ARM-core-registers\" class=\"headerlink\" title=\"B1.3.2 ARM core registers\"></a>B1.3.2 ARM core registers</h5><p>Fixme [Figure B1-2 ARM core registers, PSRs, and ELR_hyp, showing register banking] page1144</p>\n<h5 id=\"B1-3-3-Program-Status-Registers-PSRs\"><a href=\"#B1-3-3-Program-Status-Registers-PSRs\" class=\"headerlink\" title=\"B1.3.3 Program Status Registers (PSRs)\"></a>B1.3.3 Program Status Registers (PSRs)</h5><h6 id=\"The-Current-Program-Status-Register-CPSR\"><a href=\"#The-Current-Program-Status-Register-CPSR\" class=\"headerlink\" title=\"The Current Program Status Register (CPSR)\"></a>The Current Program Status Register (CPSR)</h6><p>The Current Program Status Register (CPSR) holds processor status and control information:<br>• the APSR, see The Application Program Status Register (APSR) on page A2-49<br>• the current instruction set state, see Instruction set state register, ISETSTATE on page A2-50<br>• the execution state bits for the Thumb If-Then instruction, see IT block state register, ITSTATE on page A2-51<br>• the current endianness, see Endianness mapping register, ENDIANSTATE on page A2-53<br>• the current processor mode<br>• interrupt and asynchronous abort disable bits.</p>\n<h6 id=\"The-Saved-Program-Status-Registers-SPSRs\"><a href=\"#The-Saved-Program-Status-Registers-SPSRs\" class=\"headerlink\" title=\"The Saved Program Status Registers (SPSRs)\"></a>The Saved Program Status Registers (SPSRs)</h6><p>The purpose of an SPSR is to record the pre-exception value of the CPSR. </p>\n<p>Fixme [Format of the CPSR and SPSRs] Page1148</p>\n<h5 id=\"B1-3-4-ELR-hyp\"><a href=\"#B1-3-4-ELR-hyp\" class=\"headerlink\" title=\"B1.3.4 ELR_hyp\"></a>B1.3.4 ELR_hyp</h5><p>Hyp mode does not provide its own Banked copy of LR. Instead, on taking an exception to Hyp mode, the preferred<br>return address is stored in ELR_hyp, a 32-bit Special register implemented for this purpose.<br>ELR_hyp is implemented only as part of the Virtualization Extensions.</p>\n<p>The ERET instruction uses the value in ELR_hyp as the return address for the exception. For more information, see<br>ERET on page B9-1982.</p>\n<h4 id=\"B1-4-Instruction-set-states\"><a href=\"#B1-4-Instruction-set-states\" class=\"headerlink\" title=\"B1.4 Instruction set states\"></a>B1.4 Instruction set states</h4><p>If an exception is taken to a PL1 mode, the SCTLR.TE bit for the security state the exception is taken to determines<br>the processor instruction set state that handles the exception, and if necessary, the processor changes to this<br>instruction set state on exception entry.</p>\n<p>If the exception is taken to Hyp mode, the HSCTLR.TE bit determines the processor instruction set state that<br>handles the exception, and if necessary, the processor changes to this instruction set state on exception entry.</p>\n<h4 id=\"B1-5-The-Security-Extensions\"><a href=\"#B1-5-The-Security-Extensions\" class=\"headerlink\" title=\"B1.5 The Security Extensions\"></a>B1.5 The Security Extensions</h4><h5 id=\"B1-5-1-Security-states\"><a href=\"#B1-5-1-Security-states\" class=\"headerlink\" title=\"B1.5.1 Security states\"></a>B1.5.1 Security states</h5><p>The Security Extensions define two security states, Secure state and Non-secure state.<br>• Each security state operates in its own virtual memory address space, with its own translation regime.<br>— in any implementation that includes the Security Extensions, Monitor mode is available only in Secure<br>state<br>— in an implementation that also includes the Virtualization Extensions, Hyp mode is available only in<br>Non-secure state.</p>\n<p>The ARM core registers and the processor status registers are not Banked between the Secure and the Non-secure<br>states. ARM expects that, when switching execution between the Non-secure and Secure states, a kernel running<br>mostly in Monitor mode will switch the values of these registers.<br>The registers LR_mon and SPSR_mon are UNKNOWN when executing in Non-secure state.</p>\n<h6 id=\"Changing-from-Secure-to-Non-secure-state\"><a href=\"#Changing-from-Secure-to-Non-secure-state\" class=\"headerlink\" title=\"Changing from Secure to Non-secure state\"></a>Changing from Secure to Non-secure state</h6><p>Except in Monitor mode and Hyp mode, the security state is controlled by the SCR.NS bit. Software executing in a Secure PL1 mode can change the SCR, but ARM strongly recommends that software obeys the following rules for changing SCR.NS:<br>• To avoid security holes, software must not:<br>    — Change from Secure to Non-secure state by using an MSR or CPS instruction to switch from Monitor<br>    mode to some other mode while SCR.NS is 1.<br>    — Use an MCR instruction that writes SCR.NS to change from Secure to Non-secure state. This means<br>    ARM recommends that software does not alter SCR.NS in any mode except Monitor mode. ARM<br>    deprecates changing SCR.NS in any other mode.</p>\n<p>• <strong>The usual mechanism for changing from Secure to Non-secure state is an exception return</strong>.To return to<br>Non-secure state, software executing in Monitor mode sets SCR.NS to 1 and then performs the exception<br>return.</p>\n<h4 id=\"B1-6-The-Large-Physical-Address-Extension\"><a href=\"#B1-6-The-Large-Physical-Address-Extension\" class=\"headerlink\" title=\"B1.6 The Large Physical Address Extension\"></a>B1.6 The Large Physical Address Extension</h4><p>The Large Physical Address Extension is an OPTIONAL extension to the ARMv7-A architecture profile. Any<br>implementation that includes the Large Physical Address Extension must also include the Multiprocessing<br>Extensions.</p>\n<p>The Large Physical Address Extension adds a new translation table format:<br>• the format used in an implementation that does not include the Large Physical Address Extension is now<br>called the Short-descriptor format, see Short-descriptor translation table format on page B3-1324<br>• the format added by the Large Physical Address Extension is the Long-descriptor format, see<br>Long-descriptor translation table format on page B3-1338.</p>\n<p><strong>An implementation that includes the Large Physical Address Extension must support both translation table formats.</strong></p>\n<h4 id=\"B1-7-The-Virtualization-Extensions\"><a href=\"#B1-7-The-Virtualization-Extensions\" class=\"headerlink\" title=\"B1.7 The Virtualization Extensions\"></a>B1.7 The Virtualization Extensions</h4><p>The Virtualization Extensions are an OPTIONAL extension to the ARMv7-A architecture profile. Any<br>implementation that includes the Virtualization Extensions must include the Security Extensions, the Large Physical<br>Address Extension, and the Multiprocessing Extensions.</p>\n<p>The basic model of a virtualized system involves:<br>• a hypervisor, running in Non-secure Hyp mode, that is responsible for switching Guest operating systems<br>• a number of Guest operating systems, each of which runs in the Non-secure PL1 and PL0 modes<br>• for each Guest operating system, applications, that usually run in User mode.</p>\n<p><strong>Each virtual machine is identified by a virtual machine identifier (VMID), assigned by the hypervisor.</strong><br>• With the Security Extensions, the Virtualization Extensions control the routing of interrupts and<br>asynchronous Data Abort exceptions to the appropriate one of:<br>— the current Guest OS<br>— a Guest OS that is not currently running<br>— the hypervisor<br>— the Secure monitor.</p>\n<p>• When an implementation includes the Virtualization Extensions, it provides independent translation regimes<br>for memory accesses from:<br>    — Secure modes, the Secure PL1&amp;0 translation regime<br>    — Non-secure Hyp mode, the Non-secure PL2 translation regime<br>    — Non-secure PL1 and PL0 modes, the Non-secure PL1&amp;0 translation regime</p>\n<p>• In the Non-secure PL1&amp;0 translation regime, address translation occurs in two stages:<br>— Stage 1 maps the Virtual Address (VA) to an Intermediate Physical Address (IPA). Typically, the Guest<br>OS configures and controls this stage, and believes that the IPA is the Physical Address (PA)<br>— Stage 2 maps the IPA to the PA. Typically, the hypervisor controls this stage, and a Guest OS is<br>completely unaware of this translation.</p>\n<h5 id=\"B1-7-1-Impact-of-the-Virtualization-Extensions-on-the-modes-and-exception-model\"><a href=\"#B1-7-1-Impact-of-the-Virtualization-Extensions-on-the-modes-and-exception-model\" class=\"headerlink\" title=\"B1.7.1 Impact of the Virtualization Extensions on the modes and exception model\"></a>B1.7.1 Impact of the Virtualization Extensions on the modes and exception model</h5><p>• Implements new exceptions, see:<br>    — Hypervisor Call (HVC) exception on page B1-1212<br>    — Hyp Trap exception on page B1-1209<br>    — Virtual IRQ exception on page B1-1221<br>    — Virtual FIQ exception on page B1-1223<br>    — Virtual Abort exception on page B1-1218.</p>\n<p>• Implements a new register that holds the exception vector base address for exceptions taken to Hyp mode,<br>the HVBAR.</p>\n<p>• Implements a new exception return instruction, ERET, for return from Hyp mode</p>\n<p>• Provide mechanisms to trap processor functions to Hyp mode, using the Hyp Trap exception, see Traps to<br>the hypervisor on page B1-1248.<br>When an operation is trapped to Hyp mode, the hypervisor typically either:<br>    — emulates the required operation, so the application running in the Guest OS is unaware of the trap to<br>    Hyp mode<br>    — returns an error to the Guest OS.</p>\n<h4 id=\"B1-8-Exception-handling\"><a href=\"#B1-8-Exception-handling\" class=\"headerlink\" title=\"B1.8 Exception handling\"></a>B1.8 Exception handling</h4><h5 id=\"B1-8-1-Exception-vectors-and-the-exception-base-address\"><a href=\"#B1-8-1-Exception-vectors-and-the-exception-base-address\" class=\"headerlink\" title=\"B1.8.1 Exception vectors and the exception base address\"></a>B1.8.1 Exception vectors and the exception base address</h5><p>When an exception is taken, processor execution is forced to an address that corresponds to the type of exception.<br>This address is called the exception vector for that exception.</p>\n<p><strong>A set of exception vectors comprises eight consecutive word-aligned memory addresses</strong>, starting at an exception<br>base address. These eight vectors form a vector table. <strong>For the IRQ and FIQ exceptions only</strong>, when the exceptions<br>are taken to IRQ mode and FIQ mode, software can change the exception vectors from the vector table values by<br>setting the SCTLR.VE bit to 1, see Vectored interrupt support on page B1-1168.</p>\n<h6 id=\"Implementation-that-does-not-include-the-Security-Extensions-1-pair-interrupt-vectors\"><a href=\"#Implementation-that-does-not-include-the-Security-Extensions-1-pair-interrupt-vectors\" class=\"headerlink\" title=\"Implementation that does not include the Security Extensions (1 pair interrupt vectors)\"></a>Implementation that does not include the Security Extensions (1 pair interrupt vectors)</h6><p>This section applied to all ARMv7-R implementations.<br>An implementation that does not include the Security Extensions has a single vector table, the base<br>address of which is selected by SCTLR.V, see SCTLR, System Control Register, VMSA on<br>page B4-1707 or SCTLR, System Control Register, PMSA on page B6-1932:<br>    V == 0 Exception base address = 0x00000000. This setting is referred to as normal vectors, or as<br>    low vectors.<br>    V == 1 Exception base address = 0xFFFF0000. This setting is referred to as high vectors, or<br>    Hivecs.</p>\n<h6 id=\"Implementation-that-includes-the-Security-Extensions-3-pair-interrupt-vectors\"><a href=\"#Implementation-that-includes-the-Security-Extensions-3-pair-interrupt-vectors\" class=\"headerlink\" title=\"Implementation that includes the Security Extensions (3 pair interrupt vectors)\"></a>Implementation that includes the Security Extensions (3 pair interrupt vectors)</h6><p>Any implementation that includes the Security Extensions has the following vector tables:<br>• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in<br>the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure<br>vector table, and is in the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and<br>is in the address space of the Non-secure PL1&amp;0 translation regime.</p>\n<p><strong>For the Monitor vector table, MVBAR holds the exception base address.</strong></p>\n<p>For the Secure vector table:<br>• the Secure SCTLR.V bit determines the exception base address:<br>    V == 0 The Secure VBAR holds the exception base address.<br>    V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.</p>\n<p>For the Non-secure vector table:<br>• the Non-secure SCTLR.V bit determines the exception base address:<br>    V == 0 The Non-secure VBAR holds the exception base address.<br>    V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.</p>\n<h6 id=\"Implementation-that-includes-the-Virtualization-Extensions-4-pair-interrupt-vectors\"><a href=\"#Implementation-that-includes-the-Virtualization-Extensions-4-pair-interrupt-vectors\" class=\"headerlink\" title=\"Implementation that includes the Virtualization Extensions (4 pair interrupt vectors)\"></a>Implementation that includes the Virtualization Extensions (4 pair interrupt vectors)</h6><p>An implementation that includes the Virtualization Extensions must include the Security<br>Extensions, and also includes an additional vector table. Therefore, it has the following vector<br>tables:<br>• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in<br>the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure<br>vector table, and is in the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Hyp mode, the Non-secure PL2 mode. This is the Hyp vector<br>table, and is in the address space of the Non-secure PL2 translation regime.<br>• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and<br>is in the address space of the Non-secure PL1&amp;0 translation regime.</p>\n<p>The exception base addresses of the Monitor vector table, the Secure vector table, and the<br>Non-secure vector table are determined in the same way as for an implementation that includes the<br>Security extensions but not the Virtualization extensions.</p>\n<p><strong>For the Hyp vector table, HVBAR holds the exception base address.</strong></p>\n<h6 id=\"The-vector-tables-and-exception-offsets\"><a href=\"#The-vector-tables-and-exception-offsets\" class=\"headerlink\" title=\"The vector tables and exception offsets\"></a>The vector tables and exception offsets</h6><p>Fixme [Table B1-3 The vector tables] page1167</p>\n<h5 id=\"B1-8-4-Processor-mode-for-taking-exceptions\"><a href=\"#B1-8-4-Processor-mode-for-taking-exceptions\" class=\"headerlink\" title=\"B1.8.4 Processor mode for taking exceptions\"></a>B1.8.4 Processor mode for taking exceptions</h5><h6 id=\"Exceptions-taken-to-Hyp-mode\"><a href=\"#Exceptions-taken-to-Hyp-mode\" class=\"headerlink\" title=\"Exceptions taken to Hyp mode\"></a>Exceptions taken to Hyp mode</h6><p>• Any exception taken from Hyp mode, that is not routed to Secure Monitor Mode by the controls described<br>in Asynchronous exception routing controls on page B1-1175, is taken to Hyp mode.</p>\n<p>• The following exceptions, if taken from Non-secure state, are taken to Hyp mode:<br>    — An abort that Routing of aborts on page B3-1396 identifies as taken to Hyp mode.<br>    — A Hyp Trap exception, see Traps to the hypervisor on page B1-1248.<br>    — A Hypervisor Call exception. This is generated by executing a HVC instruction in a Non-secure mode.<br>    — An asynchronous abort, IRQ exception or FIQ exception that is not routed to Secure Monitor mode<br>    but is explicitly routed to Hyp mode, as described in Asynchronous exception routing controls on<br>    page B1-1175.<br>    — A synchronous external abort, Alignment fault, Undefined Instruction exception, or Supervisor Call<br>    exception taken from the Non-secure PL0 mode and explicitly routed to Hyp mode, as described in<br>    Routing general exceptions to Hyp mode on page B1-1192.<br>    Note<br>    A synchronous external abort can be routed to Hyp mode only if it not routed to Secure Monitor mode.<br>    — A debug exception that is explicitly routed to Hyp mode as described in Routing Debug exceptions to<br>    Hyp mode on page B1-1194.</p>\n<h6 id=\"Asynchronous-exception-routing-controls\"><a href=\"#Asynchronous-exception-routing-controls\" class=\"headerlink\" title=\"Asynchronous exception routing controls\"></a>Asynchronous exception routing controls</h6><p>In an implementation that includes the Security Extensions, the following bits in the SCR control the routing of<br>asynchronous exceptions:<br>SCR.EA    When this bit is set to 1, any external abort is taken to Secure Monitor mode<br>SCR.FIQ   When this bit is set to 1, any FIQ exception is taken to Secure Monitor mode.<br>SCR.IRQ   When this bit is set to 1, any IRQ exception is taken to Secure Monitor mode.<br><strong>Only Secure software can change the values of these bits.</strong></p>\n<p>In an implementation that includes the Virtualization Extensions, the following bits in the HCR route asynchronous<br>exceptions to Hyp mode:<br>HCR.AMO   If SCR.EA is set to 0, when this bit is set to 1, an asynchronous external abort taken from a<br>          Non-secure PL1 or PL0 mode is taken to Hyp mode, instead of to Non-secure Abort mode.</p>\n<p>HCR.FMO   If SCR.FIQ is set to 0, when this bit is set to 1, an FIQ exception taken from a Non-secure PL1 or<br>          PL0 mode is taken to Hyp mode, instead of to Non-secure FIQ mode.</p>\n<p>HCR.IMO   If SCR.IRQ is set to 0, when this bit is set to 1, an IRQ exceptions taken from a Non-secure PL1 or<br>          PL0 mode is taken to Hyp mode, instead of to Non-secure IRQ mode.</p>\n<p><strong>Only software executing in Hyp mode, or Secure software executing in Monitor mode when SCR.NS is set to 1, can change the values of these bits.</strong></p>\n<h5 id=\"B1-8-5-Processor-state-on-exception-entry\"><a href=\"#B1-8-5-Processor-state-on-exception-entry\" class=\"headerlink\" title=\"B1.8.5 Processor state on exception entry\"></a>B1.8.5 Processor state on exception entry</h5><h6 id=\"Instruction-set-state-on-exception-entry\"><a href=\"#Instruction-set-state-on-exception-entry\" class=\"headerlink\" title=\"Instruction set state on exception entry\"></a>Instruction set state on exception entry</h6><p>On exception entry, CPSR.{T, J} are set to the values shown, with the CPSR.T value determined by SCTLR.TE or HSCTLR.TE</p>\n<p>Fixme [Table B1-8 CPSR.J and CPSR.T bit values on exception entry] page1182</p>\n<h6 id=\"CPSR-E-bit-value-on-exception-entr\"><a href=\"#CPSR-E-bit-value-on-exception-entr\" class=\"headerlink\" title=\"CPSR.E bit value on exception entr\"></a>CPSR.E bit value on exception entr</h6><p>Fixme [Table B1-9 CPSR.E bit value on exception entry] page1182</p>\n<h5 id=\"B1-8-6-Asynchronous-exception-masking\"><a href=\"#B1-8-6-Asynchronous-exception-masking\" class=\"headerlink\" title=\"B1.8.6 Asynchronous exception masking\"></a>B1.8.6 Asynchronous exception masking</h5><p>The CPSR.{A, I, F} bits can mask the corresponding exceptions, as follows:<br>• CPSR.A can mask asynchronous aborts<br>• CPSR.I can mask IRQ exceptions<br>• CPSR.F can mask FIQ exceptions.</p>\n<p>In an ARMv7 implementation that does not include the Security Extensions, setting one of these bits to 1 masks the<br>corresponding exception, meaning the exception cannot be taken.</p>\n<p>In an implementation that includes the Security Extensions, the SCR.{AW, FW} bits provide a mechanism to<br>prevent use of the CPSR.{A, F} mask bits by Non-secure software. In an implementation that includes the<br>Virtualization Extensions:<br>• HCR.{AMO, FMO} modify this mechanism<br>• HCR.IMO can prevent the masking, by CPSR.I, of IRQs taken from Non-secure state.</p>\n<p>When an SCR.{AW, FW} bit is set to 0, Non-secure software cannot update the corresponding<br>CPSR bit.</p>\n<p>Fixme [Table B1-11 Control of masking by CPSR.A] page1185</p>\n<p>Fixme [Table B1-12 Control of masking by CPSR.I] page1185</p>\n<p>Fixme [Table B1-13 Control of masking by CPSR.F] page1185</p>\n<h5 id=\"B1-8-7-Summaries-of-asynchronous-exception-behavior\"><a href=\"#B1-8-7-Summaries-of-asynchronous-exception-behavior\" class=\"headerlink\" title=\"B1.8.7 Summaries of asynchronous exception behavior\"></a>B1.8.7 Summaries of asynchronous exception behavior</h5><h6 id=\"Asynchronous-exception-behavior-Security-Extensions-only\"><a href=\"#Asynchronous-exception-behavior-Security-Extensions-only\" class=\"headerlink\" title=\"Asynchronous exception behavior, Security Extensions only\"></a>Asynchronous exception behavior, Security Extensions only</h6><p>Fixme [Table B1-14 Behavior of asynchronous aborts, Virtualization Extensions not implemented] page1187</p>\n<p>Fixme [Table B1-15 Behavior of IRQ exceptions, Virtualization Extensions not implemented] page1188</p>\n<p>Fixme [Table B1-16 Behavior of FIQ exceptions, Virtualization Extensions not implemented] page1188</p>\n<h6 id=\"Asynchronous-exception-behavior-with-the-Virtualization-Extensions\"><a href=\"#Asynchronous-exception-behavior-with-the-Virtualization-Extensions\" class=\"headerlink\" title=\"Asynchronous exception behavior, with the Virtualization Extensions\"></a>Asynchronous exception behavior, with the Virtualization Extensions</h6><p>Fixme [Table B1-17 Behavior of asynchronous aborts, Virtualization Extensions implemented] page1189</p>\n<p>Fixme [Table B1-18 Behavior of IRQ exceptions, Virtualization Extensions implemented] page1190</p>\n<p>Fixme [Table B1-19 Behavior of FIQ exceptions, Virtualization Extensions implemented] page1191</p>\n<h5 id=\"B1-8-8-Routing-general-exceptions-to-Hyp-mode\"><a href=\"#B1-8-8-Routing-general-exceptions-to-Hyp-mode\" class=\"headerlink\" title=\"B1.8.8 Routing general exceptions to Hyp mode\"></a>B1.8.8 Routing general exceptions to Hyp mode</h5><p>When HCR.TGE is set to 1, and the processor is in Non-secure User mode, the following exceptions are taken to<br>Hyp mode, instead of to the default Non-secure mode for handling the exception:<br>• Undefined Instruction exceptions.<br>• Supervisor Call exceptions.<br>• Synchronous External aborts.<br>• Any Alignment fault other than an alignment fault caused by the memory type when SCTLR.M is 1.</p>\n<h5 id=\"B1-8-9-Routing-Debug-exceptions-to-Hyp-mode\"><a href=\"#B1-8-9-Routing-Debug-exceptions-to-Hyp-mode\" class=\"headerlink\" title=\"B1.8.9 Routing Debug exceptions to Hyp mode\"></a>B1.8.9 Routing Debug exceptions to Hyp mode</h5><p>When HDCR.TDE is set to 1, if the processor is executing in a Non-secure mode other than Hyp mode, any Debug<br>exception is routed to Hyp mode. This means it generates a Hyp Trap exception</p>\n<h5 id=\"B1-8-10-Exception-return\"><a href=\"#B1-8-10-Exception-return\" class=\"headerlink\" title=\"B1.8.10 Exception return\"></a>B1.8.10 Exception return</h5><p>On an exception return, the CPSR takes either:<br>• the value loaded by the RFE instruction<br>• if the exception return is not performed by executing an RFE instruction, the value of the current SPSR at the<br>time of the exception return</p>\n<h6 id=\"Return-from-an-exception-taken-to-a-PL1-mode\"><a href=\"#Return-from-an-exception-taken-to-a-PL1-mode\" class=\"headerlink\" title=\"Return from an exception taken to a PL1 mode\"></a>Return from an exception taken to a PL1 mode</h6><p>For an exception taken to a PL1 mode, the ARM architecture provides the following exception return instructions:<br>• <strong>Data-processing instructions with the S bit set and the PC as a destination</strong>, see SUBS PC, LR (Thumb) on<br>page B9-2010 and SUBS PC, LR and related instructions (ARM) on page B9-2012.<br>Typically:<br>    — a return where no subtraction is required uses SUBS with an operand of 0, or the equivalent MOVS<br>    instruction<br>    — a return requiring subtraction uses SUBS with a nonzero operand.</p>\n<p>• <strong>From ARMv6, the RFE instruction, see RFE</strong> on page B9-2000. If a subtraction is required, typically it is<br>performed before saving the LR value to memory.</p>\n<p>• <strong>In ARM state, a form of the LDM instruction</strong>, see LDM (exception return) on page B9-1986. If a subtraction is<br>required, typically it is performed before saving the LR value to memory.</p>\n<h6 id=\"Return-from-an-exception-taken-to-a-PL2-mode\"><a href=\"#Return-from-an-exception-taken-to-a-PL2-mode\" class=\"headerlink\" title=\"Return from an exception taken to a PL2 mode\"></a>Return from an exception taken to a PL2 mode</h6><p>For an exception taken to a PL2 mode, the ARM architecture provides the <strong>ERET</strong> instruction, see ERET on<br>page B9-1982. An exception handler executing in a PL2 mode must return using the ERET instruction.<br>Hyp mode is the only PL2 mode. Both Hyp mode and the ERET instruction are implemented only as part of the<br>Virtualization Extensions.</p>\n<h5 id=\"B1-8-11-Virtual-exceptions-in-the-Virtualization-Extensions\"><a href=\"#B1-8-11-Virtual-exceptions-in-the-Virtualization-Extensions\" class=\"headerlink\" title=\"B1.8.11 Virtual exceptions in the Virtualization Extensions\"></a>B1.8.11 Virtual exceptions in the Virtualization Extensions</h5><p>Fixme [Table B1-20 HCR bits controlling asynchronous exceptions] page1198</p>\n<h5 id=\"B1-8-12-Low-interrupt-latency-configuration\"><a href=\"#B1-8-12-Low-interrupt-latency-configuration\" class=\"headerlink\" title=\"B1.8.12 Low interrupt latency configuration\"></a>B1.8.12 Low interrupt latency configuration</h5><p>Setting SCTLR.FI to 1 enables the low interrupt latency configuration of an implementation. This configuration can<br>reduce the interrupt latency of the processor. The mechanisms implemented to achieve low interrupt latency are<br>IMPLEMENTATION DEFINED. For the description of the SCTLR see either:<br>• SCTLR, System Control Register, VMSA on page B4-1707<br>• SCTLR, System Control Register, PMSA on page B6-1932</p>\n<h5 id=\"B1-8-13-Wait-For-Event-and-Send-Event\"><a href=\"#B1-8-13-Wait-For-Event-and-Send-Event\" class=\"headerlink\" title=\"B1.8.13 Wait For Event and Send Event\"></a>B1.8.13 Wait For Event and Send Event</h5><p>ARMv7 and ARMv6K provide a mechanism, the Wait For Event mechanism, that permits a processor in a<br>multiprocessor system to request <strong>entry to a low-power state</strong>, and, if the request succeeds, to remain in that state until<br>it receives an event generated by a Send Event operation on another processor in the system.<br><strong>example using for spin-lock</strong></p>\n<p>The Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a<br>Non-secure PL1 or PL0 mode.</p>\n<h6 id=\"WFE-wake-up-events\"><a href=\"#WFE-wake-up-events\" class=\"headerlink\" title=\"WFE wake-up events\"></a>WFE wake-up events</h6><p>The following events are WFE wake-up events:<br>• the execution of an SEV instruction on any processor in the multiprocessor system<br>• a physical IRQ interrupt, unless masked by the CPSR.I bit<br>• a physical FIQ interrupt, unless masked by the CPSR.F bit<br>• a physical asynchronous abort, unless masked by the CPSR.A bit<br>• in Non-secure state in any mode other than Hyp mode:<br>    — when HCR.IMO is set to 1, a virtual IRQ interrupt, unless masked by the CPSR.I bit<br>    — when HCR.FMO is set to 1, a virtual FIQ interrupt, unless masked by the CPSR.F bit<br>    — when HCR.AMO is set to 1, a virtual asynchronous abort, unless masked by the CPSR.A bit<br>• an asynchronous debug event, if invasive debug is enabled and the debug event is permitted<br>• an event sent by the timer event stream, see Event streams on page B8-1964<br>• an event sent by some IMPLEMENTATION DEFINED mechanism.</p>\n<h6 id=\"The-Event-Register\"><a href=\"#The-Event-Register\" class=\"headerlink\" title=\"The Event Register\"></a>The Event Register</h6><p>The Event Register is <strong>a single bit register for each processor</strong>. When set, an event register indicates that an event has<br>occurred, since the register was last cleared</p>\n<p>The Event Register is set by:<br>• an SEV instruction<br>• an event sent by some IMPLEMENTATION DEFINED mechanism<br>• a debug event that causes entry into Debug state<br>• an exception return.</p>\n<h6 id=\"The-Send-Event-instruction\"><a href=\"#The-Send-Event-instruction\" class=\"headerlink\" title=\"The Send Event instruction\"></a>The Send Event instruction</h6><p><strong>The Send Event instruction, SEV, causes an event to be signaled to all processors in the multiprocessor system.</strong><br><strong>ARM recommends that software includes a DSB instruction before an SEV instruction</strong></p>\n<p>Execution of the Send Event instruction sets the Event Register. The Send Event instruction is available at all privilege levels</p>\n<h6 id=\"The-Wait-For-Event-instruction\"><a href=\"#The-Wait-For-Event-instruction\" class=\"headerlink\" title=\"The Wait For Event instruction\"></a>The Wait For Event instruction</h6><p>The action of the Wait For Event instruction depends on the state of the Event Register:<br>• If the Event Register is set, the instruction clears the register and completes immediately. Normally, if this<br>happens the software makes another attempt to claim the lock.</p>\n<p>• If the Event Register is clear the processor can suspend execution and enter a low-power state. It can remain<br>in that state until the processor detects a WFE wake-up event or a reset. When the processor detects a WFE<br>wake-up event, or earlier if the implementation chooses, the WFE instruction completes.</p>\n<p>The Wait For Event instruction, WFE, is available at all privilege levels,</p>\n<h5 id=\"B1-8-14-Wait-For-Interrupt\"><a href=\"#B1-8-14-Wait-For-Interrupt\" class=\"headerlink\" title=\"B1.8.14 Wait For Interrupt\"></a>B1.8.14 Wait For Interrupt</h5><p>When a processor issues a WFI instruction it can suspend execution and enter a low-power state.</p>\n<p>The Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a<br>Non-secure PL1 or PL0 mode.</p>\n<p>The processor can remain in the WFI low-power state until it is reset, or it detects one of the following WFI wake-up<br>events:<br>• a physical IRQ interrupt, regardless of the value of the CPSR.I bit<br>• a physical FIQ interrupt, regardless of the value of the CPSR.F bit<br>• a physical asynchronous abort, regardless of the value of the CPSR.A bit<br>• in Non-secure state in any mode other than Hyp mode:<br>    — when HCR.IMO is set to 1, a virtual IRQ interrupt, regardless of the value of the CPSR.I bit<br>    — when HCR.FMO is set to 1, a virtual FIQ interrupt, regardless of the value of the CPSR.F bit<br>    — when HCR.AMO is set to 1, a virtual asynchronous abort, regardless of the value of the CPSR.A bit<br>• an asynchronous debug event, when invasive debug is enabled and the debug event is permitted.</p>\n<p><strong>WFI wake-up events cannot be masked by the mask bits in the CPSR.</strong></p>\n<p><strong>Using WFI to indicate an idle state on bus interfaces</strong></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpuidle_overview.html\" target=\"_blank\" rel=\"noopener\">Linux cpuidle framework(1)_概述和软件架构</a></p>\n<h4 id=\"B1-9-Exception-descriptions\"><a href=\"#B1-9-Exception-descriptions\" class=\"headerlink\" title=\"B1.9 Exception descriptions\"></a>B1.9 Exception descriptions</h4><p>skip</p>\n<h4 id=\"B1-10-Coprocessors-and-system-control\"><a href=\"#B1-10-Coprocessors-and-system-control\" class=\"headerlink\" title=\"B1.10 Coprocessors and system control\"></a>B1.10 Coprocessors and system control</h4><p>The ARM architecture supports sixteen coprocessors, usually referred to as CP0 to CP15.<br>The architecture reserves two of these coprocessors, CP14 and CP15,<br>for configuration and control related to the architecture:<br>• CP14 is reserved for the configuration and control of:<br>    — debug features, see The CP14 debug register interface on page C6-2123<br>    — trace features, see the Embedded Trace Macrocell Architecture Specification and the CoreSight<br>    Program Flow Trace Architecture Specification<br>    — the Thumb Execution Environment, see Thumb Execution Environment on page B1-1240<br>    — direct Java bytecode execution, see Jazelle direct bytecode execution on page B1-1241.<br>• CP15 is called the System Control coprocessor, and is reserved for the control and configuration of the ARM<br>processor system, including architecture and feature identification.</p>\n<p>The implementation of the CP15 registers depends heavily on whether the ARMv7 implementation is:<br>• an ARMv7-A implementation with a Virtual Memory System Architecture (VMSA)<br>• an ARMv7-R implementation with a Protected Memory System Architecture (PMSA).<br>The implementation of the CP14 registers is generally similar in ARMv7-A and ARMv7-R implementation.</p>\n<p>Most CP14 and CP15 registers are accessible only from PL1 or higher. For possible accesses from PL0:<br>• The register descriptions in Chapter B4 System Control Registers in a VMSA implementation and Chapter B6<br>System Control Registers in a PMSA implementation indicate whether a register is accessible from PL0.<br>• The descriptions of the CP14 interface in Chapter C6 Debug Register Interfaces include the permitted<br>accesses to the debug registers from PL0.<br>• The following sections summarize the permitted accesses to CP15 registers from PL0:<br>    — for a VMSA implementation, PL0 views of the CP15 registers on page B3-1488<br>    — for a PMSA implementation, PL0 views of the CP15 registers on page B5-1797.</p>\n<h4 id=\"B1-11-Advanced-SIMD-and-floating-point-support\"><a href=\"#B1-11-Advanced-SIMD-and-floating-point-support\" class=\"headerlink\" title=\"B1.11 Advanced SIMD and floating-point support\"></a>B1.11 Advanced SIMD and floating-point support</h4><p>skip</p>\n<h4 id=\"B1-12-Thumb-Execution-Environment\"><a href=\"#B1-12-Thumb-Execution-Environment\" class=\"headerlink\" title=\"B1.12 Thumb Execution Environment\"></a>B1.12 Thumb Execution Environment</h4><p>skip</p>\n<h4 id=\"B1-13-Jazelle-direct-bytecode-execution\"><a href=\"#B1-13-Jazelle-direct-bytecode-execution\" class=\"headerlink\" title=\"B1.13 Jazelle direct bytecode execution\"></a>B1.13 Jazelle direct bytecode execution</h4><p>skip</p>\n<h4 id=\"B1-14-Traps-to-the-hypervisor\"><a href=\"#B1-14-Traps-to-the-hypervisor\" class=\"headerlink\" title=\"B1.14 Traps to the hypervisor\"></a>B1.14 Traps to the hypervisor</h4><h5 id=\"B1-14-1-General-information-about-traps-to-the-hypervisor\"><a href=\"#B1-14-1-General-information-about-traps-to-the-hypervisor\" class=\"headerlink\" title=\"B1.14.1 General information about traps to the hypervisor\"></a>B1.14.1 General information about traps to the hypervisor</h5><p>The Hyp Trap exception provides the standard mechanism for trapping Guest OS functions to the hypervisor.<br>and enters the exception handler using the vector at<br>offset 0x14 from the Hyp vector base address. For more information see Exception handling on page B1-1165</p>\n<p>A Hyp Trap exception can be generated only when all of the following apply:<br>• The processor is both:<br>    — not in Debug state<br>    — in a Non-secure PL1 or PL0 mode.<br>• Traps to Hyp mode never apply in Secure state, regardless of the value of the SCR.NS bit.    </p>\n<p>B1.14.2 Trapping ID mechanisms<br>For a small number of frequently-accessed ID registers, the Virtualization Extensions provide read/write aliases of<br>the registers, accessible only from Hyp mode, or from Secure state. A read of the original ID register from a<br>Non-secure PL1 mode actually returns the value of the read/write alias register.</p>\n<p>Fixme [Table B1-26 ID register substitution by the Virtualization Extensions] page1251</p>\n<p>Fixme [Table B1-27 ID register groups for Hyp Trap exceptions] page1252</p>\n<p>B1.14.17 Summary of trap controls</p>\n<p>Fixme [Table B1-29 Summary of Hyp trap controls] page1262</p>\n<h3 id=\"B2-Common-Memory-System-Architecture-Features\"><a href=\"#B2-Common-Memory-System-Architecture-Features\" class=\"headerlink\" title=\"B2 Common Memory System Architecture Features\"></a>B2 Common Memory System Architecture Features</h3><h4 id=\"B2-2-Caches-and-branch-predictors\"><a href=\"#B2-2-Caches-and-branch-predictors\" class=\"headerlink\" title=\"B2.2 Caches and branch predictors\"></a>B2.2 Caches and branch predictors</h4><h5 id=\"B2-2-1-Cache-identification\"><a href=\"#B2-2-1-Cache-identification\" class=\"headerlink\" title=\"B2.2.1 Cache identification\"></a>B2.2.1 Cache identification</h5><p>The ARMv7 cache identification consists of a set of registers that describe the implemented caches that are under<br>the control of the processor:<br>• A single Cache Type Register defines:<br>    — the <strong>minimum line length of any of the instruction caches</strong><br>    — the <strong>minimum line length of any of the data or unified caches</strong><br>    — the <strong>cache indexing and tagging policy of the Level 1 instruction cache.</strong><br>    For more information, see:<br>    — CTR, Cache Type Register, VMSA on page B4-1556, for a VMSA implementation<br>    — CTR, Cache Type Register, PMSA on page B6-1835, for a PMSA implementation.</p>\n<p>• A single Cache Level ID Register defines:<br>    — the <strong>type of cache implemented at a each cache level, up to the maximum of seven levels</strong><br>    — the Level of Coherence (LoC) for the caches<br>    — the Level of Unification (LoU) for the caches.<br>    For more information, see:<br>    — CLIDR, Cache Level ID Register, VMSA on page B4-1530, for a VMSA implementation<br>    — CLIDR, Cache Level ID Register, PMSA on page B6-1816, for a PMSA implementation</p>\n<p>• A single Cache Size Selection Register selects the cache level and cache type of the current Cache Size<br>Identification Register, see:<br>    — CSSELR, Cache Size Selection Register, VMSA on page B4-1555, for a VMSA implementation<br>    — CSSELR, Cache Size Selection Register, PMSA on page B6-1834, for a PMSA implementation.    </p>\n<p>• For each implemented cache, across all the levels of caching, a Cache Size Identification Register defines:<br>    — <strong>whether the cache supports Write-Through, Write-Back, Read-Allocate and Write-Allocate</strong><br>    — <strong>the number of sets, associativity and line length of the cache</strong><br>    For more information, see:<br>    — CCSIDR, Cache Size ID Registers, VMSA on page B4-1528, for a VMSA implementation<br>    — CCSIDR, Cache Size ID Registers, PMSA on page B6-1814, for a PMSA implementation.</p>\n<h6 id=\"Identifying-the-cache-resources-in-ARMv7\"><a href=\"#Identifying-the-cache-resources-in-ARMv7\" class=\"headerlink\" title=\"Identifying the cache resources in ARMv7\"></a>Identifying the cache resources in ARMv7</h6><p>In ARMv7 the architecture defines support for multiple levels of cache, up to a maximum of seven levels.<br>software must:</p>\n<ol>\n<li><p><strong>Read the Cache Type Register to find the indexing and tagging policy used for the Level 1 instruction cache.</strong><br>This register also provides the size of the smallest cache lines used for the instruction caches, and for the data<br>and unified caches. These values are used in cache maintenance operations.</p>\n</li>\n<li><p><strong>Read the Cache Level ID Register to find what caches are implemented</strong>. The register includes seven Cache<br>type fields, for cache levels 1 to 7. Scanning these fields, starting from Level 1, identifies the instruction, data<br>or unified caches implemented at each level. This scan ends when it reaches a level at which no caches are<br>defined. The Cache Level ID Register also provides the Level of Unification (LoU) and the Level of<br>Coherence (LoC) for the cache implementation.</p>\n</li>\n<li><p>For each cache identified at stage 2:<br>• <strong>Write to the Cache Size Selection Register to select the required cache.</strong> A cache is identified by its<br>level, and whether it is:<br> — an instruction cache<br> — a data or unified cache.<br>• Read the Cache Size ID Register to find details of the cache.</p>\n</li>\n</ol>\n<h5 id=\"B2-2-2-Cache-behavior\"><a href=\"#B2-2-2-Cache-behavior\" class=\"headerlink\" title=\"B2.2.2 Cache behavior\"></a>B2.2.2 Cache behavior</h5><h6 id=\"General-behavior-of-the-caches\"><a href=\"#General-behavior-of-the-caches\" class=\"headerlink\" title=\"General behavior of the caches\"></a>General behavior of the caches</h6><p>When a memory location is marked with a Normal Cacheable memory attribute, determining whether a copy of the<br>memory location is held in a cache still depends on many aspects of the implementation. The following<br>non-exhaustive list of factors might be involved:<br>• the size, line length, and associativity of the cache<br>• the cache allocation algorithm<br>• activity by other elements of the system that can access the memory<br>• speculative instruction fetching algorithms<br>• speculative data fetching algorithms<br>• interrupt behaviors.</p>\n<p>For the purpose of these principles, a cache entry covers at least 16 bytes and no more than 2KB of contiguous<br>address space, aligned to its size.</p>\n<h6 id=\"Behavior-of-the-caches-at-reset\"><a href=\"#Behavior-of-the-caches-at-reset\" class=\"headerlink\" title=\"Behavior of the caches at reset\"></a>Behavior of the caches at reset</h6><p>In ARMv7:<br>• All caches are disabled at reset.<br>• An implementation can require the use of a specific cache initialization routine to invalidate its storage array<br>before it is enabled.</p>\n<p>B2.2.3 Cache enabling and disabling<br>Levels of cache on page B2-1265 indicates that:<br>• In ARMv7 the architecture defines the control of multiple levels of cache.<br>• Before ARMv7 the architecture defines the control of only one level of cache.</p>\n<p>In ARMv7:<br>• SCTLR.C enables or disables all data and unified caches for data accesses, across all levels of cache visible<br>to the processor. It is IMPLEMENTATION DEFINED whether it also enables or disables the use of unified caches<br>for instruction accesses.<br>• SCTLR.I enables or disables all instruction caches, across all levels of cache visible to the processor.</p>\n<pre><code>- SCTLR, System Control Register, VMSA on page B4-1707, for a VMSA implementation\n- SCTLR, System Control Register, PMSA on page B6-1932, for a PMSA implementation.\n</code></pre><h5 id=\"B2-2-4-Branch-predictors\"><a href=\"#B2-2-4-Branch-predictors\" class=\"headerlink\" title=\"B2.2.4 Branch predictors\"></a>B2.2.4 Branch predictors</h5><p>Branch predictor hardware typically uses a form of cache to hold branch information. The ARM architecture<br>permits this branch predictor hardware to be visible to software, and so the branch predictor is not architecturally<br>invisible. This means that under some circumstances software must perform branch predictor maintenance to avoid<br>incorrect execution caused by out-of-date entries in the branch predictor.</p>\n<h6 id=\"Requirements-for-branch-predictor-maintenance-operations\"><a href=\"#Requirements-for-branch-predictor-maintenance-operations\" class=\"headerlink\" title=\"Requirements for branch predictor maintenance operations\"></a>Requirements for branch predictor maintenance operations</h6><p>the instructions at the virtual addresses change:<br>• enabling or disabling the MMU<br>• writing new mappings to the translation tables<br>• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,<br>or a change to the VMID<br>• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID.</p>\n<p>then branch predictor maintenance operations must be performed to invalidate entries in the branch<br>predictor, to ensure that the change is visible to subsequent execution.</p>\n<h5 id=\"B2-2-6-About-ARMv7-cache-and-branch-predictor-maintenance-functionality\"><a href=\"#B2-2-6-About-ARMv7-cache-and-branch-predictor-maintenance-functionality\" class=\"headerlink\" title=\"B2.2.6 About ARMv7 cache and branch predictor maintenance functionality\"></a>B2.2.6 About ARMv7 cache and branch predictor maintenance functionality</h5><h6 id=\"Terms-used-in-describing-the-maintenance-operations\"><a href=\"#Terms-used-in-describing-the-maintenance-operations\" class=\"headerlink\" title=\"Terms used in describing the maintenance operations\"></a>Terms used in describing the maintenance operations</h6><p>• by the address of the memory location to be maintained, referred to as operating by MVA<br>• by a mechanism that describes the location in the hardware of the cache, referred to as operating by set/way.</p>\n<h6 id=\"Terminology-for-operations-by-MVA\"><a href=\"#Terminology-for-operations-by-MVA\" class=\"headerlink\" title=\"Terminology for operations by MVA\"></a>Terminology for operations by MVA</h6><p>The term Modified Virtual Address (MVA) relates to the Fast Context Switch Extension (FCSE) mechanism,described in Appendix D10 Fast Context Switch Extension (FCSE). When the FCSE is absent or disabled, the MVA and VA have the same value.</p>\n<p>Virtual addresses only exist in systems with a MMU. When no MMU is implemented, or all applicable MMUs are disabled, the MVA and VA are identical to the PA.</p>\n<h6 id=\"Terminology-for-operations-by-set-way\"><a href=\"#Terminology-for-operations-by-set-way\" class=\"headerlink\" title=\"Terminology for operations by set/way\"></a>Terminology for operations by set/way</h6><p>Cache maintenance operations by set/way refer to the particular structures in a cache.</p>\n<p><strong>Level</strong><br>The cache level of the hierarchy.</p>\n<p><strong>Set</strong><br>Each level of a cache is split up into a number of sets. Each set is a set of locations in a cache level to which an address can be assigned.</p>\n<p><strong>Way</strong><br>The Associativity of a cache defines the number of locations in a set to which an address can be assigned.</p>\n<h5 id=\"B2-2-7-Cache-and-branch-predictor-maintenance-operations\"><a href=\"#B2-2-7-Cache-and-branch-predictor-maintenance-operations\" class=\"headerlink\" title=\"B2.2.7 Cache and branch predictor maintenance operations\"></a>B2.2.7 Cache and branch predictor maintenance operations</h5><p>Cache and branch predictor maintenance operations are performed using accesses to CP15 c7. The following<br>sections define the encodings for these operations:<br>• Cache and branch predictor maintenance operations, VMSA on page B4-1743, for a VMSA implementation<br>• Cache and branch predictor maintenance operations, PMSA on page B6-1943, for a PMSA implementation.</p>\n<h6 id=\"Summary-of-cache-and-branch-predictor-maintenance-operations\"><a href=\"#Summary-of-cache-and-branch-predictor-maintenance-operations\" class=\"headerlink\" title=\"Summary of cache and branch predictor maintenance operations\"></a>Summary of cache and branch predictor maintenance operations</h6><p><strong>Data cache and unified cache operations</strong><br>Operations by MVA<br>The data and unified cache operations by MVA are:<br>DCIMVAC   Invalidate, to point of coherency.<br>DCCMVAC   Clean, to point of coherency.<br>DCCMVAU   Clean, to point of unification.<br>DCCIMVAC  Clean and invalidate, to point of coherency.</p>\n<p>Operations by set/way<br>The data and unified cache operations by set/way are:<br>DCISW     Invalidate.<br>DCCSW     Clean.<br>DCCISW    Clean and invalidate, to point of coherency.</p>\n<p><strong>Instruction cache operations</strong><br>Operation by MVA<br>ICIMVAU     Invalidate, to point of unification.</p>\n<p>Operations on all entries<br>The instruction cache operations that operate on all entries are:<br>ICIALLU     Invalidate all, to point of unification.<br>ICIALLUIS     Invalidate all, to point of unification, Inner Shareable.</p>\n<p><strong>Branch predictor operations</strong><br>Operation by MVA<br>BPIMVA     Invalidate.</p>\n<p>Operations on all entries<br>BPIALL         Invalidate all.<br>BPIALLIS     Invalidate all, Inner Shareable.</p>\n<h3 id=\"B3-Virtual-Memory-System-Architecture-VMSA\"><a href=\"#B3-Virtual-Memory-System-Architecture-VMSA\" class=\"headerlink\" title=\"B3 Virtual Memory System Architecture (VMSA)\"></a>B3 Virtual Memory System Architecture (VMSA)</h3><h4 id=\"B3-1-About-the-VMSA\"><a href=\"#B3-1-About-the-VMSA\" class=\"headerlink\" title=\"B3.1 About the VMSA\"></a>B3.1 About the VMSA</h4><p>In VMSAv7, a Memory Management Unit (MMU) controls address translation, access permissions, and memory<br>attribute determination and checking.</p>\n<p>Each supported stage of memory system control is provided by an MMU, with its own independent set of controls.<br>Therefore, the Extended VMSAv7 provides the following MMUs:<br>• Secure PL1&amp;0 stage 1 MMU<br>• Non-secure PL2 stage 1 MMU<br>• Non-secure PL1&amp;0 stage 1 MMU<br>• Non-secure PL1&amp;0 stage 2 MMU.</p>\n<p>Fixme [Figure B3-1 VMSA translation regimes, and associated MMUs]page1309</p>\n<h5 id=\"B3-1-1-Address-types-used-in-a-VMSA-description\"><a href=\"#B3-1-1-Address-types-used-in-a-VMSA-description\" class=\"headerlink\" title=\"B3.1.1 Address types used in a VMSA description\"></a>B3.1.1 Address types used in a VMSA description</h5><h6 id=\"Virtual-Address-VA\"><a href=\"#Virtual-Address-VA\" class=\"headerlink\" title=\"Virtual Address (VA)\"></a>Virtual Address (VA)</h6><p>An address used in an instruction, as a data or instruction address, is a Virtual Address (VA).<br><strong>An address held in the PC, LR, or SP, is a VA.</strong></p>\n<h6 id=\"Modified-Virtual-Address-MVA\"><a href=\"#Modified-Virtual-Address-MVA\" class=\"headerlink\" title=\"Modified Virtual Address (MVA)\"></a>Modified Virtual Address (MVA)</h6><p>On an implementation that implements and uses the FCSE(Appendix D10 Fast Context Switch Extension (FCSE)), the FCSE takes a VA and transforms it to an MVA. </p>\n<h6 id=\"Intermediate-Physical-Address-IPA\"><a href=\"#Intermediate-Physical-Address-IPA\" class=\"headerlink\" title=\"Intermediate Physical Address (IPA)\"></a>Intermediate Physical Address (IPA)</h6><p>In a translation regime that provides two stages of address translation, the IPA is the address after<br>the stage 1 translation, and is the input address for the stage 2 translation.</p>\n<h6 id=\"Physical-Address-PA\"><a href=\"#Physical-Address-PA\" class=\"headerlink\" title=\"Physical Address (PA)\"></a>Physical Address (PA)</h6><h5 id=\"B3-1-2-Address-spaces-in-a-VMSA-implementation\"><a href=\"#B3-1-2-Address-spaces-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.1.2 Address spaces in a VMSA implementation\"></a>B3.1.2 Address spaces in a VMSA implementation</h5><p>The ARMv7 architecture supports:<br>• A VA address space of up to 32 bits. The actual width is IMPLEMENTATION DEFINED.<br>• An IPA address space of up to 40 bits. The translation tables and associated system control registers define the width of the implemented address space.</p>\n<p>Note:</p>\n<blockquote>\n<p>The Large Physical Address Extension defines two translation table formats. The Long-descriptor format gives access to the full 40-bit IPA or PA address space at a granularity of 4KB. The Short-descriptor format:<br>• Gives access to a 32-bit PA address space at 4KB granularity.<br>• Optionally, gives access to a 40-bit PA address space, but only at 16MB granularity.</p>\n</blockquote>\n<p>If an implementation includes the Security Extensions, <strong>the address maps are defined independently for Secure and Non-secure operation, providing two independent 40-bit address spaces</strong>, where:<br>• a VA accessed from Non-secure state can only be translated to the Non-secure address map<br>• a VA accessed from Secure state can be translated to either the Secure or the Non-secure address map.</p>\n<h5 id=\"B3-1-3-About-address-translation\"><a href=\"#B3-1-3-About-address-translation\" class=\"headerlink\" title=\"B3.1.3 About address translation\"></a>B3.1.3 About address translation</h5><h5 id=\"B3-1-3-1-VMSAv7-without-the-Security-Extensions\"><a href=\"#B3-1-3-1-VMSAv7-without-the-Security-Extensions\" class=\"headerlink\" title=\"B3.1.3.1. VMSAv7 without the Security Extensions\"></a>B3.1.3.1. VMSAv7 without the Security Extensions</h5><p>Supports only a single PL1&amp;0 stage 1 MMU. Operation of this MMU can be split between two sets of translation tables, defined by TTBR0 and TTBR1, and controlled by TTBCR.</p>\n<h5 id=\"B3-1-3-2-VMSAv7-with-the-Security-Extensions-but-without-the-Virtualization-Extensions\"><a href=\"#B3-1-3-2-VMSAv7-with-the-Security-Extensions-but-without-the-Virtualization-Extensions\" class=\"headerlink\" title=\"B3.1.3.2. VMSAv7 with the Security Extensions but without the Virtualization Extensions\"></a>B3.1.3.2. VMSAv7 with the Security Extensions but without the Virtualization Extensions</h5><p>Supports only the Secure PL1&amp;0 stage 1 MMU and the Non-secure PL1&amp;0 stage 1 MMU.</p>\n<p>Operation of each of these MMUs can be split between two sets of translation tables, <strong>defined by the Secure and Non-secure copies of TTBR0 and TTBR1, and controlled by the Secure and Non-secure copies of TTBCR.</strong></p>\n<p><strong>Note</strong>: Secure and Non-secure has copies of TTBR0 and TTBR1, TTBCR.</p>\n<h5 id=\"B3-1-3-3-VMSAv7-with-Virtualization-Extensions\"><a href=\"#B3-1-3-3-VMSAv7-with-Virtualization-Extensions\" class=\"headerlink\" title=\"B3.1.3.3. VMSAv7 with Virtualization Extensions\"></a>B3.1.3.3. VMSAv7 with Virtualization Extensions</h5><p><strong>Secure PL1&amp;0 stage 1 MMU</strong><br>Operation of this MMU can be split between two sets of translation tables, defined by the Secure copies of TTBR0 and TTBR1, and controlled by the Secure copy of TTBCR.</p>\n<p><strong>Non-secure PL2 stage 1 MMU</strong><br>The HTTBR defines the translation table for this MMU, controlled by HTCR.</p>\n<p><strong>Non-secure PL1&amp;0 stage 1 MMU</strong><br>Operation of this MMU can be split between two sets of translation tables, defined by the Non-secure copies of TTBR0 and TTBR1 and controlled by the Non-secure copy of TTBCR.</p>\n<p><strong>Non-secure PL1&amp;0 stage 2 control</strong><br>The VTTBR defines the translation table for this MMU, controlled by VTCR.</p>\n<p>Fixme [Figure B3-2 Memory translation summary, with Virtualization Extensions]Page 1312</p>\n<p>A full translation table lookup is called a translation table walk.It is performed automatically by hardware.</p>\n<p><strong>Translation Lookaside Buffers (TLBs)</strong> reduce the average cost of a memory access by caching the results of translation table walks.</p>\n<p>To reduce the software overhead of TLB maintenance, the VMSA distinguishes between Global pages and Process-specific pages. The <strong>Address Space Identifier (ASID)</strong> identifies pages associated with <strong>a specific process</strong> and provides a mechanism for changing process-specific tables without having to maintain the TLB tructures.</p>\n<p>If an implementation includes the Virtualization Extensions, the <strong>virtual machine identifier (VMID)</strong> identifies the current virtual machine, with its own independent ASID space.</p>\n<h4 id=\"B3-2-The-effects-of-disabling-MMUs-on-VMSA-behavior\"><a href=\"#B3-2-The-effects-of-disabling-MMUs-on-VMSA-behavior\" class=\"headerlink\" title=\"B3.2 The effects of disabling MMUs on VMSA behavior\"></a>B3.2 The effects of disabling MMUs on VMSA behavior</h4><p>About the VMSA on page B3-1308 defines the translation regimes and the associated MMUs. The VMSA includes<br>an enable bit for each MMU, as follows:<br>• SCTLR.M, in the Secure copy of the register, controls Secure PL1&amp;0 stage 1 MMU<br>• SCTLR.M, in the Non-secure copy of the register, controls Non-secure PL1&amp;0 stage 1 MMU<br>• HCR.VM controls Non-secure PL1&amp;0 stage 2 MMU<br>• HSCTLR.M controls Non-secure PL2 stage 1 MMU.</p>\n<h5 id=\"B3-2-1-VMSA-behavior-when-a-stage-1-MMU-is-disabled\"><a href=\"#B3-2-1-VMSA-behavior-when-a-stage-1-MMU-is-disabled\" class=\"headerlink\" title=\"B3.2.1 VMSA behavior when a stage 1 MMU is disabled\"></a>B3.2.1 VMSA behavior when a stage 1 MMU is disabled</h5><h6 id=\"Non-secure-PL1-and-PL0-accesses-when-HCR-DC-is-set-to-1-Virtualization-Extensions\"><a href=\"#Non-secure-PL1-and-PL0-accesses-when-HCR-DC-is-set-to-1-Virtualization-Extensions\" class=\"headerlink\" title=\"Non-secure PL1 and PL0 accesses when HCR.DC is set to 1, Virtualization Extensions\"></a>Non-secure PL1 and PL0 accesses when HCR.DC is set to 1, Virtualization Extensions</h6><p>In an implementation that includes the Virtualization Extensions, for an access from a Non-secure PL1 or PL0 mode when HCR.DC is set to 1, the stage 1 translation assigns the Normal Non-shareable, Inner Write-Back Write-Allocate, Outer Write-Back Write-Allocate memory attributes.</p>\n<h6 id=\"All-other-accesses\"><a href=\"#All-other-accesses\" class=\"headerlink\" title=\"All other accesses\"></a>All other accesses</h6><p><strong>Data access</strong><br>The stage 1 translation assigns the Strongly-Ordered memory type.</p>\n<p>Note<br>This means the access is Non-cacheable. Unexpected data cache hit behavior is IMPLEMENTATION DEFINED.</p>\n<p><strong>Instruction access</strong><br>The stage 1 translation assigns Normal memory attribute, with the cacheability and<br>shareability attributes determined by the value of:<br>• the Secure copy of SCTLR.I for the Secure PL1&amp;0 translation regime<br>• the Non-secure copy of SCTLR.I for the Non-secure PL1&amp;0 translation regime<br>• HSCTLR.I for the Non-secure PL2 translation regime.</p>\n<h5 id=\"B3-2-2-VMSA-behavior-when-the-stage-2-MMU-is-disabled\"><a href=\"#B3-2-2-VMSA-behavior-when-the-stage-2-MMU-is-disabled\" class=\"headerlink\" title=\"B3.2.2 VMSA behavior when the stage 2 MMU is disabled\"></a>B3.2.2 VMSA behavior when the stage 2 MMU is disabled</h5><p>When the stage 2 MMU is disabled:<br>• the IPA output from the stage 1 translation maps <strong>flat to the PA</strong><br>• the memory attributes and permissions from the stage 1 translation apply to the PA.</p>\n<p>If the stage 1 MMU and the stage 2 MMU are both disabled, see Behavior of instruction fetches when all associated<br>MMUs are disabled.</p>\n<h4 id=\"B3-3-Translation-tables\"><a href=\"#B3-3-Translation-tables\" class=\"headerlink\" title=\"B3.3 Translation tables\"></a>B3.3 Translation tables</h4><p>VMSAv7 defines two alternative translation table formats:</p>\n<p><strong>Short-descriptor format</strong><br>This is the original format defined in issue A of this Architecture Reference Manual, and is the only format supported on implementations that do not include the Large Physical Address Extension. It uses 32-bit descriptor entries in the translation tables, and provides:<br>• <strong>Up to two levels of address lookup.</strong><br>• <strong>32-bit input addresses.</strong><br>• <strong>Output addresses of up to 40 bits.</strong><br>• Support for PAs of more than 32 bits by use of supersections, with 16MB granularity.<br>• Support for No access, Client, and Manager domains.<br>• <strong>32-bit table entries.</strong></p>\n<p><strong>Long-descriptor format</strong><br>The Large Physical Address Extension adds support for this format. It uses 64-bit descriptor entries in the translation tables, and provides:<br>• <strong>Up to three levels of address lookup.</strong><br>• <strong>Input addresses of up to 40 bits, when used for stage 2 translations.</strong><br>• <strong>Output addresses of up to 40 bits.</strong><br>• 4KB assignment granularity across the entire PA range.<br>• No support for domains, all memory regions are treated as in a Client domain.<br>• <strong>64-bit table entries.</strong><br>• Fixed 4KB table size, unless truncated by the size of the input address space.</p>\n<p>The Large Physical Address Extension is an OPTIONAL extension, but an implementation that includes the Virtualization Extensions must also include the Large Physical Address Extension.</p>\n<h5 id=\"B3-3-1-Translation-table-walks\"><a href=\"#B3-3-1-Translation-table-walks\" class=\"headerlink\" title=\"B3.3.1 Translation table walks\"></a>B3.3.1 Translation table walks</h5><p>A translation table walk occurs as the result of a TLB miss, and starts with a read of the appropriate starting-level<br>translation table.</p>\n<p>The physical address of the base of the starting-level translation table is determined from the appropriate Translation<br>table base register (TTBR).</p>\n<h5 id=\"B3-3-2-Information-returned-by-a-translation-table-lookup\"><a href=\"#B3-3-2-Information-returned-by-a-translation-table-lookup\" class=\"headerlink\" title=\"B3.3.2 Information returned by a translation table lookup\"></a>B3.3.2 Information returned by a translation table lookup</h5><p>If the required translation table descriptor is not held in a TLB, a translation table walk is performed to obtain the descriptor. A lookup, whether from the TLB or as the result of a translation table walk, returns both:<br>• an output address that corresponds to the input address for the lookup<br>• a set of properties that correspond to that output address.</p>\n<p>The returned properties are classified as providing <strong>address map control, access controls, or region attributes.</strong></p>\n<h5 id=\"B3-3-3-Determining-the-translation-table-base-address\"><a href=\"#B3-3-3-Determining-the-translation-table-base-address\" class=\"headerlink\" title=\"B3.3.3 Determining the translation table base address\"></a>B3.3.3 Determining the translation table base address</h5><p>Fixme[Figure B3-2 Memory translation summary, with Virtualization Extensions]page1312</p>\n<h5 id=\"B3-3-4-Security-Extensions-control-of-translation-table-walks\"><a href=\"#B3-3-4-Security-Extensions-control-of-translation-table-walks\" class=\"headerlink\" title=\"B3.3.4 Security Extensions control of translation table walks\"></a>B3.3.4 Security Extensions control of translation table walks</h5><p>When an implementation includes the Security Extensions, two bits in the TTBCR for the current security state<br>control whether a translation table walk is performed on a TLB miss. These two bits are the:<br>• PD0 and PD1 bits, on a processor using the Short-descriptor translation table format<br>• EPD0 and EPD1 bits, on a processor using the Long-descriptor translation table format.</p>\n<p>The effect of these bits is:<br>{E}PDx == 0 If a TLB miss occurs based on TTBRx, a translation table walk is performed. The current security<br>state determines whether the memory access is Secure or Non-secure.<br>{E}PDx == 1 If a TLB miss occurs based on TTBRx, a First level Translation fault is returned, and no translation<br>table walk is performed.</p>\n<h5 id=\"B3-3-5-Access-to-the-Secure-or-Non-secure-physical-address-map\"><a href=\"#B3-3-5-Access-to-the-Secure-or-Non-secure-physical-address-map\" class=\"headerlink\" title=\"B3.3.5 Access to the Secure or Non-secure physical address map\"></a>B3.3.5 Access to the Secure or Non-secure physical address map</h5><p>As stated in Address spaces in a VMSA implementation on page B3-1311, a processor that implements the Security<br>Extensions implements independent Secure and Non-secure address maps. These are defined by the translation<br>tables identified by the Secure TTBR0 and TTBR1. In both translation table formats:<br>• In the Secure translation tables, the NS bit in a descriptor indicates whether the descriptor refers to the Secure<br>or the Non-secure address map:<br>NS == 0 Access the Secure physical address space.<br>NS == 1 Access the Non-secure physical address space.</p>\n<h4 id=\"B3-5-Short-descriptor-translation-table-format\"><a href=\"#B3-5-Short-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.5 Short-descriptor translation table format\"></a>B3.5 Short-descriptor translation table format</h4><p>The Short-descriptor translation table format supports a memory map based on memory sections or pages:<br><strong>Supersections</strong><br>Consist of 16MB blocks of memory. Support for Supersections is optional, except that an<br>implementation that includes the Large Physical Address Extension and supports more that 32 bits<br>of Physical Address must also support Supersections to provide access to the entire Physical<br>Address space.</p>\n<p><strong>Sections</strong><br>Consist of 1MB blocks of memory.</p>\n<p><strong>Large pages</strong><br>Consist of 64KB blocks of memory.</p>\n<p><strong>Small pages</strong><br>Consist of 4KB blocks of memory.</p>\n<p>When using the Short-descriptor translation table format, two levels of translation tables are held in memory: </p>\n<ul>\n<li>First-level table  </li>\n<li>Second-level tables  </li>\n</ul>\n<p>In the translation tables, in general, a descriptor is one of:<br>• an invalid or fault entry<br>• a page table entry, that points to a next-level translation table<br>• a page or section entry, that defines the memory properties for the access<br>• a reserved format.<br>Bits[1:0] of the descriptor give the primary indication of the descriptor type.</p>\n<p>Fixme[Figure B3-3 General view of address translation using Short-descriptor format translation tables] Page 1325</p>\n<h5 id=\"B3-5-1-Short-descriptor-translation-table-format-descriptors\"><a href=\"#B3-5-1-Short-descriptor-translation-table-format-descriptors\" class=\"headerlink\" title=\"B3.5.1 Short-descriptor translation table format descriptors\"></a>B3.5.1 Short-descriptor translation table format descriptors</h5><h6 id=\"Short-descriptor-translation-table-first-level-descriptor-formats\"><a href=\"#Short-descriptor-translation-table-first-level-descriptor-formats\" class=\"headerlink\" title=\"Short-descriptor translation table first-level descriptor formats\"></a>Short-descriptor translation table first-level descriptor formats</h6><p>Fixme [Figure B3-4 Short-descriptor first-level descriptor formats] Page1326</p>\n<p>Descriptor bits[1:0] identify the descriptor type.</p>\n<h6 id=\"Short-descriptor-translation-table-second-level-descriptor-formats\"><a href=\"#Short-descriptor-translation-table-second-level-descriptor-formats\" class=\"headerlink\" title=\"Short-descriptor translation table second-level descriptor formats\"></a>Short-descriptor translation table second-level descriptor formats</h6><p>Fixme [Figure B3-5 Short-descriptor second-level descriptor formats] Page1327</p>\n<h5 id=\"B3-5-2-Memory-attributes-in-the-Short-descriptor-translation-table-format-descriptors\"><a href=\"#B3-5-2-Memory-attributes-in-the-Short-descriptor-translation-table-format-descriptors\" class=\"headerlink\" title=\"B3.5.2 Memory attributes in the Short-descriptor translation table format descriptors\"></a>B3.5.2 Memory attributes in the Short-descriptor translation table format descriptors</h5><p><strong>TEX[2:0], C, B</strong><br>Memory region attribute bits, see Memory region attributes on page B3-1366.<br>These bits are not present in a Page table entry</p>\n<p><strong>XN bit</strong><br>The Execute-never bit. Determines whether the processor can execute software from the addressed<br>region, see Execute-never restrictions on instruction fetching on page B3-1359.<br>This bit is not present in a Page table entry.</p>\n<p><strong>PXN bit, when supported</strong><br>The Privileged execute-never bit:<br>• On an implementation that does not include the Large Physical Address Extension, support<br>for the PXN bit in the Short-descriptor translation table format is OPTIONAL.<br>• On an implementation that includes the Large Physical Address Extension, the<br>Short-descriptor translation table format must include the PXN bit.</p>\n<p><strong>NS bit</strong><br>Non-secure bit. If an implementation includes the Security Extensions, for memory accesses from<br>Secure state, this bit specifies whether the translated PA is in the Secure or Non-secure address map</p>\n<p><strong>Domain</strong><br>Domain field, see Domains, Short-descriptor format only on page B3-1362.<br>Page table descriptor applies to all entries in the corresponding second-level translation table.</p>\n<p><strong>AP[2], AP[1:0]</strong><br>Access Permissions bits, see Memory access control on page B3-1356</p>\n<p><strong>S bit</strong><br>The Shareable bit.</p>\n<p><strong>nG bit</strong><br>The not global bit. Determines how the translation is marked in the TLB, see Global and<br>process-specific translation table entries on page B3-1378.</p>\n<h5 id=\"B3-5-4-Selecting-between-TTBR0-and-TTBR1-Short-descriptor-translation-table-format\"><a href=\"#B3-5-4-Selecting-between-TTBR0-and-TTBR1-Short-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.5.4 Selecting between TTBR0 and TTBR1, Short-descriptor translation table format\"></a>B3.5.4 Selecting between TTBR0 and TTBR1, Short-descriptor translation table format</h5><p>the value of TTBCR.N indicates the number of most significant bits of the input VA that determine whether TTBR0 or TTBR1 :<br>• If N == 0 then use TTBR0. Setting TTBCR.N to zero disables use of a second set of translation tables.<br>• if N &gt; 0 then:<br>    — if bits[31:32-N] of the input VA are all zero then use TTBR0<br>    — otherwise use TTBR1.</p>\n<p>Fixme [Table B3-1 Effect of TTBCR.N on address translation, Short-descriptor format] page1330<br>Whenever TTBCR.N is nonzero, the size of the translation table addressed by TTBR1 is 16KB.</p>\n<p>Fixme [Figure B3-6 How TTBCR.N controls the boundary between the TTBRs, Short-descriptor format] page1331</p>\n<h5 id=\"B3-5-5-Translation-table-walks-when-using-the-Short-descriptor-translation-table-format\"><a href=\"#B3-5-5-Translation-table-walks-when-using-the-Short-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.5.5 Translation table walks, when using the Short-descriptor translation table format\"></a>B3.5.5 Translation table walks, when using the Short-descriptor translation table format</h5><h6 id=\"Reading-a-first-level-translation-table\"><a href=\"#Reading-a-first-level-translation-table\" class=\"headerlink\" title=\"Reading a first-level translation table\"></a>Reading a first-level translation table</h6><p>Fixme [Figure B3-7 Accessing first-level translation table based on TTBR0, Short-descriptor format] page1332</p>\n<h6 id=\"The-full-translation-flow-for-Sections-Supersections-Small-pages-and-Large-pages\"><a href=\"#The-full-translation-flow-for-Sections-Supersections-Small-pages-and-Large-pages\" class=\"headerlink\" title=\"The full translation flow for Sections, Supersections, Small pages and Large pages\"></a>The full translation flow for Sections, Supersections, Small pages and Large pages</h6><p>Fixme [Figure B3-11 Small page address translation] page1337</p>\n<h4 id=\"B3-6-Long-descriptor-translation-table-format\"><a href=\"#B3-6-Long-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.6 Long-descriptor translation table format\"></a>B3.6 Long-descriptor translation table format</h4><p>Fixme [Figure B3-12 General view of stage 1 address translation using Long-descriptor format]page1338</p>\n<h5 id=\"B3-6-1-Long-descriptor-translation-table-format-descriptors\"><a href=\"#B3-6-1-Long-descriptor-translation-table-format-descriptors\" class=\"headerlink\" title=\"B3.6.1 Long-descriptor translation table format descriptors\"></a>B3.6.1 Long-descriptor translation table format descriptors</h5><p>In general, a descriptor is one of:<br>• an invalid or fault entry<br>• a table entry, that points to the next-level translation table<br>• a block entry, that defines the memory properties for the access<br>• a reserved format.</p>\n<h6 id=\"Long-descriptor-translation-table-first-level-and-second-level-descriptor-formats\"><a href=\"#Long-descriptor-translation-table-first-level-and-second-level-descriptor-formats\" class=\"headerlink\" title=\"Long-descriptor translation table first-level and second-level descriptor formats\"></a>Long-descriptor translation table first-level and second-level descriptor formats</h6><p>Fixme [Figure B3-14 Long-descriptor first-level and second-level descriptor formats]page1340</p>\n<h6 id=\"Long-descriptor-translation-table-third-level-descriptor-formats\"><a href=\"#Long-descriptor-translation-table-third-level-descriptor-formats\" class=\"headerlink\" title=\"Long-descriptor translation table third-level descriptor formats\"></a>Long-descriptor translation table third-level descriptor formats</h6><p>Fixme [Figure B3-15 Long-descriptor third-level descriptor formats]page1341</p>\n<h5 id=\"B3-6-3-Control-of-Secure-or-Non-secure-memory-access-Long-descriptor-format\"><a href=\"#B3-6-3-Control-of-Secure-or-Non-secure-memory-access-Long-descriptor-format\" class=\"headerlink\" title=\"B3.6.3 Control of Secure or Non-secure memory access, Long-descriptor format\"></a>B3.6.3 Control of Secure or Non-secure memory access, Long-descriptor format</h5><p>In the Long-descriptor format:<br>• the NS bit relates only to the memory block or page at the output address defined by the descriptor<br>• the descriptors also include an NSTable bit, see Hierarchical control of Secure or Non-secure memory<br>accesses, Long-descriptor format.</p>\n<p>NSTable == 0 The defined table address is in the Secure physical address space.<br>NSTable == 1 The defined table address is in the Non-secure physical address space.</p>\n<h5 id=\"B3-6-4-Selecting-between-TTBR0-and-TTBR1-Long-descriptor-translation-table-format\"><a href=\"#B3-6-4-Selecting-between-TTBR0-and-TTBR1-Long-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.6.4 Selecting between TTBR0 and TTBR1, Long-descriptor translation table format\"></a>B3.6.4 Selecting between TTBR0 and TTBR1, Long-descriptor translation table format</h5><p>The TTBCR.T0SZ and TTBCR.T1SZ size fields control the use of TTBR0 and TTBR1,</p>\n<p>Fixme [Table B3-2 Use of TTBR0 and TTBR1, Long-descriptor format]page1345</p>\n<p>Fixme [Figure B3-18 Control of TTBR boundary, when TTBCR.T1SZ is zero]page1346</p>\n<h5 id=\"B3-6-5-Long-descriptor-translation-table-format-address-lookup-levels\"><a href=\"#B3-6-5-Long-descriptor-translation-table-format-address-lookup-levels\" class=\"headerlink\" title=\"B3.6.5 Long-descriptor translation table format address lookup levels\"></a>B3.6.5 Long-descriptor translation table format address lookup levels</h5><p>Fixme [Table B3-3 Properties of the three levels of address lookup with Long-descriptor translation tables]page1348</p>\n<h5 id=\"B3-6-6-Translation-table-walks-when-using-the-Long-descriptor-translation-table-format\"><a href=\"#B3-6-6-Translation-table-walks-when-using-the-Long-descriptor-translation-table-format\" class=\"headerlink\" title=\"B3.6.6 Translation table walks, when using the Long-descriptor translation table format\"></a>B3.6.6 Translation table walks, when using the Long-descriptor translation table format</h5><p>Example Full translation flow, starting at second-level lookup<br>Fixme [Figure B3-22 Complete Long-descriptor format stage 1 translation, starting at second level]page1355</p>\n<h3 id=\"B3-7-Memory-access-control\"><a href=\"#B3-7-Memory-access-control\" class=\"headerlink\" title=\"B3.7 Memory access control\"></a>B3.7 Memory access control</h3><p>In addition to an output address, a translation table entry that refers to page or region of memory includes fields that<br>define properties of the target memory region.</p>\n<h5 id=\"B3-7-1-Access-permissions\"><a href=\"#B3-7-1-Access-permissions\" class=\"headerlink\" title=\"B3.7.1 Access permissions\"></a>B3.7.1 Access permissions</h5><p>Access permission bits in a translation table descriptor control access to the corresponding memory region. The<br>Short-descriptor translation table format supports two options for defining the access permissions:<br>• three bits, AP[2:0], define the access permissions<br>• two bits, AP[2:1], define the access permissions, and AP[0] can be used as an Access flag.</p>\n<p>SCTLR.AFE selects the access permissions option. Setting this bit to 1, to enable the Access flag, also selects use<br>of AP[2:1] to define access permissions</p>\n<p>The Long-descriptor translation table format uses only AP[2:1] to control the access permissions, and provides an<br>AF bit for use as an Access flag</p>\n<h6 id=\"AP-2-1-access-permissions-model\"><a href=\"#AP-2-1-access-permissions-model\" class=\"headerlink\" title=\"AP[2:1] access permissions model\"></a>AP[2:1] access permissions model</h6><p>Fixme [Table B3-6 VMSAv7 AP[2:1] access permissions model]page1357</p>\n<h6 id=\"AP-2-0-access-permissions-control-Short-descriptor-format-only\"><a href=\"#AP-2-0-access-permissions-control-Short-descriptor-format-only\" class=\"headerlink\" title=\"AP[2:0] access permissions control, Short-descriptor format only\"></a>AP[2:0] access permissions control, Short-descriptor format only</h6><p>Fixme [Table B3-8 VMSAv7 MMU access permissions]page1358</p>\n<h5 id=\"B3-7-2-Execute-never-restrictions-on-instruction-fetching\"><a href=\"#B3-7-2-Execute-never-restrictions-on-instruction-fetching\" class=\"headerlink\" title=\"B3.7.2 Execute-never restrictions on instruction fetching\"></a>B3.7.2 Execute-never restrictions on instruction fetching</h5><p>Execute-never (XN) controls provide an additional level of control on memory accesses permitted by the access<br>permissions settings. </p>\n<p><strong>XN, Execute-never</strong><br>When the XN bit is 1, a Permission fault is generated if the processor attempts to execute an<br>instruction fetched from the corresponding memory region. </p>\n<p><strong>PXN, Privileged execute-never</strong><br>When the PXN bit is 1, a Permission fault is generated if the processor is executing at PL1 and<br>attempts to execute an instruction fetched from the corresponding memory region. </p>\n<h5 id=\"B3-7-3-Domains-Short-descriptor-format-only\"><a href=\"#B3-7-3-Domains-Short-descriptor-format-only\" class=\"headerlink\" title=\"B3.7.3 Domains, Short-descriptor format only\"></a>B3.7.3 Domains, Short-descriptor format only</h5><p>A domain is a collection of memory regions. The Short-descriptor translation table format supports 16 domains, and<br>requires the software that defines a translation table to assign each VMSA memory region to a domain. </p>\n<h5 id=\"B3-7-4-The-Access-flag\"><a href=\"#B3-7-4-The-Access-flag\" class=\"headerlink\" title=\"B3.7.4 The Access flag\"></a>B3.7.4 The Access flag</h5><p>The Access flag indicates when a page or section of memory is accessed for the first time since the Access flag in<br>the corresponding translation table descriptor was set to 0</p>\n<h5 id=\"B3-7-5-PL2-control-of-Non-secure-access-permissions\"><a href=\"#B3-7-5-PL2-control-of-Non-secure-access-permissions\" class=\"headerlink\" title=\"B3.7.5 PL2 control of Non-secure access permissions\"></a>B3.7.5 PL2 control of Non-secure access permissions</h5><p>Non-secure software executing at PL2 controls two sets of translation tables, both of which use the Long-descriptor<br>translation table format:<br>• The translation tables that control the Non-secure PL2 stage 1 translations. These map VAs to PAs, for<br>memory accesses made when executing in Non-secure state at PL2, and are indicated and controlled by the<br>HTTBR and HTCR.</p>\n<p>The HAP[2:1] field in the stage 2 descriptors define the stage 2 access permissions<br>Fixme [Table B3-9 Stage 2 control of access permissions]page1365</p>\n<h4 id=\"B3-8-Memory-region-attributes\"><a href=\"#B3-8-Memory-region-attributes\" class=\"headerlink\" title=\"B3.8 Memory region attributes\"></a>B3.8 Memory region attributes</h4><h5 id=\"B3-8-1-Overview-of-memory-region-attributes-for-stage-1-translations\"><a href=\"#B3-8-1-Overview-of-memory-region-attributes-for-stage-1-translations\" class=\"headerlink\" title=\"B3.8.1 Overview of memory region attributes for stage 1 translations\"></a>B3.8.1 Overview of memory region attributes for stage 1 translations</h5><p><strong>Memory type and attributes</strong><br>These are described either:<br>• Directly, by bits in the translation table descriptor.<br>• Indirectly, by registers referenced by bits in the table descriptor. This is described as<br>remapping the memory type and attribute description.</p>\n<p>The Short-descriptor translation table format can use either of these approaches, selected by the<br>SCTLR.TRE bit:<br>TRE == 0 Remap disabled. The TEX[2:0], C, and B bits in the translation table descriptor define<br>the memory region attributes. </p>\n<p>TRE == 1 Remap enabled. The TEX[0], C, and B bits in the translation table descriptor are index<br>bits to the MMU remap registers, that define the memory region attributes:<br>• the Primary Region Remap Register, PRRR<br>• the Normal Memory Remap Register, NMRR</p>\n<p>The Long-descriptor translation table format always uses remapping. </p>\n<p><strong>Shareability</strong><br>In the Short-descriptor translation table format, the S bit in the translation table descriptor encodes<br>whether the region is shareable. </p>\n<h5 id=\"B3-8-2-Short-descriptor-format-memory-region-attributes-without-TEX-remap\"><a href=\"#B3-8-2-Short-descriptor-format-memory-region-attributes-without-TEX-remap\" class=\"headerlink\" title=\"B3.8.2 Short-descriptor format memory region attributes, without TEX remap\"></a>B3.8.2 Short-descriptor format memory region attributes, without TEX remap</h5><p>Fixme [Table B3-10 TEX, C, and B encodings when TRE == 0]page1367</p>\n<p>Cacheable memory attributes, without TEX remap<br>When TEX[2] == 1, the translation table entry describes Cacheable memory, and the rest of the encoding defines<br>the Inner and Outer cache attributes:<br>TEX[1:0] Define the Outer cache attribute.<br>C, B Define the Inner cache attribute.</p>\n<p>Fixme [Table B3-11 Inner and Outer cache attribute encoding]page1368</p>\n<h5 id=\"B3-8-3-Short-descriptor-format-memory-region-attributes-with-TEX-remap\"><a href=\"#B3-8-3-Short-descriptor-format-memory-region-attributes-with-TEX-remap\" class=\"headerlink\" title=\"B3.8.3 Short-descriptor format memory region attributes, with TEX remap\"></a>B3.8.3 Short-descriptor format memory region attributes, with TEX remap</h5><p>• The software that defines the translation tables must program the PRRR and NMRR to define seven possible<br>memory region attributes.<br>• The TEX[0], C, and B bits of the translation table descriptors define the memory region attributes, by<br>indexing PRRR and NMRR.</p>\n<p>Fixme [Table B3-12 TEX, C, and B encodings when TRE == 1]page1369</p>\n<h5 id=\"B3-8-4-Long-descriptor-format-memory-region-attributes\"><a href=\"#B3-8-4-Long-descriptor-format-memory-region-attributes\" class=\"headerlink\" title=\"B3.8.4 Long-descriptor format memory region attributes\"></a>B3.8.4 Long-descriptor format memory region attributes</h5><p>the AttrIndx[2:0] field in a block or page translation table descriptor for a stage 1 translation indicates the 8-bit field in the appropriate MAIR, that specifies<br>the attributes for the corresponding memory region:<br>• AttrIndx[2] indicates the value of n in MAIRn:<br>AttrIndx[2] == 0 Use MAIR0.<br>AttrIndx[2] == 1 Use MAIR1</p>\n<p>• AttrIndx[2:0] indicates the required Attr field, Attrn, where n = AttrIndx[2:0].<br>Each AttrIndx field defines, for the corresponding memory region:<br>• The memory type, Strongly-ordered, Device, or Normal.<br>• For Normal memory<br>    — the inner and outer cacheability, Non-cacheable, Write-Through, or Write-Back<br>    — for Write-Through Cacheable and Write-Back Cacheable regions, the Read-Allocate and<br>    Write-Allocate policy hints, each of which is Allocate or Do not allocate</p>\n<h6 id=\"Shareability-Long-descriptor-format\"><a href=\"#Shareability-Long-descriptor-format\" class=\"headerlink\" title=\"Shareability, Long-descriptor format\"></a>Shareability, Long-descriptor format</h6><p>Fixme [Table B3-14 SH[1:0] field encoding for Normal memory, Long-descriptor format]page1373</p>\n<p>For a Device or Strongly-ordered memory region, the value of the SH[1:0] field of the translation table descriptor<br>is ignored.</p>\n<h4 id=\"B3-9-Translation-Lookaside-Buffers-TLBs\"><a href=\"#B3-9-Translation-Lookaside-Buffers-TLBs\" class=\"headerlink\" title=\"B3.9 Translation Lookaside Buffers (TLBs)\"></a>B3.9 Translation Lookaside Buffers (TLBs)</h4><p>Translation Lookaside Buffers (TLBs) are an implementation technique that caches translations or translation table entries.<br>TLBs avoid the requirement for every memory access to perform a translation table walk in memory. </p>\n<h5 id=\"B3-9-1-Global-and-process-specific-translation-table-entries\"><a href=\"#B3-9-1-Global-and-process-specific-translation-table-entries\" class=\"headerlink\" title=\"B3.9.1  Global and process-specific translation table entries\"></a>B3.9.1  Global and process-specific translation table entries</h5><p>In a VMSA implementation, system software can divide a virtual memory map used by memory accesses at PL1 and PL0 into global and non-global regions, indicated by the nG bit in the translation table descriptors:<br>nG == 0<br>The translation is global, meaning the region is available for all processes.</p>\n<p>nG == 1<br>The translation is non-global, or process-specific, meaning it relates to the current ASID, as defined by the CONTEXTIDR.</p>\n<h5 id=\"B3-9-2-TLB-matching\"><a href=\"#B3-9-2-TLB-matching\" class=\"headerlink\" title=\"B3.9.2  TLB matching\"></a>B3.9.2  TLB matching</h5><h5 id=\"B3-9-3-TLB-behavior-at-reset\"><a href=\"#B3-9-3-TLB-behavior-at-reset\" class=\"headerlink\" title=\"B3.9.3  TLB behavior at reset\"></a>B3.9.3  TLB behavior at reset</h5><p>The ARMv7 architecture does not require a reset to invalidate the TLB. All TLBs are disabled from reset. All MMUs are disabled from reset, and the contents of the TLBs have no effect on address translation.</p>\n<h5 id=\"B3-9-5-TLB-conflict-aborts\"><a href=\"#B3-9-5-TLB-conflict-aborts\" class=\"headerlink\" title=\"B3.9.5  TLB conflict aborts\"></a>B3.9.5  TLB conflict aborts</h5><p>The Large Physical Address Extension introduces the concept of a TLB conflict abort, and adds fault status encodings for such an abort.</p>\n<p>An implementation can generate a TLB conflict abort if it detects that the address being looked up in the TLB hits multiple entries.<br>In some implementations, multiple hits in the TLB can generate a synchronous Data Abort or Prefetch Abort exception.</p>\n<h4 id=\"B3-10-TLB-maintenance-requirements\"><a href=\"#B3-10-TLB-maintenance-requirements\" class=\"headerlink\" title=\"B3.10 TLB maintenance requirements\"></a>B3.10 TLB maintenance requirements</h4><h5 id=\"B3-10-1-General-TLB-maintenance-requirements\"><a href=\"#B3-10-1-General-TLB-maintenance-requirements\" class=\"headerlink\" title=\"B3.10.1  General TLB maintenance requirements\"></a>B3.10.1  General TLB maintenance requirements</h5><p><strong>The architecture defines CP15 c8 functions for TLB maintenance operations</strong>, and supports the following operations:  </p>\n<ul>\n<li>invalidate all unlocked entries in the TLB  </li>\n<li>invalidate a single TLB entry, by MVA, or MVA and ASID for a non-global entry  </li>\n<li>invalidate all TLB entries that match a specified ASID. </li>\n</ul>\n<p>The Multiprocessing Extensions add the following operations:<br>• invalidate all TLB entries that match a specified MVA, regardless of the ASID</p>\n<h6 id=\"Using-break-before-make-when-updating-translation-table-entries\"><a href=\"#Using-break-before-make-when-updating-translation-table-entries\" class=\"headerlink\" title=\"Using break-before-make when updating translation table entries\"></a>Using break-before-make when updating translation table entries</h6><p>ARM strongly recommends the use of a break-before-make when changing translation table entries whenever multiple threads of execution can use the same translation tables and the change to the translation entries involves any of:<br>• A change of the memory type.<br>• A change of the cacheability attributes.<br>• A change of the output address (OA), if the OA of at least one of the old translation table entry and the new<br>translation table entry is writable.</p>\n<p><strong>break-before-make</strong></p>\n<ol>\n<li>Replace the old translation table entry, and execute DSB instruction.  </li>\n<li>Invalidate the translation table entry with a broadcast TLB invalidation instruction, and execute a DSB instruction  </li>\n<li>Write the new translation table entry, and execute a DSB instruction   </li>\n</ol>\n<h5 id=\"B3-10-2-Maintenance-requirements-on-changing-system-control-register-values\"><a href=\"#B3-10-2-Maintenance-requirements-on-changing-system-control-register-values\" class=\"headerlink\" title=\"B3.10.2 Maintenance requirements on changing system control register values\"></a>B3.10.2 Maintenance requirements on changing system control register values</h5><p>The TLB contents can be influenced by control bits in a number of system control registers. </p>\n<p>The system control register changes that this applies to are:<br>• any change to the NMRR, PRRR, MAIRn, or HMAIRn registers<br>• any change to the SCTLR.AFE bit, see Changing the Access flag enable<br>• any change to the SCTLR.TRE bit<br>• any change to the translation table base address in TTBR0<br>• any change to the translation table base address in TTBR1<br>• in an implementation that includes the Virtualization Extensions:<br>    — any change to the SCTLR.{WXN, UWXN} bits<br>    — any change to the SCR.SIF bit<br>    — any change to the HCR.VM bit<br>    — any change to HCR.PTW bit, see Changing HCR.PTW<br>    — any change to the HTTBR.BADDR field<br>    — any change to the VTTBR.BADDR field<br>• in an implementation that includes the Large Physical Address Extension, changing TTBCR.EAE, see<br>Changing the current Translation table format on page B3-1386<br>• when using the Short-descriptor translation table format:<br>    — any change to the RGN, IRGN, S, or NOS fields in TTBR0 or TTBR1<br>    — any change to the PD0 or PD1 fields in TTBCR<br>• when using the Long-descriptor translation table format:<br>    — any change to the TnSZ, ORGNn, IRGNn, SHn, or EPDn fields in the TTBCR, where n is 0 or 1<br>    — any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the HTCR<br>    — any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the VTCR.</p>\n<h5 id=\"B3-10-3-Atomicity-of-register-changes-on-changing-virtual-machine\"><a href=\"#B3-10-3-Atomicity-of-register-changes-on-changing-virtual-machine\" class=\"headerlink\" title=\"B3.10.3 Atomicity of register changes on changing virtual machine\"></a>B3.10.3 Atomicity of register changes on changing virtual machine</h5><p>From the viewpoint of software executing in a Non-secure PL1 or PL0 mode, when there is a switch from one virtual<br>machine to another, the registers that control or affect address translation must be changed atomically. </p>\n<p>This applies to the registers for:<br>• Non-secure PL1&amp;0 stage 1 address translations. This means that all of the following registers must change  atomically:<br>    — PRRR and NMRR, if using the Short-descriptor translation table format<br>    — MAIR0 and MAIR1, if using the Long-descriptor translation table format<br>    — TTBR0, TTBR1, TTBCR, DACR, and CONTEXTIDR<br>    — the SCTLR.</p>\n<p><strong>These registers apply to execution in Non-secure PL1&amp;0 modes. However, when updated as part of a switch of virtual machines they are updated by software executing in Hyp mode.</strong></p>\n<p>• Non-secure PL1&amp;0 stage 2 address translations. This means that all of the following registers and register<br>fields must change atomically:<br>    — VTTBR and VTCR<br>    — HMAIR0 and HMAIR1<br>    — the HSCTLR.</p>\n<h5 id=\"B3-11-Caches-in-a-VMSA-implementation\"><a href=\"#B3-11-Caches-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.11 Caches in a VMSA implementation\"></a>B3.11 Caches in a VMSA implementation</h5><p>B3.11.1 Data and unified caches<br><strong>The behavior of accesses from the same observer to different VAs, that are translated to the same PA with the same memory attributes, is fully coherent.</strong> This means these accesses behave as follows, regardless of<br>which VA is accessed:<br>• two writes to the same PA occur in program order<br>• a read of a PA returns the value of the last successful write to that PA<br>• a write to a PA that occurs, in program order, after a read of that PA, has no effect on the value returned by<br>that read.<br>The memory system behaves in this way without any requirement to use barrier or cache maintenance operations.</p>\n<h4 id=\"B3-11-2-Instruction-caches\"><a href=\"#B3-11-2-Instruction-caches\" class=\"headerlink\" title=\"B3.11.2 Instruction caches\"></a>B3.11.2 Instruction caches</h4><p>In the ARM architecture, an instruction cache is a cache that is accessed only as a result of an instruction fetch.<br>Therefore, <strong>an instruction cache is never written to by any load or store instruction executed by the processor.</strong></p>\n<p>The ARMv7 architecture supports three different behaviors for instruction caches:<br>• Physically-indexed, physically-tagged(PIPT) instruction caches<br>• Virtually-indexed, physically-tagged (VIPT) instruction caches<br>• ASID and VMID tagged Virtually-indexed, virtually-tagged (VIVT) instruction caches.</p>\n<h5 id=\"B3-11-2-1-PIPT-instruction-caches-amp-VIPT-instruction-caches\"><a href=\"#B3-11-2-1-PIPT-instruction-caches-amp-VIPT-instruction-caches\" class=\"headerlink\" title=\"B3.11.2.1 PIPT instruction caches &amp; VIPT instruction caches\"></a>B3.11.2.1 PIPT instruction caches &amp; VIPT instruction caches</h5><p>For PIPT instruction caches, the use of memory address translation is entirely transparent to all instruction fetches<br>that are not UNPREDICTABLE.</p>\n<p>An implementation that provides PIPT/VIPT instruction caches implements the IVIPT extension, see IVIPT architecture<br>extension </p>\n<h5 id=\"B3-11-2-2-IVIPT-architecture-extension\"><a href=\"#B3-11-2-2-IVIPT-architecture-extension\" class=\"headerlink\" title=\"B3.11.2.2 IVIPT architecture extension\"></a>B3.11.2.2 IVIPT architecture extension</h5><p>It reduces the instruction cache maintenance requirement to the following condition:<br>• instruction cache maintenance is required only after writing new data to a physical address that holds an<br>instruction.</p>\n<h5 id=\"B3-11-2-3-ASID-and-VMID-tagged-VIVT-instruction-caches\"><a href=\"#B3-11-2-3-ASID-and-VMID-tagged-VIVT-instruction-caches\" class=\"headerlink\" title=\"B3.11.2.3 ASID and VMID tagged VIVT instruction caches\"></a>B3.11.2.3 ASID and VMID tagged VIVT instruction caches</h5><p>Instruction maintenance can also be required as a result of any of the following situations:<br>• enabling or disabling the MMU<br>• writing new mappings to the translation tables<br>• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,<br>or a change to the VMID<br>• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID</p>\n<h4 id=\"B3-12-VMSA-memory-aborts\"><a href=\"#B3-12-VMSA-memory-aborts\" class=\"headerlink\" title=\"B3.12 VMSA memory aborts\"></a>B3.12 VMSA memory aborts</h4><p>In a VMSAv7 implementation, the following mechanisms cause a processor to take an exception on a failed memory<br>access:<br><strong>Debug exception</strong><br>An exception caused by the debug configuration, see About debug exceptions on<br>page C4-2090.</p>\n<p><strong>Alignment fault</strong><br>An Alignment fault is generated if the address used for a memory access does not have the<br>required alignment for the operation. For more information see Unaligned data access on<br>page A3-108 and Alignment faults on page B3-1402.</p>\n<p><strong>MMU fault</strong><br>An MMU fault is a fault generated by the fault checking sequence for the current translation<br>regime.</p>\n<p><strong>External abort</strong><br>Any memory system fault other than a Debug exception, an Alignment fault, or an MMU<br>fault</p>\n<h5 id=\"B3-12-1-Routing-of-aborts\"><a href=\"#B3-12-1-Routing-of-aborts\" class=\"headerlink\" title=\"B3.12.1 Routing of aborts\"></a>B3.12.1 Routing of aborts</h5><p>A memory abort is either a Data Abort exception or a Prefetch Abort exception. The mode to which a memory abort<br>is taken depends on the reason for the exception, the mode the processor is in when it takes the exception:</p>\n<p><strong>Memory aborts taken to Monitor mode</strong><br>If an implementation includes the Security Extensions, when SCR.EA is set to 1, all External aborts<br>are taken to Monitor mode. This applies to aborts taken from Secure modes and from Non-secure<br>modes. </p>\n<p><strong>Memory aborts taken to Secure Abort mode</strong><br>If an implementation includes the Security Extensions, when the processor is executing in Secure<br>state, all memory aborts that are not routed to Monitor mode are taken to Secure Abort mode.</p>\n<p><strong>Memory aborts taken to Hyp mode</strong><br>大致都发生在Hyp mode，Non-secure 时至少也是在stage 2 发生的错误（stage 1 VA -&gt; IPA; stage2 IPA-&gt; PA. 虚拟地址-&gt;中间地址-&gt;物理地址）</p>\n<p>includes the Virtualization Extensions, the processor is executing in Non-secure state<br>• Alignment faults taken:<br>    — When the processor is in Hyp mode.<br>    — When the processor is in a PL1 or PL0 mode and the exception is generated because<br>    the Non-secure PL1&amp;0 stage 2 translation identifies the target of an unaligned access<br>    as Device or Strongly-ordered memory.<br>    — When the processor is in the PL0 mode and HCR.TGE is set to 1. For more<br>    information see Synchronous external abort, when HCR.TGE is set to 1 on<br>    page B1-1193.</p>\n<p>• When the processor is using the Non-secure PL1&amp;0 translation regime:<br>    — MMU faults from stage 2 translations, for which the stage 1 translation did not cause<br>    an MMU fault.<br>    — Any abort taken during the stage 2 translation of an address accessed in a stage 1<br>    translation table walk that is not routed to Secure Monitor mode<br>• When the processor is using the Non-secure PL2 translation regime, MMU faults from<br>stage 1 translations.</p>\n<p>• External aborts, if SCR.EA is set to 0 and any of the following applies:<br>    — The processor was executing in Hyp mode when it took the exception.<br>    — The processor was executing in a Non-secure PL0 or PL1 mode when it took the<br>    exception, the abort is asynchronous, and HCR.AMO is set to 1.<br>    — The processor was executing in the Non-secure PL0 mode when it took the exception,<br>    the abort is synchronous, and HCR.TGE is set to 1. For more information see<br>    Synchronous external abort, when HCR.TGE is set to 1 on page B1-1193.<br>    — The abort occurred on a stage 2 translation table walk.</p>\n<p>• Debug exceptions, if HDCR.TDE is set to 1.</p>\n<p><strong>Memory aborts taken to Non-secure Abort mode</strong><br>In an implementation that does not include the Security Extensions, all memory aborts are taken to<br>Abort mode.<br>Otherwise, when the processor is executing in Non-secure state, the following aborts are taken to<br>Non-secure Abort mode:<br>• When the processor is in a Non-secure PL1 or PL0 mode, Alignment faults taken for any of<br>the following reasons:<br>    — SCTLR.A is set to 1.<br>    — An instruction that does not support unaligned accesses is committed for execution,<br>    and the instruction accesses an unaligned address.<br>    — The implementation includes the Virtualization Extensions, and the PL1&amp;0 stage 1<br>    translation identifies the target of an unaligned access as Device or Strongly-ordered<br>    memory.<br>• When the processor is using the Non-secure PL1&amp;0 translation regime, MMU faults from<br>stage 1 translations.<br>• External aborts, if all of the following apply:<br>    — the abort is not on a stage 2 translation table walk<br>    — the processor is not in Hyp mode<br>    — SCR.EA is set to 0<br>    — the abort is asynchronous, and HCR.AMO is set to 0<br>    — the abort is synchronous, and HCR.TGE is set to 0• When the processor is using the Non-secure PL1&amp;0 translation regime, MMU faults from<br>stage 1 translations.<br>• External aborts, if all of the following apply:<br>    — the abort is not on a stage 2 translation table walk<br>    — the processor is not in Hyp mode<br>    — SCR.EA is set to 0<br>    — the abort is asynchronous, and HCR.AMO is set to 0<br>    — the abort is synchronous, and HCR.TGE is set to 0</p>\n<h5 id=\"B3-12-3-The-MMU-fault-checking-sequence\"><a href=\"#B3-12-3-The-MMU-fault-checking-sequence\" class=\"headerlink\" title=\"B3.12.3 The MMU fault-checking sequence\"></a>B3.12.3 The MMU fault-checking sequence</h5><p>In a VMSA implementation, all memory accesses require VA to PA translation. Therefore, when a corresponding<br>MMU is enabled, each access requires a lookup of the translation table descriptor for the accessed VA. </p>\n<p>When using the Short-descriptor format<br>• There are one or two levels of lookup.<br>• Lookup always starts at the first level.<br>• The final level of lookup checks the Domain field of the descriptor and:<br>    — faults if there is no access to the Domain<br>    — checks the access permissions only for Client domains.<br>When using the Long-descriptor format<br>• There are one, two, or three levels of lookup.<br>• Lookup starts at either the first level or the second level.<br>• Domains are not supported. All accesses are treated as Client domain accesses.</p>\n<p>Fixme [Figure B3-23 Fetching the descriptor in a translation table walk]Page1400</p>\n<p>Fixme [Figure B3-24 VMSA fault checking sequence]Page1401</p>\n<p><strong>Stage 2 fault on a stage 1 translation table walk, Virtualization Extensions</strong><br>When an implementation that includes the Virtualization Extensions is operating in a Non-secure PL1 or PL0 mode,<br>any memory access goes through two stages of translation:<br>• stage 1, from VA to IPA<br>• stage 2, from IPA to PA</p>\n<h5 id=\"B3-12-4-Alignment-faults\"><a href=\"#B3-12-4-Alignment-faults\" class=\"headerlink\" title=\"B3.12.4 Alignment faults\"></a>B3.12.4 Alignment faults</h5><p>The ARMv7 memory architecture requires support for strict alignment checking. This checking is controlled by<br>SCTLR.A.</p>\n<p>An Alignment fault can occur on an access for which the MMU is disabled.</p>\n<p><strong>In an implementation that includes the Virtualization Extensions, any unaligned access to memory region with the Device or Strongly-ordered memory type attribute generates an Alignment fault.</strong></p>\n<h5 id=\"B3-12-5-MMU-faults\"><a href=\"#B3-12-5-MMU-faults\" class=\"headerlink\" title=\"B3.12.5 MMU faults\"></a>B3.12.5 MMU faults</h5><p>This section describes the faults that might be detected during one of the fault-checking sequences described in The<br>MMU fault-checking sequence.</p>\n<p>The following subsections describe the MMU faults that might be detected during a fault checking sequence:<br>• External abort on a translation table walk<br>• Translation fault<br>• Access flag fault on page B3-1404<br>• Domain fault, Short-descriptor format translation tables only on page B3-1404<br>• Permission fault on page B3-1405.</p>\n<p><strong>Translation fault</strong><br>A Translation fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.<br>A Translation fault is generated if bits[1:0] of a translation table descriptor identify the descriptor as either a Fault<br>encoding or a reserved encoding.</p>\n<p>In addition, if an implementation includes the Virtualization Extensions, then a Translation fault is generated if the<br>input address for a translation either does not map on to an address range of a Translation Table Base Register, or<br>the Translation Table Base Register range that it maps on to is disabled. </p>\n<p>The architecture guarantees that any translation table entry that causes a Translation fault is not cached,</p>\n<p><strong>Access flag fault</strong><br>An Access flag fault can be generated at any level of lookup,<br>• The translation tables support an Access flag bit:<br>    — the Short-descriptor format supports an Access flag only when SCTLR.AFE is set to 1<br>    — the Long-descriptor format always supports an Access flag.</p>\n<p>The architecture guarantees that any translation table entry that causes an Access flag fault is not cached, meaning<br>the TLB never holds such an entry.</p>\n<p><strong>Domain fault, Short-descriptor format translation tables only</strong><br>When using the Short-descriptor translation table format, a Domain fault can be generated at the first level or second<br>level of lookup.</p>\n<p>When a first-level/second-level descriptor fetch returns a valid Section first-level descriptor, the domain field of<br>that descriptor is checked against the DACR. A first-level Domain fault is generated if this check<br>fails.</p>\n<p>A TLB might hold a translation table entry that cause a Domain fault.</p>\n<p><strong>Permission fault</strong><br>A Permission fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.</p>\n<p>A TLB might hold a translation table entry that cause a Permission fault. Therefore, if the handling of a Permission<br>fault results in an update to the associated translation tables, the software that updates the translation tables must<br>invalidate the appropriate TLB entry.</p>\n<p>B3.12.6 External aborts<br>The ARM architecture defines external aborts as errors that occur in the memory system, other than those that are<br>detected by the MMU or Debug hardware.An external abort is one of:<br>• synchronous<br>• precise asynchronous<br>• imprecise asynchronous.</p>\n<p>The ARM architecture does not provide any method to distinguish between precise asynchronous and imprecise<br>asynchronous aborts.</p>\n<p>Normally, external aborts are rare. An imprecise asynchronous external abort is likely to be fatal to the process that<br>is running. </p>\n<h5 id=\"B3-12-7-Prioritization-of-aborts\"><a href=\"#B3-12-7-Prioritization-of-aborts\" class=\"headerlink\" title=\"B3.12.7 Prioritization of aborts\"></a>B3.12.7 Prioritization of aborts</h5><p>prioritization decreasing in next order:</p>\n<ol>\n<li>Alignment fault</li>\n<li>an MMU fault, on either the stage 1 translation or the stage 2 translation</li>\n<li>a Watchpoint debug event.</li>\n<li>an external abort</li>\n</ol>\n<h4 id=\"B3-13-Exception-reporting-in-a-VMSA-implementation\"><a href=\"#B3-13-Exception-reporting-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.13 Exception reporting in a VMSA implementation\"></a>B3.13 Exception reporting in a VMSA implementation</h4><h5 id=\"B3-13-1-About-exception-reporting\"><a href=\"#B3-13-1-About-exception-reporting\" class=\"headerlink\" title=\"B3.13.1 About exception reporting\"></a>B3.13.1 About exception reporting</h5><p>In an implementation that includes the Virtualization Extensions, exceptions can be taken to:<br>• a Secure or Non-secure PL1 mode<br>• the Non-secure PL2 mode, Hyp mode.</p>\n<h5 id=\"B3-13-2-Reporting-exceptions-taken-to-PL1-modes\"><a href=\"#B3-13-2-Reporting-exceptions-taken-to-PL1-modes\" class=\"headerlink\" title=\"B3.13.2 Reporting exceptions taken to PL1 modes\"></a>B3.13.2 Reporting exceptions taken to PL1 modes</h5><p><strong>Registers used for reporting exceptions taken to a PL1 mode</strong><br>ARMv7 defines the following registers, and register encodings, for exceptions taken to PL1 modes:<br>• the DFSR holds information about a Data Abort exception<br>• the DFAR holds the faulting address for some synchronous Data Abort exceptions<br>• the IFSR holds information about a Prefetch Abort exception<br>• the IFAR holds the faulting address of a Prefetch Abort exception<br>• on a Watchpoint debug exception, the DBGWFAR can hold fault information.</p>\n<p><strong>Auxiliary Fault Status Registers</strong><br>The ARMv7 architecture defines the following Auxiliary Fault Status Registers:<br>• the Auxiliary Data Fault Status Register, ADFSR<br>• the Auxiliary Instruction Fault Status Register, AIFSR.</p>\n<h5 id=\"B3-13-3-Fault-reporting-in-PL1-modes\"><a href=\"#B3-13-3-Fault-reporting-in-PL1-modes\" class=\"headerlink\" title=\"B3.13.3 Fault reporting in PL1 modes\"></a>B3.13.3 Fault reporting in PL1 modes</h5><p>Fixme [Table B3-23 Short-descriptor format FSR encodings] Page 1415</p>\n<p>Fixme [Table B3-24 Long-descriptor format FSR encodings] Page 1416</p>\n<h5 id=\"B3-13-5-Reporting-exceptions-taken-to-the-Non-secure-PL2-mode\"><a href=\"#B3-13-5-Reporting-exceptions-taken-to-the-Non-secure-PL2-mode\" class=\"headerlink\" title=\"B3.13.5 Reporting exceptions taken to the Non-secure PL2 mode\"></a>B3.13.5 Reporting exceptions taken to the Non-secure PL2 mode</h5><p><strong>Registers used for reporting exceptions taken to Hyp mode</strong><br>The Virtualization Extensions define the following registers for exceptions taken to Hyp mode:<br>• the HSR holds syndrome information for the exception<br>• the HDFAR holds the VA associated with a Data Abort exception<br>• the HIFAR holds the VA associated with a Prefetch Abort exception<br>• the HPFAR holds bits[39:12] of the IPA associated with some aborts on stage 2 address translations.</p>\n<p><strong>Hyp Auxiliary Fault Syndrome Registers</strong><br>The Virtualization Extensions define the following Hyp Auxiliary Fault Syndrome Registers:<br>• the Hyp Auxiliary Data Fault Syndrome Register, HADFSR<br>• the Hyp Auxiliary Instruction Fault Syndrome Register, HAIFSR.</p>\n<p>Fixme [Table B3-28 HSR.EC encodings for aborts taken to Hyp mode] Page 1422</p>\n<h5 id=\"B3-13-6-Use-of-the-HSR\"><a href=\"#B3-13-6-Use-of-the-HSR\" class=\"headerlink\" title=\"B3.13.6 Use of the HSR\"></a>B3.13.6 Use of the HSR</h5><p>The HSR holds syndrome information for any synchronous exception taken to Hyp mode. Compared with the<br>reporting of exceptions taken to PL1 modes, the HSR:<br>• Always provides details of the fault. The DFSR and IFSR are not used.<br>• Provides more extensive information, for a wider range of exceptions.</p>\n<p>Fixme [Figure B3-25 Format of the HSR, with subdivision of the ISS field for specified EC encodings] Page 1425</p>\n<p>Fixme [Table B3-29 HSR.EC field encoding] Page 1425</p>\n<p>More detail ISS encoding see arm-arm pdf</p>\n<h4 id=\"B3-14-Virtual-Address-to-Physical-Address-translation-operation\"><a href=\"#B3-14-Virtual-Address-to-Physical-Address-translation-operation\" class=\"headerlink\" title=\"B3.14 Virtual Address to Physical Address translation operation\"></a>B3.14 Virtual Address to Physical Address translation operation</h4><p><strong>CP15 c7 includes operations for Virtual Address (VA) to Physical Address (PA) translation.</strong></p>\n<h5 id=\"B3-14-1-Naming-of-the-address-translation-operations-and-operation-summary\"><a href=\"#B3-14-1-Naming-of-the-address-translation-operations-and-operation-summary\" class=\"headerlink\" title=\"B3.14.1 Naming of the address translation operations, and operation summary\"></a>B3.14.1 Naming of the address translation operations, and operation summary</h5><p>Fixme [Table B3-31 Naming of address translation operations] Page 1438</p>\n<p>In the stage 1 current state and stages 1 and 2 Non-secure state only operations, the meanings of the last two letters<br>of the names are:</p>\n<ul>\n<li>PR PL1 mode, read operation.  </li>\n<li>PW PL1 mode, write operation.  </li>\n<li>UR PL0 mode, read operation.  </li>\n<li>UW PL0 mode, write operation.</li>\n</ul>\n<h5 id=\"B3-14-2-Encoding-and-availability-of-the-address-translation-operations\"><a href=\"#B3-14-2-Encoding-and-availability-of-the-address-translation-operations\" class=\"headerlink\" title=\"B3.14.2 Encoding and availability of the address translation operations\"></a>B3.14.2 Encoding and availability of the address translation operations</h5><p>Software executing at PL0 never has any visibility of the address translation operations, but software executing at<br>PL1 or higher can use the unprivileged address translation operations to find the address translations used for<br>memory accesses by software executing at PL0 and PL1.</p>\n<p>Fixme [Table B3-32 CP15 c7 address translation operations] Page 1440</p>\n<p>The result of an operation is always returned in the PAR. The PAR is a RW register and:<br>• in all implementations, the 32-bit format PAR is accessed using an MCR or MRC instruction with CRn set to c7,<br>CRm set to c4, and opc1 and opc2 both set to 0<br>• in an implementation that includes the Large Physical Address Extension, the 64-bit format PAR is accessed<br>using an MCRR or MRRC instruction with CRm set to c7, and opc1 set to 0.</p>\n<h5 id=\"B3-14-3-Determining-the-PAR-format-Large-Physical-Address-Extension\"><a href=\"#B3-14-3-Determining-the-PAR-format-Large-Physical-Address-Extension\" class=\"headerlink\" title=\"B3.14.3 Determining the PAR format, Large Physical Address Extension\"></a>B3.14.3 Determining the PAR format, Large Physical Address Extension</h5><p>The Large Physical Address Extension extends the PAR to become a 64-bit register, and supports both 32-bit and<br>64-bit PAR formats</p>\n<h4 id=\"B3-15-About-the-system-control-registers-for-VMSA\"><a href=\"#B3-15-About-the-system-control-registers-for-VMSA\" class=\"headerlink\" title=\"B3.15 About the system control registers for VMSA\"></a>B3.15 About the system control registers for VMSA</h4><p>On an ARMv7-A or ARMv7-R implementation, the system control registers comprise:<br>• the registers accessed using the System Control Coprocessor, CP15<br>• registers accessed using the CP14 coprocessor, including:<br>    — debug registers<br>    — trace registers<br>    — execution environment registers.</p>\n<h5 id=\"B3-15-3-Classification-of-system-control-registers\"><a href=\"#B3-15-3-Classification-of-system-control-registers\" class=\"headerlink\" title=\"B3.15.3 Classification of system control registers\"></a>B3.15.3 Classification of system control registers</h5><p><strong>Banked system control registers</strong><br>Fixme [Table B3-33 Banked CP15 registers] Page 1452</p>\n<p><strong>Restricted access system control registers</strong><br>Fixme [Table B3-34 Restricted access CP15 registers] Page 1453</p>\n<p><strong>PL2-mode system control registers</strong><br>Fixme [Table B3-35 Banked PL2-mode CP15 read/write registers] Page 1455</p>\n<p>Fixme [Table B3-37 Banked PL2-mode CP15 write-only operations] Page 1457</p>\n<p><strong>Common system control registers</strong><br>Some system control registers and operations are common to the Secure and Non-secure security states.<br>Fixme [Table B3-38 Common CP15 registers] Page 1457</p>\n<h4 id=\"B3-16-Organization-of-the-CP14-registers-in-a-VMSA-implementation\"><a href=\"#B3-16-Organization-of-the-CP14-registers-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.16 Organization of the CP14 registers in a VMSA implementation\"></a>B3.16 Organization of the CP14 registers in a VMSA implementation</h4><p>The CP14 registers provide a number of distinct control functions, covering:<br>• Debug<br>• Trace<br>• Execution environment control, for the Jazelle and ThumbEE execution environments.</p>\n<p>The CP14 register encodings are classified by the {CRn, opc1, CRm, opc2} values required to access them using<br>an MCR or an MRC instruction. The opc1 value determines the primary allocation of these registers, as follows:<br>opc1==0 Debug registers.<br>opc1==1 Trace registers.<br>opc1==6 ThumbEE registers.<br>opc1==7 Jazelle registers. Can include Jazelle SUBARCHITECTURE DEFINED registers</p>\n<h4 id=\"B3-17-Organization-of-the-CP15-registers-in-a-VMSA-implementation\"><a href=\"#B3-17-Organization-of-the-CP15-registers-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B3.17 Organization of the CP15 registers in a VMSA implementation\"></a>B3.17 Organization of the CP15 registers in a VMSA implementation</h4><p>More precisely, the ordered set of values {CRn, opc1, CRm, opc2} determined the register order.</p>\n<h5 id=\"B3-17-1-CP15-register-summary-by-coprocessor-register-number\"><a href=\"#B3-17-1-CP15-register-summary-by-coprocessor-register-number\" class=\"headerlink\" title=\"B3.17.1 CP15 register summary by coprocessor register number\"></a>B3.17.1 CP15 register summary by coprocessor register number</h5><p>Fixme [Figure B3-26 CP15 register grouping by primary coprocessor register, CRn, VMSA implementation] Page 1470</p>\n<p><strong>VMSA CP15 c0 register summary, identification registers</strong><br>Fixme [Figure B3-27 CP15 c0 registers in a VMSA implementation] Page 1471</p>\n<p><strong>VMSA CP15 c1 register summary, system control registers</strong><br>Fixme [Figure B3-28 CP15 c1 registers in a VMSA implementation] Page 1472</p>\n<p><strong>VMSA CP15 c2 and c3 register summary, Memory protection and control registers</strong><br>Fixme [Figure B3-29 CP15 32-bit c2 and c3 registers] Page 1473</p>\n<p>Fixme [Figure B3-30 CP15 64-bit c2 registers] Page 1473</p>\n<p><strong>VMSA CP15 c5 and c6 register summary, Memory system fault registers</strong><br>Fixme [Figure B3-31 CP15 c5 and c6 registers in a VMSA implementation] Page 1474</p>\n<p><strong>VMSA CP15 c7 register summary, Cache maintenance, address translation, and other functions</strong><br>Fixme [Figure B3-32 CP15 32-bit c7 registers in a VMSA implementation] Page 1475</p>\n<p><strong>VMSA CP15 c8 register summary, TLB maintenance operations</strong><br>Fixme [Figure B3-34 CP15 c8 registers in a VMSA implementation] Page 1476</p>\n<p><strong>VMSA CP15 c9 register summary, reserved for cache and TCM control and performance monitors</strong><br>Fixme [Figure B3-35 Reserved CP15 c9 encodings] Page 1477</p>\n<p><strong>VMSA CP15 c10 register summary, memory remapping and TLB control registers</strong><br>Fixme [Figure B3-36 CP15 c10 registers in a VMSA implementation] Page 1478</p>\n<p><strong>VMSA CP15 c11 register summary, reserved for TCM DMA registers</strong><br>Fixme [Figure B3-37 Reserved CP15 c11 encodings] Page 1478</p>\n<p><strong>VMSA CP15 c12 register summary, Security Extensions registers</strong><br>Fixme [Figure B3-38 Security Extensions CP15 c12 registers] Page 1479</p>\n<p><strong>VMSA CP15 c13 register summary, Process, context and thread ID registers</strong><br>On an ARMv7-A implementation, the CP15 c13 registers provide:<br>• an FCSE Process ID Register, that indicates whether the implementation includes the FCSE<br>• a Context ID Register<br>• Software Thread ID Registers.<br>Fixme [Figure B3-39 CP15 c13 registers in a VMSA implementation] Page 1479</p>\n<p><strong>VMSA CP15 c14, reserved for Generic Timer Extension</strong><br>Fixme [Figure B3-40 CP15 32-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480<br>Fixme [Figure B3-41 CP15 64-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480</p>\n<p><strong>VMSA CP15 c15 register summary, IMPLEMENTATION DEFINED registers</strong></p>\n<h5 id=\"B3-17-2-Full-list-of-VMSA-CP15-registers-by-coprocessor-register-number\"><a href=\"#B3-17-2-Full-list-of-VMSA-CP15-registers-by-coprocessor-register-number\" class=\"headerlink\" title=\"B3.17.2 Full list of VMSA CP15 registers, by coprocessor register number\"></a>B3.17.2 Full list of VMSA CP15 registers, by coprocessor register number</h5><p>Fixme [Table B3-42 Summary of VMSA CP15 register descriptions, in coprocessor register number order] Page 1481</p>\n<h4 id=\"B3-18-Functional-grouping-of-VMSAv7-system-control-registers\"><a href=\"#B3-18-Functional-grouping-of-VMSAv7-system-control-registers\" class=\"headerlink\" title=\"B3.18 Functional grouping of VMSAv7 system control registers\"></a>B3.18 Functional grouping of VMSAv7 system control registers</h4><h5 id=\"B3-18-1-Identification-registers-functional-group\"><a href=\"#B3-18-1-Identification-registers-functional-group\" class=\"headerlink\" title=\"B3.18.1 Identification registers, functional group\"></a>B3.18.1 Identification registers, functional group</h5><p>Fixme [Table B3-44 Identification registers, VMSA] Page 1492</p>\n<h5 id=\"B3-18-2-Virtual-memory-control-registers-functional-group\"><a href=\"#B3-18-2-Virtual-memory-control-registers-functional-group\" class=\"headerlink\" title=\"B3.18.2 Virtual memory control registers, functional group\"></a>B3.18.2 Virtual memory control registers, functional group</h5><p>Fixme [Table B3-45 Virtual memory control registers, VMSA only] Page 1493</p>\n<h5 id=\"B3-18-3-PL1-Fault-handling-registers-functional-group\"><a href=\"#B3-18-3-PL1-Fault-handling-registers-functional-group\" class=\"headerlink\" title=\"B3.18.3 PL1 Fault handling registers, functional group\"></a>B3.18.3 PL1 Fault handling registers, functional group</h5><p>Fixme [Table B3-46 Fault handling registers, VMSA] Page 1494</p>\n<h5 id=\"B3-18-4-Other-system-control-registers-functional-group\"><a href=\"#B3-18-4-Other-system-control-registers-functional-group\" class=\"headerlink\" title=\"B3.18.4 Other system control registers, functional group\"></a>B3.18.4 Other system control registers, functional group</h5><p>Fixme [Table B3-47 Other system control registers, VMSA] Page 1494</p>\n<h5 id=\"B3-18-5-Lockdown-DMA-and-TCM-features-functional-group-VMSA\"><a href=\"#B3-18-5-Lockdown-DMA-and-TCM-features-functional-group-VMSA\" class=\"headerlink\" title=\"B3.18.5 Lockdown, DMA, and TCM features, functional group, VMSA\"></a>B3.18.5 Lockdown, DMA, and TCM features, functional group, VMSA</h5><p>Fixme [Table B3-48 Lockdown, DMA, and TCM features, VMSA] Page 1495</p>\n<h5 id=\"B3-18-6-Cache-maintenance-operations-functional-group-VMSA\"><a href=\"#B3-18-6-Cache-maintenance-operations-functional-group-VMSA\" class=\"headerlink\" title=\"B3.18.6 Cache maintenance operations, functional group, VMSA\"></a>B3.18.6 Cache maintenance operations, functional group, VMSA</h5><p>Fixme [Table B3-49 Cache and branch predictor maintenance operations, VMSA] Page 1496</p>\n<h5 id=\"B3-18-7-TLB-maintenance-operations-functional-group\"><a href=\"#B3-18-7-TLB-maintenance-operations-functional-group\" class=\"headerlink\" title=\"B3.18.7 TLB maintenance operations, functional group\"></a>B3.18.7 TLB maintenance operations, functional group</h5><p>Fixme [Table B3-50 TLB maintenance operations, VMSA only] Page 1497</p>\n<h5 id=\"B3-18-8-Address-translation-operations-functional-group\"><a href=\"#B3-18-8-Address-translation-operations-functional-group\" class=\"headerlink\" title=\"B3.18.8 Address translation operations, functional group\"></a>B3.18.8 Address translation operations, functional group</h5><p>Fixme [Table B3-51 Address translation operations, VMSA only] Page 1498</p>\n<h5 id=\"B3-18-9-Miscellaneous-operations-functional-group\"><a href=\"#B3-18-9-Miscellaneous-operations-functional-group\" class=\"headerlink\" title=\"B3.18.9 Miscellaneous operations, functional group\"></a>B3.18.9 Miscellaneous operations, functional group</h5><p>Fixme [Table B3-52 Miscellaneous system control operations, VMSA only] Page 1499</p>\n<h5 id=\"B3-18-10-Performance-Monitors-functional-group\"><a href=\"#B3-18-10-Performance-Monitors-functional-group\" class=\"headerlink\" title=\"B3.18.10 Performance Monitors, functional group\"></a>B3.18.10 Performance Monitors, functional group</h5><p>Fixme [Table B3-53 Performance monitors, VMSA] Page 1500</p>\n<h5 id=\"B3-18-11-Security-Extensions-registers-functional-group\"><a href=\"#B3-18-11-Security-Extensions-registers-functional-group\" class=\"headerlink\" title=\"B3.18.11 Security Extensions registers, functional group\"></a>B3.18.11 Security Extensions registers, functional group</h5><p>Fixme [Table B3-54 Security Extensions registers, VMSA only] Page 1500</p>\n<h5 id=\"B3-18-12-Virtualization-Extensions-registers-functional-group\"><a href=\"#B3-18-12-Virtualization-Extensions-registers-functional-group\" class=\"headerlink\" title=\"B3.18.12 Virtualization Extensions registers, functional group\"></a>B3.18.12 Virtualization Extensions registers, functional group</h5><p>Fixme [Table B3-55 Virtualization Extensions registers, VMSA with Virtualization Extensions only] Page 1501</p>\n<p>Fixme [Table B3-56 Hyp mode TLB maintenance operations, VMSA with Virtualization Extensions only] Page 1502</p>\n<h5 id=\"B3-18-13-Generic-Timer-Extension-registers\"><a href=\"#B3-18-13-Generic-Timer-Extension-registers\" class=\"headerlink\" title=\"B3.18.13 Generic Timer Extension registers\"></a>B3.18.13 Generic Timer Extension registers</h5><h5 id=\"B3-18-14-IMPLEMENTATION-DEFINED-registers-functional-group\"><a href=\"#B3-18-14-IMPLEMENTATION-DEFINED-registers-functional-group\" class=\"headerlink\" title=\"B3.18.14 IMPLEMENTATION DEFINED registers, functional group\"></a>B3.18.14 IMPLEMENTATION DEFINED registers, functional group</h5><p>Typically, an implementation uses CP15 c15 to provide test features, and any required configuration options that<br>are not covered by this manual.</p>\n<h3 id=\"B4-System-Control-Registers-in-a-VMSA-implementation\"><a href=\"#B4-System-Control-Registers-in-a-VMSA-implementation\" class=\"headerlink\" title=\"B4 System Control Registers in a VMSA implementation\"></a>B4 System Control Registers in a VMSA implementation</h3><p>Skip</p>\n<h3 id=\"B5-Protected-Memory-System-Architecture-PMSA\"><a href=\"#B5-Protected-Memory-System-Architecture-PMSA\" class=\"headerlink\" title=\"B5 Protected Memory System Architecture (PMSA)\"></a>B5 Protected Memory System Architecture (PMSA)</h3><p>Skip</p>\n<h3 id=\"B6-System-Control-Registers-in-a-PMSA-implementation\"><a href=\"#B6-System-Control-Registers-in-a-PMSA-implementation\" class=\"headerlink\" title=\"B6 System Control Registers in a PMSA implementation\"></a>B6 System Control Registers in a PMSA implementation</h3><p>Skip</p>\n<h3 id=\"B7-The-CPUID-Identification-Scheme\"><a href=\"#B7-The-CPUID-Identification-Scheme\" class=\"headerlink\" title=\"B7 The CPUID Identification Scheme\"></a>B7 The CPUID Identification Scheme</h3><h4 id=\"B7-1-Introduction-to-the-CPUID-scheme\"><a href=\"#B7-1-Introduction-to-the-CPUID-scheme\" class=\"headerlink\" title=\"B7.1 Introduction to the CPUID scheme\"></a>B7.1 Introduction to the CPUID scheme</h4><p>Before ARMv7, using Main ID Register:<br>• MIDR, Main ID Register, VMSA on page B4-1649<br>• MIDR, Main ID Register, PMSA on page B6-1894.</p>\n<p>The ARMv7 architecture implements an extended processor, using a number of registers in CP15 c0.<br><strong>ARMv7 requires the use of this scheme, and use of the scheme is indicated by a value of 0xF in the Architecture field of the Main ID Register.</strong></p>\n<p>The CPUID scheme provides information about the implemented:<br>• processor features<br>• debug features<br>• auxiliary features, in particular IMPLEMENTATION DEFINED features<br>• memory model features<br>• instruction set features.</p>\n<h4 id=\"B7-2-The-CPUID-registers\"><a href=\"#B7-2-The-CPUID-registers\" class=\"headerlink\" title=\"B7.2 The CPUID registers\"></a>B7.2 The CPUID registers</h4><h5 id=\"B7-2-1-Organization-of-the-CPUID-registers\"><a href=\"#B7-2-1-Organization-of-the-CPUID-registers\" class=\"headerlink\" title=\"B7.2.1 Organization of the CPUID registers\"></a>B7.2.1 Organization of the CPUID registers</h5><p>Fixme[Figure B7-1 CPUID register encodings] Page 1951</p>\n<p>Fixme[Table B7-1 CPUID register summary] Page 1952</p>\n<h5 id=\"B7-2-2-About-the-Instruction-Set-Attribute-registers\"><a href=\"#B7-2-2-About-the-Instruction-Set-Attribute-registers\" class=\"headerlink\" title=\"B7.2.2 About the Instruction Set Attribute registers\"></a>B7.2.2 About the Instruction Set Attribute registers</h5><p>Fixme[Table B7-2 Alphabetic list of Instruction Set Attribute registers attribute fields] Page 1954</p>\n<h3 id=\"B8-The-Generic-Timer\"><a href=\"#B8-The-Generic-Timer\" class=\"headerlink\" title=\"B8. The Generic Timer\"></a>B8. The Generic Timer</h3><h4 id=\"B8-1-About-the-Generic-Timer\"><a href=\"#B8-1-About-the-Generic-Timer\" class=\"headerlink\" title=\"B8.1 About the Generic Timer\"></a>B8.1 About the Generic Timer</h4><p>Fixme[Figure B8-1 Generic Timer example] page1960</p>\n<h5 id=\"8-1-1-System-counter\"><a href=\"#8-1-1-System-counter\" class=\"headerlink\" title=\"8.1.1 System counter\"></a>8.1.1 System counter</h5><p>The Generic Timer provides a system counter with the following specification:<br><strong>Width</strong><br>At least 56 bits wide.<br>The value returned by any 64-bit read of the counter is zero-extended to 64 bits.</p>\n<p><strong>Frequency</strong><br>Increments at a fixed frequency, typically in the range 1-50MHz.<br>Can support one or more alternative operating modes in which it increments by larger amounts at a<br>lower frequency, typically for power-saving.<br>Roll-over Roll-over time of not less than 40 years.</p>\n<p><strong>Accuracy</strong><br>ARM does not specify a required accuracy, but recommends that the counter does not gain or lose<br>more than ten seconds in a 24-hour period.<br>Use of lower-frequency modes must not affect the implemented accuracy.</p>\n<p><strong>Start-up</strong><br>Starts operating from zero.</p>\n<p>The system counter must be implemented in an always-on power domain.</p>\n<h6 id=\"Initializing-and-reading-the-system-counter-frequency\"><a href=\"#Initializing-and-reading-the-system-counter-frequency\" class=\"headerlink\" title=\"Initializing and reading the system counter frequency\"></a>Initializing and reading the system counter frequency</h6><p>Typically, the system drives the system counter at a fixed frequency and the CNTFRQ register must be programmed<br>to this value during the system boot process. </p>\n<p>In an implementation that supports the ARM Security Extensions, only<br>software executing in a Secure PL1 mode can write to CNTFRQ.</p>\n<p>Software can read the CNTFRQ register, to determine the current system counter frequency, in the following states<br>and modes:<br>• Non-secure PL2 mode.<br>• Secure and Non-secure PL1 modes.<br>• When CNTKCTL.PL0PCTEN is set to 1, Secure and Non-secure PL0 modes.</p>\n<h5 id=\"8-1-2-The-physical-counter\"><a href=\"#8-1-2-The-physical-counter\" class=\"headerlink\" title=\"8.1.2 The physical counter\"></a>8.1.2 The physical counter</h5><p>The processor provides a physical counter that contains the count value of the system counter. The CNTPCT register<br>holds the current physical counter value.</p>\n<p>In an implementation that includes the Virtualization Extensions, CNTPCT:<br>• Is always accessible from Secure PL1 modes, and from Non-secure Hyp mode.<br>• Is accessible from Non-secure PL1 modes only when CNTHCTL.PL1PCTEN is set to 1. When<br>CNTHCTL.PL1PCTEN is set to 0, any attempt to access CNTPCT from a Non-secure PL1 mode generates<br>a Hyp Trap exception, see Hyp Trap exception on page B1-1209.</p>\n<h5 id=\"8-1-3-The-virtual-counter\"><a href=\"#8-1-3-The-virtual-counter\" class=\"headerlink\" title=\"8.1.3 The virtual counter\"></a>8.1.3 The virtual counter</h5><p>An implementation of the Generic Timer always includes a virtual counter, that indicates virtual time:<br>• In a processor implementation that does not include the Virtualization Extensions, virtual time is identical to<br>physical time, and the virtual counter contains the same value as the physical counter.<br>• In a processor implementation that includes the Virtualization Extensions, the virtual counter contains the<br>value of the physical counter minus a 64-bit virtual offset. When execu</p>\n<p>CNTVCT is always accessible from Secure PL1 modes, and from Non-secure PL1 and PL2 modes</p>\n<h5 id=\"8-1-5-Timers\"><a href=\"#8-1-5-Timers\" class=\"headerlink\" title=\"8.1.5 Timers\"></a>8.1.5 Timers</h5><p>The number of timers provided by an implementation of the Generic Timer depends on whether the implementation<br>includes the Security Extensions and the Virtualization Extensions, as follows:</p>\n<p><strong>Security Extensions not implemented</strong><br>The implementation provides a physical timer and a virtual timer.</p>\n<p><strong>Security Extensions implemented, Virtualization Extensions not implemented</strong><br>The implementation provides:  </p>\n<ul>\n<li>A Non-secure physical timer.  </li>\n<li>A Secure physical timer.  </li>\n<li>A virtual timer.</li>\n</ul>\n<p><strong>Virtualization Extensions implemented</strong><br>The implementation provides:</p>\n<ul>\n<li>A Non-secure PL1 physical timer.  </li>\n<li>A Secure PL1 physical timer.  </li>\n<li>A Non-secure PL2 physical timer.  </li>\n<li>A virtual timer</li>\n</ul>\n<p>Each timer is implemented as three registers:  </p>\n<ul>\n<li>A 64-bit CompareValue register, that provides a 64-bit unsigned upcounter.  </li>\n<li>A 32-bit TimerValue register, that provides a 32-bit signed downcounter.  </li>\n<li>A 32-bit Control register.</li>\n</ul>\n<p>Fixme[Table B8-1 Timer registers summary for the Generic Timer] page1965</p>\n<h4 id=\"8-2-Generic-Timer-registers-summary\"><a href=\"#8-2-Generic-Timer-registers-summary\" class=\"headerlink\" title=\"8.2 Generic Timer registers summary\"></a>8.2 Generic Timer registers summary</h4><p>Fixme[Table B8-2 Generic Timer registers] page1969</p>"},{"title":"arm gicv2","date":"2019-04-20T05:55:44.000Z","_content":"\nGICv2\n<!--more-->\n##1. Introduction\nAbout the Generic Interrupt Controller architecture\nThe Generic Interrupt Controller (GIC) architecture defines:\n• the architectural requirements for handling all interrupt sources for any processor connected to a GIC\n• a common interrupt controller programming interface applicable to uniprocessor or multiprocessor systems\n\nThe architecture describes a GIC designed for use with one or more processors that comply with the ARM A and R\narchitecture profiles.\n\nThe GIC is a centralized resource for supporting and managing interrupts in a system that includes at least one\nprocessor. It provides:\n• registers for managing interrupt sources, interrupt behavior, and interrupt routing to one or more processors\n• support for:\n\t— the ARM architecture Security Extensions\n\t— the ARM architecture Virtualization Extensions\n\t— enabling, disabling, and generating processor interrupts from hardware (peripheral) interrupt sources\n\t— Software-generated Interrupts (SGIs)\n\t— interrupt masking and prioritization\n\t— uniprocessor and multiprocessor environments\n\t— wakeup events in power-management environments.\n\n\nThe GIC includes interrupt grouping functionality that supports:\n• configuring each interrupt as either Group 0 or Group 1\n• signaling Group 0 interrupts to the target processor using either the IRQ or the FIQ exception request\n• signaling Group 1 interrupts to the target processor using the IRQ exception request only\n• a unified scheme for handling the priority of Group 0 and Group 1 interrupts\n• optional lockdown of the configuration of some Group 0 interrupts.\n\nfiq 优先级比 irq 高\nfiq 模式下寄存器 比 irq 模式多（R8 ~ R12）\nhttp://blog.chinaunix.net/attachment/201302/21/28458801_1361445566H9Z3.png\n\n### 1.2. Security Extensions support\nThe ARM processor Security Extensions are an optional extension to the ARMv7-A architecture profile.\n\nARM Security Extensions facilitate the development of secure applications by:\n• integrating hardware security features into the architecture\n• providing Secure virtual memory space that is accessed by memory accesses in the Secure state\n• providing Non-secure virtual memory space that is accessed by memory accesses in the Non-secure state.\n\n\nWhen a GIC that implements the GIC Security Extensions is connected to a processor that implements the ARM\nSecurity Extensions:\n• Group 0(IRQ/FIQ) interrupts are Secure interrupts, and Group 1(IRQ) interrupts are Non-secure interrupts.\n\nProcessor security state and Secure and Non-secure GIC accesses：\n• a processor in Non-secure state can make only Non-secure accesses to a GIC\n• a processor in Secure state can make both Secure and Non-secure accesses to a GIC\n\n\n### 1.3. Virtualization support\nThe ARM processor Virtualization Extensions are optional extensions to the ARMv7-A architecture profile. The GIC Virtualization Extensions provide mechanisms to minimize the hypervisor overhead of routing interrupts to virtual machines.\n\nThe processor Virtualization Extensions provide hardware support for virtualizing the Non-secure state of an\nVMSAv7 implementation. The extensions support system use of a virtual machine monitor, known as the\nhypervisor, to switch guest operating systems.\n\nWhether implemented in a uniprocessor or in a multiprocessor system, the processor Virtualization Extensions\nsupport running multiple virtual machines on a single processor.\n\nThe hypervisor can either handle a physical interrupt itself, or generate a corresponding virtual interrupt that is signaled to a virtual machine. It is also possible for the hypervisor to generate virtual interrupts that do not correspond to physical interrupts.\n\n1) physical interrupt => virtual machine => virtual interrupt （产生与硬件相应的虚拟中断）\n2) virtual machine => virtual interrupt （也可以产生与硬件中断没有关的虚拟中断）\n\n### 1.4. Terminology （专用名词）\n#### 1.4.1. Interrupt states\nInactive\t\t\tAn interrupt that is not active or pending.\n\nPending \t\t\tAn interrupt from a source to the GIC that is recognized as asserted in hardware, or\n\t\t\t\t\tgenerated by software, and is waiting to be serviced by a target processor.\n\nActive \t\t\t\tAn interrupt from a source to the GIC that has been acknowledged by a processor, and is\n\t\t\t\t\tbeing serviced but has not completed.\n\nActive and pending \tA processor is servicing the interrupt and the GIC has a pending interrupt from the same\nsource.\n\n\n#### 1.4.2. Interrupt types\n\nPeripheral interrupt\n\t\t\n\t\tPrivate Peripheral Interrupt (PPI)\n\t\tThis is a peripheral interrupt that is specific to a single processor.\n\n\t\tShared Peripheral Interrupt (SPI)\n\t\tThis is a peripheral interrupt that the Distributor can route to any of a specified\n\t\tcombination of processors.\n\n\t\tEach peripheral interrupt is either:\n\t\tEdge-triggered\n\t\t\tThis is an interrupt that is asserted on detection of a rising edge of an interrupt\n\t\t\tsignal and then, regardless of the state of the signal, remains asserted until it is\n\t\t\tcleared by the conditions defined by this specification.\n\n\t\tLevel-sensitive\n\t\t\tThis is an interrupt that is asserted whenever the interrupt signal level is active,\n\t\t\tand deasserted whenever the level is not active.\n\nSoftware-generated interrupt (SGI)\n\t\tThis is an interrupt generated by software writing to a GICD_SGIR register in the GIC.The\n\t\tsystem uses SGIs for interprocessor communication.\n\n\t\tWhen an SGI occurs in a multiprocessor implementation, the CPUID field in the Interrupt\n\t\tAcknowledge Register, GICC_IAR, or the Aliased Interrupt Acknowledge Register,\n\t\tGICC_AIAR, identifies the processor that requested the interrupt.\n\n\t\t__An SGI has edge-triggered properties__. （边缘触发）\n\n\t\tIn an implementation that includes the GIC Virtualization Extensions:\n\t\t• when an SGI occurs, management registers in the GIC virtualization Extensions\n\t\tenable the requesting processor to be reported to the Guest OS, as required by the\n\t\tGIC specifications\n\t\t• by writing to the management registers in the GIC Virtualization Extensions, a\n\t\thypervisor can generate a virtual interrupt that appears to a virtual machine as an SGI.\n\nVirtual interrupt \n\tIn a GIC that implements the GIC Virtualization Extensions, an interrupt that targets a\n\tvirtual machine running on a processor, and is typically signaled to the processor by the\n\tconnected virtual CPU interface.\t\t\n\nMaintenance interrupt\n\tIn a GIC that implements the GIC Virtualization Extensions, a level-sensitive interrupt that\n\tis used to signal key events, such as a particular group of interrupts becoming enabled or\n\tdisabled. See Maintenance interrupts on page 5-164 for more information.\t\n\n#### 1.4.3. Models for handling interrupts\n\n1-N model 常规硬件中断，单个的SPI， PPI\n\tOnly one processor handles this interrupt. The system must implement a mechanism to determine\n\twhich processor handles an interrupt that is programmed to target more than one processor.\n\nN-N model 主要SGI， SPI可能会出现\n\tAll processors receive the interrupt independently. When a processor acknowledges the interrupt,\n\tthe interrupt pending state is cleared only for that processor. The interrupt remains pending for the\n\tother processors.\n\n#### 1.4.4. Spurious interrupts （假的中断）\nIt is possible that an interrupt that the GIC has signaled to a processor is no longer required.If this happens, when\nthe processor acknowledges the interrupt, the GIC returns a special Interrupt ID(1020 ~ 1023) that identifies the interrupt as a\nspurious interrupt.\n\nExample reasons for spurious interrupts are:\n• prior to the processor acknowledging an interrupt:\n— software changes the priority of the interrupt\n— software disables the interrupt\n— software changes the processor that the interrupt targets\n• for a 1-N interrupt, another target processor has previously acknowledged that interrupt.\n\n\n## 2. GIC Partitioning\n\n### 2.1 About GIC partitioning\nThe GIC architecture splits logically into a Distributor block and one or more CPU interface blocks. The GIC\nVirtualization Extensions add one or more virtual CPU interfaces to the GIC.\n\nGIC 架构有1个GIC Distributor, 一个或多个CPU Interface， 一个或多个virtual CPU interface（GIC Virtualization Extensions support）\n\nDistributor \n\tThe Distributor block performs interrupt prioritization and distribution to the CPU interface\n\tblocks that connect to the processors in the system.\n\tThe Distributor block registers are identified by the GICD_ prefix.\n\nCPU interfaces \n\tEach CPU interface block performs priority masking and preemption handling for a\n\tconnected processor in the system.\n\n\tWhen describing a GIC that includes the GIC Virtualization Extensions, a CPU interface is\n\tsometimes called a physical CPU interface, to avoid possible confusion with a virtual CPU\n\tinterface.\n\n\tCPU interface block registers are identified by the GICC_ prefix.\n\nVirtual CPU interfaces\t\n\tEach virtual CPU interface is partitioned into the following blocks:\n\t\n\tVirtual interface control\n\t\tThe main component of the virtual interface control block is the GIC virtual\n\t\tinterface control registers, that include a list of active and pending virtual\n\t\tinterrupts for the current virtual machine on the connected processor. \n\t\t\n\t\tTypically, these registers are managed by the hypervisor that is running on that processor.\n\t\t\n\t\tVirtual interface control block registers are identified by the GICH_ prefix.\n\t\n\tVirtual CPU interface\n\t\tEach virtual CPU interface block provides physical signaling of virtual\n\t\tinterrupts to the connected processor. The ARM processor Virtualization\n\t\tExtensions signal these interrupts to the current virtual machine on that\n\t\tprocessor. \n\n\t\tThe GIC virtual CPU interface registers, accessed by the virtual\n\t\tmachine, provide interrupt control and status information for the virtual\n\t\tinterrupts. The format of these registers is similar to the format of the physical\n\t\tCPU interface registers.\n\t\t\n\t\tVirtual CPU interface block registers are identified by the GICV_ prefix.\n\n Note: The virtual CPU interface does not support the power management functionality described\n\n\n A GIC can implement up to eight CPU interfaces, numbered from 0-7.\n In a GIC that implements the GIC Virtualization Extensions, virtual CPU interface numbering corresponds to the CPU interface numbering, so that\nCPU interface 0 and virtual CPU interface 0 connect to the same processor.\n\n一个GIC 最多支持8个CPU， 而 physical CPU interface 与virtual CPU interface 个数对应一样多。\n\n\nFixMe： 补上GIC logical partitioning\n\n### 2.2. The Distributor\n\nThe Distributor provides a programming interface for:\n\t• Globally enabling the forwarding of interrupts to the CPU interfaces.\n\t• Enabling or disabling each interrupt.\n\t• Setting the priority level of each interrupt.\n\t• Setting the target processor list of each interrupt.\n\t• Setting each peripheral interrupt to be level-sensitive or edge-triggered.\n\t• Setting each interrupt as either Group 0 or Group 1.\n\t• Forwarding an SGI to one or more target processors.\nIn addition, the Distributor provides:\n\t• visibility of the state of each interrupt\n\t• a mechanism for software to set or clear the pending state of a peripheral interrupt.\n\n#### 2.2.1 Interrupt IDs\nGICv2 - The GIC assigns interrupt ID numbers ID0-ID1019 as follows:\n\t具有唯一标示\n\tSPI: 32 ~ 1019 \n\n\tbanked interrupt 可重入或重复的中断， 每个CPU 的中断号可相同\n\tPPI: 16 ~ 31\n\tSGI: 0 ~ 15\nIn any system that implements the ARM Security Extensions, to support a consistent model for message passing\nbetween processors, ARM strongly recommends that all processors reserve:\n\t• ID0-ID7 for Non-secure interrupts\n\t• ID8-ID15 for Secure interrupts.\n\nInterrupt numbers ID1020-ID1023\tare reserved for special purposes,\n\n### 2.3. CPU interfaces\nEach CPU interface block provides the interface for a processor that is connected to the GIC.\n\t• enabling the signaling of interrupt requests to the processor\n\t• acknowledging an interrupt\n\t• indicating completion of the processing of an interrupt\n\t• setting an interrupt priority mask for the processor\n\t• defining the preemption policy for the processor\n\t• determining the highest priority pending interrupt for the processor.\n\nGCI CPU interfaces是否拉起中断信号给处理器流程\nSignal interrupt request flow:\n\ttake the highest priorty pending interrupt(read GICC_HPPIR) -> check interrupt priority mask and the preemption settings ->\n\tsignal or ignore interrupt request\n\nCPU获取中断ID\nThe processor acknowledges the interrupt request by reading the CPU interface Interrupt Acknowledge Register.\nThis read returns one of:\n\t• The ID number of the highest priority pending interrupt, if that interrupt is of sufficient priority for it to be\n\tsignaled to the processor. This is the normal response to an interrupt acknowledge.\n\t• Exceptionally, an ID number that indicates a spurious interrupt(1020 ~ 1023)\n\n中断处理完成后\nThere are two stages to interrupt completion:\n\t• priority drop, meaning the priority of the processed interrupt can no longer prevent the signaling of another\n\tinterrupt to the processor\n\t• interrupt deactivation, meaning the Distributor removes the active state of the interrupt.\n\nIn a GICv1 implementation, these two stages always happen together, when the processor writes to the CPU\ninterface End of Interrupt register.\n\nIn a GICv2 implementation, the GICC_CTLR.EOImode bit determines whether:\n\t• the two stages happen together, when the processor writes to the CPU interface End of Interrupt register\n\t• the two stages are separated, so that:\n\t\t— priority drop happens when the processor writes to the CPU interface End of Interrupt register\n\t\t— interrupt deactivation happens later, when the processor writes to the CPU interface Deactivate\n\t\tInterrupt register.\t\n\n#### 2.3.1 Interrupt signal bypass, and GICv2 bypass disable\nIn all GIC implementations, a CPU interface optionally includes interrupt signal bypass, so that, when the signaling\nof an interrupt by the interface is disabled, a system legacy interrupt signal is passed to the interrupt request input\non the processor, bypassing the GIC functionality.\n中断信号旁路，主要支援legacy interrupt 不会受到CPU interface disable的影响，GICv2 must also provide disable bits for the interrupt\nsignal bypass operation.\n\nFixMe 增加Interrupt signal bypass, GICv1 without Security Extensions 图片\n\n#### 2.3.2 Power management, GIC v2\nThe GICv2 architecture supports wakeup events in implementations that require power management.\nThese signals are available even when both interrupt signaling by the GIC, and interrupt bypass, are disabled.\n\n为软件提供预留或回复状态寄存器\nthe GICC_APRn registers provide support for preserving and restoring state in power-management\napplications\nHowever, to ensure that Non-secure accesses do not interfere with Secure operation, Secure and\nNon-secure copies of these registers are provided.\n\n\n### 3 Interrupt Handling and Prioritization\n#### 3.1 About interrupt handling and prioritization\nInterrupt handling describes:\n\t• how the GIC recognizes interrupts\n\t• how software can program the GIC to configure and control interrupts\n\t• the state machine the GIC maintains for each interrupt on each CPU interface\n\t• how the exception model of a processor interacts with the GIC.\n\nPrioritization describes:\n\t• the configuration and control of interrupt priority\n\t• the order of execution of pending interrupts\n\t• the determination of when interrupts are visible to a target processor, including:\n\t\t— interrupt priority masking\n\t\t— priority grouping\n\t\t— preemption of an active interrupt.\n\n\nall implementations of the GIC architecture support interrupt grouping. With interrupt grouping:\n\t• by default, all interrupts are Group 0 interrupts, and are signaled to a connected processor using the IRQ\n\tinterrupt request\n\t• each interrupt can be configured as Group 1 interrupt, or as a Group 0 interrupt\n\t• a CPU interface can be configured to signal Group 0 interrupts to a connected processor using the FIQ\n\tinterrupt request.\t\n\n\n##### 3.1.1 About interrupt handling and prioritization\n\n可以参看 1.4.2. Interrupt types节\n中断类型主要有四种：\n物理中断：SPI，PPI （可边缘，电平触发）\n软中断：SGI\n虚拟中断：virtual interrupt\n维护中断：maintenance interrupt (电平触发)，用于发送key events(具备virtualization extensions GIC)\n\n\n参看 1.4.3. Models for handling interrupts 节\nSGI 使用GIC N-N模型\n物理中断 SPI，PPI 使用GIC 1-N 模型\n\n##### 3.1.2 Identifying the supported interrupts\n中断号的分段参看2.2.1 Interrupt IDs节\n\n软件获知enable 中断\nSoftware can use the GICD_ISENABLERns to discover what interrupt IDs are supported by the GIC。\n\nGICD_ISENABLER0 provides the Set-enable bits for both:\n\t• SGIs, using interrupt IDs 15-0, corresponding to register bits [15:0]\n\t• PPIs, using interrupt IDs 31-16, corresponding to register bits [31:16].\n\nThe remaining GICD_ISENABLERns, from GICD_ISENABLER1, provide the Set-enable bits for the SPIs,\nstarting at interrupt ID 32.\n\nSoftware discovers the interrupts that are supported by:\n1. Reading the GICD_TYPER. The GICD_TYPER.ITLinesNumber field identifies the number of implemented\nGICD_ISENABLERns, and therefore the maximum number of SPIs that might be supported. （获取supported interrupt 总数）\n2. Writing to the GICD_CTLR to disable forwarding of interrupts from the distributor to the CPU interfaces.\nFor more information, see Enabling and disabling the Distributor and CPU interfaces on page 4-77.\n3. For each implemented GICD_ISENABLERn, starting with GICD_ISENABLER0:\n\t• Writing 0xFFFFFFFF to the GICD_ISENABLERn.\n\t• Reading the value of the GICD_ISENABLERn. Bits that read as 1 correspond to supported interrupt IDs.\t\n\n永久使能中断\nSoftware uses the GICD_ICENABLERns to discover the interrupts that are permanently enabled. For each\nimplemented GICD_ICENABLERn, starting with GICD_ICENABLER0, software:\n1. Writes 0xFFFFFFFF to the GICD_ICENABLERn. This disables all interrupts that can be disabled.\n2. Reads the value of the GICD_ICENABLERn. Bits that read as 1 correspond to interrupts that are\npermanently enabled.\n3. Writes 1 to any GICD_ISENABLERn bits corresponding to interrupts that must be re-enabled.\t\n\nThe GIC implements the same number of GICD_ISENABLERns and GICD_ICENABLERns.\n\n#### 3.2 General handling of interrupts\n中断状态分为：(detail see 3.2.4 Interrupt handling state machine)\n - inactive\n - pending\n - active\n - active and pending\n\nGroup, security extension 中断参看 3.4 The effect of interrupt grouping on interrupt handling\nvirtualization extension 中断处理参看 5 GIC Support for Virtualization.\n\n通用中断处理流程：\nWhen the GIC recognizes an interrupt request, it marks its state as pending. Regenerating a pending interrupt does\nnot affect the state of the interrupt.\n\nThe GIC interrupt handling sequence is:\n1. The GIC determines the interrupts that are enabled.\n2. For each pending interrupt, the GIC determines the targeted processor or processors.\n3. For each CPU interface, the Distributor forwards the highest priority pending interrupt that targets that\ninterface.\n4. Each CPU interface determines whether to signal an interrupt request to its processor, and if required, does so.\n5. The processor acknowledges the interrupt, and the GIC returns the interrupt ID and updates the interrupt\nstate.\n6. After processing the interrupt, the processor signals End of Interrupt (EOI) to the GIC.\n\nIn more detail, these steps are as follows:\n1. The GIC determines whether each interrupt is enabled. An interrupt that is not enabled has no effect on the GIC.\n\n2. For each enabled interrupt that is pending, the Distributor determines the targeted processor or processors.\n\n3. For each processor, the Distributor determines the highest priority pending interrupt, based on the priority information it holds for each interrupt, and forwards the interrupt to the targeted CPU interfaces.\n\n4. If the distributor is forwarding an interrupt request to a CPU interface, the CPU interface determines whether the interrupt has Sufficient priority to be signaled to the processor. If the interrupt has sufficient priority, the GIC signals an interrupt request to the processor.\n\n5. When a processor takes the interrupt exception, it reads the GICC_IAR of its CPU interface to acknowledge the interrupt. This read returns an Interrupt ID, and for an SGI, the source processor ID, that the processor uses to select the correct interrupt handler. When it recognizes this read, the GIC changes the state of the interrupt as follows:\n\t• if the pending state of the interrupt persists when the interrupt becomes active, or if the interrupt is generated again, from pending to active and pending.\n\t• otherwise, from pending to active\n\n\t\tNote:\n\t\t• A level-sensitive peripheral interrupt persists when it is acknowledged by the processor, because the\n\t\tinterrupt signal to the GIC remains asserted until the Interrupt Service Routine (ISR) running on the\n\t\tprocessor accesses the peripheral asserting the signal.\n\t\t• In a multiprocessor implementation, the GIC handles:\n\t\t\t— PPIs and SGIs using the GIC N-N model, where the acknowledgement of an interrupt by one\n\t\t\tprocessor has no effect on the state of the interrupt on other CPU interfaces\n\t\t\t— SPIs using the GIC 1-N model, where the acknowledgement of an interrupt by one processor\n\t\t\tremoves the pending status of the interrupt on any other targeted processors, see Implications\n\t\t\tof the 1-N model on page 3-41.\n\t\t• In GICv2, when using a software model with the GICC_CTLR.AckCtl bit set to 0, separate registers\n\t\tare used to manage Group 0 and Group 1 interrupts, as follows:\n\t\t\t— GICC_IAR, GICC_EOIR, and GICC_HPPIR for Group 0 interrupts\n\t\t\t— GICC_AIAR, GICC_AEOIR, and GICC_AHPPIR for Group 1 interrupts.\n\t\tARM deprecates the use of GICC_CTLR.AckCtl, and strongly recommends using a software model\n\t\twhere GICC_CTLR.AckCtl is set to 0, see [3.4.3 The effect of interrupt grouping on interrupt acknowledgement]\n\n6. When the processor has completed handling the interrupt, it must signal this completion to the GIC. As\ndescribed in [3.2.1 Priority drop and interrupt deactivation], this: (通知GIC， EOI 并改写状态到inactive)\n\t• always requires a valid write to an end of interrupt register (EOIR)\n\t• might also require a subsequent write to the deactivate interrupt register, GICC_DIR.\t\n\n写向EOIR 的值是从GICC_IAR 或 GICC_AIAR得到的最近处理的中断号\nFor each CPU interface, the GIC architecture requires the order of the valid writes to an EOIR to be the\nreverse of the order of the reads from the GICC_IAR or GICC_AIAR, so that each valid EOIR write refers\nto the most recent interrupt acknowledge.\n\nA CPU interface never signals to the connected processor any interrupt that is active and pending. It only\nsignals interrupts that are pending and have sufficient priority:\n\t• For PPIs and SGIs, the active status of particular interrupt ID is banked between CPU interfaces. This\n\tmeans that if a particular interrupt ID is active or active and pending on a CPU interface, then no\n\tinterrupt with that same ID is signaled on that CPU interface.\n\t• For SPIs, the active status of an interrupt is common to all CPU interfaces. This means that if an\n\tinterrupt is active or active and pending on one CPU interface then it is not signaled on any CPU\n\tinterface.\n\n\n#### 3.2.1 Priority drop and interrupt deactivation\nWhen a processor completes the processing of an interrupt, it must signal this completion to the GIC. Interrupt\ncompletion requires the following changes to the GIC state:\n\nPriority drop \nPriority drop is the drop in the Running priority that occurs on a valid write to an EOIR, either the\nGICC_EOIR or the GICC_AEOIR.\n\nInterrupt deactivation\nInterrupt deactivation is the change of the state of an interrupt, either:\n\t• from active and pending, to pending\n\t• from active, to idle\n\n在GICv1 中Priority drop  与\tInterrupt deactivation 是同时的。在GICv2 中可以设定setting GICC_CTLR.EOImode to 1 separates the priority drop and interrupt deactivation operations， and interrupt handling software must:\n\t1. Perform a valid EOIR write, to cause priority drop on the GIC CPU interface.\n\t2. Subsequently, write to the GICC_DIR, to deactivate the interrupt.\n\n\nThe GIC architecture specification requires that valid EOIR writes are ordered, so that:\n• a valid GICC_EOIR write corresponds to the most recently acknowledged interrupt\n• a valid GICC_AEOIR write corresponds to the most recently acknowledged Group 1 interrupt.\n• whether a GICC_EOIR write affects Group 0 or Group 1 interrupts depends on both:\n\t— the value of the GICC_CTLR. AckCtl bit\n\t— if the GIC implements the GIC Security Extensions, whether the write is Secure or Non-secure.\n\nNote：\nIn a GICv2 implementation that includes the Security Extensions:\n• GICC_AEOIR is an alias of the Non-secure copy of GICC_EOIR\n• GICC_AIAR is an alias of the Non-secure copy of GICC_IAR\n• GICC_AIAR and GICC_AEOIR are Secure registers, meaning they are accessible only by Secure accesses.\n\n#### 3.2.2 Interrupt controls in the GIC\n\n**Interrupt enables**\nFor peripheral interrupts, a processor:\n• enables an interrupt by writing to the appropriate GICD_ISENABLERn bit\n• disables an interrupt by writing to the appropriate GICD_ICENABLERn bit.\n\n**Setting and clearing pending state of an interrupt**\nFor peripheral interrupts, a processor can:\n• set the pending state by writing to the appropriate GICD_ISPENDRn bit\n• clear the pending state by writing to the appropriate GICD_ICPENDRn bit.\n\nFor a level-sensitive interrupt:\n• If the hardware signal of an interrupt is asserted when a processor writes to the corresponding\nGICD_ICPENDRn bit then the write to the register has no effect on the pending state of the interrupt.\n• If a processor writes a 1 to an GICD_ISPENDRn bit then the corresponding interrupt becomes pending\nregardless of the state of the hardware\nmore detail see [Control of the pending status of level-sensitive interrupts]\n\nFor SGIs, the GIC ignores writes to the corresponding GICD_ISPENDRn and GICD_ICPENDRn bits. A processor\ncannot change the state of a software-generated interrupt by writing to these registers. \nTypically, an SGI is made pending by writing to the GICD_SGIR. In GICv2, the pending state of SGIs can also be modified directly using the\nGICD_SPENDSGIRn and GICD_CPENDSGIRn bits.\n\n**Finding the active or pending state of an interrupt**\nA processor can find:\n• the pending state of an interrupt by reading the corresponding GICD_ISPENDRn or GICD_ICPENDRn bit\n• the active state of an interrupt by reading the corresponding GICD_ISACTIVERn or GICD_ICACTIVERn\nbit.\n\nIn GICv2, the processor that issues the SGI can also be determined by reading the\ncorresponding GICD_SPENDSGIRn or GICD_CPENDSGIRn bits.\n\n**Generating an SGI**\nA processor generates an SGI by writing to an GICD_SGIR. \nThe GICD_SGIR includes optimization for:\n• interrupting only the processor that writes to the GICD_SGIR\n• interrupting all processors other than the one that writes to the GICD_SGIR.\n\nGICD_SGIR 大致包含:\n• interrupt ID\n• source processor\n• target processor.\n\nSGIs from different processors use the same interrupt IDs. Therefore, any target processor can receive SGIs with\nthe same interrupt ID from different processors.\n\nOnly one interrupt with a specific interrupt ID can be active on a CPU interface at any time. This means that a CPU\ninterface cannot have two SGIs with the same interrupt ID active at the same time, even if different processors have\nsignaled SGIs with the same interrupt ID to that processor.\n\nOn the CPU interface of the target processor, reading the GICC_IAR for an SGI returns both the interrupt ID and\nthe CPU ID of the processor that generated the interrupt, the source processor for the interrupt.The combination of\ninterrupt ID and source CPU ID uniquely identifies the interrupt to the target processor.\n\nIn a multiprocessor implementation, the interrupt priority of each SGI interrupt ID is defined independently for each\ntarget processor。\n**For each CPU interface, all SGIs with a particular interrupt ID that are pending on that interface have the same priority and must be handled serially.**\n\n##### 3.2.3 Implications of the 1-N model\n__when the GIC recognizes an interrupt acknowledge from one of the target processors it clears the pending state of the interrupt on all the other targeted processors.__ A GIC implementation must ensure that any interrupt being handled using the 1-N model is only acknowledged by one CPU interface, and that all other interfaces return a spurious\ninterrupt ID.\n\nWhen multiple target processors attempt to acknowledge the interrupt, the following can occur:\n• A processor reads the GICC_IAR and obtains the interrupt ID of the interrupt to be serviced.\n\tNote:  (在多核情况下，通过share memory, lock形式，确保只有一个core 处理中断)\n\tIn GICv1, more than one target processor might have obtained this interrupt ID, if the processors read their\n\tGICC_IAR registers at very similar times. The system might require software on the target processors to\n\tensure that only one processor runs its interrupt service routine. A typical mechanism to achieve this is\n\timplementing, in shared memory, a lock on the interrupt service routine (ISR).\n\n• __A processor reads the GICC_IAR and obtains the interrupt ID 1023, indicating a spurious interrupt. The processor can return from its interrupt service routine without writing to its GICC_EOIR.__\n__The spurious interrupt ID indicates that the original interrupt is no longer pending, typically because another target processor is handling it.__\n\nNote\n\t• A GICv1 implementation might ensure that only one processor can make a 1-N interrupt active, removing\n\tthe requirement for a lock on the ISR. This is not required by the architecture, and generic GIC code must\n\tnot rely on this behavior.（GICv1 不要求在ISR 中lock）\n\t• For any processor, if an interrupt is active and pending, the GIC does not signal an interrupt exception request\n\tfor the interrupt to any processor until the active status is cleared. （如果中断是active且pending 状态，GIC 不会触发此中断给任何processor 直到active 状态清除）\n\n##### 3.2.3 Interrupt handling state machine\n\nFixme 【中断状态机】\n\n**Transition A1 or A2, add pending state**\nFor an SGI, occurs if either:\n• Software writes to a GICD_SGIR that specifies the processor as a target.\n• Software on the target processor writes to the GICD_SPENDSGIRn bit that corresponds to\nthe required source processor and interrupt ID\n\nFor an SPI or PPI, occurs if either:\n• a peripheral asserts an interrupt request signal\n• software writes to an GICD_ISPENDRn\n\n**Transition B1 or B2, remove pending state**\nFor an SGI, occurs if software on the target processor writes to the relevant bit of the\nGICD_CPENDSGIRn.\n\n物理中断\n- 电平触发，pending 会一直拉高直到处理\n- 边缘触发，写GICD_ICPENDRn 寄存器清pending 状态\n\nFor an SPI or PPI, occurs if either:\n• the level-sensitive interrupt is pending only because of the assertion of an input signal, and\nthat signal is deasserted\n• the interrupt is pending only because of the assertion of an edge-triggered interrupt signal, or\na write to an GICD_ISPENDRn, and software writes to the corresponding\nGICD_ICPENDRn.\n\n**Transition C, pending to active**\nIf the interrupt is enabled and of Sufficient priority to be signaled to the processor, occurs when\nsoftware reads from the GICC_IAR.\n\n**Transition D, pending to active and pending**\nFor an SGI, this transition occurs in either of the following circumstances:\n• If a write to set the SGI state to pending occurs at approximately the same time as a read of\nGICC_IAR.\n• When two or more pending SGIs with the same interrupt ID originate from the same source\nprocessor and target the same processor. If one of the SGIs follows transition C, the other\nSGIs follow transition D\n\nFor an SPI or PPI this transition occurs if all the following apply:\n• The interrupt is enabled.\n• Software reads from the GICC_IAR. This read adds the active state to the interrupt.\n• In addition, one of the following conditions applies:\n\t— For a level-sensitive interrupt, the interrupt signal remains asserted. This is usually the\n\tcase, because the peripheral does not deassert the interrupt until the processor has\n\tserviced the interrupt.\n\t— For an edge-triggered interrupt, whether this transition occurs depends on the timing\n\tof the read of the GICC_IAR relative to the detection of the reassertion of the interrupt.\n\tOtherwise the read of the GICC_IAR causes transition C, possibly followed by\n\ttransition A2.\n\n**Transition E1 or E2, remove active state**\nOccurs when software deactivates an interrupt by writing to either GICC_EOIR or GICC_DIR.In a GIC\nimplementation the includes the Virtualization Extensions, also occurs if the virtual CPU interface\nsignals that the corresponding physical interrupt has been deactivated\t\n\n#### 3.3 Interrupt prioritization\nSoftware configures interrupt prioritization in the GIC by assigning a priority value to each interrupt source. Priority\nvalues are 8-bit unsigned binary.A GIC supports a minimum of 16 and a maximum of 256 priority levels. If the\nGIC implements fewer than 256 priority levels, low-order bits of the priority fields are RAZ/WI.\nIn the GIC prioritization scheme, lower numbers have higher priority,\n\n| Implemented priority bits | Possible priority field values | Number of priority levels |\n|:-:|:-:|:-:|\n|[7:0] | 0x00-0xFF (0-255), all values | 256 |\n|[7:1] | 0x00-0xFE, (0-254), even values only | 128 |\n|[7:2] | 0x00-0xFC (0-252), in steps of 4 | 64 |\n|[7:3] | 0x00-0xF8 (0-248), in steps of 8 | 32 |\n|[7:4] | 0x00-0xF0 (0-240), in steps of 16 | 16 |\n\n**The GICD_IPRIORITYRn registers hold the priority value for each supported interrupt.**\n\nTo determine the number of priority bits implemented, software can write 0xFF to a writable GICD_IPRIORITYRn\npriority field, and read back the value stored.\nNote:\nARM recommends that, before checking the priority range in this way:\n• for a peripheral interrupt, software first disables the interrupt\n• for an SGI, software first checks that the interrupt is inactive\n\n##### 3.3.1 Preemption\nA CPU interface supports signaling of higher priority pending interrupts to a target processor before an active\ninterrupt completes. A pending interrupt is only signaled if both:\n• Its priority is higher than the priority mask for that CPU interface, see [Priority masking].\n• Its group priority is higher than that of the Running priority on the CPU interface, see [Priority grouping] and[\nRunning Priority Register, GICC_RPR]\n\nFor a processor that complies with the ARM architecture:\n\t— The value of the I or F bit in the CPSR determines whether the processor responds to the signaled\n\tinterrupt by starting the interrupt acknowledge procedure.\n\t— When processing a preempting interrupt, the processor must save and later restore the context of the\n\tpreviously active ISR.\n\n##### 3.3.2 Priority masking\nCPU Interface 选择高于中断阀门优先级的中断給处理器。\nThe GICC_PMR for a CPU interface defines a priority threshold.The GIC only signals\npending interrupts with a higher priority than this threshold value to the target processor. A value of zero, the register\nreset value, masks all interrupts from being signaled to the associated processor. The GIC does not use priority\ngrouping when comparing the priority of a pending interrupt with the priority threshold.\n\n##### 3.3.3 Priority grouping\n一组相同优先级的中断。\nPriority grouping uses the Binary Point Register, GICC_BPR, to split a priority value into two fields, the group\npriority and the subpriority.When determining preemption, all interrupts with the same group priority are\nconsidered to have equal priority, regardless of the subpriority. This means that there can only be one interrupt active\nat each group priority. The active group priority is also known as the **Preemption level.**\n\n\n主要是用过GICC_BPR 0~2 划分出 GICC_PMR 两个部分：Group priority field 和Subpriority field\nFixME [Table 3-2 Priority grouping by binary point] 图片page 46\n\n#### 3.4 The effect of interrupt grouping on interrupt handling\nA GICv1 implementation that includes the GIC Security Extensions, or any GICv2 implementation, provides two\ninterrupt output signals for IRQ and FIQ exception requests:\n• The CPU interface always uses the IRQ exception request for Group 1 interrupts\n• Software can configure the CPU interface to use either IRQ or FIQ exception requests for Group 0 interrupts\n\n##### 3.4.1 GIC interrupt grouping support\nThe GICD_IGROUPRn registers configure each interrupt as Group 0 or Group 1.\n\nFixMe [CPU interface control of Group 0 and Group 1 interrupts, GICv2] 图片 Page48\n\nIn an implementation that includes the GIC Security Extensions, the alias registers:\n• typically **represent aliases of the Non-secure copy of the Group 0 registers**, for example GICC_ABPR is an\nalias of the Non-Secure copy of GICC_BPR\n• are **accessible only by Secure accesses.**\n\nIn an implementation that supports interrupt grouping, GICC_CTLR contains additional fields, including fields to\ncontrol the handling of the grouped interrupts:\n• Separate enable bits to control the signaling of Group 0 and Group 1 interrupts to the connected processor: （是否支持组中断）\n\t— bit[0], the Enable bit in a GIC that does not support interrupt grouping, becomes the EnableGrp0 bit,\n\tand controls whether Group 0 interrupts are signaled to the processor\n\t— the EnableGrp1 bit is added, to control whether Group 1 interrupts are signaled to the processor.\n• The FIQEn bit, that controls whether the interface signals Group 0 interrupts to the processor using the IRQ\nor FIQ interrupt request. （Group0 是否支持FIQ）\n• The CBPR bit, that controls whether GICC_BPR or GICC_ABPR is used when determining possible\ninterrupt preemption by Group 1 interrupts, see [Control of preemption by Group 1 interrupts] （是否支持抢占）\n• The AckCtl bit, that controls whether a read of the GICC_IAR, or the Secure GICC_IAR if the GIC\nimplements the Security Extensions, can acknowledge a Group 1 interrupt.（是否支持Group1 能从GICC_IAR 读取中断ID，value 0 读到1022保留中断号，否则真实值）\n\n##### 3.4.2 Special interrupt numbers when a GIC supports interrupt grouping\n\n1020-1021 Reserved.\n\n1022 Used only if the GIC supports interrupt grouping.\nThe GIC returns this value to a processor in response to an interrupt acknowledge only when all of\nthe following apply:\n• the interrupt acknowledge is a read of GICC_IAR\n• the highest priority pending interrupt is a Group 1 interrupt\n• GICC_CTLR.AckCtl is set to 0\n• the priority of the interrupt is sufficient for it to be signaled to the processor.\n\tNote:\n\t• Interrupt ID 1022 indicates that there is a Group 1 interrupt of sufficient priority to be\n\tsignaled to the processor, that must be acknowledged by a read of the GICC_AIAR, or in an\n\timplementation that includes the GIC Security Extensions, by a read of the Non-secure\n\tGICC_IAR.\n\n1023 This value is returned to a processor, in response to an interrupt acknowledge, if there is no pending\ninterrupt with sufficient priority for it to be signaled to the processor.\nOn a processor that supports interrupt grouping, values of 1022 and 1023 are spurious interrupt IDs.\n\n##### 3.4.3 The effect of interrupt grouping on interrupt acknowledgement\n\n**When the GICC_CTLR.AckCtl bit is set to 0, to ensure system correctness, every Group 0 interrupt must have a higher priority than any Group 1 interrupt.**\n\nWhen the GICC_CTLR.AckCtl bit is set to 1, a read of GICC_IAR acknowledges the highest-priority pending\ninterrupt on the CPU interface, regardless of whether it is a Group 0 or a Group 1 interrupt. （ARM 极不推荐GICC_CTLR.AckCtl 设定为1）\n\nIn a GIC implementation that supports interrupt grouping, ARM strongly recommends setting GICC_CTLR.AckCtl\nto 0, meaning:\n• for a GICv2 implementation:\n\t— a group 0 interrupt is acknowledged by a read of GICC_IAR, or a Secure read of GICC_IAR if the\n\timplementation includes the GIC Security Extensions\n\t— a group 1 interrupt is acknowledged by a read of GICC_AIAR, or a Non-secure read of GICC_IAR if\n\tthe implementation includes the GIC Security Extensions\n• for a GICv1 implementation:\n\t— a group 0 interrupt must be acknowledged by a read of the Secure GICC_IAR\n\t— a group 1 interrupt must be acknowledged by a read of Non-secure GICC_IAR.\n\nIf the Interrupt Acknowledge register access does not correspond to the highest-priority pending interrupt on the CPU interface then:\n• a read of GICC_IAR when the highest-priority pending interrupt is a Group 1 interrupt returns the spurious\ninterrupt value 1022\n• a read of GICC_AIAR when the highest-priority pending interrupt is a Group 0 interrupt returns the spurious\ninterrupt value 1023.\n\n##### 3.4.4 GIC power on or reset configuration\nOn power-up, or after a reset, a GIC implementation that supports interrupt grouping is configured with:\n• all interrupts assigned to Group 0\n• the FIQ exception request disabled.\n\nFixMe [Reset configuration of a GIC that includes the FIQ exception request]  图片 page52\n\n#### 3.5 Interrupt grouping and interrupt prioritization\nARM strongly recommends that:\n\t• Group 0 interrupts are always assigned priority values in the lower half of the supported priority value range.\n\tThese values correspond to the higher-priority interrupts\n\t• Group 1 interrupts are always assigned priority values in the upper half of the supported priority value range.\n\tThese values correspond to the lower-priority interrupts.\n\nThis ensures that every Group 1 interrupt is of lower priority than any Group 0 interrupt.\n\n##### 3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions\nWhen a processor reads the priority value of a Group 1 interrupt, the GIC returns either the Secure or the Non-secure\nview of that value, depending on whether the access is Secure or Non-secure.\n\nThis is for a GIC that implements the maximum range of priority values.\nFixMe [Figure 3-7 Software views of the priorities of Group 1 and Group 0 interrupts]图片 Page55\n\nFixMe [Table 3-6 Effect of not implementing some priority field bits, with GIC Security Extensions]图片 Page56\n\n\n**Recommendations for managing priority values**\nARM strongly recommends that:\n• for a Group 0 interrupt, software sets bit [7] of the priority value field to 0\n• if using a Secure write to set the priority of a Group 1 interrupt, software sets bit [7] of the priority value field\nto 1.\n\n##### 3.5.2 Control of preemption by Group 1 interrupts\nWhen a GIC implementation supports interrupt grouping, the GICC_BPR is always used to determine whether a\nGroup 0 interrupt is signaled to the processor, for possible preemption.\nBy default, the GICC_ABPR is used to\ndetermine whether a Group 1 interrupt is signaled for possible preemption.\n\nHowever, when GICC_CTLR.CBPR is set to 1, GICC_BPR is used for determining possible preemption, for both Group 0 and Group 1 interrupts.\n\nPriority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0 情况与 [Priority grouping] 类似\n\n#### 3.6 Additional features of the GIC Security Extensions\nSoftware can detect support for the GIC Security Extensions by reading the GICD_TYPER.SecurityExtn bit, see\nInterrupt Controller Type Register, GICD_TYPER on page 4-88.\n\n##### 3.6.1 Access from processors not implementing the ARM Security Extensions\nWhen connecting a processor that does not support the ARM Security Extensions to a GIC that implements the GIC\nSecurity Extensions, typically all processor accesses to the GIC are assigned as either Secure or Non-secure:\n• For a processor making Secure accesses:\n\t— **The processor can control all aspects of the GIC, and therefore can make configuration changes that might affect Secure software running on other processors.**\n\t— In a GICv2 implementation, the processor **uses Secure accesses to aliased registers, such as the GICC_AIAR, to process Group 1 interrupts.**\n\t— Because GICv1 implementations do not include the aliased registers, if the implementation uses\n\tinterrupt grouping the processor might have to use the deprecated GICC_CTLR.AckCtl bit to enable\n\tGroup 1 interrupts to be processed using the standard CPU interface registers.\n\n• For a processor making Non-secure accesses:\n\t— The processor cannot control Group 0 interrupts. For the GIC to be programmed, **the system implementation must include at least one processor that can make Secure accesses.**\n\tA system might use a Secure processor to perform Secure accesses on behalf of a Non-secure\n\tprocessor. This usage model is possible if the GIC or the system provides a method for the Secure\n\tprocessor to access processor-banked copies of registers that belong to the Non-secure processor.\n\t— To **permit a Non-secure processor to control its own Group 0 interrupts, a GICv2 implementation can implement the GICD_NSACRn registers.** An implementation of these registers might permit a Secure\n\tprocessor to permit the use of Non-secure accesses from a particular processor to control some aspects\n\tof the operation of some Group 0 SGIs and SPIs.\n\t— A GIC implementation can configure the GICD_IGROUPRn reset value so that interrupts are Group\n\t1 on reset. see GICD_IGROUPR0 reset value on page 4-92 for more information\n\n\n#### 3.7 Pseudocode details of interrupt handling and prioritization\nskip, see spec\n\n\n#### 3.8 The effect of the Virtualization Extensions on interrupt handling\nsee Chapter 5 GIC Support for Virtualization\n\n#### 3.9 Example GIC usage models\n\nFixMe [Figure 3-8 Generic GIC usage model]图片page 68\n\n##### 3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts\nFixMe [Figure 3-9 Using the GIC to route Secure and Non-secure interrupts]图片page 69\n\nshows a system that implements the GIC Security Extensions, connected to a processor that\nimplements the ARM processor Security Extensions. This implementation:\n• uses Group 0 interrupts as Secure interrupts, signaled as FIQs\n• uses Group 1 interrupts as Non-secure interrupts, signaled as IRQs.\nThis means that, on the processor, FIQ interrupts are never routed to Non-secure software, and IRQ interrupts are\nnever routed to Secure software.\n\nNote：\nThe use of Group 0 and Group 1 interrupts to signal Secure interrupts as FIQs, and Non-secure interrupts as IRQs,\nrequires the processor to:\n• **route FIQs to be taken in Secure Monitor mode**\n• **prevent Non-secure software from masking FIQs**\n• **ensure that IRQs are masked whenever it is operating in Secure state.**\n\nOn a GIC reset, all interrupts are assigned to Group 0, making them Secure interrupts. Secure software on the\nprocessor:\n• programs the GICD_IGROUPRn registers to indicate which interrupts are Group 1, Non-secure\n• sets the Secure GICC_CTLR.FIQEn bit to 1 to configure the CPU interface to use FIQ for Group 0 interrupts.\n• must enable Group 0 interrupts and Group 1 interrupts, independently, in the Distributor: （配置GIC）\n\t— GICD_CTLR.EnableGrp0 enables Group 0 interrupts\n\t— GICD_CTLR.EnableGrp1 enables Group 1 interrupts.\n• must enable Group 0 interrupts and Group 1 interrupts, independently, in the CPU interface: （配置CPU Interface）\n\t— GICC_CTLR.EnableGrp0 enables Group 0 interrupts\n\t— GICC_CTLR.EnableGrp1 enables Group 1 interrupts.\n\n##### 3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions\t\n\nFixMe [Figure 3-10 Using interrupt grouping to route IRQs and FIQs] Page70\n\nOn a GIC reset, for a GIC implementation that supports interrupt grouping, all interrupts are assigned to Group 0.\nTherefore, to use this configuration, software executing on the processor must:\n• Program the GICD_IGROUPRn registers to assign IRQ interrupts to Group 1.\n• Set GICC_CTLR.FIQEn to 1, to assign Group 0 interrupts to FIQ.\n• Set GICC_CTLR.AckCtl to 0, so that both FIQ and IRQ interrupts are acknowledged from the single address\nspace, using:\n\t— the GICC_IAR to acknowledge a Group 0 interrupt\n\t— the GICC_AIAR to acknowledge a Group 1 interrupt\n\t— the GICC_EOIR to indicate completion of a Group 0 interrupt\n\t— the GICC_AEOIR to indicate completion of a Group 1 interrupt.\nHowever, GICC_AIAR and GICC_AEOIR are implemented only in a GICv2 implementation. A processor\noperating with a GICv1 implementation might have to use the deprecated mode of operation with\nGICC_CTLR.AckCtl set to 1(意味着GRP0 GRP1 都是用GICC_IAR, GICC_EOIR).\n• Configure the required binary point support model, by either:\n\t— setting GICC_CTLR.CBPR to 0, so that Group 0 uses GICC_BPR, and Group 1 uses GICC_ABPR\n\t— setting GICC_CTLR.CBPR to 1, so that Group 0 and Group 1 use a common binary point register,\n\tGICC_BPR.\n\n由于没有security, 我们只是人为的将IRQ 分配到GRP1中，将FIQ 分配到GRP0中。因此，并不需要使能GICD_CTLR.EnableGrp0/1 GICC_CTLR.EnableGrp0/1 来让GIC与CPU 支持真正的Group 即security，我们只是使用不同的寄存器\n- GICC_IAR && GICC_AIAR获知ID\n- GICC_EOIR && GICC_AEOIR 结束中断\n- GICC_CTLR.CBPR && GICC_CTLR.ABPR \n\n##### 3.9.3 Supporting IRQs and FIQs in a virtualized processor environment\t\n\nFixme [Figure 3-11 Using the GIC in a virtualized system] page72\n\n• Secure software assigns:\n\t— Secure interrupts to Group 0, signaled to the processor as FIQs\n\t— Non-secure interrupts to Group 1, signaled to the processor as IRQs\n\n• A hypervisor:\n\t— Implements a virtual distributor, using features of the Virtualization Extension on the GIC. This\n\tvirtual distributor can virtualize IRQ interrupts from the GIC as Virtual IRQ and Virtual FIQ\n\tinterrupts, that it routes to an appropriate virtual machine.\n\t— Routes physical IRQs to Hyp mode, so they can be serviced by the virtual distributor\n\n• A Guest OS running on a virtual machine assigns interrupts to Group 0 or Group 1, to assign them as FIQs\nor IRQs, using the model described in [Supporting IRQs and FIQs when not using the processor Security\nExtensions]\n\n\nWhen the GIC signals an IRQ to the processor, the interrupt is routed to Hyp mode. The hypervisor determines\nwhether the interrupt is for itself, or for a Guest OS. If it is for a Guest OS it determines:\n• which Guest OS must handle the interrupt\n• whether that Guest OS has configured the interrupt as an FIQ or as an IRQ\n• the interrupt priority, based on the priority configuration by the target Guest OS.\n\nNote:  (__Guest OS 可能不止一个__)\n• On receiving an IRQ that cannot be handled by the current Guest OS, the hypervisor can either:\n— transfer control to a Guest OS that can handle the interrupt\n— mark the interrupt as pending, as part of the saved context of the appropriate Guest OS.\n• A system can have some interrupts that can be handled by more that one Guest OS, and other interrupts that\nmust be routed to a specific Guest OS.\n\n\nA Guest OS handles a virtual interrupt exactly as it would handle the corresponding physical interrupt. __The Guest OS cannot detect that it is handling a virtual interrupt rather than a physical interrupt.__\n\nGuest OS 并不知道处理的是虚拟中断。\n\n### 4. Programmers’ Model\n\n#### 4.1.1 GIC register names\nAll of the GIC registers have names that provide a short mnemonic for the function of the register. In these names:\n• the first three letters are GIC, indicating a GIC register\n• the fourth letter is one of:\n\t— D, indicating a Distributor register\n\t— C, indicating a CPU interface register\n\t— H, indicating a virtual interface control register, typically accessed by a hypervisor\n\t— V, indicating a virtual CPU interface register.\n\nNote：\nChapter 5 GIC Support for Virtualization describes the GICH_* and GICV_* registers.\n\n#### 4.1.2 Distributor register map\nFixme [Table 4-1 Distributor register map] page74\n\n\n#### 4.1.3 CPU interface register map\nFor a multiprocessor implementation, the GIC implements a set of CPU interface registers for each CPU interface.\n__ARM strongly recommends that each processor has the same CPU interface base address for the CPU interface that connects it to the GIC. This is the private CPU interface base address for that processor.__\n\nFixme [Table 4-2 CPU interface register map] page76\n\n\n#### 4.1.4 GIC register access\nNote:\nIn the GIC architecture, all registers that are halfword-accessible or byte-accessible use a little endian memory order model.\n\nIf the GIC implements the GIC Security Extensions these affect register accesses as follows:\n• some registers are banked, see Register banking\n• some registers are accessible only using Secure accesses\n• optionally, the GIC supports lockdown of the values of some registers\n\n\n__Register banking__\nRegister banking refers to providing multiple copies of a register at the same address.\n\nThe GIC banks registers in the following cases:\n• If the GIC implements the Security Extensions, some registers are banked to provide separate Secure and\nNon-secure copies of the registers. The Secure and Non-secure register bit assignments can differ. A Secure\naccess to the register address accesses the Secure copy of the register, and a Non-secure access accesses the\nNon-secure copy. \n\n• If the GIC is implemented as part of a multiprocessor system:\n\t— Some registers are banked to provide a separate copy for each connected processor. These __include the registers associated with PPIs and SGIs, and the GICD_NSACRn, when implemented.__\n\t— The GIC implements the CPU interface registers __independently for each CPU interface__, and each\n\tconnected processor accesses these registers for the interface it connects to.\n\n#### 4.1.5 Enabling and disabling the Distributor and CPU interfaces\n\n__Implementations that support interrupt grouping__\nIn a GIC that supports interrupt grouping:\n• the GICD_CTLR.EnableGrp0 bit \n• the GICD_CTLR.EnableGrp1 bit \n• the GICC_CTLR.EnableGrp0 bit\n• the GICC_CTLR.EnableGrp1 bit \n\nFor the Distributor:\n• If the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits are both 0:\n\t— __the Distributor does not forward pending interrupts to the CPU interfaces__\n\t— it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the\n\tpending state.\n\t— __reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID__\n\t— software can read or write the Distributor registers\n\t— it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR\n\n• If either, but not both, of the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits is set to \n\t— GICD_CTLR.EnableGrp0 set to 0 and GICD_CTLR.EnableGrp1 set to 1, and the highest priority\n\tpending interrupt is in group 0\n\t— GICD_CTLR.EnableGrp0 set to 1 and GICD_CTLR.EnableGrp1 set to 0, and the highest priority\n\tpending interrupt is in group 1. (ARM 强烈不推荐这样，这样GRP0 优先级是小于GRP1)\n\n__ARM strongly recommends that all Group 0 interrupts are assigned a higher priority than all Group 1 interrupts.__\n\nFor a CPU interface, when GICC_CTLR.AckCtl == 0:\n• When GICC_CTLR.EnableGrp0 == 0\n\t— Group 0 interrupts forwarded from the Distributor are not signaled to the processor\n\t— any read of GICC_IAR returns a spurious interrupt ID\n• When GICC_CTLR.EnableGrp0 == 1, Group 0 interrupts forwarded from the Distributor are signaled to the\nprocessor.\n• When GICC_CTLR.EnableGrp1 == 0\n\t— Group 1 interrupts forwarded from the Distributor are not signaled to the processor\n\t— any read of GICC_AIAR returns a spurious interrupt ID\n• When GICC_CTLR.EnableGrp1 == 1, Group 1 interrupts forwarded from the Distributor are signaled to the\nprocessor\n• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt\nof sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR\nreturns the ID of that interrupt, or a spurious interrupt ID\n\nFor a CPU interface, when GICC_CTLR.AckCtl == 1:\n• When GICC_CTLR.EnableGrp1 == 0, any Non-secure read of GICC_IAR returns a spurious interrupt ID\n• When GICC_CTLR.EnableGrp0 == 0:\n— if GICC_CTLR.EnableGrp1 == 0, any Secure read of GICC_AIAR returns a spurious interrupt ID\n— if GICC_CTLR.EnableGrp1 == 1, Group 0 interrupts are ignored and GICC_IAR behaves as\nGICC_AIAR\n• When GICC_CTLR.EnableGrp1 == 0, a Secure read of GICC_AIAR always returns a spurious interrupt ID\n• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt\nof sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR\nreturns the ID of that interrupt, or a spurious interrupt ID.\n\nNote:\n__ARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl is set to 0.__\n\n---\n\n__Implementations that do not support interrupt grouping__\nIn a GIC that does not support interrupt grouping:\n• the GICD_CTLR.Enable bit controls the forwarding of interrupts from the Distributor to the CPU interfaces\n• the GICC_CTLR.Enable bit controls the signaling of interrupts by the CPU interface to the connected processor.\n\nFor the Distributor:\n• When GICD_CTLR.Enable is set to 1, the Distributor forwards the highest priority pending interrupt for each\nCPU interface, subject to the prioritization rules.\n• When GICD_CTLR.Enable is set to 0:\n\t— the Distributor does not forward pending interrupts to the CPU interfaces\n\t— it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the\n\tpending state.\n\t— reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID\n\t— software can read or write the Distributor registers\n\t— it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR.\n\nFor a CPU interface:\n• When GICC_CTLR.Enable is set to 1, the highest priority pending interrupt forwarded from the Distributor\nto the CPU interface is signaled to the connected processor\n• When GICC_CTLR.Enable is set to 0:\n\t— any pending interrupts forwarded from the Distributor are not signaled to the processor\n\t— software can read or write the CPU interface registers\n\t— any read of the GICC_IAR returns a spurious interrupt ID\n\t— if the Distributor is forwarding an interrupt to the CPU interface, that the interface cannot signal\n\tbecause GICC_CTLR.Enable is set to 0, it is IMPLEMENTATION DEFINED whether a read of\n\tGICC_HPPIR returns the ID of that interrupt, or a spurious interrupt ID.\n\n### 4.2 Effect of the GIC Security Extensions on the programmers’ model\nIf the GIC implements the Security Extensions, __the GICD_TYPER.SecurityExtn bit is RAO.__.\n\nThe GIC Security Extensions provide the following features:\n• The GIC must support interrupt grouping.\n• Register implementations that are consistent with those on a processor that implements the ARM Security\nExtensions, with banked.\n\nThe ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition defines the following ARM Security\nExtensions register types:\n- __Banked__\n\tThe device implements Secure and Non-secure copies of the register. The register bit assignments\n\tcan differ in the Secure and Non-secure copies of a register. A Secure access always accesses the\n\tSecure copy of the register, and a Non-secure access always accesses the Non-secure copy.\n\t\tNote\n\t\tThe GIC can also bank registers when implemented as part of a multiprocessor system, where\n\t\tregisters associated with PPIs or SGIs are banked to provide a separate copy for each connected\n\t\tprocessor.\n- __Secure__\n\tThe register is accessible only from a Secure access. The address of a Secure register is RAZ/WI to\n\tany Non-secure access.\n- __Common__\n\tThe register is accessible from both Secure and Non-secure accesses. The access permissions of\n\tsome or all fields in the register might depend on whether the access is Secure or Non-secure.\n\n| Register \t\t| Type \t\t| Description | \n|:-------------:|:---------:|:-----------:|\n| GICD_CTLR \t| Banked \t| Distributor Control Register | \n| GICD_TYPER \t| Common \t| Interrupt Controller Type Register| \n| GICD_IGROUPRn | Secure \t| Interrupt Group Registers | \n| GICD_SGIR \t| Common \t| Software Generated Interrupt Register | \n| GICC_CTLR \t| Banked \t| CPU Interface Control Register | \n| GICC_BPR \t\t| Banked \t| Binary Point Register | \n| GICC_ABPR \t| Secure \t| Aliased Binary Point Register | \n| GICC_AIAR \t| Secure \t| Aliased Interrupt Acknowledge Register | \n| GICC_AEOIR \t| Secure \t| Aliased End of Interrupt Register | \n| GICC_AHPPIR \t| Secure \t| Aliased Highest Priority Pending Interrupt Register | \n| GICC_NSAPRn \t| Secure \t| Non-secure Active Priorities Registers| \n\n#### 4.2.1 Non-secure access to register fields for Group 0 interrupt priorities\n\nNon-secure access to a priority field in the GICD_IPRIORITYRn\nIf the priority field corresponds to a Group 1 interrupt, the access operates as defined by the\nNon-secure view of interrupt priority, see[Software views of interrupt priority in a GIC that includes\nthe Security Extensions]\n\nNon-secure access to the GICC_PMR and GICC_RPR\n• If the current priority mask value is in the range 0x00-0x7F:\n\t— a read access returns the value 0x00\n\t— the GIC ignores a write access to the GICC_PMR.\n• If the current priority mask value is in the range 0x80-0xFF:\n\t— A read access returns the Non-secure view of the current value.\n\t— A write access to the GICC_PMR succeeds, based on the Non-secure view of the\n\tpriority mask value written to the register. This means a Non-secure write cannot set\n\ta priority mask value in the rage 0x00-0x7F.\n\n#### 4.2.2 Configuration lockdown\nThis provides a control signal that the system can assert to prevent write access to:\n• the register fields controlling a configured range of SPIs, when those SPIs are configured as Group 0\ninterrupts\n• some configuration registers.\n\nWhen the control signal is asserted, the affected register fields and registers are described as being locked down.\n__Lockdown is controlled by an active HIGH disable signal, CFGSDISABLE__. That is, the system asserts\nCFGSDISABLE HIGH to disable write access to the register fields and registers.\n\nThe SPIs that can be locked down are called lockable SPIs (LSPIs).\n• The GICD_TYPER.LSPI field defines the maximum number of LSPIs. If GICD_TYPER.LSPI is greater\nthan 0 then the possible LSPIs have interrupt IDs 32 to (31+(GICD_TYPER.LSPI)).\n\tNote:\n\tGICD_TYPER.LSPI only defines the range of possible LSPIs. The GIC might not support all the interrupts\n\tin this range.\n\nIf GICD_TYPER.LSPI is 0 lockdown is not supported.\n\nWhen the SPI control fields and configuration registers are locked down, the GIC prevents write accesses to:\n• The EnableGrp0 bit of the Secure copy of GICD_CTLR.\n• The following bits in the Secure copy of GICC_CTLR:\n\t— EOImodeS\n\t— IRQBypDisGrp0\n\t— FIQBypDisGrp0\n\t— CBPR\n\t— FIQEn\n\t— AckCtl\n\t— EnableGrp0\n• Fields in the GICD_ISENABLERn, GICD_ICENABLERn, GICD_ISPENDRn, GICD_ICPENDRn,\nGICD_ISACTIVERn, GICD_ICACTIVERn, GICD_IPRIORITYRn, GICD_ITARGETSRn, and\nGICD_ICFGRn registers that correspond to Lockable SPIs that are configured as Group 0:\n• Fields in the GICD_IGROUPRn registers that correspond to lockable SPIs that are configured as Group 0. If\na lockable SPI is reconfigured from Group 1 to Group 0 while CFGSDISABLE remains HIGH, the GIC\nprevents any more writes to GICD_IGROUPRn fields that correspond to that SPI, and the SPI becomes\nlocked.\t\n\n#### 4.3 Distributor register descriptions\nThe following sections describe the Distributor registers:\n• Distributor Control Register, GICD_CTLR on page 4-85\n• Interrupt Controller Type Register, GICD_TYPER on page 4-88\n• Distributor Implementer Identification Register, GICD_IIDR on page 4-90\n• Interrupt Group Registers, GICD_IGROUPRn on page 4-91\n• Interrupt Set-Enable Registers, GICD_ISENABLERn on page 4-93\n• Interrupt Clear-Enable Registers, GICD_ICENABLERn on page 4-95\n• Interrupt Set-Pending Registers, GICD_ISPENDRn on page 4-97\n• Interrupt Clear-Pending Registers, GICD_ICPENDRn on page 4-99\n• Interrupt Set-Active Registers, GICD_ISACTIVERn on page 4-102\n• Interrupt Clear-Active Registers, GICD_ICACTIVERn on page 4-103\n• Interrupt Priority Registers, GICD_IPRIORITYRn on page 4-104\n• Interrupt Processor Targets Registers, GICD_ITARGETSRn on page 4-106\n• Interrupt Configuration Registers, GICD_ICFGRn on page 4-109\n• Non-secure Access Control Registers, GICD_NSACRn on page 4-111\n• Software Generated Interrupt Register, GICD_SGIR on page 4-113\n• SGI Clear-Pending Registers, GICD_CPENDSGIRn on page 4-115\n• SGI Set-Pending Registers, GICD_SPENDSGIRn on page 4-117\n• Identification registers on page 4-119.\n\n##### 4.3.1 Distributor Control Register, GICD_CTLR\nEnables the forwarding of pending interrupts from the Distributor to the CPU interfaces.\n\nFixme [Figure 4-1 GICD_CTLR bit assignments, GICv1 without Security Extensions or Non-secure]图片 Page85\n\nFixme [Figure 4-2 GICD_CTLR bit assignments, GICv2, and GICv1 Secure copy]图片 Page85\n\n##### 4.3.2 Interrupt Controller Type Register, GICD_TYPER\nProvides information about the configuration of the GIC. It indicates:\n• whether the GIC implements the __Security Extensions__\n• the __maximum number of interrupt IDs__ that the GIC supports\n• the __number of CPU interfaces__ implemented\n• if the GIC implements the Security Extensions, the __maximum number of implemented Lockable Shared Peripheral Interrupts (LSPIs)__.\n\nFixme [Figure 4-3 GICD_TYPER bit assignments] 图片Page88\n\n[15:11]  LSPI \t\t\tIf the GIC implements the Security Extensions, the value of this field is the maximum number of\n\t\t\t\t\t\timplemented lockable SPIs, from 0 (0b00000) to 31 (0b11111). If this field is 0b00000 then the GIC does not implement configuration lockdown. If the GIC does not implement the Security Extensions, this field is reserved.\n\n[10] \t SecurityExtn \tIndicates whether the GIC implements the Security Extensions.\n\t\t\t\t\t\t\t0  Security Extensions not implemented.\n\t\t\t\t\t\t\t1  Security Extensions implemented.\t\t\t\t\t\n\n[7:5]   CPUNumber \t\tIndicates the number of implemented CPU interfaces. The number of implemented CPU interfaces is\n\t\t\t\t\t\tone more than the value of this field, for example if this field is 0b011, there are four CPU interfaces. If\n\t\t\t\t\t\tthe GIC implements the Virtualization Extensions, this is also the number of virtual CPU interfaces\t\n\n[4:0]  ITLinesNumber \tIndicates the maximum number of interrupts that the GIC supports.If ITLinesNumber=N, the\n\t\t\t\t\t\tmaximum number of interrupts is 32 * (N+1). interrupt IDs 1020-1023 are reserved for\n\t\t\t\t\t\tspecial purposes\n\nThe ITLinesNumber field only indicates the maximum number of SPIs that the GIC might support. This value\ndetermines the number of implemented interrupt registers, that is, the number of instances of the following registers:\n• GICD_IGROUPRn\n• GICD_ISENABLERn\n• GICD_ICENABLERn\n• GICD_ISPENDRn\n• GICD_ICPENDRn\n• GICD_ISACTIVERn\n• GICD_IPRIORITYRn\n• GICD_ITARGETSRn\n• GICD_ICFGRn.\n\n##### 4.3.3 Distributor Implementer Identification Register, GICD_IIDR\nProvides information about the implementer and revision of the Distributor.\n主要用于记录GIC 的产品ID， 变体ID， 实现公司ID\nFixme [Figure 4-4 GICD_IIDR bit assignments] 图片Page90\n\n##### 4.3.4 Interrupt Group Registers, GICD_IGROUPRn\nThe GICD_IGROUPR registers provide a status bit for each interrupt supported by the GIC.\nEach bit controls whether the corresponding interrupt is in Group 0 or Group 1.\nFixme [Figure 4-5 GICD_IGROUPR bit assignments] 图片Page91\n\n[31:0] Group status bits， For each bit:\n\t0 The corresponding interrupt is Group 0.\n\t1 The corresponding interrupt is Group 1.\n\n__Reset Value__\nOn start-up or reset, each interrupt with ID32 or higher resets as Group 0 and therefore all SPIs are Group 0.\n\n##### 4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn\nThe GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.\nWriting 1 to a Set-enable bit enables forwarding of the corresponding interrupt from the\nDistributor to the CPU interfaces. Reading a bit identifies whether the interrupt is enabled.\n\nThese registers are available in all configurations of the GIC. If the GIC implements the\nSecurity Extensions these registers are Common\n\nIn a multiprocessor implementation, GICD_ISENABLER0 is banked for each connected\nprocessor. This register holds the Set-enable bits for interrupts 0-31.\n\n##### 4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn\nThe GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the\nGIC. Writing 1 to a Clear-enable bit disables forwarding of the corresponding interrupt from\nthe Distributor to the CPU interfaces.\n\nIn a multiprocessor implementation, GICD_ICENABLER0 is banked for each connected\nprocessor. This register holds the Clear-enable bits for interrupts 0-31.\n\n##### 4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn\nThe GICD_ISPENDRs provide a Set-pending bit for each interrupt supported by the GIC.\nWriting 1 to a Set-pending bit sets the status of the corresponding peripheral interrupt to\npending. Reading a bit identifies whether the interrupt is pending.\n\nIn a multiprocessor implementation, GICD_ISPENDR0 is banked for each connected\nprocessor. This register holds the Set-pending bits for interrupts 0-31.\n\nFor SPIs and PPIs\nWrites \n0 \t\tHas no effect.\n1 \t\tThe effect depends on whether the interrupt is edge-triggered or\n\t\tlevel-sensitive.\n\n__Edge-triggered__\nChanges the status of the corresponding interrupt to:\n• pending if it was previously inactive\n• active and pending if it was previously active.\nHas no effect if the interrupt is already pendinga.\n\n__Level sensitive__\nIf the corresponding interrupt is not pendinga, changes the status\nof the corresponding interrupt to:\n• pending if it was previously inactive\n• active and pending if it was previously active.\n\nIf the interrupt is already pendinga:\n• because of a write to the GICD_ISPENDR, the write has\nno effect\n• because the corresponding interrupt signal is asserted, the\nwrite has no effect on the status of the interrupt, but the\ninterrupt remains pendinga if the interrupt signal is\ndeasserted.\n\n##### 4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn\nThe GICD_ICPENDRs provide a Clear-pending bit for each interrupt supported by the GIC.\nWriting 1 to a Clear-pending bit clears the pending state of the corresponding peripheral\ninterrupt. Reading a bit identifies whether the interrupt is pending\n\nIn a multiprocessor implementation, GICD_ICPENDR0 is banked for each connected\nprocessor. This register holds the Clear-pending bits for interrupts 0-31.\n\n##### 4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn\nThe GICD_ISACTIVERs provide a Set-active bit for each interrupt that the GIC supports.\nWriting to a Set-active bit Activates the corresponding interrupt. __These registers are used when preserving and restoring GIC state__\n\nIn a multiprocessor implementation, GICD_ISACTIVER0 is banked for each connected\nprocessor. This register holds the Set-active bits for interrupts 0-31.\n\n##### 4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn\nThe GICD_ICACTIVERs provide a Clear-active bit for each interrupt that the GIC\nsupports. Writing to a Clear-active bit Deactivates the corresponding interrupt. These\nregisters are used when preserving and restoring GIC state.\n\nIn a multiprocessor implementation, GICD_ICACTIVER0 is banked for each connected\nprocessor. This register holds the Clear-active bits for interrupts 0-31.\n\n##### 4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn\nThe GICD_IPRIORITYRs __provide an 8-bit priority field for each interrupt__ supported by the\nGIC. This field stores the priority of the corresponding interrupt.\n\nA GIC might implement fewer than eight priority bits, but must implement at least bits [7:4]\nof each field. In each field, unimplemented bits are RAZ/WI. see [3.3 Interrupt prioritization]\n我们可以实现CPU Interface 的Group level.\n\nIn a multiprocessor implementation, GICD_IPRIORITYR0 to GICD_IPRIORITYR7 are\nbanked for each connected processor. These registers hold the Priority fields for interrupts\n0-31.\n\nFixme [Figure 4-13 GICD_IPRIORITYR bit assignments] 图片Page104\n\n##### 4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn\nThe GICD_ITARGETSRs __provide an 8-bit CPU targets field for each interrupt supported__\nby the GIC. __This field stores the list of target processors for the interrupt.__ That is, it holds\nthe list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and\nhas sufficient priority.\n\nIn a multiprocessor implementation, GICD_ITARGETSR0 to GICD_ITARGETSR7 are\nbanked for each connected processor. These registers hold the CPU targets fields for\ninterrupts 0-31.\n\nFixme [Figure 4-14 GICD_ITARGETSR bit assignments] 图片Page106\n\nTable 4-17 shows how each bit of a CPU targets field targets the interrupt at one of the CPU interfaces.\nFixme [Table 4-17 Meaning of CPU targets field bit values] 图片Page107\n\n\nSoftware can write to an GICD_ITARGETSR at any time.  （对Active无效，对pending 的有效）\nAny change to a CPU targets field value:\n• Has no effect on any active interrupt. This means that removing a CPU interface from a targets list does not\ncancel an active state for that interrupt on that CPU interface.\n• Has an effect on any pending interrupts. This means:\n\t— adding a CPU interface to the target list of a pending interrupt makes that interrupt pending on that\n\tCPU interface\n\t— removing a CPU interface from the target list of a pending interrupt removes the pending state of that\n\tinterrupt on that CPU interface\n• If it applies to an interrupt that is active and pending, does not change the interrupt targets until the active\nstatus is cleared.\t\n\n##### 4.3.13 Interrupt Configuration Registers, GICD_ICFGRn\n__The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC__.\nThis field identifies whether the corresponding interrupt is __edge-triggered or level-sensitive.__\n\nFixme [Figure 4-15 GICD_ICFGR bit assignments] 图片Page109\n\nFor SGIs, Int_config fields are read-only, meaning that GICD_ICFGR0 is read-only.\nBefore changing the value of a programmable Int_config field, software must disable the\ncorresponding interrupt, otherwise GIC behavior is UNPREDICTABLE.\n\nThese registers are available in all configurations of the GIC. If the GIC implements the\nSecurity Extensions these registers are Common.\nIn a multiprocessor implementation, if bit[1] of the Int_config field for any PPI is\nprogrammable then GICD_ICFGR1 is banked for each connected processor. This register\nholds the Int_config fields for the PPIs, interrupts 16-31.\n\nBITS        Name                        Function\n[2F+1:2F] \tInt_config, field F \t\tFor Int_config[1], the most significant bit, bit [2F+1], the encoding is:\n\t\t\t\t\t\t\t\t\t\t0 Corresponding interrupt is level-sensitive.\n\t\t\t\t\t\t\t\t\t\t1 Corresponding interrupt is edge-triggered.\n\t\t\t\t\t\t\t\t\t\tInt_config[0], the least significant bit, bit [2F], is reserved, but see Table 4-19 for the encoding of\n\t\t\t\t\t\t\t\t\t\tthis bit on some early implementations of this GIC architecture.\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tFor SGIs:\n\t\t\t\t\t\t\t\t\t\tInt_config[1] Not programmable, RAO/WI.\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tFor PPIs and SPIs:\n\t\t\t\t\t\t\t\t\t\tInt_config[1] For SPIs, this bit is programmable.a For PPIs it is IMPLEMENTATION DEFINED\n\t\t\t\t\t\t\t\t\t\twhether this bit is programmable. A read of this bit always returns the correct value\n\t\t\t\t\t\t\t\t\t\tto indicate whether the corresponding interrupt is level-sensitive or edge-triggered.\n\n\n##### 4.3.14 Non-secure Access Control Registers, GICD_NSACRn\nThe GICD_NSACRs enable Secure software to permit Non-secure software on a particular\nprocessor to create and manage Group 0 interrupts. They provide an access control for each\nimplemented interrupt.\n\nThe GICD_NSACRn registers do not support PPI accesses, meaning that GICD_NSACR0 bits [31:16] are\nRAZ/WI.\n\nFixme [Figure 4-16 GICD_NSACR bit assignments] 图片Page111\n\nBITS            Name                    Function\n[2F+1:2F] \t\tNS_access, Field F \t\tIf the corresponding interrupt does not support configurable Non-secure access, the field is\n\t\t\t\t\t\t\t\t\t\tRAZ/WI. Otherwise, the field is RW and configures the level of Non-secure access permitted\n\t\t\t\t\t\t\t\t\t\twhen the interrupt is in Group 0. If the interrupt is in Group 1, this field is ignored. The possible\n\t\t\t\t\t\t\t\t\t\tvalues of the field are:\n\n\t\t\t\t\t\t\t\t\t\t0b00 No Non-secure access is permitted to fields associated with the corresponding\n\t\t\t\t\t\t\t\t\t\tinterrupt.\n\n\t\t\t\t\t\t\t\t\t\t0b01 Non-secure write access is permitted to fields associated with the corresponding\n\t\t\t\t\t\t\t\t\t\tinterrupt in the GICD_ISPENDRn registers. A Non-secure write access to\n\t\t\t\t\t\t\t\t\t\tGICD_SGIR is permitted to generate a Group 0 SGI for the corresponding\n\t\t\t\t\t\t\t\t\t\tinterrupt.\n\n\t\t\t\t\t\t\t\t\t\t0b10 Adds Non-secure write access permission to fields associated with the\n\t\t\t\t\t\t\t\t\t\tcorresponding interrupt in the GICD_ICPENDRn registers. Also adds\n\t\t\t\t\t\t\t\t\t\tNon-secure read access permission to fields associated with the corresponding\n\t\t\t\t\t\t\t\t\t\tinterrupt in the GICD_ISACTIVERn and GICD_ICACTIVERn registers.\n\n\t\t\t\t\t\t\t\t\t\t0b11 Adds Non-secure read and write access permission to fields associated with the\n\t\t\t\t\t\t\t\t\t\tcorresponding interrupt in the GICD_ITARGETSRn registers\n\n\n##### 4.3.15 Software Generated Interrupt Register, GICD_SGIR\t\t\t\t\t\t\t\t\t\t\nThis register is available in all configurations of the GIC. If the GIC implements the\nSecurity Extensions(read GICD_TYPER) this register is Common.\nThe NSATT field, bit [15], is implemented only if the GIC implements the Security\nExtensions.\n\nFixme [Figure 4-17 GICD_SGIR bit assignments] 图片Page113\n\n\n\nBits \t\tName \t\t\t\tFunction\n[31:26] \t- \t\t\t\t\treserved.\n[25:24] \tTargetListFilter \tDetermines how the distributor must process the requested SGI:\n\t\t\t\t\t\t\t\t0b00 Forward the interrupt to the CPU interfaces specified in the CPUTargetList fielda.\n\t\t\t\t\t\t\t\t0b01 Forward the interrupt to all CPU interfaces except that of the processor that requested the\n\t\t\t\t\t\t\t\tinterrupt.\n\t\t\t\t\t\t\t\t0b10 Forward the interrupt only to the CPU interface of the processor that requested the\n\t\t\t\t\t\t\t\tinterrupt.\n\t\t\t\t\t\t\t\t0b11 Reserved.\n[23:16] \tCPUTargetList \t\tWhen TargetList Filter = 0b00, defines the CPU interfaces to which the Distributor must forward the\n\t\t\t\t\t\t\t\tinterrupt.\n\t\t\t\t\t\t\t\tEach bit of CPUTargetList[7:0] refers to the corresponding CPU interface, for example\n\t\t\t\t\t\t\t\tCPUTargetList[0] corresponds to CPU interface 0. Setting a bit to 1 indicates that the interrupt must be\n\t\t\t\t\t\t\t\tforwarded to the corresponding interface.\n\t\t\t\t\t\t\t\tIf this field is 0x00 when TargetListFilter is 0b00, the Distributor does not forward the interrupt to any\n\t\t\t\t\t\t\t\tCPU interface.\n[15] \t\tNSATT \t\t\t\tImplemented only if the GIC includes the Security Extensions.\n\t\t\t\t\t\t\t\tSpecifies the required security value of the SGI:\n\t\t\t\t\t\t\t\t0 Forward the SGI specified in the SGIINTID field to a specified CPU interface only if the\n\t\t\t\t\t\t\t\tSGI is configured as Group 0 on that interface.\n\t\t\t\t\t\t\t\t1 Forward the SGI specified in the SGIINTID field to a specified CPU interfaces only if\n\t\t\t\t\t\t\t\tthe SGI is configured as Group 1 on that interface.\n\t\t\t\t\t\t\t\tThis field is writable only by a Secure access. Any Non-secure write to the GICD_SGIR generates an\n\t\t\t\t\t\t\t\tSGI only if the specified SGI is programmed as Group 1, regardless of the value of bit[15] of the write.\n\t\t\t\t\t\t\t\tSee SGI generation when the GIC implements the Security Extensions for more information.\n\t\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\t\tIf GIC does not implement the Security Extensions, this field is reserved.\n[3:0] \t\tSGIINTID \t\t\tThe Interrupt ID of the SGI to forward to the specified CPU interfaces. The value of this field is the\n\t\t\t\t\t\t\t\tInterrupt ID, in the range 0-15, for example a value of 0b0011 specifies Interrupt ID 3.\t\t\t\t\t\t\n\n__SGI generation when the GIC implements the Security Extensions__\nIf the GIC implements the Security Extensions, whether an SGI is forwarded to a processor specified in the write\nto the GICD_SGIR depends on:\n• whether the write to the GICD_SGIR is Group 0 (Secure) or Group 1 (Non-secure)\n• for a Secure write to the GICD_SGIR, the value of the GICD_SGIR.NSATT bit\n• whether the specified SGI is configured as Group 0 (Secure) or Group 1 (Non-secure) on the targeted\nprocessor.\n\nFixme [Table 4-22 Truth table for sending an SGI to a target processor] Page 114\n\n##### 4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn\nThe GICD_CPENDSGIRs provide a clear-pending bit for each supported SGI and source\nprocessor combination. When a processor writes a 1 to a clear-pending bit, the pending state\nof the corresponding SGI for the corresponding source processor is removed, and no longer\ntargets the processor performing the write.\n\nNote\n• __In a multiprocessor implementation, the processor accessing the register can change the SGI pending status only on the corresponding interface. Changing the pending status of an SGI for one target processor does not affect the status of that SGI on any other processor.__\n• PPIs and SPIs both use the Interrupt Clear-Pending registers, GICD_ICPENDRn\n\nThese registers are present only in GICv2. The register locations are reserved in GICv1.In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.\n\nFour SGI Clear-Pending registers are implemented.each register contains eight clear-pending bits for each of four SGIs.\nIn a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.\n\n一共四个 GICD_CPENDSGIR寄存器，每个寄存器含有四个8 bits，分别代表了四个SGIs。\n\nFixme [Figure 4-18 GICD_CPENDSGIR bit assignments] Page 115\n\nBits \t\t\t\t\t\tName \t\t\t\t\t\tFunction\n[8y+7:8y], for y=0 to 3     SGI x Clear-pending bits  \tFor each bit:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tReads \t0 SGI x from the corresponding processor is not pendinga.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1 SGI x from the corresponding processor is pendinga.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tWrites \t0 Has no effect.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1 Removes the pending state of SGI x for the corresponding processor\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tAll accesses relate only to SGIs that target the processor making the access.\n\n\n\n##### 4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn\nThe GICD_SPENDSGIRn registers provide a set-pending bit for each supported SGI and\nsource processor combination. When a processor writes a 1 to a set-pending bit, the pending\nstate is applied to the corresponding SGI for the corresponding source processor.\n\nFixme [Figure 4-19 GICD_SPENDSGIR bit assignments] page 117\n\nBits Name Function\n[8y+7:8y], for y=0 to 3   SGI x Set-pending bits\tFor each bit:\n\t\t\t\t\t\t\t\t\t\t\t\t\tReads \t0 SGI x for the corresponding processor is not pendinga.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t1 SGI x for the corresponding processor is pendinga.\n\t\t\t\t\t\t\t\t\t\t\t\t\tWrites \t0 Has no effect.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1 Adds the pending state of SGI x for the corresponding processor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif it is not already pending. If SGI x is already pending for the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcorresponding processor then the write has no effect.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\t\t\t\t\t\t\tAll accesses relate only to SGIs that target the processor making the access.\n\n##### 4.3.18 Identification registers\nThis architecture specification defines offsets 0xFD0-0xFFC in the Distributor register map as a read-only\nidentification register space.\n\nFixme [Table 4-25 The GIC identification register space] page119\n\n__Peripheral ID2 Register, ICPIDR2__\nFixme [Figure 4-20 ICPIDR2 bit assignments] page119\n\n\nBits \tName \t\tFunction\n[7:4] \tArchRev \tRevision field for the GIC architecture. The value of this field depends on the GIC architecture version:\n\t\t\t\t\t• 0x1 for GICv1\n\t\t\t\t\t• 0x2 for GICv2.\n\n#### 4.4 CPU interface register descriptions\n\n##### 4.4.1 CPU Interface Control Register, GICC_CTLR\nEnables the signaling of interrupts by the CPU interface to the connected processor, and\nprovides additional top-level control of the CPU interface. In a GICv2 implementation, this\nincludes control of the end of interrupt (EOI) behavior.\n\n有几种类型的结构：\n__for a GICv1 implementation, for__\n• an implementation that does not include the Security Extensions\n• the Non-secure copy of the register, in an implementation that includes the Security Extensions.\nFixme [Figure 4-22 GICC_CTLR bit assignments, GICv1 without Security Extensions or Non-secure] page 126\n\n__a GIC v2 implementation that includes the Security Extensions, for the Non-secure copy of the register__\nFixme [Figure 4-23 GICC_CTLR bit assignments, GICv2 with Security Extensions, Non-secure copy] page 126\n\nBits \t\tName \t\t\tFunction\n[9] \t\tEOImodeNS \t\tControls the behavior of Non-secure accesses to the GICC_EOIR and GICC_DIR registers:\n\t\t\t\t\t\t\t0 \tGICC_EOIR has both priority drop and deactivate interrupt functionality.\n\t\t\t\t\t\t\t\tAccesses to the GICC_DIR are UNPREDICTABLE.\n\t\t\t\t\t\t\t1 \tGICC_EOIR has priority drop functionality only. The GICC_DIR register has\n\t\t\t\t\t\t\t\tdeactivate interrupt functionality.\n\n[6] \t\tIRQBypDisGrp1 \tWhen the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the\n\t\t\t\t\t\t\tbypass IRQ signal is signaled to the processor:\n\t\t\t\t\t\t\t0 \tBypass IRQ signal is signaled to the processor\n\t\t\t\t\t\t\t1 \tBypass IRQ signal is not signaled to the processor.\n\n[5] \t\tFIQBypDisGrp1 \tWhen the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the\n\t\t\t\t\t\t\tbypass FIQ signal is signaled to the processor:\n\t\t\t\t\t\t\t0 \tBypass FIQ signal is signaled to the processor\n\t\t\t\t\t\t\t1 \tBypass FIQ signal is not signaled to the processor.\n\n[0] \t\tEnableGrp1 \t\tEnable for the signaling of Group 1 interrupts by the CPU interface to the connected processor.\n\t\t\t\t\t\t\t0 Disable signaling of interrupts\n\t\t\t\t\t\t\t1 Enable signaling of interrupts.\n\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\tWhen this bit is set to 0, the CPU interface ignores any pending Group 1 interrupt forwarded to\n\t\t\t\t\t\t\tit. When this bit is set to 1, the CPU interface starts to process pending Group 1 interrupts that are\n\t\t\t\t\t\t\tforwarded to it. There is a small but finite time required for a change to take effect.\n\t\t\t\t\t\n__Security Extensions, for the Secure copy of the register__\n• a GICv2 implementation, for:\n— an implementation that does not include the Security Extensions\n— the Secure copy of the register, in an implementation that includes the Security Extensions\n• a GICv1 implementation that includes the Security Extensions, for the Secure copy of the register\n\nFixme [Figure 4-24 GICC_CTLR bit assignments, GICv2 without Security Extensions or Secure] page 128\n\n\nBits \t\tName \t\t\tFunction\n[10] \t\tEOImodeNS \t\tAlias of EOImodeNS from the Non-secure copy of this register, see Table 4-30 on page 4-126.\n\t\t\t\t\t\t\tIn a GICv2 implementation that does not include the Security Extensions, and in a GICv1\n\t\t\t\t\t\t\timplementation, this bit is reserved.\n\n[9] \t\tEOImodeS \t\tControls the behavior of accesses to GICC_EOIR and GICC_DIR registers. In a GIC implementation\n\t\t\t\t\t\t\tthat includes the Security Extensions, this control applies only to Secure accesses, and the EOImodeNS\n\t\t\t\t\t\t\tbit controls the behavior of Non-secure accesses to these registers:\n\t\t\t\t\t\t\t0 \t\tGICC_EOIR has both priority drop and deactivate interrupt functionality. Accesses to\n\t\t\t\t\t\t\t\t\tthe GICC_DIR are UNPREDICTABLE.\n\t\t\t\t\t\t\t1 \t\tGICC_EOIR has priority drop functionality only. GICC_DIR has deactivate interrupt\n\t\t\t\t\t\t\t\t\tfunctionality.\n\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\tThis bit is called EOImode in a GIC implementation that does not include the Security Extensions.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved.\n\n[8] \t\tIRQBypDisGrp1 \tAlias of IRQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved\n\n[7] \t\tFIQBypDisGrp1\tAlias of FIQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved.\t\t\t\t\t\t\t\n\n[6] \t\tIRQBypDisGrp0 \tWhen the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the bypass\n\t\t\t\t\t\t\tIRQ signal is signaled to the processor:\n\t\t\t\t\t\t\t0 \t\tBypass IRQ signal is signaled to the processor\n\t\t\t\t\t\t\t1 \t\tBypass IRQ signal is not signaled to the processor.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved.\n\n[5] \t\tFIQBypDisGrp0\tWhen the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the bypass\n\t\t\t\t\t\t\tFIQ signal is signaled to the processor:\n\t\t\t\t\t\t\t0 \t\tBypass FIQ signal is signaled to the processor\n\t\t\t\t\t\t\t1 \t\tBypass FIQ signal is not signaled to the processor.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved.\n\n[4] \t\tCBPR \t\t\tControls whether the GICC_BPR provides common control to Group 0 and Group 1 interrupts.\n\t\t\t\t\t\t\t0 \t\tTo determine any preemption, use:\n\t\t\t\t\t\t\t\t\t• the GICC_BPR for Group 0 interrupts\n\t\t\t\t\t\t\t\t\t• the GICC_ABPR for Group 1 interrupts.\n\t\t\t\t\t\t\t1 \t\tTo determine any preemption use the GICC_BPR for both Group 0 and Group 1\n\t\t\t\t\t\t\t\t\tinterrupts.\n\n[3] \t\tFIQEn \t\t\tControls whether the CPU interface signals Group 0 interrupts to a target processor using the FIQ or\n\t\t\t\t\t\t\tthe IRQ signal.\n\t\t\t\t\t\t\t0 \t\tSignal Group 0 interrupts using the IRQ signal.\n\t\t\t\t\t\t\t1 \t\tSignal Group 0 interrupts using the FIQ signal.\n\t\t\t\t\t\t\tThe GIC always signals Group 1 interrupts using the IRQ signal.\n\n[2] \t\tAckCtl \t\t\tWhen the highest priority pending interrupt is a Group 1 interrupt, determines both:\n\t\t\t\t\t\t\t• whether a read of GICC_IAR acknowledges the interrupt, or returns a spurious interrupt ID\n\t\t\t\t\t\t\t• whether a read of GICC_HPPIR returns the ID of the highest priority pending interrupt, or\n\t\t\t\t\t\t\t\treturns a spurious interrupt ID.\n\n\t\t\t\t\t\t\t0 \t\tIf the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR\n\t\t\t\t\t\t\t\t\tor the GICC_HPPIR returns an Interrupt ID of 1022. A read of the GICC_IAR does\n\t\t\t\t\t\t\t\t\tnot acknowledge the interrupt, and has no effect on the pending status of the interrupt.\n\t\t\t\t\t\t\t1 \t\tIf the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR\n\t\t\t\t\t\t\t\t\tor the GICC_HPPIR returns the Interrupt ID of the Group 1 interrupt. A read of\n\t\t\t\t\t\t\t\t\tGICC_IAR acknowledges and Activates the interrupt.\n\t\t\t\t\t\t\tIn a GIC implementation that includes the Security Extensions, this control affects only the behavior\n\t\t\t\t\t\t\tof Secure register accesses.\n\t\t\t\t\t\t\tFor more information, see:\n\t\t\t\t\t\t\t• The effect of interrupt grouping on interrupt acknowledgement on page 3-50\n\t\t\t\t\t\t\t• Interrupt grouping and interrupt prioritization on page 3-53\n\t\t\t\t\t\t\t• Behavior of writes to GICC_EOIR, GICv1 with Security Extensions on page 4-139\n\t\t\t\t\t\t\t• Effect of interrupt grouping and the Security Extensions on reads of the GICC_HPPIR on\n\t\t\t\t\t\t\tpage 4-143.\n\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\tARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where\n\t\t\t\t\t\t\tGICC_CTLR.AckCtl is set to 0. See Enabling and disabling the Distributor and CPU interfaces on\n\t\t\t\t\t\t\tpage 4-77 for more information about the effects of setting this bit.\n\n[1] \t\tEnableGrp1 \t\tEnable for the signaling of Group 1 interrupts by the CPU interface to the connected processor:\n\t\t\t\t\t\t\t0 \t\tDisable signaling of Group 1 interrupts.\n\t\t\t\t\t\t\t1 \t\tEnable signaling of Group 1 interrupts.\n\n[0] \t\tEnableGrp0 \t\tEnable for the signaling of Group 0 interrupts by the CPU interface to the connected processor:\n\t\t\t\t\t\t\t0 \t\tDisable signaling of Group 0 interrupts.\n\t\t\t\t\t\t\t1 \t\tEnable signaling of Group 0 interrupts.\n\n\n##### 4.4.2 Interrupt Priority Mask Register, GICC_PMR\n__Provides an interrupt priority filter. Only interrupts with higher priority than the value in this register are signaled to the processor__\n\nFixme [Figure 4-25 GICC_PMR bit assignments] page131\n\n##### 4.4.3 Binary Point Register, GICC_BPR\nThe register defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field is used to determine __interrupt preemption.__\n\nFixme [Figure 4-26 GICC_BPR bit assignments] page133\n\nsee:\nTable 3-2 Priority grouping by binary point\nTable 3-7 Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0\n\n##### 4.4.4 Interrupt Acknowledge Register, GICC_IAR\nThe processor reads this register to obtain the interrupt ID of the signaled interrupt. This\nread acts as an acknowledge for the interrupt.\n\nWhen GICC_CTLR.AckCtl is set to 0 in a GICv2 implementation that does not include the\nSecurity Extensions, if the highest priority pending interrupt is in Group 1, the interrupt ID\n1022 is returned.\n\nFixme [Figure 4-27 GICC_IAR bit assignments] page135.\n\nBit \t\tName \t\t\tFunction\n[31:13] \t- \t\t\t\tReserved.\n[12:10] \tCPUID \t\t\t__For SGIs in a multiprocessor implementation__, this field identifies the processor that\n\t\t\t\t\t\t\trequested the interrupt. It returns the number of the CPU interface that made the\n\t\t\t\t\t\t\trequest, for example a value of 3 means the request was generated by a write to the\n\t\t\t\t\t\t\tGICD_SGIR on CPU interface 3.\n\t\t\t\t\t\t\tFor all other interrupts this field is RAZ.\n[9:0] \t\tInterrupt ID \tThe interrupt ID.\n\nThe read returns a spurious interrupt ID of 1023 if any of the following apply:\n• forwarding of interrupts by the Distributor to the CPU interface is disabled\n• signaling of interrupts by the CPU interface to the connected processor is disabled\n• no pending interrupt on the CPU interface has sufficient priority for the interface to signal it to the processor\n\n\nA non-spurious interrupt ID returned by a read of the GICC_IAR is called a valid interrupt ID.\n__When the GIC returns a valid interrupt ID to a read of the GICC_IAR it treats the read as an acknowledge of that interrupt and, as a side-effect of the read, changes the interrupt status from pending to active, or to active and pending if the pending state of the interrupt persists.__\n\nNote\n• For compatibility with possible extensions to the GIC architecture specification, ARM recommends that\nsoftware preserves the entire register value read from the GICC_IAR, and writes that value back to the\nGICC_EOIR when it has completed its processing of the interrupt.\n• Although multiple target processors might attempt to read the GICC_IAR at any time, in GICv2 only one\nprocessor can obtain a valid interrupt ID, see Implications of the 1-N model on page 3-41 for more\ninformation.\n\n\nFixme [Table 4-35 Effect of interrupt grouping and the Security Extensions on reads of GICC_IAR]Page136\n\n##### 4.4.5 End of Interrupt Register, GICC_EOIR\nA processor writes to this register to inform the CPU interface either:\n• that it has completed the processing of the specified interrupt\n• in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set\nto 1, to indicate that the interface should perform priority drop for the specified\ninterrupt. See Priority drop and interrupt deactivation on page 3-38 for more information.\n\nFixme [Figure 4-28 GICC_EOIR bit assignments]Page138\n\nFixme [Table 4-36 GICC_EOIR bit assignments]Page138\n\nFor every read of a valid Interrupt ID from the GICC_IAR, the connected processor must perform a matching write\nto the GICC_EOIR. The value written to the GICC_EOIR must be the interrupt ID read from the GICC_IAR.\nIf a read of the GICC_IAR returns the ID of a spurious interrupt, software does not have to make a corresponding\nwrite to the GICC_EOIR. If software writes the ID of a spurious interrupt to the GICC_EOIR, the GIC ignores that\nwrite.\n\n__Behavior of writes to GICC_EOIR, GICv2__\nIn a GICv2 implementation, when GICC_CTLR.AckCtl is set to 0:\n• GICC_EOIR is used for processing Group 0 interrupts\n• GICC_AEOIR is used for processing Group 1 interrupts.\n\nIn a GICv2 implementation that includes the GIC Security Extensions:\n• GICC_CTLR.EOImodeS controls the behavior of Secure accesses to GICC_EOIR and GICC_AEOIR\n• GICC_CTLR.EOImodeNS controls the behavior of Non-secure accesses to GICC_EOIR\n• when GICC_CTLR.AckCtl is set to 0:\n\t— a Non-secure write to GICC_EOIR must correspond to the most recent Non-secure read of GICC_IAR\n\t— a Secure write to the GICC_AEOIR must correspond to the most recent Secure read of the\n\tGICC_AIAR.\n\n##### 4.4.6 Running Priority Register, GICC_RPR\nIndicates the Running priority of the CPU interface\n\nFixme [Figure 4-29 GICC_RPR bit assignments] page142\n\n##### 4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR\nIndicates the Interrupt ID, and processor ID if appropriate, of the __highest priority pending__\ninterrupt on the CPU interface.\n\nFixme [Figure 4-30 GICC_HPPIR bit assignments] Page143\n\nBit\t\t\tName \t\tDescription\n[31:13] \t- \t\t\tReserved.\n[12:10] \tCPUID \t\tOn a multiprocessor implementation, if the PENDINTID field returns the ID of an\n\t\t\t\t\t\tSGI, this field contains the CPUID value for that interrupt. This identifies the\n\t\t\t\t\t\tprocessor that generated the interrupt.\n[9:0] \t\tPENDINTID \tThe interrupt ID of the highest priority pending interrupt. See Table 4-42 on\n\t\t\t\t\t\tpage 4-144 for more information about the result of Non-secure reads of the\n\t\t\t\t\t\tGICC_HPPIR when the GIC implements the Security Extensions.\n\n##### 4.4.8 Aliased Binary Point Register, GICC_ABPR\n##### 4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR\n##### 4.4.10 Aliased End of Interrupt Register, GICC_AEOIR\n##### 4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR\n与前面对应相似\n\n##### 4.4.12 Active Priorities Registers, GICC_APRn\n主要用于做电源管理时，保存与恢复。\nprovide support for preserving and restoring the active priority in power-management implementations.\n\nAlthough the format of these registers is IMPLEMENTATION DEFINED:\n• because GICv2 guarantees the ability to save and restore all GIC state, the\nGICC_APRn registers must be present in all GIC implementations\n• in an implementation that includes the GIC Security Extensions, Non-secure\naccesses must not affect Secure operation, and the architecture requires that these\nregisters are banked, to provide Secure and Non-secure copies of the registers.\n\n##### 4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn\nprovide support for preserving and restoring the active priority in power-management implementation. These are separate registers for Group 1 interrupts.\n\n##### 4.4.14 CPU Interface Identification Register, GICC_IIDR\nProvides information about the implementer and revision of the CPU interface.\n\nFixme [Figure 4-35 GICC_IIDR bit assignments] Page 152\n\nFixme [Table 4-48 GICC_IIDR bit assignments] Page 152\n\n##### 4.4.15 Deactivate Interrupt Register, GICC_DIR\nWhen interrupt priority drop is separated from interrupt deactivation, as described in\nPriority drop and interrupt deactivation on page 3-38, a write to this register __deactivates the specified interrupt.__\n\nFixme [Figure 4-36 GICC_DIR bit assignments] Page 153\n\nFixme [Table 4-49 GICC_DIR bit assignments] Page 153\n\nFixme [Table 4-50 Behavior of GICC_DIR writes] Page 154\n\n\n\n### 5 GIC Support for Virtualization\n#### 5.1 About implementing a GIC in a system with processor virtualization\n__Any ARM processor implementation that includes the Virtualization Extensions must also include the Security Extensions.__\n\nFixme [Figure 5-1 Implementing the GIC with an ARM processor that supports virtualization] Page159\n\n#### 5.2 Managing the GIC virtual CPU interface\nThe hypervisor, or similar software, manages the GIC virtual interface control registers, consisting of:\n__List registers__\nUsed to define the active and pending virtual interrupts for the virtual CPU interface. The current\nvirtual machine accesses these interrupts indirectly, using the virtual CPU interface.\n\n__Management registers__\nUsed to manage the virtual CPU interface, and to save and restore settings when switching between\nvirtual machines.\n\nThe hypervisor runs as Non-secure software in Hyp mode. To maintain the 1-N interrupt handling model, a hypervisor might have to migrate an interrupt from one virtual machine to another.\n\nWhen it receives a physical IRQ, the hypervisor determines the required destination of the interrupt and then either:\n• Processes the interrupt itself, for example if the IRQ is __a maintenance interrupt__ from the virtual CPU\ninterface. It then deactivates the physical interrupt.\n• Generates a virtual interrupt. Depending on the interrupt priority and the targeted virtual machine, the\nhypervisor takes one of the following actions:\n\t— If the interrupt is for the current virtual machine, updates the List registers with details of the interrupt,\n\tredefining the interrupts that are visible to the current virtual machine. If there is no space in the List\n\tregisters, it saves the context to memory so the details can be added at a later stage\n\t— Records that the interrupt is for a different virtual machine by saving details of the interrupt as part of\n\tthe hypervisor state associated with that virtual machine.\n\t— Switches to a different virtual machine that can handle the interrupt. In doing so it must save the\n\tinterrupt state for the current virtual machine, using the information in the List registers, and\n\treprogram the List registers, to indicate the interrupt state for the new virtual machine, including the\n\tstate for the interrupt that has arrived.\n\nThe virtual machine accesses the GIC virtual CPU interface registers. These registers have the same general format\nas the physical CPU interface registers, and, in a typical implementation the virtual machine believes it is accessing\na physical CPU interface.\n\nWhen the virtual machine handles a virtual interrupt, it writes to the virtual CPU interface to indicate when it has\nfinished this processing. The virtual CPU interface signals this completion to the physical Distributor and the\nphysical Distributor then deactivates the interrupt.\n\n##### 5.2.1 List registers and virtual interrupt handling\na hypervisor uses List registers to maintain the list of highest priority virtual interrupts.\n\n记录的数据可以超过List registers数量，多余的数据存储在MEM 中。\n__The total number of interrupts that are either pending, active, or active and pending, can exceed the number of List registers available.__\nIf this happens, the hypervisor can save one or more active interrupt entries to memory, and later restore them to the List registers，based on their priority。Therefore:\n• The List registers might not include all active, or active and pending, interrupts. Virtual CPU interface\naccesses by the virtual machine update the List registers, and normally an EOI request from the virtual\nmachine deactivates an interrupt in the list. However, the virtual machine can issue an EOI request for an\ninterrupt before the hypervisor restores the associated active interrupt entry into a List register. In this case,\nthe EOI request cannot update the List registers.\n\n• Although the List registers might include only active interrupts, with the hypervisor maintaining any pending\ninterrupts in memory, a pending interrupt cannot be signaled to the virtual machine until the hypervisor adds\nit to the List registers. Therefore, to minimize interrupt latency and ensure efficient virtual machine operation,\n__ARM strongly recommends that the List registers contain at least one pending interrupt, provided a List register is available for this interrupt.__\n\n##### 5.2.2 Completion of virtualized physical interrupts\nARM recommends that, for each CPU interface that corresponds to a\nprocessor running virtual machines, the GICC_CTLR.EOImodeNS bit is set to 1. This means that hypervisor\naccesses to the GICC_AEOIR register drops the running priority of the CPU interface but does not deactivate the\ninterrupt. After writing to the EOI register, the running priority level on the CPU interface is lower, so that\nsubsequent interrupts can be signaled to the processor.\n\nARM recommends that physical interrupt completion consists of the following separate steps:\n1. EOI\n2. interrupt deactivation.\n\nThese steps are explained in more detail as follows:\n1. After receiving a physical interrupt, the hypervisor performs an EOI request for the physical interrupt by\nwriting to the GICC_EOIR or GICC_AEOIR register. After EOI, although the virtual machine has not\nprocessed the virtual interrupt, the lower running priority of the CPU interface means that the hypervisor can\nstill receive new physical interrupts.\n\tNote\n\tThe only interrupts that are not signaled to the hypervisor are the physical interrupts most recently subject to\n\tEOI. This is because the interrupts have not been deactivated. This prevents the interrupts from being\n\tre-signaled to the hypervisor before being processed by the virtual machine.\n\n2. After the virtual machine completes processing the corresponding virtual interrupt, it writes to the\nGICV_EOIR or GICV_AEOIR to deactivate the interrupt. This deactivates both the virtual interrupt and the\ncorresponding physical interrupt, provided that both of the following conditions are true:\n• the GICV_CTLR.EOImode bit is set to 0\n• the GICH_LRn.HW bit is set to 1.\n\nAlternatively, if the GICV_CTLR.EOImode bit is set to 1, the virtual machine writes to the GICV_DIR\nregister to deactivate the interrupt.\nIf the GICH_LRn.HW bit is set to 0, the hypervisor must deactivate the physical interrupt itself. ARM\nrecommends one of the following methods for deactivating physical SGIs that are routed to a virtual machine:\n• the hypervisor deactivates the SGI by writing to the GICC_DIR register after the virtual machine\nwrites to GICC_EOIR\n• the hypervisor uses an EOI maintenance interrupt to write to the GICC_DIR register after the virtual\nmachine writes to GICV_EOIR, see Maintenance interrupts on page 5-164 for more information.\n\n处理大致流程：\n1. hypervisor 写GICC_AEOIR，让此IRQ 丢掉优先级，能让其他低优先级的中断能被处理\n2. virtual machine 处理完后，virtual cpu 写GICV_EOIR 或 GICV_AEOIR，再写GICV_DIR （依赖GICV_CTLR.EOImode 设定是否自动完成后一步）\n3. 在virtual machine 写 GICV_EOIR 后，hypervisor 用 EOI maintenance interrupt 写 GICC_DIR （GICH_LRn.HW 设定为1，自动完成此步）\n\n##### 5.2.3 Acknowledgement and completion of virtual interrupts\nTo ensure system correctness when handling virtual interrupts, one of the following conditions must be true:\n• All Group 0 interrupts must have a higher priority than any Group 1 interrupt. That is, there is no overlap in\nthe priorities allocated to Group 0 and Group 1 interrupts.\n• The GICV_CTLR.AckCtl bit must be set to 0.\n\n__ARM deprecates the use of GICC_CTLR.AckCtl and GICV_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl and GICV_CTLR.AckCtl are set to 0.__\n\n##### 5.2.4 GIC virtual interface control interface requirements\nskip\n\n##### 5.2.5 Maintenance interrupts\n__Maintenance interrupts can signal key events in the operation of a GIC that implements the Virtualization Extensions. Typically, these events are processed by the hypervisor.__\n\nNote\n• Maintenance interrupts are generated only when the global interrupt enable bit, GICH_HCR.En, is set to 1.\n\nMaintenance interrupts are level-sensitive interrupts. Configuration bits in the GICH_HCR can be set to 1 to enable\nmaintenance interrupt generation when:\n• Group 0 virtual interrupts are enabled/disabled\n• Group 1 virtual interrupts are enabled/disabled\n• There are no pending interrupts in the List registers.\n• At least one EOI request occurs with no valid List register entry for the corresponding interrupt.\n• There are no valid entries, or only one valid entry, in the List registers. This is an underflow condition.\n• At least one List register entry has received an EOI request.\n\n##### 5.2.6 Software-generated interrupts\n__Hypervisor-generated interrupts__\nA hypervisor can generate virtual interrupts that do not have a corresponding physical interrupt, by\ncreating an entry in the List registers with the GICH_LRn.HW bit cleared to 0. The hypervisor can\ncontrol how the interrupt appears to a virtual machine reading the GICV_IAR or GICV_AIAR\nregister to acknowledge the interrupt, by presenting the interrupt as:\n• an SGI, with a CPUID value provided in addition to the interrupt ID\n• a PPI or SPI, with the CPUID value set to 0.\n\nThe hypervisor can virtualize the CPUID value, but it must be consistent with the type of interrupt\nindicated by the GICH_LRn.VirtualID field. When the EOI notification is sent to the virtual CPU\ninterface, only the List registers are affected, and no notification is sent to the Distributor. See List\nRegisters, GICH_LRn on page 5-176 for more information.\n\nhypervisor 可以产生与硬件中断号不一致的虚拟中断，并且可以控制中断在虚拟机中呈现的形式：SGI，PPI，SPI。\n\n__Distributor-generated interrupts__\nBecause the hardware interrupt deactivation mechanism does not support SGIs, the hypervisor must\nvirtualize SGIs originating from the Distributor in the same way as hypervisor-generated interrupts.\nThe hypervisor can virtualize the GICH_LRn.CPUID field, because this field is not required to be\nthe same as that of the original SGI. See Completion of virtualized physical interrupts on page 5-161\nfor more information about deactivating virtualized SGIs.\n\n虚拟中断分发器 产生的虚拟机之间的SGIs。\n\n##### 5.2.7 GIC Virtualization Extensions register mapping\nThe GIC must make these virtual interface control registers accessible in the following ways:\n__Redirection through a common base address__\nThe memory map includes a common base address for the virtual interface control registers. Each\nprocessor in the system can access its own GIC virtual interface control registers through this base\naddress. The CPUID of the processor requesting access redirects the access to the GIC virtual\ninterface control registers for that processor.\n\n__Processor-specific base addresses__\nIn addition to the common base address, the memory map contains, for each processor in the system,\na processor-specific base address for the GIC virtual interface control registers. Any processor can\nuse these addresses to access its own GIC virtual interface control registers, or to access the GIC\nvirtual interface control registers of any other processor in the system.\n\nFixme [Figure 5-2 GIC virtual interface control register mappings] page166\n\n#### 5.3 GIC virtual interface control registers\nFixme [Table 5-1 GIC virtual interface control register map] page167\n\n\n##### 5.3.1 Hypervisor Control Register, GICH_HCR\nThis register contains control bits for the virtual CPU interface.\n\nFixme [Figure 5-3 GICH_HCR bit assignments] page168\n\nFixme [Table 5-2 GICH_HCR bit assignments] page168\n\nFixme [Table 5-2 GICH_HCR bit assignments] page169\n\n##### 5.3.2 VGIC Type Register, GICH_VTR\nThis is a read-only register that provides the following information about the\nimplementation of the GIC Virtualization Extensions:\n• number of priority levels supported\n• number of preemption levels supported\n• number of implemented List registers.\n\nFixme [Figure 5-4 GICH_VTR bit assignments] page170\n\nFixme [Table 5-3 GICH_VTR bit assignments] page170\n\n##### 5.3.3 Virtual Machine Control Register, GICH_VMCR\nEnables the hypervisor to save and restore the virtual machine view of the GIC state.\n\nFixme [Figure 5-5 GICH_VMCR bit assignments] page171\n\nThe GICH_VMCR is a control register that contains read and write aliases of architecture state in the virtual\nmachine view, enabling the hypervisor to save and restore this state with a single read or write, without accessing\nthe GIC virtual CPU interface registers individually.\n\n##### 5.3.4 Maintenance Interrupt Status Register, GICH_MISR\n\nIndicates which maintenance interrupts are asserted.\n\nFixme [Figure 5-6 GICH_MISR bit assignments] page172\n\nFixme [Table 5-5 GICH_MISR bit assignments] page172\n\n##### 5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1\nWhen a maintenance interrupt is received, these registers help determine which List\nregisters have outstanding EOI interrupts that require servicing.\n\nFixme [Figure 5-7 GICH_EISR0 bit assignments] page173\n\nFixme [Table 5-6 GICH_EISR0 bit assignments] page173\n\n##### 5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1\nThese registers can be used to locate a usable List register when the hypervisor is delivering\nan interrupt to a Guest OS.\n\nFixme [Figure 5-8 GICH_ELRSR0 bit assignments] page173\n\nFixme [Table 5-7 GICH_ELRSR0 bit assignments] page173\n\n##### 5.3.7 Active Priorities Register, GICH_APR\nThis register tracks which preemption levels are active in the virtual CPU interface, and is\nused to determine the current active priority. Corresponding bits are set in this register when\nan interrupt is acknowledged, based on GICH_LRn.Priority, and the least significant set bit\nis cleared on EOI.\n\nFixme [Figure 5-9 GICH_APR bit assignments] page175\n\nFixme [Table 5-8 GICH_APR bit assignments] page175\n\n##### 5.3.8 List Registers, GICH_LRn\nProvides interrupt context information for the virtual CPU interface. __A maximum of 64 List registers can be provided. The GICH_VTR.ListRegs bit defines the actual number implemented.__\n\nFixme [Figure 5-10 GICH_LR bit assignments] page176\n\nFixme [Table 5-9 GICH_LR bit assignments] page176\n\n#### 5.4 The virtual CPU interface\nA GIC virtual CPU interface signals virtual interrupts to a connected processor, The GIC virtual CPU interface registers have the same general format as the GIC physical CPU interface registers and expected behavior is that a virtual machine cannot distinguish between them.\n\n__In particular, the virtual CPU interface uses the contents of the List registers to determine when to signal virtual interrupts.__\n\nWhen a processor accesses the virtual CPU interface the List registers are updated.\n• Virtual interrupts are always handled through the virtual CPU interfaces.\n• On the connected processor, if the processor is in a Non-secure PL1 or PL0 mode, virtual interrupts are\nsignaled to the current virtual machine.\n• In addition, a virtual machine can receive virtual IRQs and virtual FIQs signaled directly by the hypervisor.\nThese exceptions are outside the scope of this specification. A virtual machine cannot distinguish:\n\t— A virtual exception signaled by the GIC from a corresponding virtual exception signaled directly by the hypervisor.\n\t— A virtual exception from the corresponding physical exception.\n• A virtual CPU interface does not require power management support, and therefore GICV_CTLR does not\nimplement the IRQBypDisGrp1, FIQBypDisGrp1, IRQBypDisGrp0, and FIQBypDisGrp0 bits that are\nsupported by GICC_CTLR\n\n#### 5.5 GIC virtual CPU interface registers\nTypically, a virtual machine is unaware of any difference between virtual interrupts and physical interrupts.\n\n__In general, these registers have the same format as the GIC physical CPU interface registers, but they operate on the interrupt view defined primarily by the List registers.__\n\nThese registers are memory-mapped, The offset of each GICV_* register is the same as the offset of the corresponding register for the physical CPU interface.\n\nFixme [Table 5-10 GIC virtual CPU interface register map] page179\n\n\n","source":"_posts/arm_gic.md","raw":"---\ntitle: arm gicv2\ndate: 2019-04-20 13:55:44\ntags:\n    - arm\n    - spec\n    - GICv2\ncategories:\n    - arm\n---\n\nGICv2\n<!--more-->\n##1. Introduction\nAbout the Generic Interrupt Controller architecture\nThe Generic Interrupt Controller (GIC) architecture defines:\n• the architectural requirements for handling all interrupt sources for any processor connected to a GIC\n• a common interrupt controller programming interface applicable to uniprocessor or multiprocessor systems\n\nThe architecture describes a GIC designed for use with one or more processors that comply with the ARM A and R\narchitecture profiles.\n\nThe GIC is a centralized resource for supporting and managing interrupts in a system that includes at least one\nprocessor. It provides:\n• registers for managing interrupt sources, interrupt behavior, and interrupt routing to one or more processors\n• support for:\n\t— the ARM architecture Security Extensions\n\t— the ARM architecture Virtualization Extensions\n\t— enabling, disabling, and generating processor interrupts from hardware (peripheral) interrupt sources\n\t— Software-generated Interrupts (SGIs)\n\t— interrupt masking and prioritization\n\t— uniprocessor and multiprocessor environments\n\t— wakeup events in power-management environments.\n\n\nThe GIC includes interrupt grouping functionality that supports:\n• configuring each interrupt as either Group 0 or Group 1\n• signaling Group 0 interrupts to the target processor using either the IRQ or the FIQ exception request\n• signaling Group 1 interrupts to the target processor using the IRQ exception request only\n• a unified scheme for handling the priority of Group 0 and Group 1 interrupts\n• optional lockdown of the configuration of some Group 0 interrupts.\n\nfiq 优先级比 irq 高\nfiq 模式下寄存器 比 irq 模式多（R8 ~ R12）\nhttp://blog.chinaunix.net/attachment/201302/21/28458801_1361445566H9Z3.png\n\n### 1.2. Security Extensions support\nThe ARM processor Security Extensions are an optional extension to the ARMv7-A architecture profile.\n\nARM Security Extensions facilitate the development of secure applications by:\n• integrating hardware security features into the architecture\n• providing Secure virtual memory space that is accessed by memory accesses in the Secure state\n• providing Non-secure virtual memory space that is accessed by memory accesses in the Non-secure state.\n\n\nWhen a GIC that implements the GIC Security Extensions is connected to a processor that implements the ARM\nSecurity Extensions:\n• Group 0(IRQ/FIQ) interrupts are Secure interrupts, and Group 1(IRQ) interrupts are Non-secure interrupts.\n\nProcessor security state and Secure and Non-secure GIC accesses：\n• a processor in Non-secure state can make only Non-secure accesses to a GIC\n• a processor in Secure state can make both Secure and Non-secure accesses to a GIC\n\n\n### 1.3. Virtualization support\nThe ARM processor Virtualization Extensions are optional extensions to the ARMv7-A architecture profile. The GIC Virtualization Extensions provide mechanisms to minimize the hypervisor overhead of routing interrupts to virtual machines.\n\nThe processor Virtualization Extensions provide hardware support for virtualizing the Non-secure state of an\nVMSAv7 implementation. The extensions support system use of a virtual machine monitor, known as the\nhypervisor, to switch guest operating systems.\n\nWhether implemented in a uniprocessor or in a multiprocessor system, the processor Virtualization Extensions\nsupport running multiple virtual machines on a single processor.\n\nThe hypervisor can either handle a physical interrupt itself, or generate a corresponding virtual interrupt that is signaled to a virtual machine. It is also possible for the hypervisor to generate virtual interrupts that do not correspond to physical interrupts.\n\n1) physical interrupt => virtual machine => virtual interrupt （产生与硬件相应的虚拟中断）\n2) virtual machine => virtual interrupt （也可以产生与硬件中断没有关的虚拟中断）\n\n### 1.4. Terminology （专用名词）\n#### 1.4.1. Interrupt states\nInactive\t\t\tAn interrupt that is not active or pending.\n\nPending \t\t\tAn interrupt from a source to the GIC that is recognized as asserted in hardware, or\n\t\t\t\t\tgenerated by software, and is waiting to be serviced by a target processor.\n\nActive \t\t\t\tAn interrupt from a source to the GIC that has been acknowledged by a processor, and is\n\t\t\t\t\tbeing serviced but has not completed.\n\nActive and pending \tA processor is servicing the interrupt and the GIC has a pending interrupt from the same\nsource.\n\n\n#### 1.4.2. Interrupt types\n\nPeripheral interrupt\n\t\t\n\t\tPrivate Peripheral Interrupt (PPI)\n\t\tThis is a peripheral interrupt that is specific to a single processor.\n\n\t\tShared Peripheral Interrupt (SPI)\n\t\tThis is a peripheral interrupt that the Distributor can route to any of a specified\n\t\tcombination of processors.\n\n\t\tEach peripheral interrupt is either:\n\t\tEdge-triggered\n\t\t\tThis is an interrupt that is asserted on detection of a rising edge of an interrupt\n\t\t\tsignal and then, regardless of the state of the signal, remains asserted until it is\n\t\t\tcleared by the conditions defined by this specification.\n\n\t\tLevel-sensitive\n\t\t\tThis is an interrupt that is asserted whenever the interrupt signal level is active,\n\t\t\tand deasserted whenever the level is not active.\n\nSoftware-generated interrupt (SGI)\n\t\tThis is an interrupt generated by software writing to a GICD_SGIR register in the GIC.The\n\t\tsystem uses SGIs for interprocessor communication.\n\n\t\tWhen an SGI occurs in a multiprocessor implementation, the CPUID field in the Interrupt\n\t\tAcknowledge Register, GICC_IAR, or the Aliased Interrupt Acknowledge Register,\n\t\tGICC_AIAR, identifies the processor that requested the interrupt.\n\n\t\t__An SGI has edge-triggered properties__. （边缘触发）\n\n\t\tIn an implementation that includes the GIC Virtualization Extensions:\n\t\t• when an SGI occurs, management registers in the GIC virtualization Extensions\n\t\tenable the requesting processor to be reported to the Guest OS, as required by the\n\t\tGIC specifications\n\t\t• by writing to the management registers in the GIC Virtualization Extensions, a\n\t\thypervisor can generate a virtual interrupt that appears to a virtual machine as an SGI.\n\nVirtual interrupt \n\tIn a GIC that implements the GIC Virtualization Extensions, an interrupt that targets a\n\tvirtual machine running on a processor, and is typically signaled to the processor by the\n\tconnected virtual CPU interface.\t\t\n\nMaintenance interrupt\n\tIn a GIC that implements the GIC Virtualization Extensions, a level-sensitive interrupt that\n\tis used to signal key events, such as a particular group of interrupts becoming enabled or\n\tdisabled. See Maintenance interrupts on page 5-164 for more information.\t\n\n#### 1.4.3. Models for handling interrupts\n\n1-N model 常规硬件中断，单个的SPI， PPI\n\tOnly one processor handles this interrupt. The system must implement a mechanism to determine\n\twhich processor handles an interrupt that is programmed to target more than one processor.\n\nN-N model 主要SGI， SPI可能会出现\n\tAll processors receive the interrupt independently. When a processor acknowledges the interrupt,\n\tthe interrupt pending state is cleared only for that processor. The interrupt remains pending for the\n\tother processors.\n\n#### 1.4.4. Spurious interrupts （假的中断）\nIt is possible that an interrupt that the GIC has signaled to a processor is no longer required.If this happens, when\nthe processor acknowledges the interrupt, the GIC returns a special Interrupt ID(1020 ~ 1023) that identifies the interrupt as a\nspurious interrupt.\n\nExample reasons for spurious interrupts are:\n• prior to the processor acknowledging an interrupt:\n— software changes the priority of the interrupt\n— software disables the interrupt\n— software changes the processor that the interrupt targets\n• for a 1-N interrupt, another target processor has previously acknowledged that interrupt.\n\n\n## 2. GIC Partitioning\n\n### 2.1 About GIC partitioning\nThe GIC architecture splits logically into a Distributor block and one or more CPU interface blocks. The GIC\nVirtualization Extensions add one or more virtual CPU interfaces to the GIC.\n\nGIC 架构有1个GIC Distributor, 一个或多个CPU Interface， 一个或多个virtual CPU interface（GIC Virtualization Extensions support）\n\nDistributor \n\tThe Distributor block performs interrupt prioritization and distribution to the CPU interface\n\tblocks that connect to the processors in the system.\n\tThe Distributor block registers are identified by the GICD_ prefix.\n\nCPU interfaces \n\tEach CPU interface block performs priority masking and preemption handling for a\n\tconnected processor in the system.\n\n\tWhen describing a GIC that includes the GIC Virtualization Extensions, a CPU interface is\n\tsometimes called a physical CPU interface, to avoid possible confusion with a virtual CPU\n\tinterface.\n\n\tCPU interface block registers are identified by the GICC_ prefix.\n\nVirtual CPU interfaces\t\n\tEach virtual CPU interface is partitioned into the following blocks:\n\t\n\tVirtual interface control\n\t\tThe main component of the virtual interface control block is the GIC virtual\n\t\tinterface control registers, that include a list of active and pending virtual\n\t\tinterrupts for the current virtual machine on the connected processor. \n\t\t\n\t\tTypically, these registers are managed by the hypervisor that is running on that processor.\n\t\t\n\t\tVirtual interface control block registers are identified by the GICH_ prefix.\n\t\n\tVirtual CPU interface\n\t\tEach virtual CPU interface block provides physical signaling of virtual\n\t\tinterrupts to the connected processor. The ARM processor Virtualization\n\t\tExtensions signal these interrupts to the current virtual machine on that\n\t\tprocessor. \n\n\t\tThe GIC virtual CPU interface registers, accessed by the virtual\n\t\tmachine, provide interrupt control and status information for the virtual\n\t\tinterrupts. The format of these registers is similar to the format of the physical\n\t\tCPU interface registers.\n\t\t\n\t\tVirtual CPU interface block registers are identified by the GICV_ prefix.\n\n Note: The virtual CPU interface does not support the power management functionality described\n\n\n A GIC can implement up to eight CPU interfaces, numbered from 0-7.\n In a GIC that implements the GIC Virtualization Extensions, virtual CPU interface numbering corresponds to the CPU interface numbering, so that\nCPU interface 0 and virtual CPU interface 0 connect to the same processor.\n\n一个GIC 最多支持8个CPU， 而 physical CPU interface 与virtual CPU interface 个数对应一样多。\n\n\nFixMe： 补上GIC logical partitioning\n\n### 2.2. The Distributor\n\nThe Distributor provides a programming interface for:\n\t• Globally enabling the forwarding of interrupts to the CPU interfaces.\n\t• Enabling or disabling each interrupt.\n\t• Setting the priority level of each interrupt.\n\t• Setting the target processor list of each interrupt.\n\t• Setting each peripheral interrupt to be level-sensitive or edge-triggered.\n\t• Setting each interrupt as either Group 0 or Group 1.\n\t• Forwarding an SGI to one or more target processors.\nIn addition, the Distributor provides:\n\t• visibility of the state of each interrupt\n\t• a mechanism for software to set or clear the pending state of a peripheral interrupt.\n\n#### 2.2.1 Interrupt IDs\nGICv2 - The GIC assigns interrupt ID numbers ID0-ID1019 as follows:\n\t具有唯一标示\n\tSPI: 32 ~ 1019 \n\n\tbanked interrupt 可重入或重复的中断， 每个CPU 的中断号可相同\n\tPPI: 16 ~ 31\n\tSGI: 0 ~ 15\nIn any system that implements the ARM Security Extensions, to support a consistent model for message passing\nbetween processors, ARM strongly recommends that all processors reserve:\n\t• ID0-ID7 for Non-secure interrupts\n\t• ID8-ID15 for Secure interrupts.\n\nInterrupt numbers ID1020-ID1023\tare reserved for special purposes,\n\n### 2.3. CPU interfaces\nEach CPU interface block provides the interface for a processor that is connected to the GIC.\n\t• enabling the signaling of interrupt requests to the processor\n\t• acknowledging an interrupt\n\t• indicating completion of the processing of an interrupt\n\t• setting an interrupt priority mask for the processor\n\t• defining the preemption policy for the processor\n\t• determining the highest priority pending interrupt for the processor.\n\nGCI CPU interfaces是否拉起中断信号给处理器流程\nSignal interrupt request flow:\n\ttake the highest priorty pending interrupt(read GICC_HPPIR) -> check interrupt priority mask and the preemption settings ->\n\tsignal or ignore interrupt request\n\nCPU获取中断ID\nThe processor acknowledges the interrupt request by reading the CPU interface Interrupt Acknowledge Register.\nThis read returns one of:\n\t• The ID number of the highest priority pending interrupt, if that interrupt is of sufficient priority for it to be\n\tsignaled to the processor. This is the normal response to an interrupt acknowledge.\n\t• Exceptionally, an ID number that indicates a spurious interrupt(1020 ~ 1023)\n\n中断处理完成后\nThere are two stages to interrupt completion:\n\t• priority drop, meaning the priority of the processed interrupt can no longer prevent the signaling of another\n\tinterrupt to the processor\n\t• interrupt deactivation, meaning the Distributor removes the active state of the interrupt.\n\nIn a GICv1 implementation, these two stages always happen together, when the processor writes to the CPU\ninterface End of Interrupt register.\n\nIn a GICv2 implementation, the GICC_CTLR.EOImode bit determines whether:\n\t• the two stages happen together, when the processor writes to the CPU interface End of Interrupt register\n\t• the two stages are separated, so that:\n\t\t— priority drop happens when the processor writes to the CPU interface End of Interrupt register\n\t\t— interrupt deactivation happens later, when the processor writes to the CPU interface Deactivate\n\t\tInterrupt register.\t\n\n#### 2.3.1 Interrupt signal bypass, and GICv2 bypass disable\nIn all GIC implementations, a CPU interface optionally includes interrupt signal bypass, so that, when the signaling\nof an interrupt by the interface is disabled, a system legacy interrupt signal is passed to the interrupt request input\non the processor, bypassing the GIC functionality.\n中断信号旁路，主要支援legacy interrupt 不会受到CPU interface disable的影响，GICv2 must also provide disable bits for the interrupt\nsignal bypass operation.\n\nFixMe 增加Interrupt signal bypass, GICv1 without Security Extensions 图片\n\n#### 2.3.2 Power management, GIC v2\nThe GICv2 architecture supports wakeup events in implementations that require power management.\nThese signals are available even when both interrupt signaling by the GIC, and interrupt bypass, are disabled.\n\n为软件提供预留或回复状态寄存器\nthe GICC_APRn registers provide support for preserving and restoring state in power-management\napplications\nHowever, to ensure that Non-secure accesses do not interfere with Secure operation, Secure and\nNon-secure copies of these registers are provided.\n\n\n### 3 Interrupt Handling and Prioritization\n#### 3.1 About interrupt handling and prioritization\nInterrupt handling describes:\n\t• how the GIC recognizes interrupts\n\t• how software can program the GIC to configure and control interrupts\n\t• the state machine the GIC maintains for each interrupt on each CPU interface\n\t• how the exception model of a processor interacts with the GIC.\n\nPrioritization describes:\n\t• the configuration and control of interrupt priority\n\t• the order of execution of pending interrupts\n\t• the determination of when interrupts are visible to a target processor, including:\n\t\t— interrupt priority masking\n\t\t— priority grouping\n\t\t— preemption of an active interrupt.\n\n\nall implementations of the GIC architecture support interrupt grouping. With interrupt grouping:\n\t• by default, all interrupts are Group 0 interrupts, and are signaled to a connected processor using the IRQ\n\tinterrupt request\n\t• each interrupt can be configured as Group 1 interrupt, or as a Group 0 interrupt\n\t• a CPU interface can be configured to signal Group 0 interrupts to a connected processor using the FIQ\n\tinterrupt request.\t\n\n\n##### 3.1.1 About interrupt handling and prioritization\n\n可以参看 1.4.2. Interrupt types节\n中断类型主要有四种：\n物理中断：SPI，PPI （可边缘，电平触发）\n软中断：SGI\n虚拟中断：virtual interrupt\n维护中断：maintenance interrupt (电平触发)，用于发送key events(具备virtualization extensions GIC)\n\n\n参看 1.4.3. Models for handling interrupts 节\nSGI 使用GIC N-N模型\n物理中断 SPI，PPI 使用GIC 1-N 模型\n\n##### 3.1.2 Identifying the supported interrupts\n中断号的分段参看2.2.1 Interrupt IDs节\n\n软件获知enable 中断\nSoftware can use the GICD_ISENABLERns to discover what interrupt IDs are supported by the GIC。\n\nGICD_ISENABLER0 provides the Set-enable bits for both:\n\t• SGIs, using interrupt IDs 15-0, corresponding to register bits [15:0]\n\t• PPIs, using interrupt IDs 31-16, corresponding to register bits [31:16].\n\nThe remaining GICD_ISENABLERns, from GICD_ISENABLER1, provide the Set-enable bits for the SPIs,\nstarting at interrupt ID 32.\n\nSoftware discovers the interrupts that are supported by:\n1. Reading the GICD_TYPER. The GICD_TYPER.ITLinesNumber field identifies the number of implemented\nGICD_ISENABLERns, and therefore the maximum number of SPIs that might be supported. （获取supported interrupt 总数）\n2. Writing to the GICD_CTLR to disable forwarding of interrupts from the distributor to the CPU interfaces.\nFor more information, see Enabling and disabling the Distributor and CPU interfaces on page 4-77.\n3. For each implemented GICD_ISENABLERn, starting with GICD_ISENABLER0:\n\t• Writing 0xFFFFFFFF to the GICD_ISENABLERn.\n\t• Reading the value of the GICD_ISENABLERn. Bits that read as 1 correspond to supported interrupt IDs.\t\n\n永久使能中断\nSoftware uses the GICD_ICENABLERns to discover the interrupts that are permanently enabled. For each\nimplemented GICD_ICENABLERn, starting with GICD_ICENABLER0, software:\n1. Writes 0xFFFFFFFF to the GICD_ICENABLERn. This disables all interrupts that can be disabled.\n2. Reads the value of the GICD_ICENABLERn. Bits that read as 1 correspond to interrupts that are\npermanently enabled.\n3. Writes 1 to any GICD_ISENABLERn bits corresponding to interrupts that must be re-enabled.\t\n\nThe GIC implements the same number of GICD_ISENABLERns and GICD_ICENABLERns.\n\n#### 3.2 General handling of interrupts\n中断状态分为：(detail see 3.2.4 Interrupt handling state machine)\n - inactive\n - pending\n - active\n - active and pending\n\nGroup, security extension 中断参看 3.4 The effect of interrupt grouping on interrupt handling\nvirtualization extension 中断处理参看 5 GIC Support for Virtualization.\n\n通用中断处理流程：\nWhen the GIC recognizes an interrupt request, it marks its state as pending. Regenerating a pending interrupt does\nnot affect the state of the interrupt.\n\nThe GIC interrupt handling sequence is:\n1. The GIC determines the interrupts that are enabled.\n2. For each pending interrupt, the GIC determines the targeted processor or processors.\n3. For each CPU interface, the Distributor forwards the highest priority pending interrupt that targets that\ninterface.\n4. Each CPU interface determines whether to signal an interrupt request to its processor, and if required, does so.\n5. The processor acknowledges the interrupt, and the GIC returns the interrupt ID and updates the interrupt\nstate.\n6. After processing the interrupt, the processor signals End of Interrupt (EOI) to the GIC.\n\nIn more detail, these steps are as follows:\n1. The GIC determines whether each interrupt is enabled. An interrupt that is not enabled has no effect on the GIC.\n\n2. For each enabled interrupt that is pending, the Distributor determines the targeted processor or processors.\n\n3. For each processor, the Distributor determines the highest priority pending interrupt, based on the priority information it holds for each interrupt, and forwards the interrupt to the targeted CPU interfaces.\n\n4. If the distributor is forwarding an interrupt request to a CPU interface, the CPU interface determines whether the interrupt has Sufficient priority to be signaled to the processor. If the interrupt has sufficient priority, the GIC signals an interrupt request to the processor.\n\n5. When a processor takes the interrupt exception, it reads the GICC_IAR of its CPU interface to acknowledge the interrupt. This read returns an Interrupt ID, and for an SGI, the source processor ID, that the processor uses to select the correct interrupt handler. When it recognizes this read, the GIC changes the state of the interrupt as follows:\n\t• if the pending state of the interrupt persists when the interrupt becomes active, or if the interrupt is generated again, from pending to active and pending.\n\t• otherwise, from pending to active\n\n\t\tNote:\n\t\t• A level-sensitive peripheral interrupt persists when it is acknowledged by the processor, because the\n\t\tinterrupt signal to the GIC remains asserted until the Interrupt Service Routine (ISR) running on the\n\t\tprocessor accesses the peripheral asserting the signal.\n\t\t• In a multiprocessor implementation, the GIC handles:\n\t\t\t— PPIs and SGIs using the GIC N-N model, where the acknowledgement of an interrupt by one\n\t\t\tprocessor has no effect on the state of the interrupt on other CPU interfaces\n\t\t\t— SPIs using the GIC 1-N model, where the acknowledgement of an interrupt by one processor\n\t\t\tremoves the pending status of the interrupt on any other targeted processors, see Implications\n\t\t\tof the 1-N model on page 3-41.\n\t\t• In GICv2, when using a software model with the GICC_CTLR.AckCtl bit set to 0, separate registers\n\t\tare used to manage Group 0 and Group 1 interrupts, as follows:\n\t\t\t— GICC_IAR, GICC_EOIR, and GICC_HPPIR for Group 0 interrupts\n\t\t\t— GICC_AIAR, GICC_AEOIR, and GICC_AHPPIR for Group 1 interrupts.\n\t\tARM deprecates the use of GICC_CTLR.AckCtl, and strongly recommends using a software model\n\t\twhere GICC_CTLR.AckCtl is set to 0, see [3.4.3 The effect of interrupt grouping on interrupt acknowledgement]\n\n6. When the processor has completed handling the interrupt, it must signal this completion to the GIC. As\ndescribed in [3.2.1 Priority drop and interrupt deactivation], this: (通知GIC， EOI 并改写状态到inactive)\n\t• always requires a valid write to an end of interrupt register (EOIR)\n\t• might also require a subsequent write to the deactivate interrupt register, GICC_DIR.\t\n\n写向EOIR 的值是从GICC_IAR 或 GICC_AIAR得到的最近处理的中断号\nFor each CPU interface, the GIC architecture requires the order of the valid writes to an EOIR to be the\nreverse of the order of the reads from the GICC_IAR or GICC_AIAR, so that each valid EOIR write refers\nto the most recent interrupt acknowledge.\n\nA CPU interface never signals to the connected processor any interrupt that is active and pending. It only\nsignals interrupts that are pending and have sufficient priority:\n\t• For PPIs and SGIs, the active status of particular interrupt ID is banked between CPU interfaces. This\n\tmeans that if a particular interrupt ID is active or active and pending on a CPU interface, then no\n\tinterrupt with that same ID is signaled on that CPU interface.\n\t• For SPIs, the active status of an interrupt is common to all CPU interfaces. This means that if an\n\tinterrupt is active or active and pending on one CPU interface then it is not signaled on any CPU\n\tinterface.\n\n\n#### 3.2.1 Priority drop and interrupt deactivation\nWhen a processor completes the processing of an interrupt, it must signal this completion to the GIC. Interrupt\ncompletion requires the following changes to the GIC state:\n\nPriority drop \nPriority drop is the drop in the Running priority that occurs on a valid write to an EOIR, either the\nGICC_EOIR or the GICC_AEOIR.\n\nInterrupt deactivation\nInterrupt deactivation is the change of the state of an interrupt, either:\n\t• from active and pending, to pending\n\t• from active, to idle\n\n在GICv1 中Priority drop  与\tInterrupt deactivation 是同时的。在GICv2 中可以设定setting GICC_CTLR.EOImode to 1 separates the priority drop and interrupt deactivation operations， and interrupt handling software must:\n\t1. Perform a valid EOIR write, to cause priority drop on the GIC CPU interface.\n\t2. Subsequently, write to the GICC_DIR, to deactivate the interrupt.\n\n\nThe GIC architecture specification requires that valid EOIR writes are ordered, so that:\n• a valid GICC_EOIR write corresponds to the most recently acknowledged interrupt\n• a valid GICC_AEOIR write corresponds to the most recently acknowledged Group 1 interrupt.\n• whether a GICC_EOIR write affects Group 0 or Group 1 interrupts depends on both:\n\t— the value of the GICC_CTLR. AckCtl bit\n\t— if the GIC implements the GIC Security Extensions, whether the write is Secure or Non-secure.\n\nNote：\nIn a GICv2 implementation that includes the Security Extensions:\n• GICC_AEOIR is an alias of the Non-secure copy of GICC_EOIR\n• GICC_AIAR is an alias of the Non-secure copy of GICC_IAR\n• GICC_AIAR and GICC_AEOIR are Secure registers, meaning they are accessible only by Secure accesses.\n\n#### 3.2.2 Interrupt controls in the GIC\n\n**Interrupt enables**\nFor peripheral interrupts, a processor:\n• enables an interrupt by writing to the appropriate GICD_ISENABLERn bit\n• disables an interrupt by writing to the appropriate GICD_ICENABLERn bit.\n\n**Setting and clearing pending state of an interrupt**\nFor peripheral interrupts, a processor can:\n• set the pending state by writing to the appropriate GICD_ISPENDRn bit\n• clear the pending state by writing to the appropriate GICD_ICPENDRn bit.\n\nFor a level-sensitive interrupt:\n• If the hardware signal of an interrupt is asserted when a processor writes to the corresponding\nGICD_ICPENDRn bit then the write to the register has no effect on the pending state of the interrupt.\n• If a processor writes a 1 to an GICD_ISPENDRn bit then the corresponding interrupt becomes pending\nregardless of the state of the hardware\nmore detail see [Control of the pending status of level-sensitive interrupts]\n\nFor SGIs, the GIC ignores writes to the corresponding GICD_ISPENDRn and GICD_ICPENDRn bits. A processor\ncannot change the state of a software-generated interrupt by writing to these registers. \nTypically, an SGI is made pending by writing to the GICD_SGIR. In GICv2, the pending state of SGIs can also be modified directly using the\nGICD_SPENDSGIRn and GICD_CPENDSGIRn bits.\n\n**Finding the active or pending state of an interrupt**\nA processor can find:\n• the pending state of an interrupt by reading the corresponding GICD_ISPENDRn or GICD_ICPENDRn bit\n• the active state of an interrupt by reading the corresponding GICD_ISACTIVERn or GICD_ICACTIVERn\nbit.\n\nIn GICv2, the processor that issues the SGI can also be determined by reading the\ncorresponding GICD_SPENDSGIRn or GICD_CPENDSGIRn bits.\n\n**Generating an SGI**\nA processor generates an SGI by writing to an GICD_SGIR. \nThe GICD_SGIR includes optimization for:\n• interrupting only the processor that writes to the GICD_SGIR\n• interrupting all processors other than the one that writes to the GICD_SGIR.\n\nGICD_SGIR 大致包含:\n• interrupt ID\n• source processor\n• target processor.\n\nSGIs from different processors use the same interrupt IDs. Therefore, any target processor can receive SGIs with\nthe same interrupt ID from different processors.\n\nOnly one interrupt with a specific interrupt ID can be active on a CPU interface at any time. This means that a CPU\ninterface cannot have two SGIs with the same interrupt ID active at the same time, even if different processors have\nsignaled SGIs with the same interrupt ID to that processor.\n\nOn the CPU interface of the target processor, reading the GICC_IAR for an SGI returns both the interrupt ID and\nthe CPU ID of the processor that generated the interrupt, the source processor for the interrupt.The combination of\ninterrupt ID and source CPU ID uniquely identifies the interrupt to the target processor.\n\nIn a multiprocessor implementation, the interrupt priority of each SGI interrupt ID is defined independently for each\ntarget processor。\n**For each CPU interface, all SGIs with a particular interrupt ID that are pending on that interface have the same priority and must be handled serially.**\n\n##### 3.2.3 Implications of the 1-N model\n__when the GIC recognizes an interrupt acknowledge from one of the target processors it clears the pending state of the interrupt on all the other targeted processors.__ A GIC implementation must ensure that any interrupt being handled using the 1-N model is only acknowledged by one CPU interface, and that all other interfaces return a spurious\ninterrupt ID.\n\nWhen multiple target processors attempt to acknowledge the interrupt, the following can occur:\n• A processor reads the GICC_IAR and obtains the interrupt ID of the interrupt to be serviced.\n\tNote:  (在多核情况下，通过share memory, lock形式，确保只有一个core 处理中断)\n\tIn GICv1, more than one target processor might have obtained this interrupt ID, if the processors read their\n\tGICC_IAR registers at very similar times. The system might require software on the target processors to\n\tensure that only one processor runs its interrupt service routine. A typical mechanism to achieve this is\n\timplementing, in shared memory, a lock on the interrupt service routine (ISR).\n\n• __A processor reads the GICC_IAR and obtains the interrupt ID 1023, indicating a spurious interrupt. The processor can return from its interrupt service routine without writing to its GICC_EOIR.__\n__The spurious interrupt ID indicates that the original interrupt is no longer pending, typically because another target processor is handling it.__\n\nNote\n\t• A GICv1 implementation might ensure that only one processor can make a 1-N interrupt active, removing\n\tthe requirement for a lock on the ISR. This is not required by the architecture, and generic GIC code must\n\tnot rely on this behavior.（GICv1 不要求在ISR 中lock）\n\t• For any processor, if an interrupt is active and pending, the GIC does not signal an interrupt exception request\n\tfor the interrupt to any processor until the active status is cleared. （如果中断是active且pending 状态，GIC 不会触发此中断给任何processor 直到active 状态清除）\n\n##### 3.2.3 Interrupt handling state machine\n\nFixme 【中断状态机】\n\n**Transition A1 or A2, add pending state**\nFor an SGI, occurs if either:\n• Software writes to a GICD_SGIR that specifies the processor as a target.\n• Software on the target processor writes to the GICD_SPENDSGIRn bit that corresponds to\nthe required source processor and interrupt ID\n\nFor an SPI or PPI, occurs if either:\n• a peripheral asserts an interrupt request signal\n• software writes to an GICD_ISPENDRn\n\n**Transition B1 or B2, remove pending state**\nFor an SGI, occurs if software on the target processor writes to the relevant bit of the\nGICD_CPENDSGIRn.\n\n物理中断\n- 电平触发，pending 会一直拉高直到处理\n- 边缘触发，写GICD_ICPENDRn 寄存器清pending 状态\n\nFor an SPI or PPI, occurs if either:\n• the level-sensitive interrupt is pending only because of the assertion of an input signal, and\nthat signal is deasserted\n• the interrupt is pending only because of the assertion of an edge-triggered interrupt signal, or\na write to an GICD_ISPENDRn, and software writes to the corresponding\nGICD_ICPENDRn.\n\n**Transition C, pending to active**\nIf the interrupt is enabled and of Sufficient priority to be signaled to the processor, occurs when\nsoftware reads from the GICC_IAR.\n\n**Transition D, pending to active and pending**\nFor an SGI, this transition occurs in either of the following circumstances:\n• If a write to set the SGI state to pending occurs at approximately the same time as a read of\nGICC_IAR.\n• When two or more pending SGIs with the same interrupt ID originate from the same source\nprocessor and target the same processor. If one of the SGIs follows transition C, the other\nSGIs follow transition D\n\nFor an SPI or PPI this transition occurs if all the following apply:\n• The interrupt is enabled.\n• Software reads from the GICC_IAR. This read adds the active state to the interrupt.\n• In addition, one of the following conditions applies:\n\t— For a level-sensitive interrupt, the interrupt signal remains asserted. This is usually the\n\tcase, because the peripheral does not deassert the interrupt until the processor has\n\tserviced the interrupt.\n\t— For an edge-triggered interrupt, whether this transition occurs depends on the timing\n\tof the read of the GICC_IAR relative to the detection of the reassertion of the interrupt.\n\tOtherwise the read of the GICC_IAR causes transition C, possibly followed by\n\ttransition A2.\n\n**Transition E1 or E2, remove active state**\nOccurs when software deactivates an interrupt by writing to either GICC_EOIR or GICC_DIR.In a GIC\nimplementation the includes the Virtualization Extensions, also occurs if the virtual CPU interface\nsignals that the corresponding physical interrupt has been deactivated\t\n\n#### 3.3 Interrupt prioritization\nSoftware configures interrupt prioritization in the GIC by assigning a priority value to each interrupt source. Priority\nvalues are 8-bit unsigned binary.A GIC supports a minimum of 16 and a maximum of 256 priority levels. If the\nGIC implements fewer than 256 priority levels, low-order bits of the priority fields are RAZ/WI.\nIn the GIC prioritization scheme, lower numbers have higher priority,\n\n| Implemented priority bits | Possible priority field values | Number of priority levels |\n|:-:|:-:|:-:|\n|[7:0] | 0x00-0xFF (0-255), all values | 256 |\n|[7:1] | 0x00-0xFE, (0-254), even values only | 128 |\n|[7:2] | 0x00-0xFC (0-252), in steps of 4 | 64 |\n|[7:3] | 0x00-0xF8 (0-248), in steps of 8 | 32 |\n|[7:4] | 0x00-0xF0 (0-240), in steps of 16 | 16 |\n\n**The GICD_IPRIORITYRn registers hold the priority value for each supported interrupt.**\n\nTo determine the number of priority bits implemented, software can write 0xFF to a writable GICD_IPRIORITYRn\npriority field, and read back the value stored.\nNote:\nARM recommends that, before checking the priority range in this way:\n• for a peripheral interrupt, software first disables the interrupt\n• for an SGI, software first checks that the interrupt is inactive\n\n##### 3.3.1 Preemption\nA CPU interface supports signaling of higher priority pending interrupts to a target processor before an active\ninterrupt completes. A pending interrupt is only signaled if both:\n• Its priority is higher than the priority mask for that CPU interface, see [Priority masking].\n• Its group priority is higher than that of the Running priority on the CPU interface, see [Priority grouping] and[\nRunning Priority Register, GICC_RPR]\n\nFor a processor that complies with the ARM architecture:\n\t— The value of the I or F bit in the CPSR determines whether the processor responds to the signaled\n\tinterrupt by starting the interrupt acknowledge procedure.\n\t— When processing a preempting interrupt, the processor must save and later restore the context of the\n\tpreviously active ISR.\n\n##### 3.3.2 Priority masking\nCPU Interface 选择高于中断阀门优先级的中断給处理器。\nThe GICC_PMR for a CPU interface defines a priority threshold.The GIC only signals\npending interrupts with a higher priority than this threshold value to the target processor. A value of zero, the register\nreset value, masks all interrupts from being signaled to the associated processor. The GIC does not use priority\ngrouping when comparing the priority of a pending interrupt with the priority threshold.\n\n##### 3.3.3 Priority grouping\n一组相同优先级的中断。\nPriority grouping uses the Binary Point Register, GICC_BPR, to split a priority value into two fields, the group\npriority and the subpriority.When determining preemption, all interrupts with the same group priority are\nconsidered to have equal priority, regardless of the subpriority. This means that there can only be one interrupt active\nat each group priority. The active group priority is also known as the **Preemption level.**\n\n\n主要是用过GICC_BPR 0~2 划分出 GICC_PMR 两个部分：Group priority field 和Subpriority field\nFixME [Table 3-2 Priority grouping by binary point] 图片page 46\n\n#### 3.4 The effect of interrupt grouping on interrupt handling\nA GICv1 implementation that includes the GIC Security Extensions, or any GICv2 implementation, provides two\ninterrupt output signals for IRQ and FIQ exception requests:\n• The CPU interface always uses the IRQ exception request for Group 1 interrupts\n• Software can configure the CPU interface to use either IRQ or FIQ exception requests for Group 0 interrupts\n\n##### 3.4.1 GIC interrupt grouping support\nThe GICD_IGROUPRn registers configure each interrupt as Group 0 or Group 1.\n\nFixMe [CPU interface control of Group 0 and Group 1 interrupts, GICv2] 图片 Page48\n\nIn an implementation that includes the GIC Security Extensions, the alias registers:\n• typically **represent aliases of the Non-secure copy of the Group 0 registers**, for example GICC_ABPR is an\nalias of the Non-Secure copy of GICC_BPR\n• are **accessible only by Secure accesses.**\n\nIn an implementation that supports interrupt grouping, GICC_CTLR contains additional fields, including fields to\ncontrol the handling of the grouped interrupts:\n• Separate enable bits to control the signaling of Group 0 and Group 1 interrupts to the connected processor: （是否支持组中断）\n\t— bit[0], the Enable bit in a GIC that does not support interrupt grouping, becomes the EnableGrp0 bit,\n\tand controls whether Group 0 interrupts are signaled to the processor\n\t— the EnableGrp1 bit is added, to control whether Group 1 interrupts are signaled to the processor.\n• The FIQEn bit, that controls whether the interface signals Group 0 interrupts to the processor using the IRQ\nor FIQ interrupt request. （Group0 是否支持FIQ）\n• The CBPR bit, that controls whether GICC_BPR or GICC_ABPR is used when determining possible\ninterrupt preemption by Group 1 interrupts, see [Control of preemption by Group 1 interrupts] （是否支持抢占）\n• The AckCtl bit, that controls whether a read of the GICC_IAR, or the Secure GICC_IAR if the GIC\nimplements the Security Extensions, can acknowledge a Group 1 interrupt.（是否支持Group1 能从GICC_IAR 读取中断ID，value 0 读到1022保留中断号，否则真实值）\n\n##### 3.4.2 Special interrupt numbers when a GIC supports interrupt grouping\n\n1020-1021 Reserved.\n\n1022 Used only if the GIC supports interrupt grouping.\nThe GIC returns this value to a processor in response to an interrupt acknowledge only when all of\nthe following apply:\n• the interrupt acknowledge is a read of GICC_IAR\n• the highest priority pending interrupt is a Group 1 interrupt\n• GICC_CTLR.AckCtl is set to 0\n• the priority of the interrupt is sufficient for it to be signaled to the processor.\n\tNote:\n\t• Interrupt ID 1022 indicates that there is a Group 1 interrupt of sufficient priority to be\n\tsignaled to the processor, that must be acknowledged by a read of the GICC_AIAR, or in an\n\timplementation that includes the GIC Security Extensions, by a read of the Non-secure\n\tGICC_IAR.\n\n1023 This value is returned to a processor, in response to an interrupt acknowledge, if there is no pending\ninterrupt with sufficient priority for it to be signaled to the processor.\nOn a processor that supports interrupt grouping, values of 1022 and 1023 are spurious interrupt IDs.\n\n##### 3.4.3 The effect of interrupt grouping on interrupt acknowledgement\n\n**When the GICC_CTLR.AckCtl bit is set to 0, to ensure system correctness, every Group 0 interrupt must have a higher priority than any Group 1 interrupt.**\n\nWhen the GICC_CTLR.AckCtl bit is set to 1, a read of GICC_IAR acknowledges the highest-priority pending\ninterrupt on the CPU interface, regardless of whether it is a Group 0 or a Group 1 interrupt. （ARM 极不推荐GICC_CTLR.AckCtl 设定为1）\n\nIn a GIC implementation that supports interrupt grouping, ARM strongly recommends setting GICC_CTLR.AckCtl\nto 0, meaning:\n• for a GICv2 implementation:\n\t— a group 0 interrupt is acknowledged by a read of GICC_IAR, or a Secure read of GICC_IAR if the\n\timplementation includes the GIC Security Extensions\n\t— a group 1 interrupt is acknowledged by a read of GICC_AIAR, or a Non-secure read of GICC_IAR if\n\tthe implementation includes the GIC Security Extensions\n• for a GICv1 implementation:\n\t— a group 0 interrupt must be acknowledged by a read of the Secure GICC_IAR\n\t— a group 1 interrupt must be acknowledged by a read of Non-secure GICC_IAR.\n\nIf the Interrupt Acknowledge register access does not correspond to the highest-priority pending interrupt on the CPU interface then:\n• a read of GICC_IAR when the highest-priority pending interrupt is a Group 1 interrupt returns the spurious\ninterrupt value 1022\n• a read of GICC_AIAR when the highest-priority pending interrupt is a Group 0 interrupt returns the spurious\ninterrupt value 1023.\n\n##### 3.4.4 GIC power on or reset configuration\nOn power-up, or after a reset, a GIC implementation that supports interrupt grouping is configured with:\n• all interrupts assigned to Group 0\n• the FIQ exception request disabled.\n\nFixMe [Reset configuration of a GIC that includes the FIQ exception request]  图片 page52\n\n#### 3.5 Interrupt grouping and interrupt prioritization\nARM strongly recommends that:\n\t• Group 0 interrupts are always assigned priority values in the lower half of the supported priority value range.\n\tThese values correspond to the higher-priority interrupts\n\t• Group 1 interrupts are always assigned priority values in the upper half of the supported priority value range.\n\tThese values correspond to the lower-priority interrupts.\n\nThis ensures that every Group 1 interrupt is of lower priority than any Group 0 interrupt.\n\n##### 3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions\nWhen a processor reads the priority value of a Group 1 interrupt, the GIC returns either the Secure or the Non-secure\nview of that value, depending on whether the access is Secure or Non-secure.\n\nThis is for a GIC that implements the maximum range of priority values.\nFixMe [Figure 3-7 Software views of the priorities of Group 1 and Group 0 interrupts]图片 Page55\n\nFixMe [Table 3-6 Effect of not implementing some priority field bits, with GIC Security Extensions]图片 Page56\n\n\n**Recommendations for managing priority values**\nARM strongly recommends that:\n• for a Group 0 interrupt, software sets bit [7] of the priority value field to 0\n• if using a Secure write to set the priority of a Group 1 interrupt, software sets bit [7] of the priority value field\nto 1.\n\n##### 3.5.2 Control of preemption by Group 1 interrupts\nWhen a GIC implementation supports interrupt grouping, the GICC_BPR is always used to determine whether a\nGroup 0 interrupt is signaled to the processor, for possible preemption.\nBy default, the GICC_ABPR is used to\ndetermine whether a Group 1 interrupt is signaled for possible preemption.\n\nHowever, when GICC_CTLR.CBPR is set to 1, GICC_BPR is used for determining possible preemption, for both Group 0 and Group 1 interrupts.\n\nPriority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0 情况与 [Priority grouping] 类似\n\n#### 3.6 Additional features of the GIC Security Extensions\nSoftware can detect support for the GIC Security Extensions by reading the GICD_TYPER.SecurityExtn bit, see\nInterrupt Controller Type Register, GICD_TYPER on page 4-88.\n\n##### 3.6.1 Access from processors not implementing the ARM Security Extensions\nWhen connecting a processor that does not support the ARM Security Extensions to a GIC that implements the GIC\nSecurity Extensions, typically all processor accesses to the GIC are assigned as either Secure or Non-secure:\n• For a processor making Secure accesses:\n\t— **The processor can control all aspects of the GIC, and therefore can make configuration changes that might affect Secure software running on other processors.**\n\t— In a GICv2 implementation, the processor **uses Secure accesses to aliased registers, such as the GICC_AIAR, to process Group 1 interrupts.**\n\t— Because GICv1 implementations do not include the aliased registers, if the implementation uses\n\tinterrupt grouping the processor might have to use the deprecated GICC_CTLR.AckCtl bit to enable\n\tGroup 1 interrupts to be processed using the standard CPU interface registers.\n\n• For a processor making Non-secure accesses:\n\t— The processor cannot control Group 0 interrupts. For the GIC to be programmed, **the system implementation must include at least one processor that can make Secure accesses.**\n\tA system might use a Secure processor to perform Secure accesses on behalf of a Non-secure\n\tprocessor. This usage model is possible if the GIC or the system provides a method for the Secure\n\tprocessor to access processor-banked copies of registers that belong to the Non-secure processor.\n\t— To **permit a Non-secure processor to control its own Group 0 interrupts, a GICv2 implementation can implement the GICD_NSACRn registers.** An implementation of these registers might permit a Secure\n\tprocessor to permit the use of Non-secure accesses from a particular processor to control some aspects\n\tof the operation of some Group 0 SGIs and SPIs.\n\t— A GIC implementation can configure the GICD_IGROUPRn reset value so that interrupts are Group\n\t1 on reset. see GICD_IGROUPR0 reset value on page 4-92 for more information\n\n\n#### 3.7 Pseudocode details of interrupt handling and prioritization\nskip, see spec\n\n\n#### 3.8 The effect of the Virtualization Extensions on interrupt handling\nsee Chapter 5 GIC Support for Virtualization\n\n#### 3.9 Example GIC usage models\n\nFixMe [Figure 3-8 Generic GIC usage model]图片page 68\n\n##### 3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts\nFixMe [Figure 3-9 Using the GIC to route Secure and Non-secure interrupts]图片page 69\n\nshows a system that implements the GIC Security Extensions, connected to a processor that\nimplements the ARM processor Security Extensions. This implementation:\n• uses Group 0 interrupts as Secure interrupts, signaled as FIQs\n• uses Group 1 interrupts as Non-secure interrupts, signaled as IRQs.\nThis means that, on the processor, FIQ interrupts are never routed to Non-secure software, and IRQ interrupts are\nnever routed to Secure software.\n\nNote：\nThe use of Group 0 and Group 1 interrupts to signal Secure interrupts as FIQs, and Non-secure interrupts as IRQs,\nrequires the processor to:\n• **route FIQs to be taken in Secure Monitor mode**\n• **prevent Non-secure software from masking FIQs**\n• **ensure that IRQs are masked whenever it is operating in Secure state.**\n\nOn a GIC reset, all interrupts are assigned to Group 0, making them Secure interrupts. Secure software on the\nprocessor:\n• programs the GICD_IGROUPRn registers to indicate which interrupts are Group 1, Non-secure\n• sets the Secure GICC_CTLR.FIQEn bit to 1 to configure the CPU interface to use FIQ for Group 0 interrupts.\n• must enable Group 0 interrupts and Group 1 interrupts, independently, in the Distributor: （配置GIC）\n\t— GICD_CTLR.EnableGrp0 enables Group 0 interrupts\n\t— GICD_CTLR.EnableGrp1 enables Group 1 interrupts.\n• must enable Group 0 interrupts and Group 1 interrupts, independently, in the CPU interface: （配置CPU Interface）\n\t— GICC_CTLR.EnableGrp0 enables Group 0 interrupts\n\t— GICC_CTLR.EnableGrp1 enables Group 1 interrupts.\n\n##### 3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions\t\n\nFixMe [Figure 3-10 Using interrupt grouping to route IRQs and FIQs] Page70\n\nOn a GIC reset, for a GIC implementation that supports interrupt grouping, all interrupts are assigned to Group 0.\nTherefore, to use this configuration, software executing on the processor must:\n• Program the GICD_IGROUPRn registers to assign IRQ interrupts to Group 1.\n• Set GICC_CTLR.FIQEn to 1, to assign Group 0 interrupts to FIQ.\n• Set GICC_CTLR.AckCtl to 0, so that both FIQ and IRQ interrupts are acknowledged from the single address\nspace, using:\n\t— the GICC_IAR to acknowledge a Group 0 interrupt\n\t— the GICC_AIAR to acknowledge a Group 1 interrupt\n\t— the GICC_EOIR to indicate completion of a Group 0 interrupt\n\t— the GICC_AEOIR to indicate completion of a Group 1 interrupt.\nHowever, GICC_AIAR and GICC_AEOIR are implemented only in a GICv2 implementation. A processor\noperating with a GICv1 implementation might have to use the deprecated mode of operation with\nGICC_CTLR.AckCtl set to 1(意味着GRP0 GRP1 都是用GICC_IAR, GICC_EOIR).\n• Configure the required binary point support model, by either:\n\t— setting GICC_CTLR.CBPR to 0, so that Group 0 uses GICC_BPR, and Group 1 uses GICC_ABPR\n\t— setting GICC_CTLR.CBPR to 1, so that Group 0 and Group 1 use a common binary point register,\n\tGICC_BPR.\n\n由于没有security, 我们只是人为的将IRQ 分配到GRP1中，将FIQ 分配到GRP0中。因此，并不需要使能GICD_CTLR.EnableGrp0/1 GICC_CTLR.EnableGrp0/1 来让GIC与CPU 支持真正的Group 即security，我们只是使用不同的寄存器\n- GICC_IAR && GICC_AIAR获知ID\n- GICC_EOIR && GICC_AEOIR 结束中断\n- GICC_CTLR.CBPR && GICC_CTLR.ABPR \n\n##### 3.9.3 Supporting IRQs and FIQs in a virtualized processor environment\t\n\nFixme [Figure 3-11 Using the GIC in a virtualized system] page72\n\n• Secure software assigns:\n\t— Secure interrupts to Group 0, signaled to the processor as FIQs\n\t— Non-secure interrupts to Group 1, signaled to the processor as IRQs\n\n• A hypervisor:\n\t— Implements a virtual distributor, using features of the Virtualization Extension on the GIC. This\n\tvirtual distributor can virtualize IRQ interrupts from the GIC as Virtual IRQ and Virtual FIQ\n\tinterrupts, that it routes to an appropriate virtual machine.\n\t— Routes physical IRQs to Hyp mode, so they can be serviced by the virtual distributor\n\n• A Guest OS running on a virtual machine assigns interrupts to Group 0 or Group 1, to assign them as FIQs\nor IRQs, using the model described in [Supporting IRQs and FIQs when not using the processor Security\nExtensions]\n\n\nWhen the GIC signals an IRQ to the processor, the interrupt is routed to Hyp mode. The hypervisor determines\nwhether the interrupt is for itself, or for a Guest OS. If it is for a Guest OS it determines:\n• which Guest OS must handle the interrupt\n• whether that Guest OS has configured the interrupt as an FIQ or as an IRQ\n• the interrupt priority, based on the priority configuration by the target Guest OS.\n\nNote:  (__Guest OS 可能不止一个__)\n• On receiving an IRQ that cannot be handled by the current Guest OS, the hypervisor can either:\n— transfer control to a Guest OS that can handle the interrupt\n— mark the interrupt as pending, as part of the saved context of the appropriate Guest OS.\n• A system can have some interrupts that can be handled by more that one Guest OS, and other interrupts that\nmust be routed to a specific Guest OS.\n\n\nA Guest OS handles a virtual interrupt exactly as it would handle the corresponding physical interrupt. __The Guest OS cannot detect that it is handling a virtual interrupt rather than a physical interrupt.__\n\nGuest OS 并不知道处理的是虚拟中断。\n\n### 4. Programmers’ Model\n\n#### 4.1.1 GIC register names\nAll of the GIC registers have names that provide a short mnemonic for the function of the register. In these names:\n• the first three letters are GIC, indicating a GIC register\n• the fourth letter is one of:\n\t— D, indicating a Distributor register\n\t— C, indicating a CPU interface register\n\t— H, indicating a virtual interface control register, typically accessed by a hypervisor\n\t— V, indicating a virtual CPU interface register.\n\nNote：\nChapter 5 GIC Support for Virtualization describes the GICH_* and GICV_* registers.\n\n#### 4.1.2 Distributor register map\nFixme [Table 4-1 Distributor register map] page74\n\n\n#### 4.1.3 CPU interface register map\nFor a multiprocessor implementation, the GIC implements a set of CPU interface registers for each CPU interface.\n__ARM strongly recommends that each processor has the same CPU interface base address for the CPU interface that connects it to the GIC. This is the private CPU interface base address for that processor.__\n\nFixme [Table 4-2 CPU interface register map] page76\n\n\n#### 4.1.4 GIC register access\nNote:\nIn the GIC architecture, all registers that are halfword-accessible or byte-accessible use a little endian memory order model.\n\nIf the GIC implements the GIC Security Extensions these affect register accesses as follows:\n• some registers are banked, see Register banking\n• some registers are accessible only using Secure accesses\n• optionally, the GIC supports lockdown of the values of some registers\n\n\n__Register banking__\nRegister banking refers to providing multiple copies of a register at the same address.\n\nThe GIC banks registers in the following cases:\n• If the GIC implements the Security Extensions, some registers are banked to provide separate Secure and\nNon-secure copies of the registers. The Secure and Non-secure register bit assignments can differ. A Secure\naccess to the register address accesses the Secure copy of the register, and a Non-secure access accesses the\nNon-secure copy. \n\n• If the GIC is implemented as part of a multiprocessor system:\n\t— Some registers are banked to provide a separate copy for each connected processor. These __include the registers associated with PPIs and SGIs, and the GICD_NSACRn, when implemented.__\n\t— The GIC implements the CPU interface registers __independently for each CPU interface__, and each\n\tconnected processor accesses these registers for the interface it connects to.\n\n#### 4.1.5 Enabling and disabling the Distributor and CPU interfaces\n\n__Implementations that support interrupt grouping__\nIn a GIC that supports interrupt grouping:\n• the GICD_CTLR.EnableGrp0 bit \n• the GICD_CTLR.EnableGrp1 bit \n• the GICC_CTLR.EnableGrp0 bit\n• the GICC_CTLR.EnableGrp1 bit \n\nFor the Distributor:\n• If the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits are both 0:\n\t— __the Distributor does not forward pending interrupts to the CPU interfaces__\n\t— it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the\n\tpending state.\n\t— __reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID__\n\t— software can read or write the Distributor registers\n\t— it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR\n\n• If either, but not both, of the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits is set to \n\t— GICD_CTLR.EnableGrp0 set to 0 and GICD_CTLR.EnableGrp1 set to 1, and the highest priority\n\tpending interrupt is in group 0\n\t— GICD_CTLR.EnableGrp0 set to 1 and GICD_CTLR.EnableGrp1 set to 0, and the highest priority\n\tpending interrupt is in group 1. (ARM 强烈不推荐这样，这样GRP0 优先级是小于GRP1)\n\n__ARM strongly recommends that all Group 0 interrupts are assigned a higher priority than all Group 1 interrupts.__\n\nFor a CPU interface, when GICC_CTLR.AckCtl == 0:\n• When GICC_CTLR.EnableGrp0 == 0\n\t— Group 0 interrupts forwarded from the Distributor are not signaled to the processor\n\t— any read of GICC_IAR returns a spurious interrupt ID\n• When GICC_CTLR.EnableGrp0 == 1, Group 0 interrupts forwarded from the Distributor are signaled to the\nprocessor.\n• When GICC_CTLR.EnableGrp1 == 0\n\t— Group 1 interrupts forwarded from the Distributor are not signaled to the processor\n\t— any read of GICC_AIAR returns a spurious interrupt ID\n• When GICC_CTLR.EnableGrp1 == 1, Group 1 interrupts forwarded from the Distributor are signaled to the\nprocessor\n• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt\nof sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR\nreturns the ID of that interrupt, or a spurious interrupt ID\n\nFor a CPU interface, when GICC_CTLR.AckCtl == 1:\n• When GICC_CTLR.EnableGrp1 == 0, any Non-secure read of GICC_IAR returns a spurious interrupt ID\n• When GICC_CTLR.EnableGrp0 == 0:\n— if GICC_CTLR.EnableGrp1 == 0, any Secure read of GICC_AIAR returns a spurious interrupt ID\n— if GICC_CTLR.EnableGrp1 == 1, Group 0 interrupts are ignored and GICC_IAR behaves as\nGICC_AIAR\n• When GICC_CTLR.EnableGrp1 == 0, a Secure read of GICC_AIAR always returns a spurious interrupt ID\n• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt\nof sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR\nreturns the ID of that interrupt, or a spurious interrupt ID.\n\nNote:\n__ARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl is set to 0.__\n\n---\n\n__Implementations that do not support interrupt grouping__\nIn a GIC that does not support interrupt grouping:\n• the GICD_CTLR.Enable bit controls the forwarding of interrupts from the Distributor to the CPU interfaces\n• the GICC_CTLR.Enable bit controls the signaling of interrupts by the CPU interface to the connected processor.\n\nFor the Distributor:\n• When GICD_CTLR.Enable is set to 1, the Distributor forwards the highest priority pending interrupt for each\nCPU interface, subject to the prioritization rules.\n• When GICD_CTLR.Enable is set to 0:\n\t— the Distributor does not forward pending interrupts to the CPU interfaces\n\t— it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the\n\tpending state.\n\t— reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID\n\t— software can read or write the Distributor registers\n\t— it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR.\n\nFor a CPU interface:\n• When GICC_CTLR.Enable is set to 1, the highest priority pending interrupt forwarded from the Distributor\nto the CPU interface is signaled to the connected processor\n• When GICC_CTLR.Enable is set to 0:\n\t— any pending interrupts forwarded from the Distributor are not signaled to the processor\n\t— software can read or write the CPU interface registers\n\t— any read of the GICC_IAR returns a spurious interrupt ID\n\t— if the Distributor is forwarding an interrupt to the CPU interface, that the interface cannot signal\n\tbecause GICC_CTLR.Enable is set to 0, it is IMPLEMENTATION DEFINED whether a read of\n\tGICC_HPPIR returns the ID of that interrupt, or a spurious interrupt ID.\n\n### 4.2 Effect of the GIC Security Extensions on the programmers’ model\nIf the GIC implements the Security Extensions, __the GICD_TYPER.SecurityExtn bit is RAO.__.\n\nThe GIC Security Extensions provide the following features:\n• The GIC must support interrupt grouping.\n• Register implementations that are consistent with those on a processor that implements the ARM Security\nExtensions, with banked.\n\nThe ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition defines the following ARM Security\nExtensions register types:\n- __Banked__\n\tThe device implements Secure and Non-secure copies of the register. The register bit assignments\n\tcan differ in the Secure and Non-secure copies of a register. A Secure access always accesses the\n\tSecure copy of the register, and a Non-secure access always accesses the Non-secure copy.\n\t\tNote\n\t\tThe GIC can also bank registers when implemented as part of a multiprocessor system, where\n\t\tregisters associated with PPIs or SGIs are banked to provide a separate copy for each connected\n\t\tprocessor.\n- __Secure__\n\tThe register is accessible only from a Secure access. The address of a Secure register is RAZ/WI to\n\tany Non-secure access.\n- __Common__\n\tThe register is accessible from both Secure and Non-secure accesses. The access permissions of\n\tsome or all fields in the register might depend on whether the access is Secure or Non-secure.\n\n| Register \t\t| Type \t\t| Description | \n|:-------------:|:---------:|:-----------:|\n| GICD_CTLR \t| Banked \t| Distributor Control Register | \n| GICD_TYPER \t| Common \t| Interrupt Controller Type Register| \n| GICD_IGROUPRn | Secure \t| Interrupt Group Registers | \n| GICD_SGIR \t| Common \t| Software Generated Interrupt Register | \n| GICC_CTLR \t| Banked \t| CPU Interface Control Register | \n| GICC_BPR \t\t| Banked \t| Binary Point Register | \n| GICC_ABPR \t| Secure \t| Aliased Binary Point Register | \n| GICC_AIAR \t| Secure \t| Aliased Interrupt Acknowledge Register | \n| GICC_AEOIR \t| Secure \t| Aliased End of Interrupt Register | \n| GICC_AHPPIR \t| Secure \t| Aliased Highest Priority Pending Interrupt Register | \n| GICC_NSAPRn \t| Secure \t| Non-secure Active Priorities Registers| \n\n#### 4.2.1 Non-secure access to register fields for Group 0 interrupt priorities\n\nNon-secure access to a priority field in the GICD_IPRIORITYRn\nIf the priority field corresponds to a Group 1 interrupt, the access operates as defined by the\nNon-secure view of interrupt priority, see[Software views of interrupt priority in a GIC that includes\nthe Security Extensions]\n\nNon-secure access to the GICC_PMR and GICC_RPR\n• If the current priority mask value is in the range 0x00-0x7F:\n\t— a read access returns the value 0x00\n\t— the GIC ignores a write access to the GICC_PMR.\n• If the current priority mask value is in the range 0x80-0xFF:\n\t— A read access returns the Non-secure view of the current value.\n\t— A write access to the GICC_PMR succeeds, based on the Non-secure view of the\n\tpriority mask value written to the register. This means a Non-secure write cannot set\n\ta priority mask value in the rage 0x00-0x7F.\n\n#### 4.2.2 Configuration lockdown\nThis provides a control signal that the system can assert to prevent write access to:\n• the register fields controlling a configured range of SPIs, when those SPIs are configured as Group 0\ninterrupts\n• some configuration registers.\n\nWhen the control signal is asserted, the affected register fields and registers are described as being locked down.\n__Lockdown is controlled by an active HIGH disable signal, CFGSDISABLE__. That is, the system asserts\nCFGSDISABLE HIGH to disable write access to the register fields and registers.\n\nThe SPIs that can be locked down are called lockable SPIs (LSPIs).\n• The GICD_TYPER.LSPI field defines the maximum number of LSPIs. If GICD_TYPER.LSPI is greater\nthan 0 then the possible LSPIs have interrupt IDs 32 to (31+(GICD_TYPER.LSPI)).\n\tNote:\n\tGICD_TYPER.LSPI only defines the range of possible LSPIs. The GIC might not support all the interrupts\n\tin this range.\n\nIf GICD_TYPER.LSPI is 0 lockdown is not supported.\n\nWhen the SPI control fields and configuration registers are locked down, the GIC prevents write accesses to:\n• The EnableGrp0 bit of the Secure copy of GICD_CTLR.\n• The following bits in the Secure copy of GICC_CTLR:\n\t— EOImodeS\n\t— IRQBypDisGrp0\n\t— FIQBypDisGrp0\n\t— CBPR\n\t— FIQEn\n\t— AckCtl\n\t— EnableGrp0\n• Fields in the GICD_ISENABLERn, GICD_ICENABLERn, GICD_ISPENDRn, GICD_ICPENDRn,\nGICD_ISACTIVERn, GICD_ICACTIVERn, GICD_IPRIORITYRn, GICD_ITARGETSRn, and\nGICD_ICFGRn registers that correspond to Lockable SPIs that are configured as Group 0:\n• Fields in the GICD_IGROUPRn registers that correspond to lockable SPIs that are configured as Group 0. If\na lockable SPI is reconfigured from Group 1 to Group 0 while CFGSDISABLE remains HIGH, the GIC\nprevents any more writes to GICD_IGROUPRn fields that correspond to that SPI, and the SPI becomes\nlocked.\t\n\n#### 4.3 Distributor register descriptions\nThe following sections describe the Distributor registers:\n• Distributor Control Register, GICD_CTLR on page 4-85\n• Interrupt Controller Type Register, GICD_TYPER on page 4-88\n• Distributor Implementer Identification Register, GICD_IIDR on page 4-90\n• Interrupt Group Registers, GICD_IGROUPRn on page 4-91\n• Interrupt Set-Enable Registers, GICD_ISENABLERn on page 4-93\n• Interrupt Clear-Enable Registers, GICD_ICENABLERn on page 4-95\n• Interrupt Set-Pending Registers, GICD_ISPENDRn on page 4-97\n• Interrupt Clear-Pending Registers, GICD_ICPENDRn on page 4-99\n• Interrupt Set-Active Registers, GICD_ISACTIVERn on page 4-102\n• Interrupt Clear-Active Registers, GICD_ICACTIVERn on page 4-103\n• Interrupt Priority Registers, GICD_IPRIORITYRn on page 4-104\n• Interrupt Processor Targets Registers, GICD_ITARGETSRn on page 4-106\n• Interrupt Configuration Registers, GICD_ICFGRn on page 4-109\n• Non-secure Access Control Registers, GICD_NSACRn on page 4-111\n• Software Generated Interrupt Register, GICD_SGIR on page 4-113\n• SGI Clear-Pending Registers, GICD_CPENDSGIRn on page 4-115\n• SGI Set-Pending Registers, GICD_SPENDSGIRn on page 4-117\n• Identification registers on page 4-119.\n\n##### 4.3.1 Distributor Control Register, GICD_CTLR\nEnables the forwarding of pending interrupts from the Distributor to the CPU interfaces.\n\nFixme [Figure 4-1 GICD_CTLR bit assignments, GICv1 without Security Extensions or Non-secure]图片 Page85\n\nFixme [Figure 4-2 GICD_CTLR bit assignments, GICv2, and GICv1 Secure copy]图片 Page85\n\n##### 4.3.2 Interrupt Controller Type Register, GICD_TYPER\nProvides information about the configuration of the GIC. It indicates:\n• whether the GIC implements the __Security Extensions__\n• the __maximum number of interrupt IDs__ that the GIC supports\n• the __number of CPU interfaces__ implemented\n• if the GIC implements the Security Extensions, the __maximum number of implemented Lockable Shared Peripheral Interrupts (LSPIs)__.\n\nFixme [Figure 4-3 GICD_TYPER bit assignments] 图片Page88\n\n[15:11]  LSPI \t\t\tIf the GIC implements the Security Extensions, the value of this field is the maximum number of\n\t\t\t\t\t\timplemented lockable SPIs, from 0 (0b00000) to 31 (0b11111). If this field is 0b00000 then the GIC does not implement configuration lockdown. If the GIC does not implement the Security Extensions, this field is reserved.\n\n[10] \t SecurityExtn \tIndicates whether the GIC implements the Security Extensions.\n\t\t\t\t\t\t\t0  Security Extensions not implemented.\n\t\t\t\t\t\t\t1  Security Extensions implemented.\t\t\t\t\t\n\n[7:5]   CPUNumber \t\tIndicates the number of implemented CPU interfaces. The number of implemented CPU interfaces is\n\t\t\t\t\t\tone more than the value of this field, for example if this field is 0b011, there are four CPU interfaces. If\n\t\t\t\t\t\tthe GIC implements the Virtualization Extensions, this is also the number of virtual CPU interfaces\t\n\n[4:0]  ITLinesNumber \tIndicates the maximum number of interrupts that the GIC supports.If ITLinesNumber=N, the\n\t\t\t\t\t\tmaximum number of interrupts is 32 * (N+1). interrupt IDs 1020-1023 are reserved for\n\t\t\t\t\t\tspecial purposes\n\nThe ITLinesNumber field only indicates the maximum number of SPIs that the GIC might support. This value\ndetermines the number of implemented interrupt registers, that is, the number of instances of the following registers:\n• GICD_IGROUPRn\n• GICD_ISENABLERn\n• GICD_ICENABLERn\n• GICD_ISPENDRn\n• GICD_ICPENDRn\n• GICD_ISACTIVERn\n• GICD_IPRIORITYRn\n• GICD_ITARGETSRn\n• GICD_ICFGRn.\n\n##### 4.3.3 Distributor Implementer Identification Register, GICD_IIDR\nProvides information about the implementer and revision of the Distributor.\n主要用于记录GIC 的产品ID， 变体ID， 实现公司ID\nFixme [Figure 4-4 GICD_IIDR bit assignments] 图片Page90\n\n##### 4.3.4 Interrupt Group Registers, GICD_IGROUPRn\nThe GICD_IGROUPR registers provide a status bit for each interrupt supported by the GIC.\nEach bit controls whether the corresponding interrupt is in Group 0 or Group 1.\nFixme [Figure 4-5 GICD_IGROUPR bit assignments] 图片Page91\n\n[31:0] Group status bits， For each bit:\n\t0 The corresponding interrupt is Group 0.\n\t1 The corresponding interrupt is Group 1.\n\n__Reset Value__\nOn start-up or reset, each interrupt with ID32 or higher resets as Group 0 and therefore all SPIs are Group 0.\n\n##### 4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn\nThe GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.\nWriting 1 to a Set-enable bit enables forwarding of the corresponding interrupt from the\nDistributor to the CPU interfaces. Reading a bit identifies whether the interrupt is enabled.\n\nThese registers are available in all configurations of the GIC. If the GIC implements the\nSecurity Extensions these registers are Common\n\nIn a multiprocessor implementation, GICD_ISENABLER0 is banked for each connected\nprocessor. This register holds the Set-enable bits for interrupts 0-31.\n\n##### 4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn\nThe GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the\nGIC. Writing 1 to a Clear-enable bit disables forwarding of the corresponding interrupt from\nthe Distributor to the CPU interfaces.\n\nIn a multiprocessor implementation, GICD_ICENABLER0 is banked for each connected\nprocessor. This register holds the Clear-enable bits for interrupts 0-31.\n\n##### 4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn\nThe GICD_ISPENDRs provide a Set-pending bit for each interrupt supported by the GIC.\nWriting 1 to a Set-pending bit sets the status of the corresponding peripheral interrupt to\npending. Reading a bit identifies whether the interrupt is pending.\n\nIn a multiprocessor implementation, GICD_ISPENDR0 is banked for each connected\nprocessor. This register holds the Set-pending bits for interrupts 0-31.\n\nFor SPIs and PPIs\nWrites \n0 \t\tHas no effect.\n1 \t\tThe effect depends on whether the interrupt is edge-triggered or\n\t\tlevel-sensitive.\n\n__Edge-triggered__\nChanges the status of the corresponding interrupt to:\n• pending if it was previously inactive\n• active and pending if it was previously active.\nHas no effect if the interrupt is already pendinga.\n\n__Level sensitive__\nIf the corresponding interrupt is not pendinga, changes the status\nof the corresponding interrupt to:\n• pending if it was previously inactive\n• active and pending if it was previously active.\n\nIf the interrupt is already pendinga:\n• because of a write to the GICD_ISPENDR, the write has\nno effect\n• because the corresponding interrupt signal is asserted, the\nwrite has no effect on the status of the interrupt, but the\ninterrupt remains pendinga if the interrupt signal is\ndeasserted.\n\n##### 4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn\nThe GICD_ICPENDRs provide a Clear-pending bit for each interrupt supported by the GIC.\nWriting 1 to a Clear-pending bit clears the pending state of the corresponding peripheral\ninterrupt. Reading a bit identifies whether the interrupt is pending\n\nIn a multiprocessor implementation, GICD_ICPENDR0 is banked for each connected\nprocessor. This register holds the Clear-pending bits for interrupts 0-31.\n\n##### 4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn\nThe GICD_ISACTIVERs provide a Set-active bit for each interrupt that the GIC supports.\nWriting to a Set-active bit Activates the corresponding interrupt. __These registers are used when preserving and restoring GIC state__\n\nIn a multiprocessor implementation, GICD_ISACTIVER0 is banked for each connected\nprocessor. This register holds the Set-active bits for interrupts 0-31.\n\n##### 4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn\nThe GICD_ICACTIVERs provide a Clear-active bit for each interrupt that the GIC\nsupports. Writing to a Clear-active bit Deactivates the corresponding interrupt. These\nregisters are used when preserving and restoring GIC state.\n\nIn a multiprocessor implementation, GICD_ICACTIVER0 is banked for each connected\nprocessor. This register holds the Clear-active bits for interrupts 0-31.\n\n##### 4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn\nThe GICD_IPRIORITYRs __provide an 8-bit priority field for each interrupt__ supported by the\nGIC. This field stores the priority of the corresponding interrupt.\n\nA GIC might implement fewer than eight priority bits, but must implement at least bits [7:4]\nof each field. In each field, unimplemented bits are RAZ/WI. see [3.3 Interrupt prioritization]\n我们可以实现CPU Interface 的Group level.\n\nIn a multiprocessor implementation, GICD_IPRIORITYR0 to GICD_IPRIORITYR7 are\nbanked for each connected processor. These registers hold the Priority fields for interrupts\n0-31.\n\nFixme [Figure 4-13 GICD_IPRIORITYR bit assignments] 图片Page104\n\n##### 4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn\nThe GICD_ITARGETSRs __provide an 8-bit CPU targets field for each interrupt supported__\nby the GIC. __This field stores the list of target processors for the interrupt.__ That is, it holds\nthe list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and\nhas sufficient priority.\n\nIn a multiprocessor implementation, GICD_ITARGETSR0 to GICD_ITARGETSR7 are\nbanked for each connected processor. These registers hold the CPU targets fields for\ninterrupts 0-31.\n\nFixme [Figure 4-14 GICD_ITARGETSR bit assignments] 图片Page106\n\nTable 4-17 shows how each bit of a CPU targets field targets the interrupt at one of the CPU interfaces.\nFixme [Table 4-17 Meaning of CPU targets field bit values] 图片Page107\n\n\nSoftware can write to an GICD_ITARGETSR at any time.  （对Active无效，对pending 的有效）\nAny change to a CPU targets field value:\n• Has no effect on any active interrupt. This means that removing a CPU interface from a targets list does not\ncancel an active state for that interrupt on that CPU interface.\n• Has an effect on any pending interrupts. This means:\n\t— adding a CPU interface to the target list of a pending interrupt makes that interrupt pending on that\n\tCPU interface\n\t— removing a CPU interface from the target list of a pending interrupt removes the pending state of that\n\tinterrupt on that CPU interface\n• If it applies to an interrupt that is active and pending, does not change the interrupt targets until the active\nstatus is cleared.\t\n\n##### 4.3.13 Interrupt Configuration Registers, GICD_ICFGRn\n__The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC__.\nThis field identifies whether the corresponding interrupt is __edge-triggered or level-sensitive.__\n\nFixme [Figure 4-15 GICD_ICFGR bit assignments] 图片Page109\n\nFor SGIs, Int_config fields are read-only, meaning that GICD_ICFGR0 is read-only.\nBefore changing the value of a programmable Int_config field, software must disable the\ncorresponding interrupt, otherwise GIC behavior is UNPREDICTABLE.\n\nThese registers are available in all configurations of the GIC. If the GIC implements the\nSecurity Extensions these registers are Common.\nIn a multiprocessor implementation, if bit[1] of the Int_config field for any PPI is\nprogrammable then GICD_ICFGR1 is banked for each connected processor. This register\nholds the Int_config fields for the PPIs, interrupts 16-31.\n\nBITS        Name                        Function\n[2F+1:2F] \tInt_config, field F \t\tFor Int_config[1], the most significant bit, bit [2F+1], the encoding is:\n\t\t\t\t\t\t\t\t\t\t0 Corresponding interrupt is level-sensitive.\n\t\t\t\t\t\t\t\t\t\t1 Corresponding interrupt is edge-triggered.\n\t\t\t\t\t\t\t\t\t\tInt_config[0], the least significant bit, bit [2F], is reserved, but see Table 4-19 for the encoding of\n\t\t\t\t\t\t\t\t\t\tthis bit on some early implementations of this GIC architecture.\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tFor SGIs:\n\t\t\t\t\t\t\t\t\t\tInt_config[1] Not programmable, RAO/WI.\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tFor PPIs and SPIs:\n\t\t\t\t\t\t\t\t\t\tInt_config[1] For SPIs, this bit is programmable.a For PPIs it is IMPLEMENTATION DEFINED\n\t\t\t\t\t\t\t\t\t\twhether this bit is programmable. A read of this bit always returns the correct value\n\t\t\t\t\t\t\t\t\t\tto indicate whether the corresponding interrupt is level-sensitive or edge-triggered.\n\n\n##### 4.3.14 Non-secure Access Control Registers, GICD_NSACRn\nThe GICD_NSACRs enable Secure software to permit Non-secure software on a particular\nprocessor to create and manage Group 0 interrupts. They provide an access control for each\nimplemented interrupt.\n\nThe GICD_NSACRn registers do not support PPI accesses, meaning that GICD_NSACR0 bits [31:16] are\nRAZ/WI.\n\nFixme [Figure 4-16 GICD_NSACR bit assignments] 图片Page111\n\nBITS            Name                    Function\n[2F+1:2F] \t\tNS_access, Field F \t\tIf the corresponding interrupt does not support configurable Non-secure access, the field is\n\t\t\t\t\t\t\t\t\t\tRAZ/WI. Otherwise, the field is RW and configures the level of Non-secure access permitted\n\t\t\t\t\t\t\t\t\t\twhen the interrupt is in Group 0. If the interrupt is in Group 1, this field is ignored. The possible\n\t\t\t\t\t\t\t\t\t\tvalues of the field are:\n\n\t\t\t\t\t\t\t\t\t\t0b00 No Non-secure access is permitted to fields associated with the corresponding\n\t\t\t\t\t\t\t\t\t\tinterrupt.\n\n\t\t\t\t\t\t\t\t\t\t0b01 Non-secure write access is permitted to fields associated with the corresponding\n\t\t\t\t\t\t\t\t\t\tinterrupt in the GICD_ISPENDRn registers. A Non-secure write access to\n\t\t\t\t\t\t\t\t\t\tGICD_SGIR is permitted to generate a Group 0 SGI for the corresponding\n\t\t\t\t\t\t\t\t\t\tinterrupt.\n\n\t\t\t\t\t\t\t\t\t\t0b10 Adds Non-secure write access permission to fields associated with the\n\t\t\t\t\t\t\t\t\t\tcorresponding interrupt in the GICD_ICPENDRn registers. Also adds\n\t\t\t\t\t\t\t\t\t\tNon-secure read access permission to fields associated with the corresponding\n\t\t\t\t\t\t\t\t\t\tinterrupt in the GICD_ISACTIVERn and GICD_ICACTIVERn registers.\n\n\t\t\t\t\t\t\t\t\t\t0b11 Adds Non-secure read and write access permission to fields associated with the\n\t\t\t\t\t\t\t\t\t\tcorresponding interrupt in the GICD_ITARGETSRn registers\n\n\n##### 4.3.15 Software Generated Interrupt Register, GICD_SGIR\t\t\t\t\t\t\t\t\t\t\nThis register is available in all configurations of the GIC. If the GIC implements the\nSecurity Extensions(read GICD_TYPER) this register is Common.\nThe NSATT field, bit [15], is implemented only if the GIC implements the Security\nExtensions.\n\nFixme [Figure 4-17 GICD_SGIR bit assignments] 图片Page113\n\n\n\nBits \t\tName \t\t\t\tFunction\n[31:26] \t- \t\t\t\t\treserved.\n[25:24] \tTargetListFilter \tDetermines how the distributor must process the requested SGI:\n\t\t\t\t\t\t\t\t0b00 Forward the interrupt to the CPU interfaces specified in the CPUTargetList fielda.\n\t\t\t\t\t\t\t\t0b01 Forward the interrupt to all CPU interfaces except that of the processor that requested the\n\t\t\t\t\t\t\t\tinterrupt.\n\t\t\t\t\t\t\t\t0b10 Forward the interrupt only to the CPU interface of the processor that requested the\n\t\t\t\t\t\t\t\tinterrupt.\n\t\t\t\t\t\t\t\t0b11 Reserved.\n[23:16] \tCPUTargetList \t\tWhen TargetList Filter = 0b00, defines the CPU interfaces to which the Distributor must forward the\n\t\t\t\t\t\t\t\tinterrupt.\n\t\t\t\t\t\t\t\tEach bit of CPUTargetList[7:0] refers to the corresponding CPU interface, for example\n\t\t\t\t\t\t\t\tCPUTargetList[0] corresponds to CPU interface 0. Setting a bit to 1 indicates that the interrupt must be\n\t\t\t\t\t\t\t\tforwarded to the corresponding interface.\n\t\t\t\t\t\t\t\tIf this field is 0x00 when TargetListFilter is 0b00, the Distributor does not forward the interrupt to any\n\t\t\t\t\t\t\t\tCPU interface.\n[15] \t\tNSATT \t\t\t\tImplemented only if the GIC includes the Security Extensions.\n\t\t\t\t\t\t\t\tSpecifies the required security value of the SGI:\n\t\t\t\t\t\t\t\t0 Forward the SGI specified in the SGIINTID field to a specified CPU interface only if the\n\t\t\t\t\t\t\t\tSGI is configured as Group 0 on that interface.\n\t\t\t\t\t\t\t\t1 Forward the SGI specified in the SGIINTID field to a specified CPU interfaces only if\n\t\t\t\t\t\t\t\tthe SGI is configured as Group 1 on that interface.\n\t\t\t\t\t\t\t\tThis field is writable only by a Secure access. Any Non-secure write to the GICD_SGIR generates an\n\t\t\t\t\t\t\t\tSGI only if the specified SGI is programmed as Group 1, regardless of the value of bit[15] of the write.\n\t\t\t\t\t\t\t\tSee SGI generation when the GIC implements the Security Extensions for more information.\n\t\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\t\tIf GIC does not implement the Security Extensions, this field is reserved.\n[3:0] \t\tSGIINTID \t\t\tThe Interrupt ID of the SGI to forward to the specified CPU interfaces. The value of this field is the\n\t\t\t\t\t\t\t\tInterrupt ID, in the range 0-15, for example a value of 0b0011 specifies Interrupt ID 3.\t\t\t\t\t\t\n\n__SGI generation when the GIC implements the Security Extensions__\nIf the GIC implements the Security Extensions, whether an SGI is forwarded to a processor specified in the write\nto the GICD_SGIR depends on:\n• whether the write to the GICD_SGIR is Group 0 (Secure) or Group 1 (Non-secure)\n• for a Secure write to the GICD_SGIR, the value of the GICD_SGIR.NSATT bit\n• whether the specified SGI is configured as Group 0 (Secure) or Group 1 (Non-secure) on the targeted\nprocessor.\n\nFixme [Table 4-22 Truth table for sending an SGI to a target processor] Page 114\n\n##### 4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn\nThe GICD_CPENDSGIRs provide a clear-pending bit for each supported SGI and source\nprocessor combination. When a processor writes a 1 to a clear-pending bit, the pending state\nof the corresponding SGI for the corresponding source processor is removed, and no longer\ntargets the processor performing the write.\n\nNote\n• __In a multiprocessor implementation, the processor accessing the register can change the SGI pending status only on the corresponding interface. Changing the pending status of an SGI for one target processor does not affect the status of that SGI on any other processor.__\n• PPIs and SPIs both use the Interrupt Clear-Pending registers, GICD_ICPENDRn\n\nThese registers are present only in GICv2. The register locations are reserved in GICv1.In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.\n\nFour SGI Clear-Pending registers are implemented.each register contains eight clear-pending bits for each of four SGIs.\nIn a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.\n\n一共四个 GICD_CPENDSGIR寄存器，每个寄存器含有四个8 bits，分别代表了四个SGIs。\n\nFixme [Figure 4-18 GICD_CPENDSGIR bit assignments] Page 115\n\nBits \t\t\t\t\t\tName \t\t\t\t\t\tFunction\n[8y+7:8y], for y=0 to 3     SGI x Clear-pending bits  \tFor each bit:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tReads \t0 SGI x from the corresponding processor is not pendinga.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1 SGI x from the corresponding processor is pendinga.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tWrites \t0 Has no effect.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1 Removes the pending state of SGI x for the corresponding processor\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tAll accesses relate only to SGIs that target the processor making the access.\n\n\n\n##### 4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn\nThe GICD_SPENDSGIRn registers provide a set-pending bit for each supported SGI and\nsource processor combination. When a processor writes a 1 to a set-pending bit, the pending\nstate is applied to the corresponding SGI for the corresponding source processor.\n\nFixme [Figure 4-19 GICD_SPENDSGIR bit assignments] page 117\n\nBits Name Function\n[8y+7:8y], for y=0 to 3   SGI x Set-pending bits\tFor each bit:\n\t\t\t\t\t\t\t\t\t\t\t\t\tReads \t0 SGI x for the corresponding processor is not pendinga.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t1 SGI x for the corresponding processor is pendinga.\n\t\t\t\t\t\t\t\t\t\t\t\t\tWrites \t0 Has no effect.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1 Adds the pending state of SGI x for the corresponding processor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif it is not already pending. If SGI x is already pending for the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcorresponding processor then the write has no effect.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\t\t\t\t\t\t\tAll accesses relate only to SGIs that target the processor making the access.\n\n##### 4.3.18 Identification registers\nThis architecture specification defines offsets 0xFD0-0xFFC in the Distributor register map as a read-only\nidentification register space.\n\nFixme [Table 4-25 The GIC identification register space] page119\n\n__Peripheral ID2 Register, ICPIDR2__\nFixme [Figure 4-20 ICPIDR2 bit assignments] page119\n\n\nBits \tName \t\tFunction\n[7:4] \tArchRev \tRevision field for the GIC architecture. The value of this field depends on the GIC architecture version:\n\t\t\t\t\t• 0x1 for GICv1\n\t\t\t\t\t• 0x2 for GICv2.\n\n#### 4.4 CPU interface register descriptions\n\n##### 4.4.1 CPU Interface Control Register, GICC_CTLR\nEnables the signaling of interrupts by the CPU interface to the connected processor, and\nprovides additional top-level control of the CPU interface. In a GICv2 implementation, this\nincludes control of the end of interrupt (EOI) behavior.\n\n有几种类型的结构：\n__for a GICv1 implementation, for__\n• an implementation that does not include the Security Extensions\n• the Non-secure copy of the register, in an implementation that includes the Security Extensions.\nFixme [Figure 4-22 GICC_CTLR bit assignments, GICv1 without Security Extensions or Non-secure] page 126\n\n__a GIC v2 implementation that includes the Security Extensions, for the Non-secure copy of the register__\nFixme [Figure 4-23 GICC_CTLR bit assignments, GICv2 with Security Extensions, Non-secure copy] page 126\n\nBits \t\tName \t\t\tFunction\n[9] \t\tEOImodeNS \t\tControls the behavior of Non-secure accesses to the GICC_EOIR and GICC_DIR registers:\n\t\t\t\t\t\t\t0 \tGICC_EOIR has both priority drop and deactivate interrupt functionality.\n\t\t\t\t\t\t\t\tAccesses to the GICC_DIR are UNPREDICTABLE.\n\t\t\t\t\t\t\t1 \tGICC_EOIR has priority drop functionality only. The GICC_DIR register has\n\t\t\t\t\t\t\t\tdeactivate interrupt functionality.\n\n[6] \t\tIRQBypDisGrp1 \tWhen the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the\n\t\t\t\t\t\t\tbypass IRQ signal is signaled to the processor:\n\t\t\t\t\t\t\t0 \tBypass IRQ signal is signaled to the processor\n\t\t\t\t\t\t\t1 \tBypass IRQ signal is not signaled to the processor.\n\n[5] \t\tFIQBypDisGrp1 \tWhen the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the\n\t\t\t\t\t\t\tbypass FIQ signal is signaled to the processor:\n\t\t\t\t\t\t\t0 \tBypass FIQ signal is signaled to the processor\n\t\t\t\t\t\t\t1 \tBypass FIQ signal is not signaled to the processor.\n\n[0] \t\tEnableGrp1 \t\tEnable for the signaling of Group 1 interrupts by the CPU interface to the connected processor.\n\t\t\t\t\t\t\t0 Disable signaling of interrupts\n\t\t\t\t\t\t\t1 Enable signaling of interrupts.\n\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\tWhen this bit is set to 0, the CPU interface ignores any pending Group 1 interrupt forwarded to\n\t\t\t\t\t\t\tit. When this bit is set to 1, the CPU interface starts to process pending Group 1 interrupts that are\n\t\t\t\t\t\t\tforwarded to it. There is a small but finite time required for a change to take effect.\n\t\t\t\t\t\n__Security Extensions, for the Secure copy of the register__\n• a GICv2 implementation, for:\n— an implementation that does not include the Security Extensions\n— the Secure copy of the register, in an implementation that includes the Security Extensions\n• a GICv1 implementation that includes the Security Extensions, for the Secure copy of the register\n\nFixme [Figure 4-24 GICC_CTLR bit assignments, GICv2 without Security Extensions or Secure] page 128\n\n\nBits \t\tName \t\t\tFunction\n[10] \t\tEOImodeNS \t\tAlias of EOImodeNS from the Non-secure copy of this register, see Table 4-30 on page 4-126.\n\t\t\t\t\t\t\tIn a GICv2 implementation that does not include the Security Extensions, and in a GICv1\n\t\t\t\t\t\t\timplementation, this bit is reserved.\n\n[9] \t\tEOImodeS \t\tControls the behavior of accesses to GICC_EOIR and GICC_DIR registers. In a GIC implementation\n\t\t\t\t\t\t\tthat includes the Security Extensions, this control applies only to Secure accesses, and the EOImodeNS\n\t\t\t\t\t\t\tbit controls the behavior of Non-secure accesses to these registers:\n\t\t\t\t\t\t\t0 \t\tGICC_EOIR has both priority drop and deactivate interrupt functionality. Accesses to\n\t\t\t\t\t\t\t\t\tthe GICC_DIR are UNPREDICTABLE.\n\t\t\t\t\t\t\t1 \t\tGICC_EOIR has priority drop functionality only. GICC_DIR has deactivate interrupt\n\t\t\t\t\t\t\t\t\tfunctionality.\n\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\tThis bit is called EOImode in a GIC implementation that does not include the Security Extensions.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved.\n\n[8] \t\tIRQBypDisGrp1 \tAlias of IRQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved\n\n[7] \t\tFIQBypDisGrp1\tAlias of FIQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved.\t\t\t\t\t\t\t\n\n[6] \t\tIRQBypDisGrp0 \tWhen the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the bypass\n\t\t\t\t\t\t\tIRQ signal is signaled to the processor:\n\t\t\t\t\t\t\t0 \t\tBypass IRQ signal is signaled to the processor\n\t\t\t\t\t\t\t1 \t\tBypass IRQ signal is not signaled to the processor.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved.\n\n[5] \t\tFIQBypDisGrp0\tWhen the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the bypass\n\t\t\t\t\t\t\tFIQ signal is signaled to the processor:\n\t\t\t\t\t\t\t0 \t\tBypass FIQ signal is signaled to the processor\n\t\t\t\t\t\t\t1 \t\tBypass FIQ signal is not signaled to the processor.\n\t\t\t\t\t\t\tIn a GICv1 implementation, this bit is reserved.\n\n[4] \t\tCBPR \t\t\tControls whether the GICC_BPR provides common control to Group 0 and Group 1 interrupts.\n\t\t\t\t\t\t\t0 \t\tTo determine any preemption, use:\n\t\t\t\t\t\t\t\t\t• the GICC_BPR for Group 0 interrupts\n\t\t\t\t\t\t\t\t\t• the GICC_ABPR for Group 1 interrupts.\n\t\t\t\t\t\t\t1 \t\tTo determine any preemption use the GICC_BPR for both Group 0 and Group 1\n\t\t\t\t\t\t\t\t\tinterrupts.\n\n[3] \t\tFIQEn \t\t\tControls whether the CPU interface signals Group 0 interrupts to a target processor using the FIQ or\n\t\t\t\t\t\t\tthe IRQ signal.\n\t\t\t\t\t\t\t0 \t\tSignal Group 0 interrupts using the IRQ signal.\n\t\t\t\t\t\t\t1 \t\tSignal Group 0 interrupts using the FIQ signal.\n\t\t\t\t\t\t\tThe GIC always signals Group 1 interrupts using the IRQ signal.\n\n[2] \t\tAckCtl \t\t\tWhen the highest priority pending interrupt is a Group 1 interrupt, determines both:\n\t\t\t\t\t\t\t• whether a read of GICC_IAR acknowledges the interrupt, or returns a spurious interrupt ID\n\t\t\t\t\t\t\t• whether a read of GICC_HPPIR returns the ID of the highest priority pending interrupt, or\n\t\t\t\t\t\t\t\treturns a spurious interrupt ID.\n\n\t\t\t\t\t\t\t0 \t\tIf the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR\n\t\t\t\t\t\t\t\t\tor the GICC_HPPIR returns an Interrupt ID of 1022. A read of the GICC_IAR does\n\t\t\t\t\t\t\t\t\tnot acknowledge the interrupt, and has no effect on the pending status of the interrupt.\n\t\t\t\t\t\t\t1 \t\tIf the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR\n\t\t\t\t\t\t\t\t\tor the GICC_HPPIR returns the Interrupt ID of the Group 1 interrupt. A read of\n\t\t\t\t\t\t\t\t\tGICC_IAR acknowledges and Activates the interrupt.\n\t\t\t\t\t\t\tIn a GIC implementation that includes the Security Extensions, this control affects only the behavior\n\t\t\t\t\t\t\tof Secure register accesses.\n\t\t\t\t\t\t\tFor more information, see:\n\t\t\t\t\t\t\t• The effect of interrupt grouping on interrupt acknowledgement on page 3-50\n\t\t\t\t\t\t\t• Interrupt grouping and interrupt prioritization on page 3-53\n\t\t\t\t\t\t\t• Behavior of writes to GICC_EOIR, GICv1 with Security Extensions on page 4-139\n\t\t\t\t\t\t\t• Effect of interrupt grouping and the Security Extensions on reads of the GICC_HPPIR on\n\t\t\t\t\t\t\tpage 4-143.\n\t\t\t\t\t\t\tNote\n\t\t\t\t\t\t\tARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where\n\t\t\t\t\t\t\tGICC_CTLR.AckCtl is set to 0. See Enabling and disabling the Distributor and CPU interfaces on\n\t\t\t\t\t\t\tpage 4-77 for more information about the effects of setting this bit.\n\n[1] \t\tEnableGrp1 \t\tEnable for the signaling of Group 1 interrupts by the CPU interface to the connected processor:\n\t\t\t\t\t\t\t0 \t\tDisable signaling of Group 1 interrupts.\n\t\t\t\t\t\t\t1 \t\tEnable signaling of Group 1 interrupts.\n\n[0] \t\tEnableGrp0 \t\tEnable for the signaling of Group 0 interrupts by the CPU interface to the connected processor:\n\t\t\t\t\t\t\t0 \t\tDisable signaling of Group 0 interrupts.\n\t\t\t\t\t\t\t1 \t\tEnable signaling of Group 0 interrupts.\n\n\n##### 4.4.2 Interrupt Priority Mask Register, GICC_PMR\n__Provides an interrupt priority filter. Only interrupts with higher priority than the value in this register are signaled to the processor__\n\nFixme [Figure 4-25 GICC_PMR bit assignments] page131\n\n##### 4.4.3 Binary Point Register, GICC_BPR\nThe register defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field is used to determine __interrupt preemption.__\n\nFixme [Figure 4-26 GICC_BPR bit assignments] page133\n\nsee:\nTable 3-2 Priority grouping by binary point\nTable 3-7 Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0\n\n##### 4.4.4 Interrupt Acknowledge Register, GICC_IAR\nThe processor reads this register to obtain the interrupt ID of the signaled interrupt. This\nread acts as an acknowledge for the interrupt.\n\nWhen GICC_CTLR.AckCtl is set to 0 in a GICv2 implementation that does not include the\nSecurity Extensions, if the highest priority pending interrupt is in Group 1, the interrupt ID\n1022 is returned.\n\nFixme [Figure 4-27 GICC_IAR bit assignments] page135.\n\nBit \t\tName \t\t\tFunction\n[31:13] \t- \t\t\t\tReserved.\n[12:10] \tCPUID \t\t\t__For SGIs in a multiprocessor implementation__, this field identifies the processor that\n\t\t\t\t\t\t\trequested the interrupt. It returns the number of the CPU interface that made the\n\t\t\t\t\t\t\trequest, for example a value of 3 means the request was generated by a write to the\n\t\t\t\t\t\t\tGICD_SGIR on CPU interface 3.\n\t\t\t\t\t\t\tFor all other interrupts this field is RAZ.\n[9:0] \t\tInterrupt ID \tThe interrupt ID.\n\nThe read returns a spurious interrupt ID of 1023 if any of the following apply:\n• forwarding of interrupts by the Distributor to the CPU interface is disabled\n• signaling of interrupts by the CPU interface to the connected processor is disabled\n• no pending interrupt on the CPU interface has sufficient priority for the interface to signal it to the processor\n\n\nA non-spurious interrupt ID returned by a read of the GICC_IAR is called a valid interrupt ID.\n__When the GIC returns a valid interrupt ID to a read of the GICC_IAR it treats the read as an acknowledge of that interrupt and, as a side-effect of the read, changes the interrupt status from pending to active, or to active and pending if the pending state of the interrupt persists.__\n\nNote\n• For compatibility with possible extensions to the GIC architecture specification, ARM recommends that\nsoftware preserves the entire register value read from the GICC_IAR, and writes that value back to the\nGICC_EOIR when it has completed its processing of the interrupt.\n• Although multiple target processors might attempt to read the GICC_IAR at any time, in GICv2 only one\nprocessor can obtain a valid interrupt ID, see Implications of the 1-N model on page 3-41 for more\ninformation.\n\n\nFixme [Table 4-35 Effect of interrupt grouping and the Security Extensions on reads of GICC_IAR]Page136\n\n##### 4.4.5 End of Interrupt Register, GICC_EOIR\nA processor writes to this register to inform the CPU interface either:\n• that it has completed the processing of the specified interrupt\n• in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set\nto 1, to indicate that the interface should perform priority drop for the specified\ninterrupt. See Priority drop and interrupt deactivation on page 3-38 for more information.\n\nFixme [Figure 4-28 GICC_EOIR bit assignments]Page138\n\nFixme [Table 4-36 GICC_EOIR bit assignments]Page138\n\nFor every read of a valid Interrupt ID from the GICC_IAR, the connected processor must perform a matching write\nto the GICC_EOIR. The value written to the GICC_EOIR must be the interrupt ID read from the GICC_IAR.\nIf a read of the GICC_IAR returns the ID of a spurious interrupt, software does not have to make a corresponding\nwrite to the GICC_EOIR. If software writes the ID of a spurious interrupt to the GICC_EOIR, the GIC ignores that\nwrite.\n\n__Behavior of writes to GICC_EOIR, GICv2__\nIn a GICv2 implementation, when GICC_CTLR.AckCtl is set to 0:\n• GICC_EOIR is used for processing Group 0 interrupts\n• GICC_AEOIR is used for processing Group 1 interrupts.\n\nIn a GICv2 implementation that includes the GIC Security Extensions:\n• GICC_CTLR.EOImodeS controls the behavior of Secure accesses to GICC_EOIR and GICC_AEOIR\n• GICC_CTLR.EOImodeNS controls the behavior of Non-secure accesses to GICC_EOIR\n• when GICC_CTLR.AckCtl is set to 0:\n\t— a Non-secure write to GICC_EOIR must correspond to the most recent Non-secure read of GICC_IAR\n\t— a Secure write to the GICC_AEOIR must correspond to the most recent Secure read of the\n\tGICC_AIAR.\n\n##### 4.4.6 Running Priority Register, GICC_RPR\nIndicates the Running priority of the CPU interface\n\nFixme [Figure 4-29 GICC_RPR bit assignments] page142\n\n##### 4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR\nIndicates the Interrupt ID, and processor ID if appropriate, of the __highest priority pending__\ninterrupt on the CPU interface.\n\nFixme [Figure 4-30 GICC_HPPIR bit assignments] Page143\n\nBit\t\t\tName \t\tDescription\n[31:13] \t- \t\t\tReserved.\n[12:10] \tCPUID \t\tOn a multiprocessor implementation, if the PENDINTID field returns the ID of an\n\t\t\t\t\t\tSGI, this field contains the CPUID value for that interrupt. This identifies the\n\t\t\t\t\t\tprocessor that generated the interrupt.\n[9:0] \t\tPENDINTID \tThe interrupt ID of the highest priority pending interrupt. See Table 4-42 on\n\t\t\t\t\t\tpage 4-144 for more information about the result of Non-secure reads of the\n\t\t\t\t\t\tGICC_HPPIR when the GIC implements the Security Extensions.\n\n##### 4.4.8 Aliased Binary Point Register, GICC_ABPR\n##### 4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR\n##### 4.4.10 Aliased End of Interrupt Register, GICC_AEOIR\n##### 4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR\n与前面对应相似\n\n##### 4.4.12 Active Priorities Registers, GICC_APRn\n主要用于做电源管理时，保存与恢复。\nprovide support for preserving and restoring the active priority in power-management implementations.\n\nAlthough the format of these registers is IMPLEMENTATION DEFINED:\n• because GICv2 guarantees the ability to save and restore all GIC state, the\nGICC_APRn registers must be present in all GIC implementations\n• in an implementation that includes the GIC Security Extensions, Non-secure\naccesses must not affect Secure operation, and the architecture requires that these\nregisters are banked, to provide Secure and Non-secure copies of the registers.\n\n##### 4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn\nprovide support for preserving and restoring the active priority in power-management implementation. These are separate registers for Group 1 interrupts.\n\n##### 4.4.14 CPU Interface Identification Register, GICC_IIDR\nProvides information about the implementer and revision of the CPU interface.\n\nFixme [Figure 4-35 GICC_IIDR bit assignments] Page 152\n\nFixme [Table 4-48 GICC_IIDR bit assignments] Page 152\n\n##### 4.4.15 Deactivate Interrupt Register, GICC_DIR\nWhen interrupt priority drop is separated from interrupt deactivation, as described in\nPriority drop and interrupt deactivation on page 3-38, a write to this register __deactivates the specified interrupt.__\n\nFixme [Figure 4-36 GICC_DIR bit assignments] Page 153\n\nFixme [Table 4-49 GICC_DIR bit assignments] Page 153\n\nFixme [Table 4-50 Behavior of GICC_DIR writes] Page 154\n\n\n\n### 5 GIC Support for Virtualization\n#### 5.1 About implementing a GIC in a system with processor virtualization\n__Any ARM processor implementation that includes the Virtualization Extensions must also include the Security Extensions.__\n\nFixme [Figure 5-1 Implementing the GIC with an ARM processor that supports virtualization] Page159\n\n#### 5.2 Managing the GIC virtual CPU interface\nThe hypervisor, or similar software, manages the GIC virtual interface control registers, consisting of:\n__List registers__\nUsed to define the active and pending virtual interrupts for the virtual CPU interface. The current\nvirtual machine accesses these interrupts indirectly, using the virtual CPU interface.\n\n__Management registers__\nUsed to manage the virtual CPU interface, and to save and restore settings when switching between\nvirtual machines.\n\nThe hypervisor runs as Non-secure software in Hyp mode. To maintain the 1-N interrupt handling model, a hypervisor might have to migrate an interrupt from one virtual machine to another.\n\nWhen it receives a physical IRQ, the hypervisor determines the required destination of the interrupt and then either:\n• Processes the interrupt itself, for example if the IRQ is __a maintenance interrupt__ from the virtual CPU\ninterface. It then deactivates the physical interrupt.\n• Generates a virtual interrupt. Depending on the interrupt priority and the targeted virtual machine, the\nhypervisor takes one of the following actions:\n\t— If the interrupt is for the current virtual machine, updates the List registers with details of the interrupt,\n\tredefining the interrupts that are visible to the current virtual machine. If there is no space in the List\n\tregisters, it saves the context to memory so the details can be added at a later stage\n\t— Records that the interrupt is for a different virtual machine by saving details of the interrupt as part of\n\tthe hypervisor state associated with that virtual machine.\n\t— Switches to a different virtual machine that can handle the interrupt. In doing so it must save the\n\tinterrupt state for the current virtual machine, using the information in the List registers, and\n\treprogram the List registers, to indicate the interrupt state for the new virtual machine, including the\n\tstate for the interrupt that has arrived.\n\nThe virtual machine accesses the GIC virtual CPU interface registers. These registers have the same general format\nas the physical CPU interface registers, and, in a typical implementation the virtual machine believes it is accessing\na physical CPU interface.\n\nWhen the virtual machine handles a virtual interrupt, it writes to the virtual CPU interface to indicate when it has\nfinished this processing. The virtual CPU interface signals this completion to the physical Distributor and the\nphysical Distributor then deactivates the interrupt.\n\n##### 5.2.1 List registers and virtual interrupt handling\na hypervisor uses List registers to maintain the list of highest priority virtual interrupts.\n\n记录的数据可以超过List registers数量，多余的数据存储在MEM 中。\n__The total number of interrupts that are either pending, active, or active and pending, can exceed the number of List registers available.__\nIf this happens, the hypervisor can save one or more active interrupt entries to memory, and later restore them to the List registers，based on their priority。Therefore:\n• The List registers might not include all active, or active and pending, interrupts. Virtual CPU interface\naccesses by the virtual machine update the List registers, and normally an EOI request from the virtual\nmachine deactivates an interrupt in the list. However, the virtual machine can issue an EOI request for an\ninterrupt before the hypervisor restores the associated active interrupt entry into a List register. In this case,\nthe EOI request cannot update the List registers.\n\n• Although the List registers might include only active interrupts, with the hypervisor maintaining any pending\ninterrupts in memory, a pending interrupt cannot be signaled to the virtual machine until the hypervisor adds\nit to the List registers. Therefore, to minimize interrupt latency and ensure efficient virtual machine operation,\n__ARM strongly recommends that the List registers contain at least one pending interrupt, provided a List register is available for this interrupt.__\n\n##### 5.2.2 Completion of virtualized physical interrupts\nARM recommends that, for each CPU interface that corresponds to a\nprocessor running virtual machines, the GICC_CTLR.EOImodeNS bit is set to 1. This means that hypervisor\naccesses to the GICC_AEOIR register drops the running priority of the CPU interface but does not deactivate the\ninterrupt. After writing to the EOI register, the running priority level on the CPU interface is lower, so that\nsubsequent interrupts can be signaled to the processor.\n\nARM recommends that physical interrupt completion consists of the following separate steps:\n1. EOI\n2. interrupt deactivation.\n\nThese steps are explained in more detail as follows:\n1. After receiving a physical interrupt, the hypervisor performs an EOI request for the physical interrupt by\nwriting to the GICC_EOIR or GICC_AEOIR register. After EOI, although the virtual machine has not\nprocessed the virtual interrupt, the lower running priority of the CPU interface means that the hypervisor can\nstill receive new physical interrupts.\n\tNote\n\tThe only interrupts that are not signaled to the hypervisor are the physical interrupts most recently subject to\n\tEOI. This is because the interrupts have not been deactivated. This prevents the interrupts from being\n\tre-signaled to the hypervisor before being processed by the virtual machine.\n\n2. After the virtual machine completes processing the corresponding virtual interrupt, it writes to the\nGICV_EOIR or GICV_AEOIR to deactivate the interrupt. This deactivates both the virtual interrupt and the\ncorresponding physical interrupt, provided that both of the following conditions are true:\n• the GICV_CTLR.EOImode bit is set to 0\n• the GICH_LRn.HW bit is set to 1.\n\nAlternatively, if the GICV_CTLR.EOImode bit is set to 1, the virtual machine writes to the GICV_DIR\nregister to deactivate the interrupt.\nIf the GICH_LRn.HW bit is set to 0, the hypervisor must deactivate the physical interrupt itself. ARM\nrecommends one of the following methods for deactivating physical SGIs that are routed to a virtual machine:\n• the hypervisor deactivates the SGI by writing to the GICC_DIR register after the virtual machine\nwrites to GICC_EOIR\n• the hypervisor uses an EOI maintenance interrupt to write to the GICC_DIR register after the virtual\nmachine writes to GICV_EOIR, see Maintenance interrupts on page 5-164 for more information.\n\n处理大致流程：\n1. hypervisor 写GICC_AEOIR，让此IRQ 丢掉优先级，能让其他低优先级的中断能被处理\n2. virtual machine 处理完后，virtual cpu 写GICV_EOIR 或 GICV_AEOIR，再写GICV_DIR （依赖GICV_CTLR.EOImode 设定是否自动完成后一步）\n3. 在virtual machine 写 GICV_EOIR 后，hypervisor 用 EOI maintenance interrupt 写 GICC_DIR （GICH_LRn.HW 设定为1，自动完成此步）\n\n##### 5.2.3 Acknowledgement and completion of virtual interrupts\nTo ensure system correctness when handling virtual interrupts, one of the following conditions must be true:\n• All Group 0 interrupts must have a higher priority than any Group 1 interrupt. That is, there is no overlap in\nthe priorities allocated to Group 0 and Group 1 interrupts.\n• The GICV_CTLR.AckCtl bit must be set to 0.\n\n__ARM deprecates the use of GICC_CTLR.AckCtl and GICV_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl and GICV_CTLR.AckCtl are set to 0.__\n\n##### 5.2.4 GIC virtual interface control interface requirements\nskip\n\n##### 5.2.5 Maintenance interrupts\n__Maintenance interrupts can signal key events in the operation of a GIC that implements the Virtualization Extensions. Typically, these events are processed by the hypervisor.__\n\nNote\n• Maintenance interrupts are generated only when the global interrupt enable bit, GICH_HCR.En, is set to 1.\n\nMaintenance interrupts are level-sensitive interrupts. Configuration bits in the GICH_HCR can be set to 1 to enable\nmaintenance interrupt generation when:\n• Group 0 virtual interrupts are enabled/disabled\n• Group 1 virtual interrupts are enabled/disabled\n• There are no pending interrupts in the List registers.\n• At least one EOI request occurs with no valid List register entry for the corresponding interrupt.\n• There are no valid entries, or only one valid entry, in the List registers. This is an underflow condition.\n• At least one List register entry has received an EOI request.\n\n##### 5.2.6 Software-generated interrupts\n__Hypervisor-generated interrupts__\nA hypervisor can generate virtual interrupts that do not have a corresponding physical interrupt, by\ncreating an entry in the List registers with the GICH_LRn.HW bit cleared to 0. The hypervisor can\ncontrol how the interrupt appears to a virtual machine reading the GICV_IAR or GICV_AIAR\nregister to acknowledge the interrupt, by presenting the interrupt as:\n• an SGI, with a CPUID value provided in addition to the interrupt ID\n• a PPI or SPI, with the CPUID value set to 0.\n\nThe hypervisor can virtualize the CPUID value, but it must be consistent with the type of interrupt\nindicated by the GICH_LRn.VirtualID field. When the EOI notification is sent to the virtual CPU\ninterface, only the List registers are affected, and no notification is sent to the Distributor. See List\nRegisters, GICH_LRn on page 5-176 for more information.\n\nhypervisor 可以产生与硬件中断号不一致的虚拟中断，并且可以控制中断在虚拟机中呈现的形式：SGI，PPI，SPI。\n\n__Distributor-generated interrupts__\nBecause the hardware interrupt deactivation mechanism does not support SGIs, the hypervisor must\nvirtualize SGIs originating from the Distributor in the same way as hypervisor-generated interrupts.\nThe hypervisor can virtualize the GICH_LRn.CPUID field, because this field is not required to be\nthe same as that of the original SGI. See Completion of virtualized physical interrupts on page 5-161\nfor more information about deactivating virtualized SGIs.\n\n虚拟中断分发器 产生的虚拟机之间的SGIs。\n\n##### 5.2.7 GIC Virtualization Extensions register mapping\nThe GIC must make these virtual interface control registers accessible in the following ways:\n__Redirection through a common base address__\nThe memory map includes a common base address for the virtual interface control registers. Each\nprocessor in the system can access its own GIC virtual interface control registers through this base\naddress. The CPUID of the processor requesting access redirects the access to the GIC virtual\ninterface control registers for that processor.\n\n__Processor-specific base addresses__\nIn addition to the common base address, the memory map contains, for each processor in the system,\na processor-specific base address for the GIC virtual interface control registers. Any processor can\nuse these addresses to access its own GIC virtual interface control registers, or to access the GIC\nvirtual interface control registers of any other processor in the system.\n\nFixme [Figure 5-2 GIC virtual interface control register mappings] page166\n\n#### 5.3 GIC virtual interface control registers\nFixme [Table 5-1 GIC virtual interface control register map] page167\n\n\n##### 5.3.1 Hypervisor Control Register, GICH_HCR\nThis register contains control bits for the virtual CPU interface.\n\nFixme [Figure 5-3 GICH_HCR bit assignments] page168\n\nFixme [Table 5-2 GICH_HCR bit assignments] page168\n\nFixme [Table 5-2 GICH_HCR bit assignments] page169\n\n##### 5.3.2 VGIC Type Register, GICH_VTR\nThis is a read-only register that provides the following information about the\nimplementation of the GIC Virtualization Extensions:\n• number of priority levels supported\n• number of preemption levels supported\n• number of implemented List registers.\n\nFixme [Figure 5-4 GICH_VTR bit assignments] page170\n\nFixme [Table 5-3 GICH_VTR bit assignments] page170\n\n##### 5.3.3 Virtual Machine Control Register, GICH_VMCR\nEnables the hypervisor to save and restore the virtual machine view of the GIC state.\n\nFixme [Figure 5-5 GICH_VMCR bit assignments] page171\n\nThe GICH_VMCR is a control register that contains read and write aliases of architecture state in the virtual\nmachine view, enabling the hypervisor to save and restore this state with a single read or write, without accessing\nthe GIC virtual CPU interface registers individually.\n\n##### 5.3.4 Maintenance Interrupt Status Register, GICH_MISR\n\nIndicates which maintenance interrupts are asserted.\n\nFixme [Figure 5-6 GICH_MISR bit assignments] page172\n\nFixme [Table 5-5 GICH_MISR bit assignments] page172\n\n##### 5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1\nWhen a maintenance interrupt is received, these registers help determine which List\nregisters have outstanding EOI interrupts that require servicing.\n\nFixme [Figure 5-7 GICH_EISR0 bit assignments] page173\n\nFixme [Table 5-6 GICH_EISR0 bit assignments] page173\n\n##### 5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1\nThese registers can be used to locate a usable List register when the hypervisor is delivering\nan interrupt to a Guest OS.\n\nFixme [Figure 5-8 GICH_ELRSR0 bit assignments] page173\n\nFixme [Table 5-7 GICH_ELRSR0 bit assignments] page173\n\n##### 5.3.7 Active Priorities Register, GICH_APR\nThis register tracks which preemption levels are active in the virtual CPU interface, and is\nused to determine the current active priority. Corresponding bits are set in this register when\nan interrupt is acknowledged, based on GICH_LRn.Priority, and the least significant set bit\nis cleared on EOI.\n\nFixme [Figure 5-9 GICH_APR bit assignments] page175\n\nFixme [Table 5-8 GICH_APR bit assignments] page175\n\n##### 5.3.8 List Registers, GICH_LRn\nProvides interrupt context information for the virtual CPU interface. __A maximum of 64 List registers can be provided. The GICH_VTR.ListRegs bit defines the actual number implemented.__\n\nFixme [Figure 5-10 GICH_LR bit assignments] page176\n\nFixme [Table 5-9 GICH_LR bit assignments] page176\n\n#### 5.4 The virtual CPU interface\nA GIC virtual CPU interface signals virtual interrupts to a connected processor, The GIC virtual CPU interface registers have the same general format as the GIC physical CPU interface registers and expected behavior is that a virtual machine cannot distinguish between them.\n\n__In particular, the virtual CPU interface uses the contents of the List registers to determine when to signal virtual interrupts.__\n\nWhen a processor accesses the virtual CPU interface the List registers are updated.\n• Virtual interrupts are always handled through the virtual CPU interfaces.\n• On the connected processor, if the processor is in a Non-secure PL1 or PL0 mode, virtual interrupts are\nsignaled to the current virtual machine.\n• In addition, a virtual machine can receive virtual IRQs and virtual FIQs signaled directly by the hypervisor.\nThese exceptions are outside the scope of this specification. A virtual machine cannot distinguish:\n\t— A virtual exception signaled by the GIC from a corresponding virtual exception signaled directly by the hypervisor.\n\t— A virtual exception from the corresponding physical exception.\n• A virtual CPU interface does not require power management support, and therefore GICV_CTLR does not\nimplement the IRQBypDisGrp1, FIQBypDisGrp1, IRQBypDisGrp0, and FIQBypDisGrp0 bits that are\nsupported by GICC_CTLR\n\n#### 5.5 GIC virtual CPU interface registers\nTypically, a virtual machine is unaware of any difference between virtual interrupts and physical interrupts.\n\n__In general, these registers have the same format as the GIC physical CPU interface registers, but they operate on the interrupt view defined primarily by the List registers.__\n\nThese registers are memory-mapped, The offset of each GICV_* register is the same as the offset of the corresponding register for the physical CPU interface.\n\nFixme [Table 5-10 GIC virtual CPU interface register map] page179\n\n\n","slug":"arm_gic","published":1,"updated":"2019-07-08T06:16:07.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck915p103008szkgrikrhh4o3","content":"<p>GICv2<br><a id=\"more\"></a></p>\n<p>##1. Introduction<br>About the Generic Interrupt Controller architecture<br>The Generic Interrupt Controller (GIC) architecture defines:<br>• the architectural requirements for handling all interrupt sources for any processor connected to a GIC<br>• a common interrupt controller programming interface applicable to uniprocessor or multiprocessor systems</p>\n<p>The architecture describes a GIC designed for use with one or more processors that comply with the ARM A and R<br>architecture profiles.</p>\n<p>The GIC is a centralized resource for supporting and managing interrupts in a system that includes at least one<br>processor. It provides:<br>• registers for managing interrupt sources, interrupt behavior, and interrupt routing to one or more processors<br>• support for:<br>    — the ARM architecture Security Extensions<br>    — the ARM architecture Virtualization Extensions<br>    — enabling, disabling, and generating processor interrupts from hardware (peripheral) interrupt sources<br>    — Software-generated Interrupts (SGIs)<br>    — interrupt masking and prioritization<br>    — uniprocessor and multiprocessor environments<br>    — wakeup events in power-management environments.</p>\n<p>The GIC includes interrupt grouping functionality that supports:<br>• configuring each interrupt as either Group 0 or Group 1<br>• signaling Group 0 interrupts to the target processor using either the IRQ or the FIQ exception request<br>• signaling Group 1 interrupts to the target processor using the IRQ exception request only<br>• a unified scheme for handling the priority of Group 0 and Group 1 interrupts<br>• optional lockdown of the configuration of some Group 0 interrupts.</p>\n<p>fiq 优先级比 irq 高<br>fiq 模式下寄存器 比 irq 模式多（R8 ~ R12）<br><a href=\"http://blog.chinaunix.net/attachment/201302/21/28458801_1361445566H9Z3.png\" target=\"_blank\" rel=\"noopener\">http://blog.chinaunix.net/attachment/201302/21/28458801_1361445566H9Z3.png</a></p>\n<h3 id=\"1-2-Security-Extensions-support\"><a href=\"#1-2-Security-Extensions-support\" class=\"headerlink\" title=\"1.2. Security Extensions support\"></a>1.2. Security Extensions support</h3><p>The ARM processor Security Extensions are an optional extension to the ARMv7-A architecture profile.</p>\n<p>ARM Security Extensions facilitate the development of secure applications by:<br>• integrating hardware security features into the architecture<br>• providing Secure virtual memory space that is accessed by memory accesses in the Secure state<br>• providing Non-secure virtual memory space that is accessed by memory accesses in the Non-secure state.</p>\n<p>When a GIC that implements the GIC Security Extensions is connected to a processor that implements the ARM<br>Security Extensions:<br>• Group 0(IRQ/FIQ) interrupts are Secure interrupts, and Group 1(IRQ) interrupts are Non-secure interrupts.</p>\n<p>Processor security state and Secure and Non-secure GIC accesses：<br>• a processor in Non-secure state can make only Non-secure accesses to a GIC<br>• a processor in Secure state can make both Secure and Non-secure accesses to a GIC</p>\n<h3 id=\"1-3-Virtualization-support\"><a href=\"#1-3-Virtualization-support\" class=\"headerlink\" title=\"1.3. Virtualization support\"></a>1.3. Virtualization support</h3><p>The ARM processor Virtualization Extensions are optional extensions to the ARMv7-A architecture profile. The GIC Virtualization Extensions provide mechanisms to minimize the hypervisor overhead of routing interrupts to virtual machines.</p>\n<p>The processor Virtualization Extensions provide hardware support for virtualizing the Non-secure state of an<br>VMSAv7 implementation. The extensions support system use of a virtual machine monitor, known as the<br>hypervisor, to switch guest operating systems.</p>\n<p>Whether implemented in a uniprocessor or in a multiprocessor system, the processor Virtualization Extensions<br>support running multiple virtual machines on a single processor.</p>\n<p>The hypervisor can either handle a physical interrupt itself, or generate a corresponding virtual interrupt that is signaled to a virtual machine. It is also possible for the hypervisor to generate virtual interrupts that do not correspond to physical interrupts.</p>\n<p>1) physical interrupt =&gt; virtual machine =&gt; virtual interrupt （产生与硬件相应的虚拟中断）<br>2) virtual machine =&gt; virtual interrupt （也可以产生与硬件中断没有关的虚拟中断）</p>\n<h3 id=\"1-4-Terminology-（专用名词）\"><a href=\"#1-4-Terminology-（专用名词）\" class=\"headerlink\" title=\"1.4. Terminology （专用名词）\"></a>1.4. Terminology （专用名词）</h3><h4 id=\"1-4-1-Interrupt-states\"><a href=\"#1-4-1-Interrupt-states\" class=\"headerlink\" title=\"1.4.1. Interrupt states\"></a>1.4.1. Interrupt states</h4><p>Inactive            An interrupt that is not active or pending.</p>\n<p>Pending             An interrupt from a source to the GIC that is recognized as asserted in hardware, or<br>                    generated by software, and is waiting to be serviced by a target processor.</p>\n<p>Active                 An interrupt from a source to the GIC that has been acknowledged by a processor, and is<br>                    being serviced but has not completed.</p>\n<p>Active and pending     A processor is servicing the interrupt and the GIC has a pending interrupt from the same<br>source.</p>\n<h4 id=\"1-4-2-Interrupt-types\"><a href=\"#1-4-2-Interrupt-types\" class=\"headerlink\" title=\"1.4.2. Interrupt types\"></a>1.4.2. Interrupt types</h4><p>Peripheral interrupt</p>\n<pre><code>Private Peripheral Interrupt (PPI)\nThis is a peripheral interrupt that is specific to a single processor.\n\nShared Peripheral Interrupt (SPI)\nThis is a peripheral interrupt that the Distributor can route to any of a specified\ncombination of processors.\n\nEach peripheral interrupt is either:\nEdge-triggered\n    This is an interrupt that is asserted on detection of a rising edge of an interrupt\n    signal and then, regardless of the state of the signal, remains asserted until it is\n    cleared by the conditions defined by this specification.\n\nLevel-sensitive\n    This is an interrupt that is asserted whenever the interrupt signal level is active,\n    and deasserted whenever the level is not active.\n</code></pre><p>Software-generated interrupt (SGI)<br>        This is an interrupt generated by software writing to a GICD_SGIR register in the GIC.The<br>        system uses SGIs for interprocessor communication.</p>\n<pre><code>When an SGI occurs in a multiprocessor implementation, the CPUID field in the Interrupt\nAcknowledge Register, GICC_IAR, or the Aliased Interrupt Acknowledge Register,\nGICC_AIAR, identifies the processor that requested the interrupt.\n\n__An SGI has edge-triggered properties__. （边缘触发）\n\nIn an implementation that includes the GIC Virtualization Extensions:\n• when an SGI occurs, management registers in the GIC virtualization Extensions\nenable the requesting processor to be reported to the Guest OS, as required by the\nGIC specifications\n• by writing to the management registers in the GIC Virtualization Extensions, a\nhypervisor can generate a virtual interrupt that appears to a virtual machine as an SGI.\n</code></pre><p>Virtual interrupt<br>    In a GIC that implements the GIC Virtualization Extensions, an interrupt that targets a<br>    virtual machine running on a processor, and is typically signaled to the processor by the<br>    connected virtual CPU interface.        </p>\n<p>Maintenance interrupt<br>    In a GIC that implements the GIC Virtualization Extensions, a level-sensitive interrupt that<br>    is used to signal key events, such as a particular group of interrupts becoming enabled or<br>    disabled. See Maintenance interrupts on page 5-164 for more information.    </p>\n<h4 id=\"1-4-3-Models-for-handling-interrupts\"><a href=\"#1-4-3-Models-for-handling-interrupts\" class=\"headerlink\" title=\"1.4.3. Models for handling interrupts\"></a>1.4.3. Models for handling interrupts</h4><p>1-N model 常规硬件中断，单个的SPI， PPI<br>    Only one processor handles this interrupt. The system must implement a mechanism to determine<br>    which processor handles an interrupt that is programmed to target more than one processor.</p>\n<p>N-N model 主要SGI， SPI可能会出现<br>    All processors receive the interrupt independently. When a processor acknowledges the interrupt,<br>    the interrupt pending state is cleared only for that processor. The interrupt remains pending for the<br>    other processors.</p>\n<h4 id=\"1-4-4-Spurious-interrupts-（假的中断）\"><a href=\"#1-4-4-Spurious-interrupts-（假的中断）\" class=\"headerlink\" title=\"1.4.4. Spurious interrupts （假的中断）\"></a>1.4.4. Spurious interrupts （假的中断）</h4><p>It is possible that an interrupt that the GIC has signaled to a processor is no longer required.If this happens, when<br>the processor acknowledges the interrupt, the GIC returns a special Interrupt ID(1020 ~ 1023) that identifies the interrupt as a<br>spurious interrupt.</p>\n<p>Example reasons for spurious interrupts are:<br>• prior to the processor acknowledging an interrupt:<br>— software changes the priority of the interrupt<br>— software disables the interrupt<br>— software changes the processor that the interrupt targets<br>• for a 1-N interrupt, another target processor has previously acknowledged that interrupt.</p>\n<h2 id=\"2-GIC-Partitioning\"><a href=\"#2-GIC-Partitioning\" class=\"headerlink\" title=\"2. GIC Partitioning\"></a>2. GIC Partitioning</h2><h3 id=\"2-1-About-GIC-partitioning\"><a href=\"#2-1-About-GIC-partitioning\" class=\"headerlink\" title=\"2.1 About GIC partitioning\"></a>2.1 About GIC partitioning</h3><p>The GIC architecture splits logically into a Distributor block and one or more CPU interface blocks. The GIC<br>Virtualization Extensions add one or more virtual CPU interfaces to the GIC.</p>\n<p>GIC 架构有1个GIC Distributor, 一个或多个CPU Interface， 一个或多个virtual CPU interface（GIC Virtualization Extensions support）</p>\n<p>Distributor<br>    The Distributor block performs interrupt prioritization and distribution to the CPU interface<br>    blocks that connect to the processors in the system.<br>    The Distributor block registers are identified by the GICD_ prefix.</p>\n<p>CPU interfaces<br>    Each CPU interface block performs priority masking and preemption handling for a<br>    connected processor in the system.</p>\n<pre><code>When describing a GIC that includes the GIC Virtualization Extensions, a CPU interface is\nsometimes called a physical CPU interface, to avoid possible confusion with a virtual CPU\ninterface.\n\nCPU interface block registers are identified by the GICC_ prefix.\n</code></pre><p>Virtual CPU interfaces<br>    Each virtual CPU interface is partitioned into the following blocks:</p>\n<pre><code>Virtual interface control\n    The main component of the virtual interface control block is the GIC virtual\n    interface control registers, that include a list of active and pending virtual\n    interrupts for the current virtual machine on the connected processor. \n\n    Typically, these registers are managed by the hypervisor that is running on that processor.\n\n    Virtual interface control block registers are identified by the GICH_ prefix.\n\nVirtual CPU interface\n    Each virtual CPU interface block provides physical signaling of virtual\n    interrupts to the connected processor. The ARM processor Virtualization\n    Extensions signal these interrupts to the current virtual machine on that\n    processor. \n\n    The GIC virtual CPU interface registers, accessed by the virtual\n    machine, provide interrupt control and status information for the virtual\n    interrupts. The format of these registers is similar to the format of the physical\n    CPU interface registers.\n\n    Virtual CPU interface block registers are identified by the GICV_ prefix.\n</code></pre><p> Note: The virtual CPU interface does not support the power management functionality described</p>\n<p> A GIC can implement up to eight CPU interfaces, numbered from 0-7.<br> In a GIC that implements the GIC Virtualization Extensions, virtual CPU interface numbering corresponds to the CPU interface numbering, so that<br>CPU interface 0 and virtual CPU interface 0 connect to the same processor.</p>\n<p>一个GIC 最多支持8个CPU， 而 physical CPU interface 与virtual CPU interface 个数对应一样多。</p>\n<p>FixMe： 补上GIC logical partitioning</p>\n<h3 id=\"2-2-The-Distributor\"><a href=\"#2-2-The-Distributor\" class=\"headerlink\" title=\"2.2. The Distributor\"></a>2.2. The Distributor</h3><p>The Distributor provides a programming interface for:<br>    • Globally enabling the forwarding of interrupts to the CPU interfaces.<br>    • Enabling or disabling each interrupt.<br>    • Setting the priority level of each interrupt.<br>    • Setting the target processor list of each interrupt.<br>    • Setting each peripheral interrupt to be level-sensitive or edge-triggered.<br>    • Setting each interrupt as either Group 0 or Group 1.<br>    • Forwarding an SGI to one or more target processors.<br>In addition, the Distributor provides:<br>    • visibility of the state of each interrupt<br>    • a mechanism for software to set or clear the pending state of a peripheral interrupt.</p>\n<h4 id=\"2-2-1-Interrupt-IDs\"><a href=\"#2-2-1-Interrupt-IDs\" class=\"headerlink\" title=\"2.2.1 Interrupt IDs\"></a>2.2.1 Interrupt IDs</h4><p>GICv2 - The GIC assigns interrupt ID numbers ID0-ID1019 as follows:<br>    具有唯一标示<br>    SPI: 32 ~ 1019 </p>\n<pre><code>banked interrupt 可重入或重复的中断， 每个CPU 的中断号可相同\nPPI: 16 ~ 31\nSGI: 0 ~ 15\n</code></pre><p>In any system that implements the ARM Security Extensions, to support a consistent model for message passing<br>between processors, ARM strongly recommends that all processors reserve:<br>    • ID0-ID7 for Non-secure interrupts<br>    • ID8-ID15 for Secure interrupts.</p>\n<p>Interrupt numbers ID1020-ID1023    are reserved for special purposes,</p>\n<h3 id=\"2-3-CPU-interfaces\"><a href=\"#2-3-CPU-interfaces\" class=\"headerlink\" title=\"2.3. CPU interfaces\"></a>2.3. CPU interfaces</h3><p>Each CPU interface block provides the interface for a processor that is connected to the GIC.<br>    • enabling the signaling of interrupt requests to the processor<br>    • acknowledging an interrupt<br>    • indicating completion of the processing of an interrupt<br>    • setting an interrupt priority mask for the processor<br>    • defining the preemption policy for the processor<br>    • determining the highest priority pending interrupt for the processor.</p>\n<p>GCI CPU interfaces是否拉起中断信号给处理器流程<br>Signal interrupt request flow:<br>    take the highest priorty pending interrupt(read GICC_HPPIR) -&gt; check interrupt priority mask and the preemption settings -&gt;<br>    signal or ignore interrupt request</p>\n<p>CPU获取中断ID<br>The processor acknowledges the interrupt request by reading the CPU interface Interrupt Acknowledge Register.<br>This read returns one of:<br>    • The ID number of the highest priority pending interrupt, if that interrupt is of sufficient priority for it to be<br>    signaled to the processor. This is the normal response to an interrupt acknowledge.<br>    • Exceptionally, an ID number that indicates a spurious interrupt(1020 ~ 1023)</p>\n<p>中断处理完成后<br>There are two stages to interrupt completion:<br>    • priority drop, meaning the priority of the processed interrupt can no longer prevent the signaling of another<br>    interrupt to the processor<br>    • interrupt deactivation, meaning the Distributor removes the active state of the interrupt.</p>\n<p>In a GICv1 implementation, these two stages always happen together, when the processor writes to the CPU<br>interface End of Interrupt register.</p>\n<p>In a GICv2 implementation, the GICC_CTLR.EOImode bit determines whether:<br>    • the two stages happen together, when the processor writes to the CPU interface End of Interrupt register<br>    • the two stages are separated, so that:<br>        — priority drop happens when the processor writes to the CPU interface End of Interrupt register<br>        — interrupt deactivation happens later, when the processor writes to the CPU interface Deactivate<br>        Interrupt register.    </p>\n<h4 id=\"2-3-1-Interrupt-signal-bypass-and-GICv2-bypass-disable\"><a href=\"#2-3-1-Interrupt-signal-bypass-and-GICv2-bypass-disable\" class=\"headerlink\" title=\"2.3.1 Interrupt signal bypass, and GICv2 bypass disable\"></a>2.3.1 Interrupt signal bypass, and GICv2 bypass disable</h4><p>In all GIC implementations, a CPU interface optionally includes interrupt signal bypass, so that, when the signaling<br>of an interrupt by the interface is disabled, a system legacy interrupt signal is passed to the interrupt request input<br>on the processor, bypassing the GIC functionality.<br>中断信号旁路，主要支援legacy interrupt 不会受到CPU interface disable的影响，GICv2 must also provide disable bits for the interrupt<br>signal bypass operation.</p>\n<p>FixMe 增加Interrupt signal bypass, GICv1 without Security Extensions 图片</p>\n<h4 id=\"2-3-2-Power-management-GIC-v2\"><a href=\"#2-3-2-Power-management-GIC-v2\" class=\"headerlink\" title=\"2.3.2 Power management, GIC v2\"></a>2.3.2 Power management, GIC v2</h4><p>The GICv2 architecture supports wakeup events in implementations that require power management.<br>These signals are available even when both interrupt signaling by the GIC, and interrupt bypass, are disabled.</p>\n<p>为软件提供预留或回复状态寄存器<br>the GICC_APRn registers provide support for preserving and restoring state in power-management<br>applications<br>However, to ensure that Non-secure accesses do not interfere with Secure operation, Secure and<br>Non-secure copies of these registers are provided.</p>\n<h3 id=\"3-Interrupt-Handling-and-Prioritization\"><a href=\"#3-Interrupt-Handling-and-Prioritization\" class=\"headerlink\" title=\"3 Interrupt Handling and Prioritization\"></a>3 Interrupt Handling and Prioritization</h3><h4 id=\"3-1-About-interrupt-handling-and-prioritization\"><a href=\"#3-1-About-interrupt-handling-and-prioritization\" class=\"headerlink\" title=\"3.1 About interrupt handling and prioritization\"></a>3.1 About interrupt handling and prioritization</h4><p>Interrupt handling describes:<br>    • how the GIC recognizes interrupts<br>    • how software can program the GIC to configure and control interrupts<br>    • the state machine the GIC maintains for each interrupt on each CPU interface<br>    • how the exception model of a processor interacts with the GIC.</p>\n<p>Prioritization describes:<br>    • the configuration and control of interrupt priority<br>    • the order of execution of pending interrupts<br>    • the determination of when interrupts are visible to a target processor, including:<br>        — interrupt priority masking<br>        — priority grouping<br>        — preemption of an active interrupt.</p>\n<p>all implementations of the GIC architecture support interrupt grouping. With interrupt grouping:<br>    • by default, all interrupts are Group 0 interrupts, and are signaled to a connected processor using the IRQ<br>    interrupt request<br>    • each interrupt can be configured as Group 1 interrupt, or as a Group 0 interrupt<br>    • a CPU interface can be configured to signal Group 0 interrupts to a connected processor using the FIQ<br>    interrupt request.    </p>\n<h5 id=\"3-1-1-About-interrupt-handling-and-prioritization\"><a href=\"#3-1-1-About-interrupt-handling-and-prioritization\" class=\"headerlink\" title=\"3.1.1 About interrupt handling and prioritization\"></a>3.1.1 About interrupt handling and prioritization</h5><p>可以参看 1.4.2. Interrupt types节<br>中断类型主要有四种：<br>物理中断：SPI，PPI （可边缘，电平触发）<br>软中断：SGI<br>虚拟中断：virtual interrupt<br>维护中断：maintenance interrupt (电平触发)，用于发送key events(具备virtualization extensions GIC)</p>\n<p>参看 1.4.3. Models for handling interrupts 节<br>SGI 使用GIC N-N模型<br>物理中断 SPI，PPI 使用GIC 1-N 模型</p>\n<h5 id=\"3-1-2-Identifying-the-supported-interrupts\"><a href=\"#3-1-2-Identifying-the-supported-interrupts\" class=\"headerlink\" title=\"3.1.2 Identifying the supported interrupts\"></a>3.1.2 Identifying the supported interrupts</h5><p>中断号的分段参看2.2.1 Interrupt IDs节</p>\n<p>软件获知enable 中断<br>Software can use the GICD_ISENABLERns to discover what interrupt IDs are supported by the GIC。</p>\n<p>GICD_ISENABLER0 provides the Set-enable bits for both:<br>    • SGIs, using interrupt IDs 15-0, corresponding to register bits [15:0]<br>    • PPIs, using interrupt IDs 31-16, corresponding to register bits [31:16].</p>\n<p>The remaining GICD_ISENABLERns, from GICD_ISENABLER1, provide the Set-enable bits for the SPIs,<br>starting at interrupt ID 32.</p>\n<p>Software discovers the interrupts that are supported by:</p>\n<ol>\n<li>Reading the GICD_TYPER. The GICD_TYPER.ITLinesNumber field identifies the number of implemented<br>GICD_ISENABLERns, and therefore the maximum number of SPIs that might be supported. （获取supported interrupt 总数）</li>\n<li>Writing to the GICD_CTLR to disable forwarding of interrupts from the distributor to the CPU interfaces.<br>For more information, see Enabling and disabling the Distributor and CPU interfaces on page 4-77.</li>\n<li>For each implemented GICD_ISENABLERn, starting with GICD_ISENABLER0:<br> • Writing 0xFFFFFFFF to the GICD_ISENABLERn.<br> • Reading the value of the GICD_ISENABLERn. Bits that read as 1 correspond to supported interrupt IDs.    </li>\n</ol>\n<p>永久使能中断<br>Software uses the GICD_ICENABLERns to discover the interrupts that are permanently enabled. For each<br>implemented GICD_ICENABLERn, starting with GICD_ICENABLER0, software:</p>\n<ol>\n<li>Writes 0xFFFFFFFF to the GICD_ICENABLERn. This disables all interrupts that can be disabled.</li>\n<li>Reads the value of the GICD_ICENABLERn. Bits that read as 1 correspond to interrupts that are<br>permanently enabled.</li>\n<li>Writes 1 to any GICD_ISENABLERn bits corresponding to interrupts that must be re-enabled.    </li>\n</ol>\n<p>The GIC implements the same number of GICD_ISENABLERns and GICD_ICENABLERns.</p>\n<h4 id=\"3-2-General-handling-of-interrupts\"><a href=\"#3-2-General-handling-of-interrupts\" class=\"headerlink\" title=\"3.2 General handling of interrupts\"></a>3.2 General handling of interrupts</h4><p>中断状态分为：(detail see 3.2.4 Interrupt handling state machine)</p>\n<ul>\n<li>inactive</li>\n<li>pending</li>\n<li>active</li>\n<li>active and pending</li>\n</ul>\n<p>Group, security extension 中断参看 3.4 The effect of interrupt grouping on interrupt handling<br>virtualization extension 中断处理参看 5 GIC Support for Virtualization.</p>\n<p>通用中断处理流程：<br>When the GIC recognizes an interrupt request, it marks its state as pending. Regenerating a pending interrupt does<br>not affect the state of the interrupt.</p>\n<p>The GIC interrupt handling sequence is:</p>\n<ol>\n<li>The GIC determines the interrupts that are enabled.</li>\n<li>For each pending interrupt, the GIC determines the targeted processor or processors.</li>\n<li>For each CPU interface, the Distributor forwards the highest priority pending interrupt that targets that<br>interface.</li>\n<li>Each CPU interface determines whether to signal an interrupt request to its processor, and if required, does so.</li>\n<li>The processor acknowledges the interrupt, and the GIC returns the interrupt ID and updates the interrupt<br>state.</li>\n<li>After processing the interrupt, the processor signals End of Interrupt (EOI) to the GIC.</li>\n</ol>\n<p>In more detail, these steps are as follows:</p>\n<ol>\n<li><p>The GIC determines whether each interrupt is enabled. An interrupt that is not enabled has no effect on the GIC.</p>\n</li>\n<li><p>For each enabled interrupt that is pending, the Distributor determines the targeted processor or processors.</p>\n</li>\n<li><p>For each processor, the Distributor determines the highest priority pending interrupt, based on the priority information it holds for each interrupt, and forwards the interrupt to the targeted CPU interfaces.</p>\n</li>\n<li><p>If the distributor is forwarding an interrupt request to a CPU interface, the CPU interface determines whether the interrupt has Sufficient priority to be signaled to the processor. If the interrupt has sufficient priority, the GIC signals an interrupt request to the processor.</p>\n</li>\n<li><p>When a processor takes the interrupt exception, it reads the GICC_IAR of its CPU interface to acknowledge the interrupt. This read returns an Interrupt ID, and for an SGI, the source processor ID, that the processor uses to select the correct interrupt handler. When it recognizes this read, the GIC changes the state of the interrupt as follows:<br> • if the pending state of the interrupt persists when the interrupt becomes active, or if the interrupt is generated again, from pending to active and pending.<br> • otherwise, from pending to active</p>\n<pre><code>Note:\n• A level-sensitive peripheral interrupt persists when it is acknowledged by the processor, because the\ninterrupt signal to the GIC remains asserted until the Interrupt Service Routine (ISR) running on the\nprocessor accesses the peripheral asserting the signal.\n• In a multiprocessor implementation, the GIC handles:\n    — PPIs and SGIs using the GIC N-N model, where the acknowledgement of an interrupt by one\n    processor has no effect on the state of the interrupt on other CPU interfaces\n    — SPIs using the GIC 1-N model, where the acknowledgement of an interrupt by one processor\n    removes the pending status of the interrupt on any other targeted processors, see Implications\n    of the 1-N model on page 3-41.\n• In GICv2, when using a software model with the GICC_CTLR.AckCtl bit set to 0, separate registers\nare used to manage Group 0 and Group 1 interrupts, as follows:\n    — GICC_IAR, GICC_EOIR, and GICC_HPPIR for Group 0 interrupts\n    — GICC_AIAR, GICC_AEOIR, and GICC_AHPPIR for Group 1 interrupts.\nARM deprecates the use of GICC_CTLR.AckCtl, and strongly recommends using a software model\nwhere GICC_CTLR.AckCtl is set to 0, see [3.4.3 The effect of interrupt grouping on interrupt acknowledgement]\n</code></pre></li>\n<li><p>When the processor has completed handling the interrupt, it must signal this completion to the GIC. As<br>described in [3.2.1 Priority drop and interrupt deactivation], this: (通知GIC， EOI 并改写状态到inactive)<br> • always requires a valid write to an end of interrupt register (EOIR)<br> • might also require a subsequent write to the deactivate interrupt register, GICC_DIR.    </p>\n</li>\n</ol>\n<p>写向EOIR 的值是从GICC_IAR 或 GICC_AIAR得到的最近处理的中断号<br>For each CPU interface, the GIC architecture requires the order of the valid writes to an EOIR to be the<br>reverse of the order of the reads from the GICC_IAR or GICC_AIAR, so that each valid EOIR write refers<br>to the most recent interrupt acknowledge.</p>\n<p>A CPU interface never signals to the connected processor any interrupt that is active and pending. It only<br>signals interrupts that are pending and have sufficient priority:<br>    • For PPIs and SGIs, the active status of particular interrupt ID is banked between CPU interfaces. This<br>    means that if a particular interrupt ID is active or active and pending on a CPU interface, then no<br>    interrupt with that same ID is signaled on that CPU interface.<br>    • For SPIs, the active status of an interrupt is common to all CPU interfaces. This means that if an<br>    interrupt is active or active and pending on one CPU interface then it is not signaled on any CPU<br>    interface.</p>\n<h4 id=\"3-2-1-Priority-drop-and-interrupt-deactivation\"><a href=\"#3-2-1-Priority-drop-and-interrupt-deactivation\" class=\"headerlink\" title=\"3.2.1 Priority drop and interrupt deactivation\"></a>3.2.1 Priority drop and interrupt deactivation</h4><p>When a processor completes the processing of an interrupt, it must signal this completion to the GIC. Interrupt<br>completion requires the following changes to the GIC state:</p>\n<p>Priority drop<br>Priority drop is the drop in the Running priority that occurs on a valid write to an EOIR, either the<br>GICC_EOIR or the GICC_AEOIR.</p>\n<p>Interrupt deactivation<br>Interrupt deactivation is the change of the state of an interrupt, either:<br>    • from active and pending, to pending<br>    • from active, to idle</p>\n<p>在GICv1 中Priority drop  与    Interrupt deactivation 是同时的。在GICv2 中可以设定setting GICC_CTLR.EOImode to 1 separates the priority drop and interrupt deactivation operations， and interrupt handling software must:</p>\n<pre><code>1. Perform a valid EOIR write, to cause priority drop on the GIC CPU interface.\n2. Subsequently, write to the GICC_DIR, to deactivate the interrupt.\n</code></pre><p>The GIC architecture specification requires that valid EOIR writes are ordered, so that:<br>• a valid GICC_EOIR write corresponds to the most recently acknowledged interrupt<br>• a valid GICC_AEOIR write corresponds to the most recently acknowledged Group 1 interrupt.<br>• whether a GICC_EOIR write affects Group 0 or Group 1 interrupts depends on both:<br>    — the value of the GICC_CTLR. AckCtl bit<br>    — if the GIC implements the GIC Security Extensions, whether the write is Secure or Non-secure.</p>\n<p>Note：<br>In a GICv2 implementation that includes the Security Extensions:<br>• GICC_AEOIR is an alias of the Non-secure copy of GICC_EOIR<br>• GICC_AIAR is an alias of the Non-secure copy of GICC_IAR<br>• GICC_AIAR and GICC_AEOIR are Secure registers, meaning they are accessible only by Secure accesses.</p>\n<h4 id=\"3-2-2-Interrupt-controls-in-the-GIC\"><a href=\"#3-2-2-Interrupt-controls-in-the-GIC\" class=\"headerlink\" title=\"3.2.2 Interrupt controls in the GIC\"></a>3.2.2 Interrupt controls in the GIC</h4><p><strong>Interrupt enables</strong><br>For peripheral interrupts, a processor:<br>• enables an interrupt by writing to the appropriate GICD_ISENABLERn bit<br>• disables an interrupt by writing to the appropriate GICD_ICENABLERn bit.</p>\n<p><strong>Setting and clearing pending state of an interrupt</strong><br>For peripheral interrupts, a processor can:<br>• set the pending state by writing to the appropriate GICD_ISPENDRn bit<br>• clear the pending state by writing to the appropriate GICD_ICPENDRn bit.</p>\n<p>For a level-sensitive interrupt:<br>• If the hardware signal of an interrupt is asserted when a processor writes to the corresponding<br>GICD_ICPENDRn bit then the write to the register has no effect on the pending state of the interrupt.<br>• If a processor writes a 1 to an GICD_ISPENDRn bit then the corresponding interrupt becomes pending<br>regardless of the state of the hardware<br>more detail see [Control of the pending status of level-sensitive interrupts]</p>\n<p>For SGIs, the GIC ignores writes to the corresponding GICD_ISPENDRn and GICD_ICPENDRn bits. A processor<br>cannot change the state of a software-generated interrupt by writing to these registers.<br>Typically, an SGI is made pending by writing to the GICD_SGIR. In GICv2, the pending state of SGIs can also be modified directly using the<br>GICD_SPENDSGIRn and GICD_CPENDSGIRn bits.</p>\n<p><strong>Finding the active or pending state of an interrupt</strong><br>A processor can find:<br>• the pending state of an interrupt by reading the corresponding GICD_ISPENDRn or GICD_ICPENDRn bit<br>• the active state of an interrupt by reading the corresponding GICD_ISACTIVERn or GICD_ICACTIVERn<br>bit.</p>\n<p>In GICv2, the processor that issues the SGI can also be determined by reading the<br>corresponding GICD_SPENDSGIRn or GICD_CPENDSGIRn bits.</p>\n<p><strong>Generating an SGI</strong><br>A processor generates an SGI by writing to an GICD_SGIR.<br>The GICD_SGIR includes optimization for:<br>• interrupting only the processor that writes to the GICD_SGIR<br>• interrupting all processors other than the one that writes to the GICD_SGIR.</p>\n<p>GICD_SGIR 大致包含:<br>• interrupt ID<br>• source processor<br>• target processor.</p>\n<p>SGIs from different processors use the same interrupt IDs. Therefore, any target processor can receive SGIs with<br>the same interrupt ID from different processors.</p>\n<p>Only one interrupt with a specific interrupt ID can be active on a CPU interface at any time. This means that a CPU<br>interface cannot have two SGIs with the same interrupt ID active at the same time, even if different processors have<br>signaled SGIs with the same interrupt ID to that processor.</p>\n<p>On the CPU interface of the target processor, reading the GICC_IAR for an SGI returns both the interrupt ID and<br>the CPU ID of the processor that generated the interrupt, the source processor for the interrupt.The combination of<br>interrupt ID and source CPU ID uniquely identifies the interrupt to the target processor.</p>\n<p>In a multiprocessor implementation, the interrupt priority of each SGI interrupt ID is defined independently for each<br>target processor。<br><strong>For each CPU interface, all SGIs with a particular interrupt ID that are pending on that interface have the same priority and must be handled serially.</strong></p>\n<h5 id=\"3-2-3-Implications-of-the-1-N-model\"><a href=\"#3-2-3-Implications-of-the-1-N-model\" class=\"headerlink\" title=\"3.2.3 Implications of the 1-N model\"></a>3.2.3 Implications of the 1-N model</h5><p><strong>when the GIC recognizes an interrupt acknowledge from one of the target processors it clears the pending state of the interrupt on all the other targeted processors.</strong> A GIC implementation must ensure that any interrupt being handled using the 1-N model is only acknowledged by one CPU interface, and that all other interfaces return a spurious<br>interrupt ID.</p>\n<p>When multiple target processors attempt to acknowledge the interrupt, the following can occur:<br>• A processor reads the GICC_IAR and obtains the interrupt ID of the interrupt to be serviced.<br>    Note:  (在多核情况下，通过share memory, lock形式，确保只有一个core 处理中断)<br>    In GICv1, more than one target processor might have obtained this interrupt ID, if the processors read their<br>    GICC_IAR registers at very similar times. The system might require software on the target processors to<br>    ensure that only one processor runs its interrupt service routine. A typical mechanism to achieve this is<br>    implementing, in shared memory, a lock on the interrupt service routine (ISR).</p>\n<p>• <strong>A processor reads the GICC_IAR and obtains the interrupt ID 1023, indicating a spurious interrupt. The processor can return from its interrupt service routine without writing to its GICC_EOIR.</strong><br><strong>The spurious interrupt ID indicates that the original interrupt is no longer pending, typically because another target processor is handling it.</strong></p>\n<p>Note<br>    • A GICv1 implementation might ensure that only one processor can make a 1-N interrupt active, removing<br>    the requirement for a lock on the ISR. This is not required by the architecture, and generic GIC code must<br>    not rely on this behavior.（GICv1 不要求在ISR 中lock）<br>    • For any processor, if an interrupt is active and pending, the GIC does not signal an interrupt exception request<br>    for the interrupt to any processor until the active status is cleared. （如果中断是active且pending 状态，GIC 不会触发此中断给任何processor 直到active 状态清除）</p>\n<h5 id=\"3-2-3-Interrupt-handling-state-machine\"><a href=\"#3-2-3-Interrupt-handling-state-machine\" class=\"headerlink\" title=\"3.2.3 Interrupt handling state machine\"></a>3.2.3 Interrupt handling state machine</h5><p>Fixme 【中断状态机】</p>\n<p><strong>Transition A1 or A2, add pending state</strong><br>For an SGI, occurs if either:<br>• Software writes to a GICD_SGIR that specifies the processor as a target.<br>• Software on the target processor writes to the GICD_SPENDSGIRn bit that corresponds to<br>the required source processor and interrupt ID</p>\n<p>For an SPI or PPI, occurs if either:<br>• a peripheral asserts an interrupt request signal<br>• software writes to an GICD_ISPENDRn</p>\n<p><strong>Transition B1 or B2, remove pending state</strong><br>For an SGI, occurs if software on the target processor writes to the relevant bit of the<br>GICD_CPENDSGIRn.</p>\n<p>物理中断</p>\n<ul>\n<li>电平触发，pending 会一直拉高直到处理</li>\n<li>边缘触发，写GICD_ICPENDRn 寄存器清pending 状态</li>\n</ul>\n<p>For an SPI or PPI, occurs if either:<br>• the level-sensitive interrupt is pending only because of the assertion of an input signal, and<br>that signal is deasserted<br>• the interrupt is pending only because of the assertion of an edge-triggered interrupt signal, or<br>a write to an GICD_ISPENDRn, and software writes to the corresponding<br>GICD_ICPENDRn.</p>\n<p><strong>Transition C, pending to active</strong><br>If the interrupt is enabled and of Sufficient priority to be signaled to the processor, occurs when<br>software reads from the GICC_IAR.</p>\n<p><strong>Transition D, pending to active and pending</strong><br>For an SGI, this transition occurs in either of the following circumstances:<br>• If a write to set the SGI state to pending occurs at approximately the same time as a read of<br>GICC_IAR.<br>• When two or more pending SGIs with the same interrupt ID originate from the same source<br>processor and target the same processor. If one of the SGIs follows transition C, the other<br>SGIs follow transition D</p>\n<p>For an SPI or PPI this transition occurs if all the following apply:<br>• The interrupt is enabled.<br>• Software reads from the GICC_IAR. This read adds the active state to the interrupt.<br>• In addition, one of the following conditions applies:<br>    — For a level-sensitive interrupt, the interrupt signal remains asserted. This is usually the<br>    case, because the peripheral does not deassert the interrupt until the processor has<br>    serviced the interrupt.<br>    — For an edge-triggered interrupt, whether this transition occurs depends on the timing<br>    of the read of the GICC_IAR relative to the detection of the reassertion of the interrupt.<br>    Otherwise the read of the GICC_IAR causes transition C, possibly followed by<br>    transition A2.</p>\n<p><strong>Transition E1 or E2, remove active state</strong><br>Occurs when software deactivates an interrupt by writing to either GICC_EOIR or GICC_DIR.In a GIC<br>implementation the includes the Virtualization Extensions, also occurs if the virtual CPU interface<br>signals that the corresponding physical interrupt has been deactivated    </p>\n<h4 id=\"3-3-Interrupt-prioritization\"><a href=\"#3-3-Interrupt-prioritization\" class=\"headerlink\" title=\"3.3 Interrupt prioritization\"></a>3.3 Interrupt prioritization</h4><p>Software configures interrupt prioritization in the GIC by assigning a priority value to each interrupt source. Priority<br>values are 8-bit unsigned binary.A GIC supports a minimum of 16 and a maximum of 256 priority levels. If the<br>GIC implements fewer than 256 priority levels, low-order bits of the priority fields are RAZ/WI.<br>In the GIC prioritization scheme, lower numbers have higher priority,</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Implemented priority bits</th>\n<th style=\"text-align:center\">Possible priority field values</th>\n<th style=\"text-align:center\">Number of priority levels</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">[7:0]</td>\n<td style=\"text-align:center\">0x00-0xFF (0-255), all values</td>\n<td style=\"text-align:center\">256</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[7:1]</td>\n<td style=\"text-align:center\">0x00-0xFE, (0-254), even values only</td>\n<td style=\"text-align:center\">128</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[7:2]</td>\n<td style=\"text-align:center\">0x00-0xFC (0-252), in steps of 4</td>\n<td style=\"text-align:center\">64</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[7:3]</td>\n<td style=\"text-align:center\">0x00-0xF8 (0-248), in steps of 8</td>\n<td style=\"text-align:center\">32</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[7:4]</td>\n<td style=\"text-align:center\">0x00-0xF0 (0-240), in steps of 16</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n</tbody>\n</table>\n<p><strong>The GICD_IPRIORITYRn registers hold the priority value for each supported interrupt.</strong></p>\n<p>To determine the number of priority bits implemented, software can write 0xFF to a writable GICD_IPRIORITYRn<br>priority field, and read back the value stored.<br>Note:<br>ARM recommends that, before checking the priority range in this way:<br>• for a peripheral interrupt, software first disables the interrupt<br>• for an SGI, software first checks that the interrupt is inactive</p>\n<h5 id=\"3-3-1-Preemption\"><a href=\"#3-3-1-Preemption\" class=\"headerlink\" title=\"3.3.1 Preemption\"></a>3.3.1 Preemption</h5><p>A CPU interface supports signaling of higher priority pending interrupts to a target processor before an active<br>interrupt completes. A pending interrupt is only signaled if both:<br>• Its priority is higher than the priority mask for that CPU interface, see [Priority masking].<br>• Its group priority is higher than that of the Running priority on the CPU interface, see [Priority grouping] and[<br>Running Priority Register, GICC_RPR]</p>\n<p>For a processor that complies with the ARM architecture:<br>    — The value of the I or F bit in the CPSR determines whether the processor responds to the signaled<br>    interrupt by starting the interrupt acknowledge procedure.<br>    — When processing a preempting interrupt, the processor must save and later restore the context of the<br>    previously active ISR.</p>\n<h5 id=\"3-3-2-Priority-masking\"><a href=\"#3-3-2-Priority-masking\" class=\"headerlink\" title=\"3.3.2 Priority masking\"></a>3.3.2 Priority masking</h5><p>CPU Interface 选择高于中断阀门优先级的中断給处理器。<br>The GICC_PMR for a CPU interface defines a priority threshold.The GIC only signals<br>pending interrupts with a higher priority than this threshold value to the target processor. A value of zero, the register<br>reset value, masks all interrupts from being signaled to the associated processor. The GIC does not use priority<br>grouping when comparing the priority of a pending interrupt with the priority threshold.</p>\n<h5 id=\"3-3-3-Priority-grouping\"><a href=\"#3-3-3-Priority-grouping\" class=\"headerlink\" title=\"3.3.3 Priority grouping\"></a>3.3.3 Priority grouping</h5><p>一组相同优先级的中断。<br>Priority grouping uses the Binary Point Register, GICC_BPR, to split a priority value into two fields, the group<br>priority and the subpriority.When determining preemption, all interrupts with the same group priority are<br>considered to have equal priority, regardless of the subpriority. This means that there can only be one interrupt active<br>at each group priority. The active group priority is also known as the <strong>Preemption level.</strong></p>\n<p>主要是用过GICC_BPR 0~2 划分出 GICC_PMR 两个部分：Group priority field 和Subpriority field<br>FixME [Table 3-2 Priority grouping by binary point] 图片page 46</p>\n<h4 id=\"3-4-The-effect-of-interrupt-grouping-on-interrupt-handling\"><a href=\"#3-4-The-effect-of-interrupt-grouping-on-interrupt-handling\" class=\"headerlink\" title=\"3.4 The effect of interrupt grouping on interrupt handling\"></a>3.4 The effect of interrupt grouping on interrupt handling</h4><p>A GICv1 implementation that includes the GIC Security Extensions, or any GICv2 implementation, provides two<br>interrupt output signals for IRQ and FIQ exception requests:<br>• The CPU interface always uses the IRQ exception request for Group 1 interrupts<br>• Software can configure the CPU interface to use either IRQ or FIQ exception requests for Group 0 interrupts</p>\n<h5 id=\"3-4-1-GIC-interrupt-grouping-support\"><a href=\"#3-4-1-GIC-interrupt-grouping-support\" class=\"headerlink\" title=\"3.4.1 GIC interrupt grouping support\"></a>3.4.1 GIC interrupt grouping support</h5><p>The GICD_IGROUPRn registers configure each interrupt as Group 0 or Group 1.</p>\n<p>FixMe [CPU interface control of Group 0 and Group 1 interrupts, GICv2] 图片 Page48</p>\n<p>In an implementation that includes the GIC Security Extensions, the alias registers:<br>• typically <strong>represent aliases of the Non-secure copy of the Group 0 registers</strong>, for example GICC_ABPR is an<br>alias of the Non-Secure copy of GICC_BPR<br>• are <strong>accessible only by Secure accesses.</strong></p>\n<p>In an implementation that supports interrupt grouping, GICC_CTLR contains additional fields, including fields to<br>control the handling of the grouped interrupts:<br>• Separate enable bits to control the signaling of Group 0 and Group 1 interrupts to the connected processor: （是否支持组中断）<br>    — bit[0], the Enable bit in a GIC that does not support interrupt grouping, becomes the EnableGrp0 bit,<br>    and controls whether Group 0 interrupts are signaled to the processor<br>    — the EnableGrp1 bit is added, to control whether Group 1 interrupts are signaled to the processor.<br>• The FIQEn bit, that controls whether the interface signals Group 0 interrupts to the processor using the IRQ<br>or FIQ interrupt request. （Group0 是否支持FIQ）<br>• The CBPR bit, that controls whether GICC_BPR or GICC_ABPR is used when determining possible<br>interrupt preemption by Group 1 interrupts, see [Control of preemption by Group 1 interrupts] （是否支持抢占）<br>• The AckCtl bit, that controls whether a read of the GICC_IAR, or the Secure GICC_IAR if the GIC<br>implements the Security Extensions, can acknowledge a Group 1 interrupt.（是否支持Group1 能从GICC_IAR 读取中断ID，value 0 读到1022保留中断号，否则真实值）</p>\n<h5 id=\"3-4-2-Special-interrupt-numbers-when-a-GIC-supports-interrupt-grouping\"><a href=\"#3-4-2-Special-interrupt-numbers-when-a-GIC-supports-interrupt-grouping\" class=\"headerlink\" title=\"3.4.2 Special interrupt numbers when a GIC supports interrupt grouping\"></a>3.4.2 Special interrupt numbers when a GIC supports interrupt grouping</h5><p>1020-1021 Reserved.</p>\n<p>1022 Used only if the GIC supports interrupt grouping.<br>The GIC returns this value to a processor in response to an interrupt acknowledge only when all of<br>the following apply:<br>• the interrupt acknowledge is a read of GICC_IAR<br>• the highest priority pending interrupt is a Group 1 interrupt<br>• GICC_CTLR.AckCtl is set to 0<br>• the priority of the interrupt is sufficient for it to be signaled to the processor.<br>    Note:<br>    • Interrupt ID 1022 indicates that there is a Group 1 interrupt of sufficient priority to be<br>    signaled to the processor, that must be acknowledged by a read of the GICC_AIAR, or in an<br>    implementation that includes the GIC Security Extensions, by a read of the Non-secure<br>    GICC_IAR.</p>\n<p>1023 This value is returned to a processor, in response to an interrupt acknowledge, if there is no pending<br>interrupt with sufficient priority for it to be signaled to the processor.<br>On a processor that supports interrupt grouping, values of 1022 and 1023 are spurious interrupt IDs.</p>\n<h5 id=\"3-4-3-The-effect-of-interrupt-grouping-on-interrupt-acknowledgement\"><a href=\"#3-4-3-The-effect-of-interrupt-grouping-on-interrupt-acknowledgement\" class=\"headerlink\" title=\"3.4.3 The effect of interrupt grouping on interrupt acknowledgement\"></a>3.4.3 The effect of interrupt grouping on interrupt acknowledgement</h5><p><strong>When the GICC_CTLR.AckCtl bit is set to 0, to ensure system correctness, every Group 0 interrupt must have a higher priority than any Group 1 interrupt.</strong></p>\n<p>When the GICC_CTLR.AckCtl bit is set to 1, a read of GICC_IAR acknowledges the highest-priority pending<br>interrupt on the CPU interface, regardless of whether it is a Group 0 or a Group 1 interrupt. （ARM 极不推荐GICC_CTLR.AckCtl 设定为1）</p>\n<p>In a GIC implementation that supports interrupt grouping, ARM strongly recommends setting GICC_CTLR.AckCtl<br>to 0, meaning:<br>• for a GICv2 implementation:<br>    — a group 0 interrupt is acknowledged by a read of GICC_IAR, or a Secure read of GICC_IAR if the<br>    implementation includes the GIC Security Extensions<br>    — a group 1 interrupt is acknowledged by a read of GICC_AIAR, or a Non-secure read of GICC_IAR if<br>    the implementation includes the GIC Security Extensions<br>• for a GICv1 implementation:<br>    — a group 0 interrupt must be acknowledged by a read of the Secure GICC_IAR<br>    — a group 1 interrupt must be acknowledged by a read of Non-secure GICC_IAR.</p>\n<p>If the Interrupt Acknowledge register access does not correspond to the highest-priority pending interrupt on the CPU interface then:<br>• a read of GICC_IAR when the highest-priority pending interrupt is a Group 1 interrupt returns the spurious<br>interrupt value 1022<br>• a read of GICC_AIAR when the highest-priority pending interrupt is a Group 0 interrupt returns the spurious<br>interrupt value 1023.</p>\n<h5 id=\"3-4-4-GIC-power-on-or-reset-configuration\"><a href=\"#3-4-4-GIC-power-on-or-reset-configuration\" class=\"headerlink\" title=\"3.4.4 GIC power on or reset configuration\"></a>3.4.4 GIC power on or reset configuration</h5><p>On power-up, or after a reset, a GIC implementation that supports interrupt grouping is configured with:<br>• all interrupts assigned to Group 0<br>• the FIQ exception request disabled.</p>\n<p>FixMe [Reset configuration of a GIC that includes the FIQ exception request]  图片 page52</p>\n<h4 id=\"3-5-Interrupt-grouping-and-interrupt-prioritization\"><a href=\"#3-5-Interrupt-grouping-and-interrupt-prioritization\" class=\"headerlink\" title=\"3.5 Interrupt grouping and interrupt prioritization\"></a>3.5 Interrupt grouping and interrupt prioritization</h4><p>ARM strongly recommends that:<br>    • Group 0 interrupts are always assigned priority values in the lower half of the supported priority value range.<br>    These values correspond to the higher-priority interrupts<br>    • Group 1 interrupts are always assigned priority values in the upper half of the supported priority value range.<br>    These values correspond to the lower-priority interrupts.</p>\n<p>This ensures that every Group 1 interrupt is of lower priority than any Group 0 interrupt.</p>\n<h5 id=\"3-5-1-Software-views-of-interrupt-priority-in-a-GIC-that-includes-the-Security-Extensions\"><a href=\"#3-5-1-Software-views-of-interrupt-priority-in-a-GIC-that-includes-the-Security-Extensions\" class=\"headerlink\" title=\"3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions\"></a>3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions</h5><p>When a processor reads the priority value of a Group 1 interrupt, the GIC returns either the Secure or the Non-secure<br>view of that value, depending on whether the access is Secure or Non-secure.</p>\n<p>This is for a GIC that implements the maximum range of priority values.<br>FixMe [Figure 3-7 Software views of the priorities of Group 1 and Group 0 interrupts]图片 Page55</p>\n<p>FixMe [Table 3-6 Effect of not implementing some priority field bits, with GIC Security Extensions]图片 Page56</p>\n<p><strong>Recommendations for managing priority values</strong><br>ARM strongly recommends that:<br>• for a Group 0 interrupt, software sets bit [7] of the priority value field to 0<br>• if using a Secure write to set the priority of a Group 1 interrupt, software sets bit [7] of the priority value field<br>to 1.</p>\n<h5 id=\"3-5-2-Control-of-preemption-by-Group-1-interrupts\"><a href=\"#3-5-2-Control-of-preemption-by-Group-1-interrupts\" class=\"headerlink\" title=\"3.5.2 Control of preemption by Group 1 interrupts\"></a>3.5.2 Control of preemption by Group 1 interrupts</h5><p>When a GIC implementation supports interrupt grouping, the GICC_BPR is always used to determine whether a<br>Group 0 interrupt is signaled to the processor, for possible preemption.<br>By default, the GICC_ABPR is used to<br>determine whether a Group 1 interrupt is signaled for possible preemption.</p>\n<p>However, when GICC_CTLR.CBPR is set to 1, GICC_BPR is used for determining possible preemption, for both Group 0 and Group 1 interrupts.</p>\n<p>Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0 情况与 [Priority grouping] 类似</p>\n<h4 id=\"3-6-Additional-features-of-the-GIC-Security-Extensions\"><a href=\"#3-6-Additional-features-of-the-GIC-Security-Extensions\" class=\"headerlink\" title=\"3.6 Additional features of the GIC Security Extensions\"></a>3.6 Additional features of the GIC Security Extensions</h4><p>Software can detect support for the GIC Security Extensions by reading the GICD_TYPER.SecurityExtn bit, see<br>Interrupt Controller Type Register, GICD_TYPER on page 4-88.</p>\n<h5 id=\"3-6-1-Access-from-processors-not-implementing-the-ARM-Security-Extensions\"><a href=\"#3-6-1-Access-from-processors-not-implementing-the-ARM-Security-Extensions\" class=\"headerlink\" title=\"3.6.1 Access from processors not implementing the ARM Security Extensions\"></a>3.6.1 Access from processors not implementing the ARM Security Extensions</h5><p>When connecting a processor that does not support the ARM Security Extensions to a GIC that implements the GIC<br>Security Extensions, typically all processor accesses to the GIC are assigned as either Secure or Non-secure:<br>• For a processor making Secure accesses:<br>    — <strong>The processor can control all aspects of the GIC, and therefore can make configuration changes that might affect Secure software running on other processors.</strong><br>    — In a GICv2 implementation, the processor <strong>uses Secure accesses to aliased registers, such as the GICC_AIAR, to process Group 1 interrupts.</strong><br>    — Because GICv1 implementations do not include the aliased registers, if the implementation uses<br>    interrupt grouping the processor might have to use the deprecated GICC_CTLR.AckCtl bit to enable<br>    Group 1 interrupts to be processed using the standard CPU interface registers.</p>\n<p>• For a processor making Non-secure accesses:<br>    — The processor cannot control Group 0 interrupts. For the GIC to be programmed, <strong>the system implementation must include at least one processor that can make Secure accesses.</strong><br>    A system might use a Secure processor to perform Secure accesses on behalf of a Non-secure<br>    processor. This usage model is possible if the GIC or the system provides a method for the Secure<br>    processor to access processor-banked copies of registers that belong to the Non-secure processor.<br>    — To <strong>permit a Non-secure processor to control its own Group 0 interrupts, a GICv2 implementation can implement the GICD_NSACRn registers.</strong> An implementation of these registers might permit a Secure<br>    processor to permit the use of Non-secure accesses from a particular processor to control some aspects<br>    of the operation of some Group 0 SGIs and SPIs.<br>    — A GIC implementation can configure the GICD_IGROUPRn reset value so that interrupts are Group<br>    1 on reset. see GICD_IGROUPR0 reset value on page 4-92 for more information</p>\n<h4 id=\"3-7-Pseudocode-details-of-interrupt-handling-and-prioritization\"><a href=\"#3-7-Pseudocode-details-of-interrupt-handling-and-prioritization\" class=\"headerlink\" title=\"3.7 Pseudocode details of interrupt handling and prioritization\"></a>3.7 Pseudocode details of interrupt handling and prioritization</h4><p>skip, see spec</p>\n<h4 id=\"3-8-The-effect-of-the-Virtualization-Extensions-on-interrupt-handling\"><a href=\"#3-8-The-effect-of-the-Virtualization-Extensions-on-interrupt-handling\" class=\"headerlink\" title=\"3.8 The effect of the Virtualization Extensions on interrupt handling\"></a>3.8 The effect of the Virtualization Extensions on interrupt handling</h4><p>see Chapter 5 GIC Support for Virtualization</p>\n<h4 id=\"3-9-Example-GIC-usage-models\"><a href=\"#3-9-Example-GIC-usage-models\" class=\"headerlink\" title=\"3.9 Example GIC usage models\"></a>3.9 Example GIC usage models</h4><p>FixMe [Figure 3-8 Generic GIC usage model]图片page 68</p>\n<h5 id=\"3-9-1-Using-IRQs-and-FIQs-to-provide-Non-secure-and-Secure-interrupts\"><a href=\"#3-9-1-Using-IRQs-and-FIQs-to-provide-Non-secure-and-Secure-interrupts\" class=\"headerlink\" title=\"3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts\"></a>3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts</h5><p>FixMe [Figure 3-9 Using the GIC to route Secure and Non-secure interrupts]图片page 69</p>\n<p>shows a system that implements the GIC Security Extensions, connected to a processor that<br>implements the ARM processor Security Extensions. This implementation:<br>• uses Group 0 interrupts as Secure interrupts, signaled as FIQs<br>• uses Group 1 interrupts as Non-secure interrupts, signaled as IRQs.<br>This means that, on the processor, FIQ interrupts are never routed to Non-secure software, and IRQ interrupts are<br>never routed to Secure software.</p>\n<p>Note：<br>The use of Group 0 and Group 1 interrupts to signal Secure interrupts as FIQs, and Non-secure interrupts as IRQs,<br>requires the processor to:<br>• <strong>route FIQs to be taken in Secure Monitor mode</strong><br>• <strong>prevent Non-secure software from masking FIQs</strong><br>• <strong>ensure that IRQs are masked whenever it is operating in Secure state.</strong></p>\n<p>On a GIC reset, all interrupts are assigned to Group 0, making them Secure interrupts. Secure software on the<br>processor:<br>• programs the GICD_IGROUPRn registers to indicate which interrupts are Group 1, Non-secure<br>• sets the Secure GICC_CTLR.FIQEn bit to 1 to configure the CPU interface to use FIQ for Group 0 interrupts.<br>• must enable Group 0 interrupts and Group 1 interrupts, independently, in the Distributor: （配置GIC）<br>    — GICD_CTLR.EnableGrp0 enables Group 0 interrupts<br>    — GICD_CTLR.EnableGrp1 enables Group 1 interrupts.<br>• must enable Group 0 interrupts and Group 1 interrupts, independently, in the CPU interface: （配置CPU Interface）<br>    — GICC_CTLR.EnableGrp0 enables Group 0 interrupts<br>    — GICC_CTLR.EnableGrp1 enables Group 1 interrupts.</p>\n<h5 id=\"3-9-2-Supporting-IRQs-and-FIQs-when-not-using-the-processor-Security-Extensions\"><a href=\"#3-9-2-Supporting-IRQs-and-FIQs-when-not-using-the-processor-Security-Extensions\" class=\"headerlink\" title=\"3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions\"></a>3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions</h5><p>FixMe [Figure 3-10 Using interrupt grouping to route IRQs and FIQs] Page70</p>\n<p>On a GIC reset, for a GIC implementation that supports interrupt grouping, all interrupts are assigned to Group 0.<br>Therefore, to use this configuration, software executing on the processor must:<br>• Program the GICD_IGROUPRn registers to assign IRQ interrupts to Group 1.<br>• Set GICC_CTLR.FIQEn to 1, to assign Group 0 interrupts to FIQ.<br>• Set GICC_CTLR.AckCtl to 0, so that both FIQ and IRQ interrupts are acknowledged from the single address<br>space, using:<br>    — the GICC_IAR to acknowledge a Group 0 interrupt<br>    — the GICC_AIAR to acknowledge a Group 1 interrupt<br>    — the GICC_EOIR to indicate completion of a Group 0 interrupt<br>    — the GICC_AEOIR to indicate completion of a Group 1 interrupt.<br>However, GICC_AIAR and GICC_AEOIR are implemented only in a GICv2 implementation. A processor<br>operating with a GICv1 implementation might have to use the deprecated mode of operation with<br>GICC_CTLR.AckCtl set to 1(意味着GRP0 GRP1 都是用GICC_IAR, GICC_EOIR).<br>• Configure the required binary point support model, by either:<br>    — setting GICC_CTLR.CBPR to 0, so that Group 0 uses GICC_BPR, and Group 1 uses GICC_ABPR<br>    — setting GICC_CTLR.CBPR to 1, so that Group 0 and Group 1 use a common binary point register,<br>    GICC_BPR.</p>\n<p>由于没有security, 我们只是人为的将IRQ 分配到GRP1中，将FIQ 分配到GRP0中。因此，并不需要使能GICD_CTLR.EnableGrp0/1 GICC_CTLR.EnableGrp0/1 来让GIC与CPU 支持真正的Group 即security，我们只是使用不同的寄存器</p>\n<ul>\n<li>GICC_IAR &amp;&amp; GICC_AIAR获知ID</li>\n<li>GICC_EOIR &amp;&amp; GICC_AEOIR 结束中断</li>\n<li>GICC_CTLR.CBPR &amp;&amp; GICC_CTLR.ABPR </li>\n</ul>\n<h5 id=\"3-9-3-Supporting-IRQs-and-FIQs-in-a-virtualized-processor-environment\"><a href=\"#3-9-3-Supporting-IRQs-and-FIQs-in-a-virtualized-processor-environment\" class=\"headerlink\" title=\"3.9.3 Supporting IRQs and FIQs in a virtualized processor environment\"></a>3.9.3 Supporting IRQs and FIQs in a virtualized processor environment</h5><p>Fixme [Figure 3-11 Using the GIC in a virtualized system] page72</p>\n<p>• Secure software assigns:<br>    — Secure interrupts to Group 0, signaled to the processor as FIQs<br>    — Non-secure interrupts to Group 1, signaled to the processor as IRQs</p>\n<p>• A hypervisor:<br>    — Implements a virtual distributor, using features of the Virtualization Extension on the GIC. This<br>    virtual distributor can virtualize IRQ interrupts from the GIC as Virtual IRQ and Virtual FIQ<br>    interrupts, that it routes to an appropriate virtual machine.<br>    — Routes physical IRQs to Hyp mode, so they can be serviced by the virtual distributor</p>\n<p>• A Guest OS running on a virtual machine assigns interrupts to Group 0 or Group 1, to assign them as FIQs<br>or IRQs, using the model described in [Supporting IRQs and FIQs when not using the processor Security<br>Extensions]</p>\n<p>When the GIC signals an IRQ to the processor, the interrupt is routed to Hyp mode. The hypervisor determines<br>whether the interrupt is for itself, or for a Guest OS. If it is for a Guest OS it determines:<br>• which Guest OS must handle the interrupt<br>• whether that Guest OS has configured the interrupt as an FIQ or as an IRQ<br>• the interrupt priority, based on the priority configuration by the target Guest OS.</p>\n<p>Note:  (<strong>Guest OS 可能不止一个</strong>)<br>• On receiving an IRQ that cannot be handled by the current Guest OS, the hypervisor can either:<br>— transfer control to a Guest OS that can handle the interrupt<br>— mark the interrupt as pending, as part of the saved context of the appropriate Guest OS.<br>• A system can have some interrupts that can be handled by more that one Guest OS, and other interrupts that<br>must be routed to a specific Guest OS.</p>\n<p>A Guest OS handles a virtual interrupt exactly as it would handle the corresponding physical interrupt. <strong>The Guest OS cannot detect that it is handling a virtual interrupt rather than a physical interrupt.</strong></p>\n<p>Guest OS 并不知道处理的是虚拟中断。</p>\n<h3 id=\"4-Programmers’-Model\"><a href=\"#4-Programmers’-Model\" class=\"headerlink\" title=\"4. Programmers’ Model\"></a>4. Programmers’ Model</h3><h4 id=\"4-1-1-GIC-register-names\"><a href=\"#4-1-1-GIC-register-names\" class=\"headerlink\" title=\"4.1.1 GIC register names\"></a>4.1.1 GIC register names</h4><p>All of the GIC registers have names that provide a short mnemonic for the function of the register. In these names:<br>• the first three letters are GIC, indicating a GIC register<br>• the fourth letter is one of:<br>    — D, indicating a Distributor register<br>    — C, indicating a CPU interface register<br>    — H, indicating a virtual interface control register, typically accessed by a hypervisor<br>    — V, indicating a virtual CPU interface register.</p>\n<p>Note：<br>Chapter 5 GIC Support for Virtualization describes the GICH_<em> and GICV_</em> registers.</p>\n<h4 id=\"4-1-2-Distributor-register-map\"><a href=\"#4-1-2-Distributor-register-map\" class=\"headerlink\" title=\"4.1.2 Distributor register map\"></a>4.1.2 Distributor register map</h4><p>Fixme [Table 4-1 Distributor register map] page74</p>\n<h4 id=\"4-1-3-CPU-interface-register-map\"><a href=\"#4-1-3-CPU-interface-register-map\" class=\"headerlink\" title=\"4.1.3 CPU interface register map\"></a>4.1.3 CPU interface register map</h4><p>For a multiprocessor implementation, the GIC implements a set of CPU interface registers for each CPU interface.<br><strong>ARM strongly recommends that each processor has the same CPU interface base address for the CPU interface that connects it to the GIC. This is the private CPU interface base address for that processor.</strong></p>\n<p>Fixme [Table 4-2 CPU interface register map] page76</p>\n<h4 id=\"4-1-4-GIC-register-access\"><a href=\"#4-1-4-GIC-register-access\" class=\"headerlink\" title=\"4.1.4 GIC register access\"></a>4.1.4 GIC register access</h4><p>Note:<br>In the GIC architecture, all registers that are halfword-accessible or byte-accessible use a little endian memory order model.</p>\n<p>If the GIC implements the GIC Security Extensions these affect register accesses as follows:<br>• some registers are banked, see Register banking<br>• some registers are accessible only using Secure accesses<br>• optionally, the GIC supports lockdown of the values of some registers</p>\n<p><strong>Register banking</strong><br>Register banking refers to providing multiple copies of a register at the same address.</p>\n<p>The GIC banks registers in the following cases:<br>• If the GIC implements the Security Extensions, some registers are banked to provide separate Secure and<br>Non-secure copies of the registers. The Secure and Non-secure register bit assignments can differ. A Secure<br>access to the register address accesses the Secure copy of the register, and a Non-secure access accesses the<br>Non-secure copy. </p>\n<p>• If the GIC is implemented as part of a multiprocessor system:<br>    — Some registers are banked to provide a separate copy for each connected processor. These <strong>include the registers associated with PPIs and SGIs, and the GICD_NSACRn, when implemented.</strong><br>    — The GIC implements the CPU interface registers <strong>independently for each CPU interface</strong>, and each<br>    connected processor accesses these registers for the interface it connects to.</p>\n<h4 id=\"4-1-5-Enabling-and-disabling-the-Distributor-and-CPU-interfaces\"><a href=\"#4-1-5-Enabling-and-disabling-the-Distributor-and-CPU-interfaces\" class=\"headerlink\" title=\"4.1.5 Enabling and disabling the Distributor and CPU interfaces\"></a>4.1.5 Enabling and disabling the Distributor and CPU interfaces</h4><p><strong>Implementations that support interrupt grouping</strong><br>In a GIC that supports interrupt grouping:<br>• the GICD_CTLR.EnableGrp0 bit<br>• the GICD_CTLR.EnableGrp1 bit<br>• the GICC_CTLR.EnableGrp0 bit<br>• the GICC_CTLR.EnableGrp1 bit </p>\n<p>For the Distributor:<br>• If the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits are both 0:<br>    — <strong>the Distributor does not forward pending interrupts to the CPU interfaces</strong><br>    — it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the<br>    pending state.<br>    — <strong>reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID</strong><br>    — software can read or write the Distributor registers<br>    — it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR</p>\n<p>• If either, but not both, of the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits is set to<br>    — GICD_CTLR.EnableGrp0 set to 0 and GICD_CTLR.EnableGrp1 set to 1, and the highest priority<br>    pending interrupt is in group 0<br>    — GICD_CTLR.EnableGrp0 set to 1 and GICD_CTLR.EnableGrp1 set to 0, and the highest priority<br>    pending interrupt is in group 1. (ARM 强烈不推荐这样，这样GRP0 优先级是小于GRP1)</p>\n<p><strong>ARM strongly recommends that all Group 0 interrupts are assigned a higher priority than all Group 1 interrupts.</strong></p>\n<p>For a CPU interface, when GICC_CTLR.AckCtl == 0:<br>• When GICC_CTLR.EnableGrp0 == 0<br>    — Group 0 interrupts forwarded from the Distributor are not signaled to the processor<br>    — any read of GICC_IAR returns a spurious interrupt ID<br>• When GICC_CTLR.EnableGrp0 == 1, Group 0 interrupts forwarded from the Distributor are signaled to the<br>processor.<br>• When GICC_CTLR.EnableGrp1 == 0<br>    — Group 1 interrupts forwarded from the Distributor are not signaled to the processor<br>    — any read of GICC_AIAR returns a spurious interrupt ID<br>• When GICC_CTLR.EnableGrp1 == 1, Group 1 interrupts forwarded from the Distributor are signaled to the<br>processor<br>• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt<br>of sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR<br>returns the ID of that interrupt, or a spurious interrupt ID</p>\n<p>For a CPU interface, when GICC_CTLR.AckCtl == 1:<br>• When GICC_CTLR.EnableGrp1 == 0, any Non-secure read of GICC_IAR returns a spurious interrupt ID<br>• When GICC_CTLR.EnableGrp0 == 0:<br>— if GICC_CTLR.EnableGrp1 == 0, any Secure read of GICC_AIAR returns a spurious interrupt ID<br>— if GICC_CTLR.EnableGrp1 == 1, Group 0 interrupts are ignored and GICC_IAR behaves as<br>GICC_AIAR<br>• When GICC_CTLR.EnableGrp1 == 0, a Secure read of GICC_AIAR always returns a spurious interrupt ID<br>• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt<br>of sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR<br>returns the ID of that interrupt, or a spurious interrupt ID.</p>\n<p>Note:<br><strong>ARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl is set to 0.</strong></p>\n<hr>\n<p><strong>Implementations that do not support interrupt grouping</strong><br>In a GIC that does not support interrupt grouping:<br>• the GICD_CTLR.Enable bit controls the forwarding of interrupts from the Distributor to the CPU interfaces<br>• the GICC_CTLR.Enable bit controls the signaling of interrupts by the CPU interface to the connected processor.</p>\n<p>For the Distributor:<br>• When GICD_CTLR.Enable is set to 1, the Distributor forwards the highest priority pending interrupt for each<br>CPU interface, subject to the prioritization rules.<br>• When GICD_CTLR.Enable is set to 0:<br>    — the Distributor does not forward pending interrupts to the CPU interfaces<br>    — it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the<br>    pending state.<br>    — reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID<br>    — software can read or write the Distributor registers<br>    — it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR.</p>\n<p>For a CPU interface:<br>• When GICC_CTLR.Enable is set to 1, the highest priority pending interrupt forwarded from the Distributor<br>to the CPU interface is signaled to the connected processor<br>• When GICC_CTLR.Enable is set to 0:<br>    — any pending interrupts forwarded from the Distributor are not signaled to the processor<br>    — software can read or write the CPU interface registers<br>    — any read of the GICC_IAR returns a spurious interrupt ID<br>    — if the Distributor is forwarding an interrupt to the CPU interface, that the interface cannot signal<br>    because GICC_CTLR.Enable is set to 0, it is IMPLEMENTATION DEFINED whether a read of<br>    GICC_HPPIR returns the ID of that interrupt, or a spurious interrupt ID.</p>\n<h3 id=\"4-2-Effect-of-the-GIC-Security-Extensions-on-the-programmers’-model\"><a href=\"#4-2-Effect-of-the-GIC-Security-Extensions-on-the-programmers’-model\" class=\"headerlink\" title=\"4.2 Effect of the GIC Security Extensions on the programmers’ model\"></a>4.2 Effect of the GIC Security Extensions on the programmers’ model</h3><p>If the GIC implements the Security Extensions, <strong>the GICD_TYPER.SecurityExtn bit is RAO.</strong>.</p>\n<p>The GIC Security Extensions provide the following features:<br>• The GIC must support interrupt grouping.<br>• Register implementations that are consistent with those on a processor that implements the ARM Security<br>Extensions, with banked.</p>\n<p>The ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition defines the following ARM Security<br>Extensions register types:</p>\n<ul>\n<li><strong>Banked</strong><br>  The device implements Secure and Non-secure copies of the register. The register bit assignments<br>  can differ in the Secure and Non-secure copies of a register. A Secure access always accesses the<br>  Secure copy of the register, and a Non-secure access always accesses the Non-secure copy.<pre><code>Note\nThe GIC can also bank registers when implemented as part of a multiprocessor system, where\nregisters associated with PPIs or SGIs are banked to provide a separate copy for each connected\nprocessor.\n</code></pre></li>\n<li><strong>Secure</strong><br>  The register is accessible only from a Secure access. The address of a Secure register is RAZ/WI to<br>  any Non-secure access.</li>\n<li><strong>Common</strong><br>  The register is accessible from both Secure and Non-secure accesses. The access permissions of<br>  some or all fields in the register might depend on whether the access is Secure or Non-secure.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Register</th>\n<th style=\"text-align:center\">Type</th>\n<th style=\"text-align:center\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">GICD_CTLR</td>\n<td style=\"text-align:center\">Banked</td>\n<td style=\"text-align:center\">Distributor Control Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICD_TYPER</td>\n<td style=\"text-align:center\">Common</td>\n<td style=\"text-align:center\">Interrupt Controller Type Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICD_IGROUPRn</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Interrupt Group Registers</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICD_SGIR</td>\n<td style=\"text-align:center\">Common</td>\n<td style=\"text-align:center\">Software Generated Interrupt Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_CTLR</td>\n<td style=\"text-align:center\">Banked</td>\n<td style=\"text-align:center\">CPU Interface Control Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_BPR</td>\n<td style=\"text-align:center\">Banked</td>\n<td style=\"text-align:center\">Binary Point Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_ABPR</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Aliased Binary Point Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_AIAR</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Aliased Interrupt Acknowledge Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_AEOIR</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Aliased End of Interrupt Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_AHPPIR</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Aliased Highest Priority Pending Interrupt Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_NSAPRn</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Non-secure Active Priorities Registers</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"4-2-1-Non-secure-access-to-register-fields-for-Group-0-interrupt-priorities\"><a href=\"#4-2-1-Non-secure-access-to-register-fields-for-Group-0-interrupt-priorities\" class=\"headerlink\" title=\"4.2.1 Non-secure access to register fields for Group 0 interrupt priorities\"></a>4.2.1 Non-secure access to register fields for Group 0 interrupt priorities</h4><p>Non-secure access to a priority field in the GICD_IPRIORITYRn<br>If the priority field corresponds to a Group 1 interrupt, the access operates as defined by the<br>Non-secure view of interrupt priority, see[Software views of interrupt priority in a GIC that includes<br>the Security Extensions]</p>\n<p>Non-secure access to the GICC_PMR and GICC_RPR<br>• If the current priority mask value is in the range 0x00-0x7F:<br>    — a read access returns the value 0x00<br>    — the GIC ignores a write access to the GICC_PMR.<br>• If the current priority mask value is in the range 0x80-0xFF:<br>    — A read access returns the Non-secure view of the current value.<br>    — A write access to the GICC_PMR succeeds, based on the Non-secure view of the<br>    priority mask value written to the register. This means a Non-secure write cannot set<br>    a priority mask value in the rage 0x00-0x7F.</p>\n<h4 id=\"4-2-2-Configuration-lockdown\"><a href=\"#4-2-2-Configuration-lockdown\" class=\"headerlink\" title=\"4.2.2 Configuration lockdown\"></a>4.2.2 Configuration lockdown</h4><p>This provides a control signal that the system can assert to prevent write access to:<br>• the register fields controlling a configured range of SPIs, when those SPIs are configured as Group 0<br>interrupts<br>• some configuration registers.</p>\n<p>When the control signal is asserted, the affected register fields and registers are described as being locked down.<br><strong>Lockdown is controlled by an active HIGH disable signal, CFGSDISABLE</strong>. That is, the system asserts<br>CFGSDISABLE HIGH to disable write access to the register fields and registers.</p>\n<p>The SPIs that can be locked down are called lockable SPIs (LSPIs).<br>• The GICD_TYPER.LSPI field defines the maximum number of LSPIs. If GICD_TYPER.LSPI is greater<br>than 0 then the possible LSPIs have interrupt IDs 32 to (31+(GICD_TYPER.LSPI)).<br>    Note:<br>    GICD_TYPER.LSPI only defines the range of possible LSPIs. The GIC might not support all the interrupts<br>    in this range.</p>\n<p>If GICD_TYPER.LSPI is 0 lockdown is not supported.</p>\n<p>When the SPI control fields and configuration registers are locked down, the GIC prevents write accesses to:<br>• The EnableGrp0 bit of the Secure copy of GICD_CTLR.<br>• The following bits in the Secure copy of GICC_CTLR:<br>    — EOImodeS<br>    — IRQBypDisGrp0<br>    — FIQBypDisGrp0<br>    — CBPR<br>    — FIQEn<br>    — AckCtl<br>    — EnableGrp0<br>• Fields in the GICD_ISENABLERn, GICD_ICENABLERn, GICD_ISPENDRn, GICD_ICPENDRn,<br>GICD_ISACTIVERn, GICD_ICACTIVERn, GICD_IPRIORITYRn, GICD_ITARGETSRn, and<br>GICD_ICFGRn registers that correspond to Lockable SPIs that are configured as Group 0:<br>• Fields in the GICD_IGROUPRn registers that correspond to lockable SPIs that are configured as Group 0. If<br>a lockable SPI is reconfigured from Group 1 to Group 0 while CFGSDISABLE remains HIGH, the GIC<br>prevents any more writes to GICD_IGROUPRn fields that correspond to that SPI, and the SPI becomes<br>locked.    </p>\n<h4 id=\"4-3-Distributor-register-descriptions\"><a href=\"#4-3-Distributor-register-descriptions\" class=\"headerlink\" title=\"4.3 Distributor register descriptions\"></a>4.3 Distributor register descriptions</h4><p>The following sections describe the Distributor registers:<br>• Distributor Control Register, GICD_CTLR on page 4-85<br>• Interrupt Controller Type Register, GICD_TYPER on page 4-88<br>• Distributor Implementer Identification Register, GICD_IIDR on page 4-90<br>• Interrupt Group Registers, GICD_IGROUPRn on page 4-91<br>• Interrupt Set-Enable Registers, GICD_ISENABLERn on page 4-93<br>• Interrupt Clear-Enable Registers, GICD_ICENABLERn on page 4-95<br>• Interrupt Set-Pending Registers, GICD_ISPENDRn on page 4-97<br>• Interrupt Clear-Pending Registers, GICD_ICPENDRn on page 4-99<br>• Interrupt Set-Active Registers, GICD_ISACTIVERn on page 4-102<br>• Interrupt Clear-Active Registers, GICD_ICACTIVERn on page 4-103<br>• Interrupt Priority Registers, GICD_IPRIORITYRn on page 4-104<br>• Interrupt Processor Targets Registers, GICD_ITARGETSRn on page 4-106<br>• Interrupt Configuration Registers, GICD_ICFGRn on page 4-109<br>• Non-secure Access Control Registers, GICD_NSACRn on page 4-111<br>• Software Generated Interrupt Register, GICD_SGIR on page 4-113<br>• SGI Clear-Pending Registers, GICD_CPENDSGIRn on page 4-115<br>• SGI Set-Pending Registers, GICD_SPENDSGIRn on page 4-117<br>• Identification registers on page 4-119.</p>\n<h5 id=\"4-3-1-Distributor-Control-Register-GICD-CTLR\"><a href=\"#4-3-1-Distributor-Control-Register-GICD-CTLR\" class=\"headerlink\" title=\"4.3.1 Distributor Control Register, GICD_CTLR\"></a>4.3.1 Distributor Control Register, GICD_CTLR</h5><p>Enables the forwarding of pending interrupts from the Distributor to the CPU interfaces.</p>\n<p>Fixme [Figure 4-1 GICD_CTLR bit assignments, GICv1 without Security Extensions or Non-secure]图片 Page85</p>\n<p>Fixme [Figure 4-2 GICD_CTLR bit assignments, GICv2, and GICv1 Secure copy]图片 Page85</p>\n<h5 id=\"4-3-2-Interrupt-Controller-Type-Register-GICD-TYPER\"><a href=\"#4-3-2-Interrupt-Controller-Type-Register-GICD-TYPER\" class=\"headerlink\" title=\"4.3.2 Interrupt Controller Type Register, GICD_TYPER\"></a>4.3.2 Interrupt Controller Type Register, GICD_TYPER</h5><p>Provides information about the configuration of the GIC. It indicates:<br>• whether the GIC implements the <strong>Security Extensions</strong><br>• the <strong>maximum number of interrupt IDs</strong> that the GIC supports<br>• the <strong>number of CPU interfaces</strong> implemented<br>• if the GIC implements the Security Extensions, the <strong>maximum number of implemented Lockable Shared Peripheral Interrupts (LSPIs)</strong>.</p>\n<p>Fixme [Figure 4-3 GICD_TYPER bit assignments] 图片Page88</p>\n<p>[15:11]  LSPI             If the GIC implements the Security Extensions, the value of this field is the maximum number of<br>                        implemented lockable SPIs, from 0 (0b00000) to 31 (0b11111). If this field is 0b00000 then the GIC does not implement configuration lockdown. If the GIC does not implement the Security Extensions, this field is reserved.</p>\n<p>[10]      SecurityExtn     Indicates whether the GIC implements the Security Extensions.<br>                            0  Security Extensions not implemented.<br>                            1  Security Extensions implemented.                    </p>\n<p>[7:5]   CPUNumber         Indicates the number of implemented CPU interfaces. The number of implemented CPU interfaces is<br>                        one more than the value of this field, for example if this field is 0b011, there are four CPU interfaces. If<br>                        the GIC implements the Virtualization Extensions, this is also the number of virtual CPU interfaces    </p>\n<p>[4:0]  ITLinesNumber     Indicates the maximum number of interrupts that the GIC supports.If ITLinesNumber=N, the<br>                        maximum number of interrupts is 32 * (N+1). interrupt IDs 1020-1023 are reserved for<br>                        special purposes</p>\n<p>The ITLinesNumber field only indicates the maximum number of SPIs that the GIC might support. This value<br>determines the number of implemented interrupt registers, that is, the number of instances of the following registers:<br>• GICD_IGROUPRn<br>• GICD_ISENABLERn<br>• GICD_ICENABLERn<br>• GICD_ISPENDRn<br>• GICD_ICPENDRn<br>• GICD_ISACTIVERn<br>• GICD_IPRIORITYRn<br>• GICD_ITARGETSRn<br>• GICD_ICFGRn.</p>\n<h5 id=\"4-3-3-Distributor-Implementer-Identification-Register-GICD-IIDR\"><a href=\"#4-3-3-Distributor-Implementer-Identification-Register-GICD-IIDR\" class=\"headerlink\" title=\"4.3.3 Distributor Implementer Identification Register, GICD_IIDR\"></a>4.3.3 Distributor Implementer Identification Register, GICD_IIDR</h5><p>Provides information about the implementer and revision of the Distributor.<br>主要用于记录GIC 的产品ID， 变体ID， 实现公司ID<br>Fixme [Figure 4-4 GICD_IIDR bit assignments] 图片Page90</p>\n<h5 id=\"4-3-4-Interrupt-Group-Registers-GICD-IGROUPRn\"><a href=\"#4-3-4-Interrupt-Group-Registers-GICD-IGROUPRn\" class=\"headerlink\" title=\"4.3.4 Interrupt Group Registers, GICD_IGROUPRn\"></a>4.3.4 Interrupt Group Registers, GICD_IGROUPRn</h5><p>The GICD_IGROUPR registers provide a status bit for each interrupt supported by the GIC.<br>Each bit controls whether the corresponding interrupt is in Group 0 or Group 1.<br>Fixme [Figure 4-5 GICD_IGROUPR bit assignments] 图片Page91</p>\n<p>[31:0] Group status bits， For each bit:<br>    0 The corresponding interrupt is Group 0.<br>    1 The corresponding interrupt is Group 1.</p>\n<p><strong>Reset Value</strong><br>On start-up or reset, each interrupt with ID32 or higher resets as Group 0 and therefore all SPIs are Group 0.</p>\n<h5 id=\"4-3-5-Interrupt-Set-Enable-Registers-GICD-ISENABLERn\"><a href=\"#4-3-5-Interrupt-Set-Enable-Registers-GICD-ISENABLERn\" class=\"headerlink\" title=\"4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn\"></a>4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn</h5><p>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.<br>Writing 1 to a Set-enable bit enables forwarding of the corresponding interrupt from the<br>Distributor to the CPU interfaces. Reading a bit identifies whether the interrupt is enabled.</p>\n<p>These registers are available in all configurations of the GIC. If the GIC implements the<br>Security Extensions these registers are Common</p>\n<p>In a multiprocessor implementation, GICD_ISENABLER0 is banked for each connected<br>processor. This register holds the Set-enable bits for interrupts 0-31.</p>\n<h5 id=\"4-3-6-Interrupt-Clear-Enable-Registers-GICD-ICENABLERn\"><a href=\"#4-3-6-Interrupt-Clear-Enable-Registers-GICD-ICENABLERn\" class=\"headerlink\" title=\"4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn\"></a>4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn</h5><p>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the<br>GIC. Writing 1 to a Clear-enable bit disables forwarding of the corresponding interrupt from<br>the Distributor to the CPU interfaces.</p>\n<p>In a multiprocessor implementation, GICD_ICENABLER0 is banked for each connected<br>processor. This register holds the Clear-enable bits for interrupts 0-31.</p>\n<h5 id=\"4-3-7-Interrupt-Set-Pending-Registers-GICD-ISPENDRn\"><a href=\"#4-3-7-Interrupt-Set-Pending-Registers-GICD-ISPENDRn\" class=\"headerlink\" title=\"4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn\"></a>4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn</h5><p>The GICD_ISPENDRs provide a Set-pending bit for each interrupt supported by the GIC.<br>Writing 1 to a Set-pending bit sets the status of the corresponding peripheral interrupt to<br>pending. Reading a bit identifies whether the interrupt is pending.</p>\n<p>In a multiprocessor implementation, GICD_ISPENDR0 is banked for each connected<br>processor. This register holds the Set-pending bits for interrupts 0-31.</p>\n<p>For SPIs and PPIs<br>Writes<br>0         Has no effect.<br>1         The effect depends on whether the interrupt is edge-triggered or<br>        level-sensitive.</p>\n<p><strong>Edge-triggered</strong><br>Changes the status of the corresponding interrupt to:<br>• pending if it was previously inactive<br>• active and pending if it was previously active.<br>Has no effect if the interrupt is already pendinga.</p>\n<p><strong>Level sensitive</strong><br>If the corresponding interrupt is not pendinga, changes the status<br>of the corresponding interrupt to:<br>• pending if it was previously inactive<br>• active and pending if it was previously active.</p>\n<p>If the interrupt is already pendinga:<br>• because of a write to the GICD_ISPENDR, the write has<br>no effect<br>• because the corresponding interrupt signal is asserted, the<br>write has no effect on the status of the interrupt, but the<br>interrupt remains pendinga if the interrupt signal is<br>deasserted.</p>\n<h5 id=\"4-3-8-Interrupt-Clear-Pending-Registers-GICD-ICPENDRn\"><a href=\"#4-3-8-Interrupt-Clear-Pending-Registers-GICD-ICPENDRn\" class=\"headerlink\" title=\"4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn\"></a>4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn</h5><p>The GICD_ICPENDRs provide a Clear-pending bit for each interrupt supported by the GIC.<br>Writing 1 to a Clear-pending bit clears the pending state of the corresponding peripheral<br>interrupt. Reading a bit identifies whether the interrupt is pending</p>\n<p>In a multiprocessor implementation, GICD_ICPENDR0 is banked for each connected<br>processor. This register holds the Clear-pending bits for interrupts 0-31.</p>\n<h5 id=\"4-3-9-Interrupt-Set-Active-Registers-GICD-ISACTIVERn\"><a href=\"#4-3-9-Interrupt-Set-Active-Registers-GICD-ISACTIVERn\" class=\"headerlink\" title=\"4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn\"></a>4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn</h5><p>The GICD_ISACTIVERs provide a Set-active bit for each interrupt that the GIC supports.<br>Writing to a Set-active bit Activates the corresponding interrupt. <strong>These registers are used when preserving and restoring GIC state</strong></p>\n<p>In a multiprocessor implementation, GICD_ISACTIVER0 is banked for each connected<br>processor. This register holds the Set-active bits for interrupts 0-31.</p>\n<h5 id=\"4-3-10-Interrupt-Clear-Active-Registers-GICD-ICACTIVERn\"><a href=\"#4-3-10-Interrupt-Clear-Active-Registers-GICD-ICACTIVERn\" class=\"headerlink\" title=\"4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn\"></a>4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn</h5><p>The GICD_ICACTIVERs provide a Clear-active bit for each interrupt that the GIC<br>supports. Writing to a Clear-active bit Deactivates the corresponding interrupt. These<br>registers are used when preserving and restoring GIC state.</p>\n<p>In a multiprocessor implementation, GICD_ICACTIVER0 is banked for each connected<br>processor. This register holds the Clear-active bits for interrupts 0-31.</p>\n<h5 id=\"4-3-11-Interrupt-Priority-Registers-GICD-IPRIORITYRn\"><a href=\"#4-3-11-Interrupt-Priority-Registers-GICD-IPRIORITYRn\" class=\"headerlink\" title=\"4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn\"></a>4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn</h5><p>The GICD_IPRIORITYRs <strong>provide an 8-bit priority field for each interrupt</strong> supported by the<br>GIC. This field stores the priority of the corresponding interrupt.</p>\n<p>A GIC might implement fewer than eight priority bits, but must implement at least bits [7:4]<br>of each field. In each field, unimplemented bits are RAZ/WI. see [3.3 Interrupt prioritization]<br>我们可以实现CPU Interface 的Group level.</p>\n<p>In a multiprocessor implementation, GICD_IPRIORITYR0 to GICD_IPRIORITYR7 are<br>banked for each connected processor. These registers hold the Priority fields for interrupts<br>0-31.</p>\n<p>Fixme [Figure 4-13 GICD_IPRIORITYR bit assignments] 图片Page104</p>\n<h5 id=\"4-3-12-Interrupt-Processor-Targets-Registers-GICD-ITARGETSRn\"><a href=\"#4-3-12-Interrupt-Processor-Targets-Registers-GICD-ITARGETSRn\" class=\"headerlink\" title=\"4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn\"></a>4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn</h5><p>The GICD_ITARGETSRs <strong>provide an 8-bit CPU targets field for each interrupt supported</strong><br>by the GIC. <strong>This field stores the list of target processors for the interrupt.</strong> That is, it holds<br>the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and<br>has sufficient priority.</p>\n<p>In a multiprocessor implementation, GICD_ITARGETSR0 to GICD_ITARGETSR7 are<br>banked for each connected processor. These registers hold the CPU targets fields for<br>interrupts 0-31.</p>\n<p>Fixme [Figure 4-14 GICD_ITARGETSR bit assignments] 图片Page106</p>\n<p>Table 4-17 shows how each bit of a CPU targets field targets the interrupt at one of the CPU interfaces.<br>Fixme [Table 4-17 Meaning of CPU targets field bit values] 图片Page107</p>\n<p>Software can write to an GICD_ITARGETSR at any time.  （对Active无效，对pending 的有效）<br>Any change to a CPU targets field value:<br>• Has no effect on any active interrupt. This means that removing a CPU interface from a targets list does not<br>cancel an active state for that interrupt on that CPU interface.<br>• Has an effect on any pending interrupts. This means:<br>    — adding a CPU interface to the target list of a pending interrupt makes that interrupt pending on that<br>    CPU interface<br>    — removing a CPU interface from the target list of a pending interrupt removes the pending state of that<br>    interrupt on that CPU interface<br>• If it applies to an interrupt that is active and pending, does not change the interrupt targets until the active<br>status is cleared.    </p>\n<h5 id=\"4-3-13-Interrupt-Configuration-Registers-GICD-ICFGRn\"><a href=\"#4-3-13-Interrupt-Configuration-Registers-GICD-ICFGRn\" class=\"headerlink\" title=\"4.3.13 Interrupt Configuration Registers, GICD_ICFGRn\"></a>4.3.13 Interrupt Configuration Registers, GICD_ICFGRn</h5><p><strong>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC</strong>.<br>This field identifies whether the corresponding interrupt is <strong>edge-triggered or level-sensitive.</strong></p>\n<p>Fixme [Figure 4-15 GICD_ICFGR bit assignments] 图片Page109</p>\n<p>For SGIs, Int_config fields are read-only, meaning that GICD_ICFGR0 is read-only.<br>Before changing the value of a programmable Int_config field, software must disable the<br>corresponding interrupt, otherwise GIC behavior is UNPREDICTABLE.</p>\n<p>These registers are available in all configurations of the GIC. If the GIC implements the<br>Security Extensions these registers are Common.<br>In a multiprocessor implementation, if bit[1] of the Int_config field for any PPI is<br>programmable then GICD_ICFGR1 is banked for each connected processor. This register<br>holds the Int_config fields for the PPIs, interrupts 16-31.</p>\n<p>BITS        Name                        Function<br>[2F+1:2F]     Int_config, field F         For Int_config[1], the most significant bit, bit [2F+1], the encoding is:<br>                                        0 Corresponding interrupt is level-sensitive.<br>                                        1 Corresponding interrupt is edge-triggered.<br>                                        Int_config[0], the least significant bit, bit [2F], is reserved, but see Table 4-19 for the encoding of<br>                                        this bit on some early implementations of this GIC architecture.</p>\n<pre><code>For SGIs:\nInt_config[1] Not programmable, RAO/WI.\n\nFor PPIs and SPIs:\nInt_config[1] For SPIs, this bit is programmable.a For PPIs it is IMPLEMENTATION DEFINED\nwhether this bit is programmable. A read of this bit always returns the correct value\nto indicate whether the corresponding interrupt is level-sensitive or edge-triggered.\n</code></pre><h5 id=\"4-3-14-Non-secure-Access-Control-Registers-GICD-NSACRn\"><a href=\"#4-3-14-Non-secure-Access-Control-Registers-GICD-NSACRn\" class=\"headerlink\" title=\"4.3.14 Non-secure Access Control Registers, GICD_NSACRn\"></a>4.3.14 Non-secure Access Control Registers, GICD_NSACRn</h5><p>The GICD_NSACRs enable Secure software to permit Non-secure software on a particular<br>processor to create and manage Group 0 interrupts. They provide an access control for each<br>implemented interrupt.</p>\n<p>The GICD_NSACRn registers do not support PPI accesses, meaning that GICD_NSACR0 bits [31:16] are<br>RAZ/WI.</p>\n<p>Fixme [Figure 4-16 GICD_NSACR bit assignments] 图片Page111</p>\n<p>BITS            Name                    Function<br>[2F+1:2F]         NS_access, Field F         If the corresponding interrupt does not support configurable Non-secure access, the field is<br>                                        RAZ/WI. Otherwise, the field is RW and configures the level of Non-secure access permitted<br>                                        when the interrupt is in Group 0. If the interrupt is in Group 1, this field is ignored. The possible<br>                                        values of the field are:</p>\n<pre><code>0b00 No Non-secure access is permitted to fields associated with the corresponding\ninterrupt.\n\n0b01 Non-secure write access is permitted to fields associated with the corresponding\ninterrupt in the GICD_ISPENDRn registers. A Non-secure write access to\nGICD_SGIR is permitted to generate a Group 0 SGI for the corresponding\ninterrupt.\n\n0b10 Adds Non-secure write access permission to fields associated with the\ncorresponding interrupt in the GICD_ICPENDRn registers. Also adds\nNon-secure read access permission to fields associated with the corresponding\ninterrupt in the GICD_ISACTIVERn and GICD_ICACTIVERn registers.\n\n0b11 Adds Non-secure read and write access permission to fields associated with the\ncorresponding interrupt in the GICD_ITARGETSRn registers\n</code></pre><h5 id=\"4-3-15-Software-Generated-Interrupt-Register-GICD-SGIR\"><a href=\"#4-3-15-Software-Generated-Interrupt-Register-GICD-SGIR\" class=\"headerlink\" title=\"4.3.15 Software Generated Interrupt Register, GICD_SGIR\"></a>4.3.15 Software Generated Interrupt Register, GICD_SGIR</h5><p>This register is available in all configurations of the GIC. If the GIC implements the<br>Security Extensions(read GICD_TYPER) this register is Common.<br>The NSATT field, bit [15], is implemented only if the GIC implements the Security<br>Extensions.</p>\n<p>Fixme [Figure 4-17 GICD_SGIR bit assignments] 图片Page113</p>\n<p>Bits         Name                 Function<br>[31:26]     -                     reserved.<br>[25:24]     TargetListFilter     Determines how the distributor must process the requested SGI:<br>                                0b00 Forward the interrupt to the CPU interfaces specified in the CPUTargetList fielda.<br>                                0b01 Forward the interrupt to all CPU interfaces except that of the processor that requested the<br>                                interrupt.<br>                                0b10 Forward the interrupt only to the CPU interface of the processor that requested the<br>                                interrupt.<br>                                0b11 Reserved.<br>[23:16]     CPUTargetList         When TargetList Filter = 0b00, defines the CPU interfaces to which the Distributor must forward the<br>                                interrupt.<br>                                Each bit of CPUTargetList[7:0] refers to the corresponding CPU interface, for example<br>                                CPUTargetList[0] corresponds to CPU interface 0. Setting a bit to 1 indicates that the interrupt must be<br>                                forwarded to the corresponding interface.<br>                                If this field is 0x00 when TargetListFilter is 0b00, the Distributor does not forward the interrupt to any<br>                                CPU interface.<br>[15]         NSATT                 Implemented only if the GIC includes the Security Extensions.<br>                                Specifies the required security value of the SGI:<br>                                0 Forward the SGI specified in the SGIINTID field to a specified CPU interface only if the<br>                                SGI is configured as Group 0 on that interface.<br>                                1 Forward the SGI specified in the SGIINTID field to a specified CPU interfaces only if<br>                                the SGI is configured as Group 1 on that interface.<br>                                This field is writable only by a Secure access. Any Non-secure write to the GICD_SGIR generates an<br>                                SGI only if the specified SGI is programmed as Group 1, regardless of the value of bit[15] of the write.<br>                                See SGI generation when the GIC implements the Security Extensions for more information.<br>                                Note<br>                                If GIC does not implement the Security Extensions, this field is reserved.<br>[3:0]         SGIINTID             The Interrupt ID of the SGI to forward to the specified CPU interfaces. The value of this field is the<br>                                Interrupt ID, in the range 0-15, for example a value of 0b0011 specifies Interrupt ID 3.                        </p>\n<p><strong>SGI generation when the GIC implements the Security Extensions</strong><br>If the GIC implements the Security Extensions, whether an SGI is forwarded to a processor specified in the write<br>to the GICD_SGIR depends on:<br>• whether the write to the GICD_SGIR is Group 0 (Secure) or Group 1 (Non-secure)<br>• for a Secure write to the GICD_SGIR, the value of the GICD_SGIR.NSATT bit<br>• whether the specified SGI is configured as Group 0 (Secure) or Group 1 (Non-secure) on the targeted<br>processor.</p>\n<p>Fixme [Table 4-22 Truth table for sending an SGI to a target processor] Page 114</p>\n<h5 id=\"4-3-16-SGI-Clear-Pending-Registers-GICD-CPENDSGIRn\"><a href=\"#4-3-16-SGI-Clear-Pending-Registers-GICD-CPENDSGIRn\" class=\"headerlink\" title=\"4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn\"></a>4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn</h5><p>The GICD_CPENDSGIRs provide a clear-pending bit for each supported SGI and source<br>processor combination. When a processor writes a 1 to a clear-pending bit, the pending state<br>of the corresponding SGI for the corresponding source processor is removed, and no longer<br>targets the processor performing the write.</p>\n<p>Note<br>• <strong>In a multiprocessor implementation, the processor accessing the register can change the SGI pending status only on the corresponding interface. Changing the pending status of an SGI for one target processor does not affect the status of that SGI on any other processor.</strong><br>• PPIs and SPIs both use the Interrupt Clear-Pending registers, GICD_ICPENDRn</p>\n<p>These registers are present only in GICv2. The register locations are reserved in GICv1.In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.</p>\n<p>Four SGI Clear-Pending registers are implemented.each register contains eight clear-pending bits for each of four SGIs.<br>In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.</p>\n<p>一共四个 GICD_CPENDSGIR寄存器，每个寄存器含有四个8 bits，分别代表了四个SGIs。</p>\n<p>Fixme [Figure 4-18 GICD_CPENDSGIR bit assignments] Page 115</p>\n<p>Bits                         Name                         Function<br>[8y+7:8y], for y=0 to 3     SGI x Clear-pending bits      For each bit:<br>                                                        Reads     0 SGI x from the corresponding processor is not pendinga.<br>                                                                1 SGI x from the corresponding processor is pendinga.<br>                                                        Writes     0 Has no effect.<br>                                                                1 Removes the pending state of SGI x for the corresponding processor<br>                                                        Note<br>                                                        All accesses relate only to SGIs that target the processor making the access.</p>\n<h5 id=\"4-3-17-SGI-Set-Pending-Registers-GICD-SPENDSGIRn\"><a href=\"#4-3-17-SGI-Set-Pending-Registers-GICD-SPENDSGIRn\" class=\"headerlink\" title=\"4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn\"></a>4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn</h5><p>The GICD_SPENDSGIRn registers provide a set-pending bit for each supported SGI and<br>source processor combination. When a processor writes a 1 to a set-pending bit, the pending<br>state is applied to the corresponding SGI for the corresponding source processor.</p>\n<p>Fixme [Figure 4-19 GICD_SPENDSGIR bit assignments] page 117</p>\n<p>Bits Name Function<br>[8y+7:8y], for y=0 to 3   SGI x Set-pending bits    For each bit:<br>                                                    Reads     0 SGI x for the corresponding processor is not pendinga.<br>                                                              1 SGI x for the corresponding processor is pendinga.<br>                                                    Writes     0 Has no effect.<br>                                                            1 Adds the pending state of SGI x for the corresponding processor,<br>                                                            if it is not already pending. If SGI x is already pending for the<br>                                                            corresponding processor then the write has no effect.</p>\n<pre><code>Note\nAll accesses relate only to SGIs that target the processor making the access.\n</code></pre><h5 id=\"4-3-18-Identification-registers\"><a href=\"#4-3-18-Identification-registers\" class=\"headerlink\" title=\"4.3.18 Identification registers\"></a>4.3.18 Identification registers</h5><p>This architecture specification defines offsets 0xFD0-0xFFC in the Distributor register map as a read-only<br>identification register space.</p>\n<p>Fixme [Table 4-25 The GIC identification register space] page119</p>\n<p><strong>Peripheral ID2 Register, ICPIDR2</strong><br>Fixme [Figure 4-20 ICPIDR2 bit assignments] page119</p>\n<p>Bits     Name         Function<br>[7:4]     ArchRev     Revision field for the GIC architecture. The value of this field depends on the GIC architecture version:<br>                    • 0x1 for GICv1<br>                    • 0x2 for GICv2.</p>\n<h4 id=\"4-4-CPU-interface-register-descriptions\"><a href=\"#4-4-CPU-interface-register-descriptions\" class=\"headerlink\" title=\"4.4 CPU interface register descriptions\"></a>4.4 CPU interface register descriptions</h4><h5 id=\"4-4-1-CPU-Interface-Control-Register-GICC-CTLR\"><a href=\"#4-4-1-CPU-Interface-Control-Register-GICC-CTLR\" class=\"headerlink\" title=\"4.4.1 CPU Interface Control Register, GICC_CTLR\"></a>4.4.1 CPU Interface Control Register, GICC_CTLR</h5><p>Enables the signaling of interrupts by the CPU interface to the connected processor, and<br>provides additional top-level control of the CPU interface. In a GICv2 implementation, this<br>includes control of the end of interrupt (EOI) behavior.</p>\n<p>有几种类型的结构：<br><strong>for a GICv1 implementation, for</strong><br>• an implementation that does not include the Security Extensions<br>• the Non-secure copy of the register, in an implementation that includes the Security Extensions.<br>Fixme [Figure 4-22 GICC_CTLR bit assignments, GICv1 without Security Extensions or Non-secure] page 126</p>\n<p><strong>a GIC v2 implementation that includes the Security Extensions, for the Non-secure copy of the register</strong><br>Fixme [Figure 4-23 GICC_CTLR bit assignments, GICv2 with Security Extensions, Non-secure copy] page 126</p>\n<p>Bits         Name             Function<br>[9]         EOImodeNS         Controls the behavior of Non-secure accesses to the GICC_EOIR and GICC_DIR registers:<br>                            0     GICC_EOIR has both priority drop and deactivate interrupt functionality.<br>                                Accesses to the GICC_DIR are UNPREDICTABLE.<br>                            1     GICC_EOIR has priority drop functionality only. The GICC_DIR register has<br>                                deactivate interrupt functionality.</p>\n<p>[6]         IRQBypDisGrp1     When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the<br>                            bypass IRQ signal is signaled to the processor:<br>                            0     Bypass IRQ signal is signaled to the processor<br>                            1     Bypass IRQ signal is not signaled to the processor.</p>\n<p>[5]         FIQBypDisGrp1     When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the<br>                            bypass FIQ signal is signaled to the processor:<br>                            0     Bypass FIQ signal is signaled to the processor<br>                            1     Bypass FIQ signal is not signaled to the processor.</p>\n<p>[0]         EnableGrp1         Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor.<br>                            0 Disable signaling of interrupts<br>                            1 Enable signaling of interrupts.<br>                            Note<br>                            When this bit is set to 0, the CPU interface ignores any pending Group 1 interrupt forwarded to<br>                            it. When this bit is set to 1, the CPU interface starts to process pending Group 1 interrupts that are<br>                            forwarded to it. There is a small but finite time required for a change to take effect.</p>\n<p><strong>Security Extensions, for the Secure copy of the register</strong><br>• a GICv2 implementation, for:<br>— an implementation that does not include the Security Extensions<br>— the Secure copy of the register, in an implementation that includes the Security Extensions<br>• a GICv1 implementation that includes the Security Extensions, for the Secure copy of the register</p>\n<p>Fixme [Figure 4-24 GICC_CTLR bit assignments, GICv2 without Security Extensions or Secure] page 128</p>\n<p>Bits         Name             Function<br>[10]         EOImodeNS         Alias of EOImodeNS from the Non-secure copy of this register, see Table 4-30 on page 4-126.<br>                            In a GICv2 implementation that does not include the Security Extensions, and in a GICv1<br>                            implementation, this bit is reserved.</p>\n<p>[9]         EOImodeS         Controls the behavior of accesses to GICC_EOIR and GICC_DIR registers. In a GIC implementation<br>                            that includes the Security Extensions, this control applies only to Secure accesses, and the EOImodeNS<br>                            bit controls the behavior of Non-secure accesses to these registers:<br>                            0         GICC_EOIR has both priority drop and deactivate interrupt functionality. Accesses to<br>                                    the GICC_DIR are UNPREDICTABLE.<br>                            1         GICC_EOIR has priority drop functionality only. GICC_DIR has deactivate interrupt<br>                                    functionality.<br>                            Note<br>                            This bit is called EOImode in a GIC implementation that does not include the Security Extensions.<br>                            In a GICv1 implementation, this bit is reserved.</p>\n<p>[8]         IRQBypDisGrp1     Alias of IRQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.<br>                            In a GICv1 implementation, this bit is reserved</p>\n<p>[7]         FIQBypDisGrp1    Alias of FIQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.<br>                            In a GICv1 implementation, this bit is reserved.                            </p>\n<p>[6]         IRQBypDisGrp0     When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the bypass<br>                            IRQ signal is signaled to the processor:<br>                            0         Bypass IRQ signal is signaled to the processor<br>                            1         Bypass IRQ signal is not signaled to the processor.<br>                            In a GICv1 implementation, this bit is reserved.</p>\n<p>[5]         FIQBypDisGrp0    When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the bypass<br>                            FIQ signal is signaled to the processor:<br>                            0         Bypass FIQ signal is signaled to the processor<br>                            1         Bypass FIQ signal is not signaled to the processor.<br>                            In a GICv1 implementation, this bit is reserved.</p>\n<p>[4]         CBPR             Controls whether the GICC_BPR provides common control to Group 0 and Group 1 interrupts.<br>                            0         To determine any preemption, use:<br>                                    • the GICC_BPR for Group 0 interrupts<br>                                    • the GICC_ABPR for Group 1 interrupts.<br>                            1         To determine any preemption use the GICC_BPR for both Group 0 and Group 1<br>                                    interrupts.</p>\n<p>[3]         FIQEn             Controls whether the CPU interface signals Group 0 interrupts to a target processor using the FIQ or<br>                            the IRQ signal.<br>                            0         Signal Group 0 interrupts using the IRQ signal.<br>                            1         Signal Group 0 interrupts using the FIQ signal.<br>                            The GIC always signals Group 1 interrupts using the IRQ signal.</p>\n<p>[2]         AckCtl             When the highest priority pending interrupt is a Group 1 interrupt, determines both:<br>                            • whether a read of GICC_IAR acknowledges the interrupt, or returns a spurious interrupt ID<br>                            • whether a read of GICC_HPPIR returns the ID of the highest priority pending interrupt, or<br>                                returns a spurious interrupt ID.</p>\n<pre><code>0         If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR\n        or the GICC_HPPIR returns an Interrupt ID of 1022. A read of the GICC_IAR does\n        not acknowledge the interrupt, and has no effect on the pending status of the interrupt.\n1         If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR\n        or the GICC_HPPIR returns the Interrupt ID of the Group 1 interrupt. A read of\n        GICC_IAR acknowledges and Activates the interrupt.\nIn a GIC implementation that includes the Security Extensions, this control affects only the behavior\nof Secure register accesses.\nFor more information, see:\n• The effect of interrupt grouping on interrupt acknowledgement on page 3-50\n• Interrupt grouping and interrupt prioritization on page 3-53\n• Behavior of writes to GICC_EOIR, GICv1 with Security Extensions on page 4-139\n• Effect of interrupt grouping and the Security Extensions on reads of the GICC_HPPIR on\npage 4-143.\nNote\nARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where\nGICC_CTLR.AckCtl is set to 0. See Enabling and disabling the Distributor and CPU interfaces on\npage 4-77 for more information about the effects of setting this bit.\n</code></pre><p>[1]         EnableGrp1         Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor:<br>                            0         Disable signaling of Group 1 interrupts.<br>                            1         Enable signaling of Group 1 interrupts.</p>\n<p>[0]         EnableGrp0         Enable for the signaling of Group 0 interrupts by the CPU interface to the connected processor:<br>                            0         Disable signaling of Group 0 interrupts.<br>                            1         Enable signaling of Group 0 interrupts.</p>\n<h5 id=\"4-4-2-Interrupt-Priority-Mask-Register-GICC-PMR\"><a href=\"#4-4-2-Interrupt-Priority-Mask-Register-GICC-PMR\" class=\"headerlink\" title=\"4.4.2 Interrupt Priority Mask Register, GICC_PMR\"></a>4.4.2 Interrupt Priority Mask Register, GICC_PMR</h5><p><strong>Provides an interrupt priority filter. Only interrupts with higher priority than the value in this register are signaled to the processor</strong></p>\n<p>Fixme [Figure 4-25 GICC_PMR bit assignments] page131</p>\n<h5 id=\"4-4-3-Binary-Point-Register-GICC-BPR\"><a href=\"#4-4-3-Binary-Point-Register-GICC-BPR\" class=\"headerlink\" title=\"4.4.3 Binary Point Register, GICC_BPR\"></a>4.4.3 Binary Point Register, GICC_BPR</h5><p>The register defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field is used to determine <strong>interrupt preemption.</strong></p>\n<p>Fixme [Figure 4-26 GICC_BPR bit assignments] page133</p>\n<p>see:<br>Table 3-2 Priority grouping by binary point<br>Table 3-7 Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0</p>\n<h5 id=\"4-4-4-Interrupt-Acknowledge-Register-GICC-IAR\"><a href=\"#4-4-4-Interrupt-Acknowledge-Register-GICC-IAR\" class=\"headerlink\" title=\"4.4.4 Interrupt Acknowledge Register, GICC_IAR\"></a>4.4.4 Interrupt Acknowledge Register, GICC_IAR</h5><p>The processor reads this register to obtain the interrupt ID of the signaled interrupt. This<br>read acts as an acknowledge for the interrupt.</p>\n<p>When GICC_CTLR.AckCtl is set to 0 in a GICv2 implementation that does not include the<br>Security Extensions, if the highest priority pending interrupt is in Group 1, the interrupt ID<br>1022 is returned.</p>\n<p>Fixme [Figure 4-27 GICC_IAR bit assignments] page135.</p>\n<p>Bit         Name             Function<br>[31:13]     -                 Reserved.<br>[12:10]     CPUID             <strong>For SGIs in a multiprocessor implementation</strong>, this field identifies the processor that<br>                            requested the interrupt. It returns the number of the CPU interface that made the<br>                            request, for example a value of 3 means the request was generated by a write to the<br>                            GICD_SGIR on CPU interface 3.<br>                            For all other interrupts this field is RAZ.<br>[9:0]         Interrupt ID     The interrupt ID.</p>\n<p>The read returns a spurious interrupt ID of 1023 if any of the following apply:<br>• forwarding of interrupts by the Distributor to the CPU interface is disabled<br>• signaling of interrupts by the CPU interface to the connected processor is disabled<br>• no pending interrupt on the CPU interface has sufficient priority for the interface to signal it to the processor</p>\n<p>A non-spurious interrupt ID returned by a read of the GICC_IAR is called a valid interrupt ID.<br><strong>When the GIC returns a valid interrupt ID to a read of the GICC_IAR it treats the read as an acknowledge of that interrupt and, as a side-effect of the read, changes the interrupt status from pending to active, or to active and pending if the pending state of the interrupt persists.</strong></p>\n<p>Note<br>• For compatibility with possible extensions to the GIC architecture specification, ARM recommends that<br>software preserves the entire register value read from the GICC_IAR, and writes that value back to the<br>GICC_EOIR when it has completed its processing of the interrupt.<br>• Although multiple target processors might attempt to read the GICC_IAR at any time, in GICv2 only one<br>processor can obtain a valid interrupt ID, see Implications of the 1-N model on page 3-41 for more<br>information.</p>\n<p>Fixme [Table 4-35 Effect of interrupt grouping and the Security Extensions on reads of GICC_IAR]Page136</p>\n<h5 id=\"4-4-5-End-of-Interrupt-Register-GICC-EOIR\"><a href=\"#4-4-5-End-of-Interrupt-Register-GICC-EOIR\" class=\"headerlink\" title=\"4.4.5 End of Interrupt Register, GICC_EOIR\"></a>4.4.5 End of Interrupt Register, GICC_EOIR</h5><p>A processor writes to this register to inform the CPU interface either:<br>• that it has completed the processing of the specified interrupt<br>• in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set<br>to 1, to indicate that the interface should perform priority drop for the specified<br>interrupt. See Priority drop and interrupt deactivation on page 3-38 for more information.</p>\n<p>Fixme [Figure 4-28 GICC_EOIR bit assignments]Page138</p>\n<p>Fixme [Table 4-36 GICC_EOIR bit assignments]Page138</p>\n<p>For every read of a valid Interrupt ID from the GICC_IAR, the connected processor must perform a matching write<br>to the GICC_EOIR. The value written to the GICC_EOIR must be the interrupt ID read from the GICC_IAR.<br>If a read of the GICC_IAR returns the ID of a spurious interrupt, software does not have to make a corresponding<br>write to the GICC_EOIR. If software writes the ID of a spurious interrupt to the GICC_EOIR, the GIC ignores that<br>write.</p>\n<p><strong>Behavior of writes to GICC_EOIR, GICv2</strong><br>In a GICv2 implementation, when GICC_CTLR.AckCtl is set to 0:<br>• GICC_EOIR is used for processing Group 0 interrupts<br>• GICC_AEOIR is used for processing Group 1 interrupts.</p>\n<p>In a GICv2 implementation that includes the GIC Security Extensions:<br>• GICC_CTLR.EOImodeS controls the behavior of Secure accesses to GICC_EOIR and GICC_AEOIR<br>• GICC_CTLR.EOImodeNS controls the behavior of Non-secure accesses to GICC_EOIR<br>• when GICC_CTLR.AckCtl is set to 0:<br>    — a Non-secure write to GICC_EOIR must correspond to the most recent Non-secure read of GICC_IAR<br>    — a Secure write to the GICC_AEOIR must correspond to the most recent Secure read of the<br>    GICC_AIAR.</p>\n<h5 id=\"4-4-6-Running-Priority-Register-GICC-RPR\"><a href=\"#4-4-6-Running-Priority-Register-GICC-RPR\" class=\"headerlink\" title=\"4.4.6 Running Priority Register, GICC_RPR\"></a>4.4.6 Running Priority Register, GICC_RPR</h5><p>Indicates the Running priority of the CPU interface</p>\n<p>Fixme [Figure 4-29 GICC_RPR bit assignments] page142</p>\n<h5 id=\"4-4-7-Highest-Priority-Pending-Interrupt-Register-GICC-HPPIR\"><a href=\"#4-4-7-Highest-Priority-Pending-Interrupt-Register-GICC-HPPIR\" class=\"headerlink\" title=\"4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR\"></a>4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR</h5><p>Indicates the Interrupt ID, and processor ID if appropriate, of the <strong>highest priority pending</strong><br>interrupt on the CPU interface.</p>\n<p>Fixme [Figure 4-30 GICC_HPPIR bit assignments] Page143</p>\n<p>Bit            Name         Description<br>[31:13]     -             Reserved.<br>[12:10]     CPUID         On a multiprocessor implementation, if the PENDINTID field returns the ID of an<br>                        SGI, this field contains the CPUID value for that interrupt. This identifies the<br>                        processor that generated the interrupt.<br>[9:0]         PENDINTID     The interrupt ID of the highest priority pending interrupt. See Table 4-42 on<br>                        page 4-144 for more information about the result of Non-secure reads of the<br>                        GICC_HPPIR when the GIC implements the Security Extensions.</p>\n<h5 id=\"4-4-8-Aliased-Binary-Point-Register-GICC-ABPR\"><a href=\"#4-4-8-Aliased-Binary-Point-Register-GICC-ABPR\" class=\"headerlink\" title=\"4.4.8 Aliased Binary Point Register, GICC_ABPR\"></a>4.4.8 Aliased Binary Point Register, GICC_ABPR</h5><h5 id=\"4-4-9-Aliased-Interrupt-Acknowledge-Register-GICC-AIAR\"><a href=\"#4-4-9-Aliased-Interrupt-Acknowledge-Register-GICC-AIAR\" class=\"headerlink\" title=\"4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR\"></a>4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR</h5><h5 id=\"4-4-10-Aliased-End-of-Interrupt-Register-GICC-AEOIR\"><a href=\"#4-4-10-Aliased-End-of-Interrupt-Register-GICC-AEOIR\" class=\"headerlink\" title=\"4.4.10 Aliased End of Interrupt Register, GICC_AEOIR\"></a>4.4.10 Aliased End of Interrupt Register, GICC_AEOIR</h5><h5 id=\"4-4-11-Aliased-Highest-Priority-Pending-Interrupt-Register-GICC-AHPPIR\"><a href=\"#4-4-11-Aliased-Highest-Priority-Pending-Interrupt-Register-GICC-AHPPIR\" class=\"headerlink\" title=\"4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR\"></a>4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR</h5><p>与前面对应相似</p>\n<h5 id=\"4-4-12-Active-Priorities-Registers-GICC-APRn\"><a href=\"#4-4-12-Active-Priorities-Registers-GICC-APRn\" class=\"headerlink\" title=\"4.4.12 Active Priorities Registers, GICC_APRn\"></a>4.4.12 Active Priorities Registers, GICC_APRn</h5><p>主要用于做电源管理时，保存与恢复。<br>provide support for preserving and restoring the active priority in power-management implementations.</p>\n<p>Although the format of these registers is IMPLEMENTATION DEFINED:<br>• because GICv2 guarantees the ability to save and restore all GIC state, the<br>GICC_APRn registers must be present in all GIC implementations<br>• in an implementation that includes the GIC Security Extensions, Non-secure<br>accesses must not affect Secure operation, and the architecture requires that these<br>registers are banked, to provide Secure and Non-secure copies of the registers.</p>\n<h5 id=\"4-4-13-Non-secure-Active-Priorities-Registers-GICC-NSAPRn\"><a href=\"#4-4-13-Non-secure-Active-Priorities-Registers-GICC-NSAPRn\" class=\"headerlink\" title=\"4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn\"></a>4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn</h5><p>provide support for preserving and restoring the active priority in power-management implementation. These are separate registers for Group 1 interrupts.</p>\n<h5 id=\"4-4-14-CPU-Interface-Identification-Register-GICC-IIDR\"><a href=\"#4-4-14-CPU-Interface-Identification-Register-GICC-IIDR\" class=\"headerlink\" title=\"4.4.14 CPU Interface Identification Register, GICC_IIDR\"></a>4.4.14 CPU Interface Identification Register, GICC_IIDR</h5><p>Provides information about the implementer and revision of the CPU interface.</p>\n<p>Fixme [Figure 4-35 GICC_IIDR bit assignments] Page 152</p>\n<p>Fixme [Table 4-48 GICC_IIDR bit assignments] Page 152</p>\n<h5 id=\"4-4-15-Deactivate-Interrupt-Register-GICC-DIR\"><a href=\"#4-4-15-Deactivate-Interrupt-Register-GICC-DIR\" class=\"headerlink\" title=\"4.4.15 Deactivate Interrupt Register, GICC_DIR\"></a>4.4.15 Deactivate Interrupt Register, GICC_DIR</h5><p>When interrupt priority drop is separated from interrupt deactivation, as described in<br>Priority drop and interrupt deactivation on page 3-38, a write to this register <strong>deactivates the specified interrupt.</strong></p>\n<p>Fixme [Figure 4-36 GICC_DIR bit assignments] Page 153</p>\n<p>Fixme [Table 4-49 GICC_DIR bit assignments] Page 153</p>\n<p>Fixme [Table 4-50 Behavior of GICC_DIR writes] Page 154</p>\n<h3 id=\"5-GIC-Support-for-Virtualization\"><a href=\"#5-GIC-Support-for-Virtualization\" class=\"headerlink\" title=\"5 GIC Support for Virtualization\"></a>5 GIC Support for Virtualization</h3><h4 id=\"5-1-About-implementing-a-GIC-in-a-system-with-processor-virtualization\"><a href=\"#5-1-About-implementing-a-GIC-in-a-system-with-processor-virtualization\" class=\"headerlink\" title=\"5.1 About implementing a GIC in a system with processor virtualization\"></a>5.1 About implementing a GIC in a system with processor virtualization</h4><p><strong>Any ARM processor implementation that includes the Virtualization Extensions must also include the Security Extensions.</strong></p>\n<p>Fixme [Figure 5-1 Implementing the GIC with an ARM processor that supports virtualization] Page159</p>\n<h4 id=\"5-2-Managing-the-GIC-virtual-CPU-interface\"><a href=\"#5-2-Managing-the-GIC-virtual-CPU-interface\" class=\"headerlink\" title=\"5.2 Managing the GIC virtual CPU interface\"></a>5.2 Managing the GIC virtual CPU interface</h4><p>The hypervisor, or similar software, manages the GIC virtual interface control registers, consisting of:<br><strong>List registers</strong><br>Used to define the active and pending virtual interrupts for the virtual CPU interface. The current<br>virtual machine accesses these interrupts indirectly, using the virtual CPU interface.</p>\n<p><strong>Management registers</strong><br>Used to manage the virtual CPU interface, and to save and restore settings when switching between<br>virtual machines.</p>\n<p>The hypervisor runs as Non-secure software in Hyp mode. To maintain the 1-N interrupt handling model, a hypervisor might have to migrate an interrupt from one virtual machine to another.</p>\n<p>When it receives a physical IRQ, the hypervisor determines the required destination of the interrupt and then either:<br>• Processes the interrupt itself, for example if the IRQ is <strong>a maintenance interrupt</strong> from the virtual CPU<br>interface. It then deactivates the physical interrupt.<br>• Generates a virtual interrupt. Depending on the interrupt priority and the targeted virtual machine, the<br>hypervisor takes one of the following actions:<br>    — If the interrupt is for the current virtual machine, updates the List registers with details of the interrupt,<br>    redefining the interrupts that are visible to the current virtual machine. If there is no space in the List<br>    registers, it saves the context to memory so the details can be added at a later stage<br>    — Records that the interrupt is for a different virtual machine by saving details of the interrupt as part of<br>    the hypervisor state associated with that virtual machine.<br>    — Switches to a different virtual machine that can handle the interrupt. In doing so it must save the<br>    interrupt state for the current virtual machine, using the information in the List registers, and<br>    reprogram the List registers, to indicate the interrupt state for the new virtual machine, including the<br>    state for the interrupt that has arrived.</p>\n<p>The virtual machine accesses the GIC virtual CPU interface registers. These registers have the same general format<br>as the physical CPU interface registers, and, in a typical implementation the virtual machine believes it is accessing<br>a physical CPU interface.</p>\n<p>When the virtual machine handles a virtual interrupt, it writes to the virtual CPU interface to indicate when it has<br>finished this processing. The virtual CPU interface signals this completion to the physical Distributor and the<br>physical Distributor then deactivates the interrupt.</p>\n<h5 id=\"5-2-1-List-registers-and-virtual-interrupt-handling\"><a href=\"#5-2-1-List-registers-and-virtual-interrupt-handling\" class=\"headerlink\" title=\"5.2.1 List registers and virtual interrupt handling\"></a>5.2.1 List registers and virtual interrupt handling</h5><p>a hypervisor uses List registers to maintain the list of highest priority virtual interrupts.</p>\n<p>记录的数据可以超过List registers数量，多余的数据存储在MEM 中。<br><strong>The total number of interrupts that are either pending, active, or active and pending, can exceed the number of List registers available.</strong><br>If this happens, the hypervisor can save one or more active interrupt entries to memory, and later restore them to the List registers，based on their priority。Therefore:<br>• The List registers might not include all active, or active and pending, interrupts. Virtual CPU interface<br>accesses by the virtual machine update the List registers, and normally an EOI request from the virtual<br>machine deactivates an interrupt in the list. However, the virtual machine can issue an EOI request for an<br>interrupt before the hypervisor restores the associated active interrupt entry into a List register. In this case,<br>the EOI request cannot update the List registers.</p>\n<p>• Although the List registers might include only active interrupts, with the hypervisor maintaining any pending<br>interrupts in memory, a pending interrupt cannot be signaled to the virtual machine until the hypervisor adds<br>it to the List registers. Therefore, to minimize interrupt latency and ensure efficient virtual machine operation,<br><strong>ARM strongly recommends that the List registers contain at least one pending interrupt, provided a List register is available for this interrupt.</strong></p>\n<h5 id=\"5-2-2-Completion-of-virtualized-physical-interrupts\"><a href=\"#5-2-2-Completion-of-virtualized-physical-interrupts\" class=\"headerlink\" title=\"5.2.2 Completion of virtualized physical interrupts\"></a>5.2.2 Completion of virtualized physical interrupts</h5><p>ARM recommends that, for each CPU interface that corresponds to a<br>processor running virtual machines, the GICC_CTLR.EOImodeNS bit is set to 1. This means that hypervisor<br>accesses to the GICC_AEOIR register drops the running priority of the CPU interface but does not deactivate the<br>interrupt. After writing to the EOI register, the running priority level on the CPU interface is lower, so that<br>subsequent interrupts can be signaled to the processor.</p>\n<p>ARM recommends that physical interrupt completion consists of the following separate steps:</p>\n<ol>\n<li>EOI</li>\n<li>interrupt deactivation.</li>\n</ol>\n<p>These steps are explained in more detail as follows:</p>\n<ol>\n<li><p>After receiving a physical interrupt, the hypervisor performs an EOI request for the physical interrupt by<br>writing to the GICC_EOIR or GICC_AEOIR register. After EOI, although the virtual machine has not<br>processed the virtual interrupt, the lower running priority of the CPU interface means that the hypervisor can<br>still receive new physical interrupts.<br> Note<br> The only interrupts that are not signaled to the hypervisor are the physical interrupts most recently subject to<br> EOI. This is because the interrupts have not been deactivated. This prevents the interrupts from being<br> re-signaled to the hypervisor before being processed by the virtual machine.</p>\n</li>\n<li><p>After the virtual machine completes processing the corresponding virtual interrupt, it writes to the<br>GICV_EOIR or GICV_AEOIR to deactivate the interrupt. This deactivates both the virtual interrupt and the<br>corresponding physical interrupt, provided that both of the following conditions are true:<br>• the GICV_CTLR.EOImode bit is set to 0<br>• the GICH_LRn.HW bit is set to 1.</p>\n</li>\n</ol>\n<p>Alternatively, if the GICV_CTLR.EOImode bit is set to 1, the virtual machine writes to the GICV_DIR<br>register to deactivate the interrupt.<br>If the GICH_LRn.HW bit is set to 0, the hypervisor must deactivate the physical interrupt itself. ARM<br>recommends one of the following methods for deactivating physical SGIs that are routed to a virtual machine:<br>• the hypervisor deactivates the SGI by writing to the GICC_DIR register after the virtual machine<br>writes to GICC_EOIR<br>• the hypervisor uses an EOI maintenance interrupt to write to the GICC_DIR register after the virtual<br>machine writes to GICV_EOIR, see Maintenance interrupts on page 5-164 for more information.</p>\n<p>处理大致流程：</p>\n<ol>\n<li>hypervisor 写GICC_AEOIR，让此IRQ 丢掉优先级，能让其他低优先级的中断能被处理</li>\n<li>virtual machine 处理完后，virtual cpu 写GICV_EOIR 或 GICV_AEOIR，再写GICV_DIR （依赖GICV_CTLR.EOImode 设定是否自动完成后一步）</li>\n<li>在virtual machine 写 GICV_EOIR 后，hypervisor 用 EOI maintenance interrupt 写 GICC_DIR （GICH_LRn.HW 设定为1，自动完成此步）</li>\n</ol>\n<h5 id=\"5-2-3-Acknowledgement-and-completion-of-virtual-interrupts\"><a href=\"#5-2-3-Acknowledgement-and-completion-of-virtual-interrupts\" class=\"headerlink\" title=\"5.2.3 Acknowledgement and completion of virtual interrupts\"></a>5.2.3 Acknowledgement and completion of virtual interrupts</h5><p>To ensure system correctness when handling virtual interrupts, one of the following conditions must be true:<br>• All Group 0 interrupts must have a higher priority than any Group 1 interrupt. That is, there is no overlap in<br>the priorities allocated to Group 0 and Group 1 interrupts.<br>• The GICV_CTLR.AckCtl bit must be set to 0.</p>\n<p><strong>ARM deprecates the use of GICC_CTLR.AckCtl and GICV_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl and GICV_CTLR.AckCtl are set to 0.</strong></p>\n<h5 id=\"5-2-4-GIC-virtual-interface-control-interface-requirements\"><a href=\"#5-2-4-GIC-virtual-interface-control-interface-requirements\" class=\"headerlink\" title=\"5.2.4 GIC virtual interface control interface requirements\"></a>5.2.4 GIC virtual interface control interface requirements</h5><p>skip</p>\n<h5 id=\"5-2-5-Maintenance-interrupts\"><a href=\"#5-2-5-Maintenance-interrupts\" class=\"headerlink\" title=\"5.2.5 Maintenance interrupts\"></a>5.2.5 Maintenance interrupts</h5><p><strong>Maintenance interrupts can signal key events in the operation of a GIC that implements the Virtualization Extensions. Typically, these events are processed by the hypervisor.</strong></p>\n<p>Note<br>• Maintenance interrupts are generated only when the global interrupt enable bit, GICH_HCR.En, is set to 1.</p>\n<p>Maintenance interrupts are level-sensitive interrupts. Configuration bits in the GICH_HCR can be set to 1 to enable<br>maintenance interrupt generation when:<br>• Group 0 virtual interrupts are enabled/disabled<br>• Group 1 virtual interrupts are enabled/disabled<br>• There are no pending interrupts in the List registers.<br>• At least one EOI request occurs with no valid List register entry for the corresponding interrupt.<br>• There are no valid entries, or only one valid entry, in the List registers. This is an underflow condition.<br>• At least one List register entry has received an EOI request.</p>\n<h5 id=\"5-2-6-Software-generated-interrupts\"><a href=\"#5-2-6-Software-generated-interrupts\" class=\"headerlink\" title=\"5.2.6 Software-generated interrupts\"></a>5.2.6 Software-generated interrupts</h5><p><strong>Hypervisor-generated interrupts</strong><br>A hypervisor can generate virtual interrupts that do not have a corresponding physical interrupt, by<br>creating an entry in the List registers with the GICH_LRn.HW bit cleared to 0. The hypervisor can<br>control how the interrupt appears to a virtual machine reading the GICV_IAR or GICV_AIAR<br>register to acknowledge the interrupt, by presenting the interrupt as:<br>• an SGI, with a CPUID value provided in addition to the interrupt ID<br>• a PPI or SPI, with the CPUID value set to 0.</p>\n<p>The hypervisor can virtualize the CPUID value, but it must be consistent with the type of interrupt<br>indicated by the GICH_LRn.VirtualID field. When the EOI notification is sent to the virtual CPU<br>interface, only the List registers are affected, and no notification is sent to the Distributor. See List<br>Registers, GICH_LRn on page 5-176 for more information.</p>\n<p>hypervisor 可以产生与硬件中断号不一致的虚拟中断，并且可以控制中断在虚拟机中呈现的形式：SGI，PPI，SPI。</p>\n<p><strong>Distributor-generated interrupts</strong><br>Because the hardware interrupt deactivation mechanism does not support SGIs, the hypervisor must<br>virtualize SGIs originating from the Distributor in the same way as hypervisor-generated interrupts.<br>The hypervisor can virtualize the GICH_LRn.CPUID field, because this field is not required to be<br>the same as that of the original SGI. See Completion of virtualized physical interrupts on page 5-161<br>for more information about deactivating virtualized SGIs.</p>\n<p>虚拟中断分发器 产生的虚拟机之间的SGIs。</p>\n<h5 id=\"5-2-7-GIC-Virtualization-Extensions-register-mapping\"><a href=\"#5-2-7-GIC-Virtualization-Extensions-register-mapping\" class=\"headerlink\" title=\"5.2.7 GIC Virtualization Extensions register mapping\"></a>5.2.7 GIC Virtualization Extensions register mapping</h5><p>The GIC must make these virtual interface control registers accessible in the following ways:<br><strong>Redirection through a common base address</strong><br>The memory map includes a common base address for the virtual interface control registers. Each<br>processor in the system can access its own GIC virtual interface control registers through this base<br>address. The CPUID of the processor requesting access redirects the access to the GIC virtual<br>interface control registers for that processor.</p>\n<p><strong>Processor-specific base addresses</strong><br>In addition to the common base address, the memory map contains, for each processor in the system,<br>a processor-specific base address for the GIC virtual interface control registers. Any processor can<br>use these addresses to access its own GIC virtual interface control registers, or to access the GIC<br>virtual interface control registers of any other processor in the system.</p>\n<p>Fixme [Figure 5-2 GIC virtual interface control register mappings] page166</p>\n<h4 id=\"5-3-GIC-virtual-interface-control-registers\"><a href=\"#5-3-GIC-virtual-interface-control-registers\" class=\"headerlink\" title=\"5.3 GIC virtual interface control registers\"></a>5.3 GIC virtual interface control registers</h4><p>Fixme [Table 5-1 GIC virtual interface control register map] page167</p>\n<h5 id=\"5-3-1-Hypervisor-Control-Register-GICH-HCR\"><a href=\"#5-3-1-Hypervisor-Control-Register-GICH-HCR\" class=\"headerlink\" title=\"5.3.1 Hypervisor Control Register, GICH_HCR\"></a>5.3.1 Hypervisor Control Register, GICH_HCR</h5><p>This register contains control bits for the virtual CPU interface.</p>\n<p>Fixme [Figure 5-3 GICH_HCR bit assignments] page168</p>\n<p>Fixme [Table 5-2 GICH_HCR bit assignments] page168</p>\n<p>Fixme [Table 5-2 GICH_HCR bit assignments] page169</p>\n<h5 id=\"5-3-2-VGIC-Type-Register-GICH-VTR\"><a href=\"#5-3-2-VGIC-Type-Register-GICH-VTR\" class=\"headerlink\" title=\"5.3.2 VGIC Type Register, GICH_VTR\"></a>5.3.2 VGIC Type Register, GICH_VTR</h5><p>This is a read-only register that provides the following information about the<br>implementation of the GIC Virtualization Extensions:<br>• number of priority levels supported<br>• number of preemption levels supported<br>• number of implemented List registers.</p>\n<p>Fixme [Figure 5-4 GICH_VTR bit assignments] page170</p>\n<p>Fixme [Table 5-3 GICH_VTR bit assignments] page170</p>\n<h5 id=\"5-3-3-Virtual-Machine-Control-Register-GICH-VMCR\"><a href=\"#5-3-3-Virtual-Machine-Control-Register-GICH-VMCR\" class=\"headerlink\" title=\"5.3.3 Virtual Machine Control Register, GICH_VMCR\"></a>5.3.3 Virtual Machine Control Register, GICH_VMCR</h5><p>Enables the hypervisor to save and restore the virtual machine view of the GIC state.</p>\n<p>Fixme [Figure 5-5 GICH_VMCR bit assignments] page171</p>\n<p>The GICH_VMCR is a control register that contains read and write aliases of architecture state in the virtual<br>machine view, enabling the hypervisor to save and restore this state with a single read or write, without accessing<br>the GIC virtual CPU interface registers individually.</p>\n<h5 id=\"5-3-4-Maintenance-Interrupt-Status-Register-GICH-MISR\"><a href=\"#5-3-4-Maintenance-Interrupt-Status-Register-GICH-MISR\" class=\"headerlink\" title=\"5.3.4 Maintenance Interrupt Status Register, GICH_MISR\"></a>5.3.4 Maintenance Interrupt Status Register, GICH_MISR</h5><p>Indicates which maintenance interrupts are asserted.</p>\n<p>Fixme [Figure 5-6 GICH_MISR bit assignments] page172</p>\n<p>Fixme [Table 5-5 GICH_MISR bit assignments] page172</p>\n<h5 id=\"5-3-5-End-of-Interrupt-Status-Registers-GICH-EISR0-and-GICH-EISR1\"><a href=\"#5-3-5-End-of-Interrupt-Status-Registers-GICH-EISR0-and-GICH-EISR1\" class=\"headerlink\" title=\"5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1\"></a>5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1</h5><p>When a maintenance interrupt is received, these registers help determine which List<br>registers have outstanding EOI interrupts that require servicing.</p>\n<p>Fixme [Figure 5-7 GICH_EISR0 bit assignments] page173</p>\n<p>Fixme [Table 5-6 GICH_EISR0 bit assignments] page173</p>\n<h5 id=\"5-3-6-Empty-List-Register-Status-Registers-GICH-ELRSR0-and-GICH-ELRSR1\"><a href=\"#5-3-6-Empty-List-Register-Status-Registers-GICH-ELRSR0-and-GICH-ELRSR1\" class=\"headerlink\" title=\"5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1\"></a>5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1</h5><p>These registers can be used to locate a usable List register when the hypervisor is delivering<br>an interrupt to a Guest OS.</p>\n<p>Fixme [Figure 5-8 GICH_ELRSR0 bit assignments] page173</p>\n<p>Fixme [Table 5-7 GICH_ELRSR0 bit assignments] page173</p>\n<h5 id=\"5-3-7-Active-Priorities-Register-GICH-APR\"><a href=\"#5-3-7-Active-Priorities-Register-GICH-APR\" class=\"headerlink\" title=\"5.3.7 Active Priorities Register, GICH_APR\"></a>5.3.7 Active Priorities Register, GICH_APR</h5><p>This register tracks which preemption levels are active in the virtual CPU interface, and is<br>used to determine the current active priority. Corresponding bits are set in this register when<br>an interrupt is acknowledged, based on GICH_LRn.Priority, and the least significant set bit<br>is cleared on EOI.</p>\n<p>Fixme [Figure 5-9 GICH_APR bit assignments] page175</p>\n<p>Fixme [Table 5-8 GICH_APR bit assignments] page175</p>\n<h5 id=\"5-3-8-List-Registers-GICH-LRn\"><a href=\"#5-3-8-List-Registers-GICH-LRn\" class=\"headerlink\" title=\"5.3.8 List Registers, GICH_LRn\"></a>5.3.8 List Registers, GICH_LRn</h5><p>Provides interrupt context information for the virtual CPU interface. <strong>A maximum of 64 List registers can be provided. The GICH_VTR.ListRegs bit defines the actual number implemented.</strong></p>\n<p>Fixme [Figure 5-10 GICH_LR bit assignments] page176</p>\n<p>Fixme [Table 5-9 GICH_LR bit assignments] page176</p>\n<h4 id=\"5-4-The-virtual-CPU-interface\"><a href=\"#5-4-The-virtual-CPU-interface\" class=\"headerlink\" title=\"5.4 The virtual CPU interface\"></a>5.4 The virtual CPU interface</h4><p>A GIC virtual CPU interface signals virtual interrupts to a connected processor, The GIC virtual CPU interface registers have the same general format as the GIC physical CPU interface registers and expected behavior is that a virtual machine cannot distinguish between them.</p>\n<p><strong>In particular, the virtual CPU interface uses the contents of the List registers to determine when to signal virtual interrupts.</strong></p>\n<p>When a processor accesses the virtual CPU interface the List registers are updated.<br>• Virtual interrupts are always handled through the virtual CPU interfaces.<br>• On the connected processor, if the processor is in a Non-secure PL1 or PL0 mode, virtual interrupts are<br>signaled to the current virtual machine.<br>• In addition, a virtual machine can receive virtual IRQs and virtual FIQs signaled directly by the hypervisor.<br>These exceptions are outside the scope of this specification. A virtual machine cannot distinguish:<br>    — A virtual exception signaled by the GIC from a corresponding virtual exception signaled directly by the hypervisor.<br>    — A virtual exception from the corresponding physical exception.<br>• A virtual CPU interface does not require power management support, and therefore GICV_CTLR does not<br>implement the IRQBypDisGrp1, FIQBypDisGrp1, IRQBypDisGrp0, and FIQBypDisGrp0 bits that are<br>supported by GICC_CTLR</p>\n<h4 id=\"5-5-GIC-virtual-CPU-interface-registers\"><a href=\"#5-5-GIC-virtual-CPU-interface-registers\" class=\"headerlink\" title=\"5.5 GIC virtual CPU interface registers\"></a>5.5 GIC virtual CPU interface registers</h4><p>Typically, a virtual machine is unaware of any difference between virtual interrupts and physical interrupts.</p>\n<p><strong>In general, these registers have the same format as the GIC physical CPU interface registers, but they operate on the interrupt view defined primarily by the List registers.</strong></p>\n<p>These registers are memory-mapped, The offset of each GICV_* register is the same as the offset of the corresponding register for the physical CPU interface.</p>\n<p>Fixme [Table 5-10 GIC virtual CPU interface register map] page179</p>\n","site":{"data":{}},"excerpt":"<p>GICv2<br>","more":"</p>\n<p>##1. Introduction<br>About the Generic Interrupt Controller architecture<br>The Generic Interrupt Controller (GIC) architecture defines:<br>• the architectural requirements for handling all interrupt sources for any processor connected to a GIC<br>• a common interrupt controller programming interface applicable to uniprocessor or multiprocessor systems</p>\n<p>The architecture describes a GIC designed for use with one or more processors that comply with the ARM A and R<br>architecture profiles.</p>\n<p>The GIC is a centralized resource for supporting and managing interrupts in a system that includes at least one<br>processor. It provides:<br>• registers for managing interrupt sources, interrupt behavior, and interrupt routing to one or more processors<br>• support for:<br>    — the ARM architecture Security Extensions<br>    — the ARM architecture Virtualization Extensions<br>    — enabling, disabling, and generating processor interrupts from hardware (peripheral) interrupt sources<br>    — Software-generated Interrupts (SGIs)<br>    — interrupt masking and prioritization<br>    — uniprocessor and multiprocessor environments<br>    — wakeup events in power-management environments.</p>\n<p>The GIC includes interrupt grouping functionality that supports:<br>• configuring each interrupt as either Group 0 or Group 1<br>• signaling Group 0 interrupts to the target processor using either the IRQ or the FIQ exception request<br>• signaling Group 1 interrupts to the target processor using the IRQ exception request only<br>• a unified scheme for handling the priority of Group 0 and Group 1 interrupts<br>• optional lockdown of the configuration of some Group 0 interrupts.</p>\n<p>fiq 优先级比 irq 高<br>fiq 模式下寄存器 比 irq 模式多（R8 ~ R12）<br><a href=\"http://blog.chinaunix.net/attachment/201302/21/28458801_1361445566H9Z3.png\" target=\"_blank\" rel=\"noopener\">http://blog.chinaunix.net/attachment/201302/21/28458801_1361445566H9Z3.png</a></p>\n<h3 id=\"1-2-Security-Extensions-support\"><a href=\"#1-2-Security-Extensions-support\" class=\"headerlink\" title=\"1.2. Security Extensions support\"></a>1.2. Security Extensions support</h3><p>The ARM processor Security Extensions are an optional extension to the ARMv7-A architecture profile.</p>\n<p>ARM Security Extensions facilitate the development of secure applications by:<br>• integrating hardware security features into the architecture<br>• providing Secure virtual memory space that is accessed by memory accesses in the Secure state<br>• providing Non-secure virtual memory space that is accessed by memory accesses in the Non-secure state.</p>\n<p>When a GIC that implements the GIC Security Extensions is connected to a processor that implements the ARM<br>Security Extensions:<br>• Group 0(IRQ/FIQ) interrupts are Secure interrupts, and Group 1(IRQ) interrupts are Non-secure interrupts.</p>\n<p>Processor security state and Secure and Non-secure GIC accesses：<br>• a processor in Non-secure state can make only Non-secure accesses to a GIC<br>• a processor in Secure state can make both Secure and Non-secure accesses to a GIC</p>\n<h3 id=\"1-3-Virtualization-support\"><a href=\"#1-3-Virtualization-support\" class=\"headerlink\" title=\"1.3. Virtualization support\"></a>1.3. Virtualization support</h3><p>The ARM processor Virtualization Extensions are optional extensions to the ARMv7-A architecture profile. The GIC Virtualization Extensions provide mechanisms to minimize the hypervisor overhead of routing interrupts to virtual machines.</p>\n<p>The processor Virtualization Extensions provide hardware support for virtualizing the Non-secure state of an<br>VMSAv7 implementation. The extensions support system use of a virtual machine monitor, known as the<br>hypervisor, to switch guest operating systems.</p>\n<p>Whether implemented in a uniprocessor or in a multiprocessor system, the processor Virtualization Extensions<br>support running multiple virtual machines on a single processor.</p>\n<p>The hypervisor can either handle a physical interrupt itself, or generate a corresponding virtual interrupt that is signaled to a virtual machine. It is also possible for the hypervisor to generate virtual interrupts that do not correspond to physical interrupts.</p>\n<p>1) physical interrupt =&gt; virtual machine =&gt; virtual interrupt （产生与硬件相应的虚拟中断）<br>2) virtual machine =&gt; virtual interrupt （也可以产生与硬件中断没有关的虚拟中断）</p>\n<h3 id=\"1-4-Terminology-（专用名词）\"><a href=\"#1-4-Terminology-（专用名词）\" class=\"headerlink\" title=\"1.4. Terminology （专用名词）\"></a>1.4. Terminology （专用名词）</h3><h4 id=\"1-4-1-Interrupt-states\"><a href=\"#1-4-1-Interrupt-states\" class=\"headerlink\" title=\"1.4.1. Interrupt states\"></a>1.4.1. Interrupt states</h4><p>Inactive            An interrupt that is not active or pending.</p>\n<p>Pending             An interrupt from a source to the GIC that is recognized as asserted in hardware, or<br>                    generated by software, and is waiting to be serviced by a target processor.</p>\n<p>Active                 An interrupt from a source to the GIC that has been acknowledged by a processor, and is<br>                    being serviced but has not completed.</p>\n<p>Active and pending     A processor is servicing the interrupt and the GIC has a pending interrupt from the same<br>source.</p>\n<h4 id=\"1-4-2-Interrupt-types\"><a href=\"#1-4-2-Interrupt-types\" class=\"headerlink\" title=\"1.4.2. Interrupt types\"></a>1.4.2. Interrupt types</h4><p>Peripheral interrupt</p>\n<pre><code>Private Peripheral Interrupt (PPI)\nThis is a peripheral interrupt that is specific to a single processor.\n\nShared Peripheral Interrupt (SPI)\nThis is a peripheral interrupt that the Distributor can route to any of a specified\ncombination of processors.\n\nEach peripheral interrupt is either:\nEdge-triggered\n    This is an interrupt that is asserted on detection of a rising edge of an interrupt\n    signal and then, regardless of the state of the signal, remains asserted until it is\n    cleared by the conditions defined by this specification.\n\nLevel-sensitive\n    This is an interrupt that is asserted whenever the interrupt signal level is active,\n    and deasserted whenever the level is not active.\n</code></pre><p>Software-generated interrupt (SGI)<br>        This is an interrupt generated by software writing to a GICD_SGIR register in the GIC.The<br>        system uses SGIs for interprocessor communication.</p>\n<pre><code>When an SGI occurs in a multiprocessor implementation, the CPUID field in the Interrupt\nAcknowledge Register, GICC_IAR, or the Aliased Interrupt Acknowledge Register,\nGICC_AIAR, identifies the processor that requested the interrupt.\n\n__An SGI has edge-triggered properties__. （边缘触发）\n\nIn an implementation that includes the GIC Virtualization Extensions:\n• when an SGI occurs, management registers in the GIC virtualization Extensions\nenable the requesting processor to be reported to the Guest OS, as required by the\nGIC specifications\n• by writing to the management registers in the GIC Virtualization Extensions, a\nhypervisor can generate a virtual interrupt that appears to a virtual machine as an SGI.\n</code></pre><p>Virtual interrupt<br>    In a GIC that implements the GIC Virtualization Extensions, an interrupt that targets a<br>    virtual machine running on a processor, and is typically signaled to the processor by the<br>    connected virtual CPU interface.        </p>\n<p>Maintenance interrupt<br>    In a GIC that implements the GIC Virtualization Extensions, a level-sensitive interrupt that<br>    is used to signal key events, such as a particular group of interrupts becoming enabled or<br>    disabled. See Maintenance interrupts on page 5-164 for more information.    </p>\n<h4 id=\"1-4-3-Models-for-handling-interrupts\"><a href=\"#1-4-3-Models-for-handling-interrupts\" class=\"headerlink\" title=\"1.4.3. Models for handling interrupts\"></a>1.4.3. Models for handling interrupts</h4><p>1-N model 常规硬件中断，单个的SPI， PPI<br>    Only one processor handles this interrupt. The system must implement a mechanism to determine<br>    which processor handles an interrupt that is programmed to target more than one processor.</p>\n<p>N-N model 主要SGI， SPI可能会出现<br>    All processors receive the interrupt independently. When a processor acknowledges the interrupt,<br>    the interrupt pending state is cleared only for that processor. The interrupt remains pending for the<br>    other processors.</p>\n<h4 id=\"1-4-4-Spurious-interrupts-（假的中断）\"><a href=\"#1-4-4-Spurious-interrupts-（假的中断）\" class=\"headerlink\" title=\"1.4.4. Spurious interrupts （假的中断）\"></a>1.4.4. Spurious interrupts （假的中断）</h4><p>It is possible that an interrupt that the GIC has signaled to a processor is no longer required.If this happens, when<br>the processor acknowledges the interrupt, the GIC returns a special Interrupt ID(1020 ~ 1023) that identifies the interrupt as a<br>spurious interrupt.</p>\n<p>Example reasons for spurious interrupts are:<br>• prior to the processor acknowledging an interrupt:<br>— software changes the priority of the interrupt<br>— software disables the interrupt<br>— software changes the processor that the interrupt targets<br>• for a 1-N interrupt, another target processor has previously acknowledged that interrupt.</p>\n<h2 id=\"2-GIC-Partitioning\"><a href=\"#2-GIC-Partitioning\" class=\"headerlink\" title=\"2. GIC Partitioning\"></a>2. GIC Partitioning</h2><h3 id=\"2-1-About-GIC-partitioning\"><a href=\"#2-1-About-GIC-partitioning\" class=\"headerlink\" title=\"2.1 About GIC partitioning\"></a>2.1 About GIC partitioning</h3><p>The GIC architecture splits logically into a Distributor block and one or more CPU interface blocks. The GIC<br>Virtualization Extensions add one or more virtual CPU interfaces to the GIC.</p>\n<p>GIC 架构有1个GIC Distributor, 一个或多个CPU Interface， 一个或多个virtual CPU interface（GIC Virtualization Extensions support）</p>\n<p>Distributor<br>    The Distributor block performs interrupt prioritization and distribution to the CPU interface<br>    blocks that connect to the processors in the system.<br>    The Distributor block registers are identified by the GICD_ prefix.</p>\n<p>CPU interfaces<br>    Each CPU interface block performs priority masking and preemption handling for a<br>    connected processor in the system.</p>\n<pre><code>When describing a GIC that includes the GIC Virtualization Extensions, a CPU interface is\nsometimes called a physical CPU interface, to avoid possible confusion with a virtual CPU\ninterface.\n\nCPU interface block registers are identified by the GICC_ prefix.\n</code></pre><p>Virtual CPU interfaces<br>    Each virtual CPU interface is partitioned into the following blocks:</p>\n<pre><code>Virtual interface control\n    The main component of the virtual interface control block is the GIC virtual\n    interface control registers, that include a list of active and pending virtual\n    interrupts for the current virtual machine on the connected processor. \n\n    Typically, these registers are managed by the hypervisor that is running on that processor.\n\n    Virtual interface control block registers are identified by the GICH_ prefix.\n\nVirtual CPU interface\n    Each virtual CPU interface block provides physical signaling of virtual\n    interrupts to the connected processor. The ARM processor Virtualization\n    Extensions signal these interrupts to the current virtual machine on that\n    processor. \n\n    The GIC virtual CPU interface registers, accessed by the virtual\n    machine, provide interrupt control and status information for the virtual\n    interrupts. The format of these registers is similar to the format of the physical\n    CPU interface registers.\n\n    Virtual CPU interface block registers are identified by the GICV_ prefix.\n</code></pre><p> Note: The virtual CPU interface does not support the power management functionality described</p>\n<p> A GIC can implement up to eight CPU interfaces, numbered from 0-7.<br> In a GIC that implements the GIC Virtualization Extensions, virtual CPU interface numbering corresponds to the CPU interface numbering, so that<br>CPU interface 0 and virtual CPU interface 0 connect to the same processor.</p>\n<p>一个GIC 最多支持8个CPU， 而 physical CPU interface 与virtual CPU interface 个数对应一样多。</p>\n<p>FixMe： 补上GIC logical partitioning</p>\n<h3 id=\"2-2-The-Distributor\"><a href=\"#2-2-The-Distributor\" class=\"headerlink\" title=\"2.2. The Distributor\"></a>2.2. The Distributor</h3><p>The Distributor provides a programming interface for:<br>    • Globally enabling the forwarding of interrupts to the CPU interfaces.<br>    • Enabling or disabling each interrupt.<br>    • Setting the priority level of each interrupt.<br>    • Setting the target processor list of each interrupt.<br>    • Setting each peripheral interrupt to be level-sensitive or edge-triggered.<br>    • Setting each interrupt as either Group 0 or Group 1.<br>    • Forwarding an SGI to one or more target processors.<br>In addition, the Distributor provides:<br>    • visibility of the state of each interrupt<br>    • a mechanism for software to set or clear the pending state of a peripheral interrupt.</p>\n<h4 id=\"2-2-1-Interrupt-IDs\"><a href=\"#2-2-1-Interrupt-IDs\" class=\"headerlink\" title=\"2.2.1 Interrupt IDs\"></a>2.2.1 Interrupt IDs</h4><p>GICv2 - The GIC assigns interrupt ID numbers ID0-ID1019 as follows:<br>    具有唯一标示<br>    SPI: 32 ~ 1019 </p>\n<pre><code>banked interrupt 可重入或重复的中断， 每个CPU 的中断号可相同\nPPI: 16 ~ 31\nSGI: 0 ~ 15\n</code></pre><p>In any system that implements the ARM Security Extensions, to support a consistent model for message passing<br>between processors, ARM strongly recommends that all processors reserve:<br>    • ID0-ID7 for Non-secure interrupts<br>    • ID8-ID15 for Secure interrupts.</p>\n<p>Interrupt numbers ID1020-ID1023    are reserved for special purposes,</p>\n<h3 id=\"2-3-CPU-interfaces\"><a href=\"#2-3-CPU-interfaces\" class=\"headerlink\" title=\"2.3. CPU interfaces\"></a>2.3. CPU interfaces</h3><p>Each CPU interface block provides the interface for a processor that is connected to the GIC.<br>    • enabling the signaling of interrupt requests to the processor<br>    • acknowledging an interrupt<br>    • indicating completion of the processing of an interrupt<br>    • setting an interrupt priority mask for the processor<br>    • defining the preemption policy for the processor<br>    • determining the highest priority pending interrupt for the processor.</p>\n<p>GCI CPU interfaces是否拉起中断信号给处理器流程<br>Signal interrupt request flow:<br>    take the highest priorty pending interrupt(read GICC_HPPIR) -&gt; check interrupt priority mask and the preemption settings -&gt;<br>    signal or ignore interrupt request</p>\n<p>CPU获取中断ID<br>The processor acknowledges the interrupt request by reading the CPU interface Interrupt Acknowledge Register.<br>This read returns one of:<br>    • The ID number of the highest priority pending interrupt, if that interrupt is of sufficient priority for it to be<br>    signaled to the processor. This is the normal response to an interrupt acknowledge.<br>    • Exceptionally, an ID number that indicates a spurious interrupt(1020 ~ 1023)</p>\n<p>中断处理完成后<br>There are two stages to interrupt completion:<br>    • priority drop, meaning the priority of the processed interrupt can no longer prevent the signaling of another<br>    interrupt to the processor<br>    • interrupt deactivation, meaning the Distributor removes the active state of the interrupt.</p>\n<p>In a GICv1 implementation, these two stages always happen together, when the processor writes to the CPU<br>interface End of Interrupt register.</p>\n<p>In a GICv2 implementation, the GICC_CTLR.EOImode bit determines whether:<br>    • the two stages happen together, when the processor writes to the CPU interface End of Interrupt register<br>    • the two stages are separated, so that:<br>        — priority drop happens when the processor writes to the CPU interface End of Interrupt register<br>        — interrupt deactivation happens later, when the processor writes to the CPU interface Deactivate<br>        Interrupt register.    </p>\n<h4 id=\"2-3-1-Interrupt-signal-bypass-and-GICv2-bypass-disable\"><a href=\"#2-3-1-Interrupt-signal-bypass-and-GICv2-bypass-disable\" class=\"headerlink\" title=\"2.3.1 Interrupt signal bypass, and GICv2 bypass disable\"></a>2.3.1 Interrupt signal bypass, and GICv2 bypass disable</h4><p>In all GIC implementations, a CPU interface optionally includes interrupt signal bypass, so that, when the signaling<br>of an interrupt by the interface is disabled, a system legacy interrupt signal is passed to the interrupt request input<br>on the processor, bypassing the GIC functionality.<br>中断信号旁路，主要支援legacy interrupt 不会受到CPU interface disable的影响，GICv2 must also provide disable bits for the interrupt<br>signal bypass operation.</p>\n<p>FixMe 增加Interrupt signal bypass, GICv1 without Security Extensions 图片</p>\n<h4 id=\"2-3-2-Power-management-GIC-v2\"><a href=\"#2-3-2-Power-management-GIC-v2\" class=\"headerlink\" title=\"2.3.2 Power management, GIC v2\"></a>2.3.2 Power management, GIC v2</h4><p>The GICv2 architecture supports wakeup events in implementations that require power management.<br>These signals are available even when both interrupt signaling by the GIC, and interrupt bypass, are disabled.</p>\n<p>为软件提供预留或回复状态寄存器<br>the GICC_APRn registers provide support for preserving and restoring state in power-management<br>applications<br>However, to ensure that Non-secure accesses do not interfere with Secure operation, Secure and<br>Non-secure copies of these registers are provided.</p>\n<h3 id=\"3-Interrupt-Handling-and-Prioritization\"><a href=\"#3-Interrupt-Handling-and-Prioritization\" class=\"headerlink\" title=\"3 Interrupt Handling and Prioritization\"></a>3 Interrupt Handling and Prioritization</h3><h4 id=\"3-1-About-interrupt-handling-and-prioritization\"><a href=\"#3-1-About-interrupt-handling-and-prioritization\" class=\"headerlink\" title=\"3.1 About interrupt handling and prioritization\"></a>3.1 About interrupt handling and prioritization</h4><p>Interrupt handling describes:<br>    • how the GIC recognizes interrupts<br>    • how software can program the GIC to configure and control interrupts<br>    • the state machine the GIC maintains for each interrupt on each CPU interface<br>    • how the exception model of a processor interacts with the GIC.</p>\n<p>Prioritization describes:<br>    • the configuration and control of interrupt priority<br>    • the order of execution of pending interrupts<br>    • the determination of when interrupts are visible to a target processor, including:<br>        — interrupt priority masking<br>        — priority grouping<br>        — preemption of an active interrupt.</p>\n<p>all implementations of the GIC architecture support interrupt grouping. With interrupt grouping:<br>    • by default, all interrupts are Group 0 interrupts, and are signaled to a connected processor using the IRQ<br>    interrupt request<br>    • each interrupt can be configured as Group 1 interrupt, or as a Group 0 interrupt<br>    • a CPU interface can be configured to signal Group 0 interrupts to a connected processor using the FIQ<br>    interrupt request.    </p>\n<h5 id=\"3-1-1-About-interrupt-handling-and-prioritization\"><a href=\"#3-1-1-About-interrupt-handling-and-prioritization\" class=\"headerlink\" title=\"3.1.1 About interrupt handling and prioritization\"></a>3.1.1 About interrupt handling and prioritization</h5><p>可以参看 1.4.2. Interrupt types节<br>中断类型主要有四种：<br>物理中断：SPI，PPI （可边缘，电平触发）<br>软中断：SGI<br>虚拟中断：virtual interrupt<br>维护中断：maintenance interrupt (电平触发)，用于发送key events(具备virtualization extensions GIC)</p>\n<p>参看 1.4.3. Models for handling interrupts 节<br>SGI 使用GIC N-N模型<br>物理中断 SPI，PPI 使用GIC 1-N 模型</p>\n<h5 id=\"3-1-2-Identifying-the-supported-interrupts\"><a href=\"#3-1-2-Identifying-the-supported-interrupts\" class=\"headerlink\" title=\"3.1.2 Identifying the supported interrupts\"></a>3.1.2 Identifying the supported interrupts</h5><p>中断号的分段参看2.2.1 Interrupt IDs节</p>\n<p>软件获知enable 中断<br>Software can use the GICD_ISENABLERns to discover what interrupt IDs are supported by the GIC。</p>\n<p>GICD_ISENABLER0 provides the Set-enable bits for both:<br>    • SGIs, using interrupt IDs 15-0, corresponding to register bits [15:0]<br>    • PPIs, using interrupt IDs 31-16, corresponding to register bits [31:16].</p>\n<p>The remaining GICD_ISENABLERns, from GICD_ISENABLER1, provide the Set-enable bits for the SPIs,<br>starting at interrupt ID 32.</p>\n<p>Software discovers the interrupts that are supported by:</p>\n<ol>\n<li>Reading the GICD_TYPER. The GICD_TYPER.ITLinesNumber field identifies the number of implemented<br>GICD_ISENABLERns, and therefore the maximum number of SPIs that might be supported. （获取supported interrupt 总数）</li>\n<li>Writing to the GICD_CTLR to disable forwarding of interrupts from the distributor to the CPU interfaces.<br>For more information, see Enabling and disabling the Distributor and CPU interfaces on page 4-77.</li>\n<li>For each implemented GICD_ISENABLERn, starting with GICD_ISENABLER0:<br> • Writing 0xFFFFFFFF to the GICD_ISENABLERn.<br> • Reading the value of the GICD_ISENABLERn. Bits that read as 1 correspond to supported interrupt IDs.    </li>\n</ol>\n<p>永久使能中断<br>Software uses the GICD_ICENABLERns to discover the interrupts that are permanently enabled. For each<br>implemented GICD_ICENABLERn, starting with GICD_ICENABLER0, software:</p>\n<ol>\n<li>Writes 0xFFFFFFFF to the GICD_ICENABLERn. This disables all interrupts that can be disabled.</li>\n<li>Reads the value of the GICD_ICENABLERn. Bits that read as 1 correspond to interrupts that are<br>permanently enabled.</li>\n<li>Writes 1 to any GICD_ISENABLERn bits corresponding to interrupts that must be re-enabled.    </li>\n</ol>\n<p>The GIC implements the same number of GICD_ISENABLERns and GICD_ICENABLERns.</p>\n<h4 id=\"3-2-General-handling-of-interrupts\"><a href=\"#3-2-General-handling-of-interrupts\" class=\"headerlink\" title=\"3.2 General handling of interrupts\"></a>3.2 General handling of interrupts</h4><p>中断状态分为：(detail see 3.2.4 Interrupt handling state machine)</p>\n<ul>\n<li>inactive</li>\n<li>pending</li>\n<li>active</li>\n<li>active and pending</li>\n</ul>\n<p>Group, security extension 中断参看 3.4 The effect of interrupt grouping on interrupt handling<br>virtualization extension 中断处理参看 5 GIC Support for Virtualization.</p>\n<p>通用中断处理流程：<br>When the GIC recognizes an interrupt request, it marks its state as pending. Regenerating a pending interrupt does<br>not affect the state of the interrupt.</p>\n<p>The GIC interrupt handling sequence is:</p>\n<ol>\n<li>The GIC determines the interrupts that are enabled.</li>\n<li>For each pending interrupt, the GIC determines the targeted processor or processors.</li>\n<li>For each CPU interface, the Distributor forwards the highest priority pending interrupt that targets that<br>interface.</li>\n<li>Each CPU interface determines whether to signal an interrupt request to its processor, and if required, does so.</li>\n<li>The processor acknowledges the interrupt, and the GIC returns the interrupt ID and updates the interrupt<br>state.</li>\n<li>After processing the interrupt, the processor signals End of Interrupt (EOI) to the GIC.</li>\n</ol>\n<p>In more detail, these steps are as follows:</p>\n<ol>\n<li><p>The GIC determines whether each interrupt is enabled. An interrupt that is not enabled has no effect on the GIC.</p>\n</li>\n<li><p>For each enabled interrupt that is pending, the Distributor determines the targeted processor or processors.</p>\n</li>\n<li><p>For each processor, the Distributor determines the highest priority pending interrupt, based on the priority information it holds for each interrupt, and forwards the interrupt to the targeted CPU interfaces.</p>\n</li>\n<li><p>If the distributor is forwarding an interrupt request to a CPU interface, the CPU interface determines whether the interrupt has Sufficient priority to be signaled to the processor. If the interrupt has sufficient priority, the GIC signals an interrupt request to the processor.</p>\n</li>\n<li><p>When a processor takes the interrupt exception, it reads the GICC_IAR of its CPU interface to acknowledge the interrupt. This read returns an Interrupt ID, and for an SGI, the source processor ID, that the processor uses to select the correct interrupt handler. When it recognizes this read, the GIC changes the state of the interrupt as follows:<br> • if the pending state of the interrupt persists when the interrupt becomes active, or if the interrupt is generated again, from pending to active and pending.<br> • otherwise, from pending to active</p>\n<pre><code>Note:\n• A level-sensitive peripheral interrupt persists when it is acknowledged by the processor, because the\ninterrupt signal to the GIC remains asserted until the Interrupt Service Routine (ISR) running on the\nprocessor accesses the peripheral asserting the signal.\n• In a multiprocessor implementation, the GIC handles:\n    — PPIs and SGIs using the GIC N-N model, where the acknowledgement of an interrupt by one\n    processor has no effect on the state of the interrupt on other CPU interfaces\n    — SPIs using the GIC 1-N model, where the acknowledgement of an interrupt by one processor\n    removes the pending status of the interrupt on any other targeted processors, see Implications\n    of the 1-N model on page 3-41.\n• In GICv2, when using a software model with the GICC_CTLR.AckCtl bit set to 0, separate registers\nare used to manage Group 0 and Group 1 interrupts, as follows:\n    — GICC_IAR, GICC_EOIR, and GICC_HPPIR for Group 0 interrupts\n    — GICC_AIAR, GICC_AEOIR, and GICC_AHPPIR for Group 1 interrupts.\nARM deprecates the use of GICC_CTLR.AckCtl, and strongly recommends using a software model\nwhere GICC_CTLR.AckCtl is set to 0, see [3.4.3 The effect of interrupt grouping on interrupt acknowledgement]\n</code></pre></li>\n<li><p>When the processor has completed handling the interrupt, it must signal this completion to the GIC. As<br>described in [3.2.1 Priority drop and interrupt deactivation], this: (通知GIC， EOI 并改写状态到inactive)<br> • always requires a valid write to an end of interrupt register (EOIR)<br> • might also require a subsequent write to the deactivate interrupt register, GICC_DIR.    </p>\n</li>\n</ol>\n<p>写向EOIR 的值是从GICC_IAR 或 GICC_AIAR得到的最近处理的中断号<br>For each CPU interface, the GIC architecture requires the order of the valid writes to an EOIR to be the<br>reverse of the order of the reads from the GICC_IAR or GICC_AIAR, so that each valid EOIR write refers<br>to the most recent interrupt acknowledge.</p>\n<p>A CPU interface never signals to the connected processor any interrupt that is active and pending. It only<br>signals interrupts that are pending and have sufficient priority:<br>    • For PPIs and SGIs, the active status of particular interrupt ID is banked between CPU interfaces. This<br>    means that if a particular interrupt ID is active or active and pending on a CPU interface, then no<br>    interrupt with that same ID is signaled on that CPU interface.<br>    • For SPIs, the active status of an interrupt is common to all CPU interfaces. This means that if an<br>    interrupt is active or active and pending on one CPU interface then it is not signaled on any CPU<br>    interface.</p>\n<h4 id=\"3-2-1-Priority-drop-and-interrupt-deactivation\"><a href=\"#3-2-1-Priority-drop-and-interrupt-deactivation\" class=\"headerlink\" title=\"3.2.1 Priority drop and interrupt deactivation\"></a>3.2.1 Priority drop and interrupt deactivation</h4><p>When a processor completes the processing of an interrupt, it must signal this completion to the GIC. Interrupt<br>completion requires the following changes to the GIC state:</p>\n<p>Priority drop<br>Priority drop is the drop in the Running priority that occurs on a valid write to an EOIR, either the<br>GICC_EOIR or the GICC_AEOIR.</p>\n<p>Interrupt deactivation<br>Interrupt deactivation is the change of the state of an interrupt, either:<br>    • from active and pending, to pending<br>    • from active, to idle</p>\n<p>在GICv1 中Priority drop  与    Interrupt deactivation 是同时的。在GICv2 中可以设定setting GICC_CTLR.EOImode to 1 separates the priority drop and interrupt deactivation operations， and interrupt handling software must:</p>\n<pre><code>1. Perform a valid EOIR write, to cause priority drop on the GIC CPU interface.\n2. Subsequently, write to the GICC_DIR, to deactivate the interrupt.\n</code></pre><p>The GIC architecture specification requires that valid EOIR writes are ordered, so that:<br>• a valid GICC_EOIR write corresponds to the most recently acknowledged interrupt<br>• a valid GICC_AEOIR write corresponds to the most recently acknowledged Group 1 interrupt.<br>• whether a GICC_EOIR write affects Group 0 or Group 1 interrupts depends on both:<br>    — the value of the GICC_CTLR. AckCtl bit<br>    — if the GIC implements the GIC Security Extensions, whether the write is Secure or Non-secure.</p>\n<p>Note：<br>In a GICv2 implementation that includes the Security Extensions:<br>• GICC_AEOIR is an alias of the Non-secure copy of GICC_EOIR<br>• GICC_AIAR is an alias of the Non-secure copy of GICC_IAR<br>• GICC_AIAR and GICC_AEOIR are Secure registers, meaning they are accessible only by Secure accesses.</p>\n<h4 id=\"3-2-2-Interrupt-controls-in-the-GIC\"><a href=\"#3-2-2-Interrupt-controls-in-the-GIC\" class=\"headerlink\" title=\"3.2.2 Interrupt controls in the GIC\"></a>3.2.2 Interrupt controls in the GIC</h4><p><strong>Interrupt enables</strong><br>For peripheral interrupts, a processor:<br>• enables an interrupt by writing to the appropriate GICD_ISENABLERn bit<br>• disables an interrupt by writing to the appropriate GICD_ICENABLERn bit.</p>\n<p><strong>Setting and clearing pending state of an interrupt</strong><br>For peripheral interrupts, a processor can:<br>• set the pending state by writing to the appropriate GICD_ISPENDRn bit<br>• clear the pending state by writing to the appropriate GICD_ICPENDRn bit.</p>\n<p>For a level-sensitive interrupt:<br>• If the hardware signal of an interrupt is asserted when a processor writes to the corresponding<br>GICD_ICPENDRn bit then the write to the register has no effect on the pending state of the interrupt.<br>• If a processor writes a 1 to an GICD_ISPENDRn bit then the corresponding interrupt becomes pending<br>regardless of the state of the hardware<br>more detail see [Control of the pending status of level-sensitive interrupts]</p>\n<p>For SGIs, the GIC ignores writes to the corresponding GICD_ISPENDRn and GICD_ICPENDRn bits. A processor<br>cannot change the state of a software-generated interrupt by writing to these registers.<br>Typically, an SGI is made pending by writing to the GICD_SGIR. In GICv2, the pending state of SGIs can also be modified directly using the<br>GICD_SPENDSGIRn and GICD_CPENDSGIRn bits.</p>\n<p><strong>Finding the active or pending state of an interrupt</strong><br>A processor can find:<br>• the pending state of an interrupt by reading the corresponding GICD_ISPENDRn or GICD_ICPENDRn bit<br>• the active state of an interrupt by reading the corresponding GICD_ISACTIVERn or GICD_ICACTIVERn<br>bit.</p>\n<p>In GICv2, the processor that issues the SGI can also be determined by reading the<br>corresponding GICD_SPENDSGIRn or GICD_CPENDSGIRn bits.</p>\n<p><strong>Generating an SGI</strong><br>A processor generates an SGI by writing to an GICD_SGIR.<br>The GICD_SGIR includes optimization for:<br>• interrupting only the processor that writes to the GICD_SGIR<br>• interrupting all processors other than the one that writes to the GICD_SGIR.</p>\n<p>GICD_SGIR 大致包含:<br>• interrupt ID<br>• source processor<br>• target processor.</p>\n<p>SGIs from different processors use the same interrupt IDs. Therefore, any target processor can receive SGIs with<br>the same interrupt ID from different processors.</p>\n<p>Only one interrupt with a specific interrupt ID can be active on a CPU interface at any time. This means that a CPU<br>interface cannot have two SGIs with the same interrupt ID active at the same time, even if different processors have<br>signaled SGIs with the same interrupt ID to that processor.</p>\n<p>On the CPU interface of the target processor, reading the GICC_IAR for an SGI returns both the interrupt ID and<br>the CPU ID of the processor that generated the interrupt, the source processor for the interrupt.The combination of<br>interrupt ID and source CPU ID uniquely identifies the interrupt to the target processor.</p>\n<p>In a multiprocessor implementation, the interrupt priority of each SGI interrupt ID is defined independently for each<br>target processor。<br><strong>For each CPU interface, all SGIs with a particular interrupt ID that are pending on that interface have the same priority and must be handled serially.</strong></p>\n<h5 id=\"3-2-3-Implications-of-the-1-N-model\"><a href=\"#3-2-3-Implications-of-the-1-N-model\" class=\"headerlink\" title=\"3.2.3 Implications of the 1-N model\"></a>3.2.3 Implications of the 1-N model</h5><p><strong>when the GIC recognizes an interrupt acknowledge from one of the target processors it clears the pending state of the interrupt on all the other targeted processors.</strong> A GIC implementation must ensure that any interrupt being handled using the 1-N model is only acknowledged by one CPU interface, and that all other interfaces return a spurious<br>interrupt ID.</p>\n<p>When multiple target processors attempt to acknowledge the interrupt, the following can occur:<br>• A processor reads the GICC_IAR and obtains the interrupt ID of the interrupt to be serviced.<br>    Note:  (在多核情况下，通过share memory, lock形式，确保只有一个core 处理中断)<br>    In GICv1, more than one target processor might have obtained this interrupt ID, if the processors read their<br>    GICC_IAR registers at very similar times. The system might require software on the target processors to<br>    ensure that only one processor runs its interrupt service routine. A typical mechanism to achieve this is<br>    implementing, in shared memory, a lock on the interrupt service routine (ISR).</p>\n<p>• <strong>A processor reads the GICC_IAR and obtains the interrupt ID 1023, indicating a spurious interrupt. The processor can return from its interrupt service routine without writing to its GICC_EOIR.</strong><br><strong>The spurious interrupt ID indicates that the original interrupt is no longer pending, typically because another target processor is handling it.</strong></p>\n<p>Note<br>    • A GICv1 implementation might ensure that only one processor can make a 1-N interrupt active, removing<br>    the requirement for a lock on the ISR. This is not required by the architecture, and generic GIC code must<br>    not rely on this behavior.（GICv1 不要求在ISR 中lock）<br>    • For any processor, if an interrupt is active and pending, the GIC does not signal an interrupt exception request<br>    for the interrupt to any processor until the active status is cleared. （如果中断是active且pending 状态，GIC 不会触发此中断给任何processor 直到active 状态清除）</p>\n<h5 id=\"3-2-3-Interrupt-handling-state-machine\"><a href=\"#3-2-3-Interrupt-handling-state-machine\" class=\"headerlink\" title=\"3.2.3 Interrupt handling state machine\"></a>3.2.3 Interrupt handling state machine</h5><p>Fixme 【中断状态机】</p>\n<p><strong>Transition A1 or A2, add pending state</strong><br>For an SGI, occurs if either:<br>• Software writes to a GICD_SGIR that specifies the processor as a target.<br>• Software on the target processor writes to the GICD_SPENDSGIRn bit that corresponds to<br>the required source processor and interrupt ID</p>\n<p>For an SPI or PPI, occurs if either:<br>• a peripheral asserts an interrupt request signal<br>• software writes to an GICD_ISPENDRn</p>\n<p><strong>Transition B1 or B2, remove pending state</strong><br>For an SGI, occurs if software on the target processor writes to the relevant bit of the<br>GICD_CPENDSGIRn.</p>\n<p>物理中断</p>\n<ul>\n<li>电平触发，pending 会一直拉高直到处理</li>\n<li>边缘触发，写GICD_ICPENDRn 寄存器清pending 状态</li>\n</ul>\n<p>For an SPI or PPI, occurs if either:<br>• the level-sensitive interrupt is pending only because of the assertion of an input signal, and<br>that signal is deasserted<br>• the interrupt is pending only because of the assertion of an edge-triggered interrupt signal, or<br>a write to an GICD_ISPENDRn, and software writes to the corresponding<br>GICD_ICPENDRn.</p>\n<p><strong>Transition C, pending to active</strong><br>If the interrupt is enabled and of Sufficient priority to be signaled to the processor, occurs when<br>software reads from the GICC_IAR.</p>\n<p><strong>Transition D, pending to active and pending</strong><br>For an SGI, this transition occurs in either of the following circumstances:<br>• If a write to set the SGI state to pending occurs at approximately the same time as a read of<br>GICC_IAR.<br>• When two or more pending SGIs with the same interrupt ID originate from the same source<br>processor and target the same processor. If one of the SGIs follows transition C, the other<br>SGIs follow transition D</p>\n<p>For an SPI or PPI this transition occurs if all the following apply:<br>• The interrupt is enabled.<br>• Software reads from the GICC_IAR. This read adds the active state to the interrupt.<br>• In addition, one of the following conditions applies:<br>    — For a level-sensitive interrupt, the interrupt signal remains asserted. This is usually the<br>    case, because the peripheral does not deassert the interrupt until the processor has<br>    serviced the interrupt.<br>    — For an edge-triggered interrupt, whether this transition occurs depends on the timing<br>    of the read of the GICC_IAR relative to the detection of the reassertion of the interrupt.<br>    Otherwise the read of the GICC_IAR causes transition C, possibly followed by<br>    transition A2.</p>\n<p><strong>Transition E1 or E2, remove active state</strong><br>Occurs when software deactivates an interrupt by writing to either GICC_EOIR or GICC_DIR.In a GIC<br>implementation the includes the Virtualization Extensions, also occurs if the virtual CPU interface<br>signals that the corresponding physical interrupt has been deactivated    </p>\n<h4 id=\"3-3-Interrupt-prioritization\"><a href=\"#3-3-Interrupt-prioritization\" class=\"headerlink\" title=\"3.3 Interrupt prioritization\"></a>3.3 Interrupt prioritization</h4><p>Software configures interrupt prioritization in the GIC by assigning a priority value to each interrupt source. Priority<br>values are 8-bit unsigned binary.A GIC supports a minimum of 16 and a maximum of 256 priority levels. If the<br>GIC implements fewer than 256 priority levels, low-order bits of the priority fields are RAZ/WI.<br>In the GIC prioritization scheme, lower numbers have higher priority,</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Implemented priority bits</th>\n<th style=\"text-align:center\">Possible priority field values</th>\n<th style=\"text-align:center\">Number of priority levels</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">[7:0]</td>\n<td style=\"text-align:center\">0x00-0xFF (0-255), all values</td>\n<td style=\"text-align:center\">256</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[7:1]</td>\n<td style=\"text-align:center\">0x00-0xFE, (0-254), even values only</td>\n<td style=\"text-align:center\">128</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[7:2]</td>\n<td style=\"text-align:center\">0x00-0xFC (0-252), in steps of 4</td>\n<td style=\"text-align:center\">64</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[7:3]</td>\n<td style=\"text-align:center\">0x00-0xF8 (0-248), in steps of 8</td>\n<td style=\"text-align:center\">32</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[7:4]</td>\n<td style=\"text-align:center\">0x00-0xF0 (0-240), in steps of 16</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n</tbody>\n</table>\n<p><strong>The GICD_IPRIORITYRn registers hold the priority value for each supported interrupt.</strong></p>\n<p>To determine the number of priority bits implemented, software can write 0xFF to a writable GICD_IPRIORITYRn<br>priority field, and read back the value stored.<br>Note:<br>ARM recommends that, before checking the priority range in this way:<br>• for a peripheral interrupt, software first disables the interrupt<br>• for an SGI, software first checks that the interrupt is inactive</p>\n<h5 id=\"3-3-1-Preemption\"><a href=\"#3-3-1-Preemption\" class=\"headerlink\" title=\"3.3.1 Preemption\"></a>3.3.1 Preemption</h5><p>A CPU interface supports signaling of higher priority pending interrupts to a target processor before an active<br>interrupt completes. A pending interrupt is only signaled if both:<br>• Its priority is higher than the priority mask for that CPU interface, see [Priority masking].<br>• Its group priority is higher than that of the Running priority on the CPU interface, see [Priority grouping] and[<br>Running Priority Register, GICC_RPR]</p>\n<p>For a processor that complies with the ARM architecture:<br>    — The value of the I or F bit in the CPSR determines whether the processor responds to the signaled<br>    interrupt by starting the interrupt acknowledge procedure.<br>    — When processing a preempting interrupt, the processor must save and later restore the context of the<br>    previously active ISR.</p>\n<h5 id=\"3-3-2-Priority-masking\"><a href=\"#3-3-2-Priority-masking\" class=\"headerlink\" title=\"3.3.2 Priority masking\"></a>3.3.2 Priority masking</h5><p>CPU Interface 选择高于中断阀门优先级的中断給处理器。<br>The GICC_PMR for a CPU interface defines a priority threshold.The GIC only signals<br>pending interrupts with a higher priority than this threshold value to the target processor. A value of zero, the register<br>reset value, masks all interrupts from being signaled to the associated processor. The GIC does not use priority<br>grouping when comparing the priority of a pending interrupt with the priority threshold.</p>\n<h5 id=\"3-3-3-Priority-grouping\"><a href=\"#3-3-3-Priority-grouping\" class=\"headerlink\" title=\"3.3.3 Priority grouping\"></a>3.3.3 Priority grouping</h5><p>一组相同优先级的中断。<br>Priority grouping uses the Binary Point Register, GICC_BPR, to split a priority value into two fields, the group<br>priority and the subpriority.When determining preemption, all interrupts with the same group priority are<br>considered to have equal priority, regardless of the subpriority. This means that there can only be one interrupt active<br>at each group priority. The active group priority is also known as the <strong>Preemption level.</strong></p>\n<p>主要是用过GICC_BPR 0~2 划分出 GICC_PMR 两个部分：Group priority field 和Subpriority field<br>FixME [Table 3-2 Priority grouping by binary point] 图片page 46</p>\n<h4 id=\"3-4-The-effect-of-interrupt-grouping-on-interrupt-handling\"><a href=\"#3-4-The-effect-of-interrupt-grouping-on-interrupt-handling\" class=\"headerlink\" title=\"3.4 The effect of interrupt grouping on interrupt handling\"></a>3.4 The effect of interrupt grouping on interrupt handling</h4><p>A GICv1 implementation that includes the GIC Security Extensions, or any GICv2 implementation, provides two<br>interrupt output signals for IRQ and FIQ exception requests:<br>• The CPU interface always uses the IRQ exception request for Group 1 interrupts<br>• Software can configure the CPU interface to use either IRQ or FIQ exception requests for Group 0 interrupts</p>\n<h5 id=\"3-4-1-GIC-interrupt-grouping-support\"><a href=\"#3-4-1-GIC-interrupt-grouping-support\" class=\"headerlink\" title=\"3.4.1 GIC interrupt grouping support\"></a>3.4.1 GIC interrupt grouping support</h5><p>The GICD_IGROUPRn registers configure each interrupt as Group 0 or Group 1.</p>\n<p>FixMe [CPU interface control of Group 0 and Group 1 interrupts, GICv2] 图片 Page48</p>\n<p>In an implementation that includes the GIC Security Extensions, the alias registers:<br>• typically <strong>represent aliases of the Non-secure copy of the Group 0 registers</strong>, for example GICC_ABPR is an<br>alias of the Non-Secure copy of GICC_BPR<br>• are <strong>accessible only by Secure accesses.</strong></p>\n<p>In an implementation that supports interrupt grouping, GICC_CTLR contains additional fields, including fields to<br>control the handling of the grouped interrupts:<br>• Separate enable bits to control the signaling of Group 0 and Group 1 interrupts to the connected processor: （是否支持组中断）<br>    — bit[0], the Enable bit in a GIC that does not support interrupt grouping, becomes the EnableGrp0 bit,<br>    and controls whether Group 0 interrupts are signaled to the processor<br>    — the EnableGrp1 bit is added, to control whether Group 1 interrupts are signaled to the processor.<br>• The FIQEn bit, that controls whether the interface signals Group 0 interrupts to the processor using the IRQ<br>or FIQ interrupt request. （Group0 是否支持FIQ）<br>• The CBPR bit, that controls whether GICC_BPR or GICC_ABPR is used when determining possible<br>interrupt preemption by Group 1 interrupts, see [Control of preemption by Group 1 interrupts] （是否支持抢占）<br>• The AckCtl bit, that controls whether a read of the GICC_IAR, or the Secure GICC_IAR if the GIC<br>implements the Security Extensions, can acknowledge a Group 1 interrupt.（是否支持Group1 能从GICC_IAR 读取中断ID，value 0 读到1022保留中断号，否则真实值）</p>\n<h5 id=\"3-4-2-Special-interrupt-numbers-when-a-GIC-supports-interrupt-grouping\"><a href=\"#3-4-2-Special-interrupt-numbers-when-a-GIC-supports-interrupt-grouping\" class=\"headerlink\" title=\"3.4.2 Special interrupt numbers when a GIC supports interrupt grouping\"></a>3.4.2 Special interrupt numbers when a GIC supports interrupt grouping</h5><p>1020-1021 Reserved.</p>\n<p>1022 Used only if the GIC supports interrupt grouping.<br>The GIC returns this value to a processor in response to an interrupt acknowledge only when all of<br>the following apply:<br>• the interrupt acknowledge is a read of GICC_IAR<br>• the highest priority pending interrupt is a Group 1 interrupt<br>• GICC_CTLR.AckCtl is set to 0<br>• the priority of the interrupt is sufficient for it to be signaled to the processor.<br>    Note:<br>    • Interrupt ID 1022 indicates that there is a Group 1 interrupt of sufficient priority to be<br>    signaled to the processor, that must be acknowledged by a read of the GICC_AIAR, or in an<br>    implementation that includes the GIC Security Extensions, by a read of the Non-secure<br>    GICC_IAR.</p>\n<p>1023 This value is returned to a processor, in response to an interrupt acknowledge, if there is no pending<br>interrupt with sufficient priority for it to be signaled to the processor.<br>On a processor that supports interrupt grouping, values of 1022 and 1023 are spurious interrupt IDs.</p>\n<h5 id=\"3-4-3-The-effect-of-interrupt-grouping-on-interrupt-acknowledgement\"><a href=\"#3-4-3-The-effect-of-interrupt-grouping-on-interrupt-acknowledgement\" class=\"headerlink\" title=\"3.4.3 The effect of interrupt grouping on interrupt acknowledgement\"></a>3.4.3 The effect of interrupt grouping on interrupt acknowledgement</h5><p><strong>When the GICC_CTLR.AckCtl bit is set to 0, to ensure system correctness, every Group 0 interrupt must have a higher priority than any Group 1 interrupt.</strong></p>\n<p>When the GICC_CTLR.AckCtl bit is set to 1, a read of GICC_IAR acknowledges the highest-priority pending<br>interrupt on the CPU interface, regardless of whether it is a Group 0 or a Group 1 interrupt. （ARM 极不推荐GICC_CTLR.AckCtl 设定为1）</p>\n<p>In a GIC implementation that supports interrupt grouping, ARM strongly recommends setting GICC_CTLR.AckCtl<br>to 0, meaning:<br>• for a GICv2 implementation:<br>    — a group 0 interrupt is acknowledged by a read of GICC_IAR, or a Secure read of GICC_IAR if the<br>    implementation includes the GIC Security Extensions<br>    — a group 1 interrupt is acknowledged by a read of GICC_AIAR, or a Non-secure read of GICC_IAR if<br>    the implementation includes the GIC Security Extensions<br>• for a GICv1 implementation:<br>    — a group 0 interrupt must be acknowledged by a read of the Secure GICC_IAR<br>    — a group 1 interrupt must be acknowledged by a read of Non-secure GICC_IAR.</p>\n<p>If the Interrupt Acknowledge register access does not correspond to the highest-priority pending interrupt on the CPU interface then:<br>• a read of GICC_IAR when the highest-priority pending interrupt is a Group 1 interrupt returns the spurious<br>interrupt value 1022<br>• a read of GICC_AIAR when the highest-priority pending interrupt is a Group 0 interrupt returns the spurious<br>interrupt value 1023.</p>\n<h5 id=\"3-4-4-GIC-power-on-or-reset-configuration\"><a href=\"#3-4-4-GIC-power-on-or-reset-configuration\" class=\"headerlink\" title=\"3.4.4 GIC power on or reset configuration\"></a>3.4.4 GIC power on or reset configuration</h5><p>On power-up, or after a reset, a GIC implementation that supports interrupt grouping is configured with:<br>• all interrupts assigned to Group 0<br>• the FIQ exception request disabled.</p>\n<p>FixMe [Reset configuration of a GIC that includes the FIQ exception request]  图片 page52</p>\n<h4 id=\"3-5-Interrupt-grouping-and-interrupt-prioritization\"><a href=\"#3-5-Interrupt-grouping-and-interrupt-prioritization\" class=\"headerlink\" title=\"3.5 Interrupt grouping and interrupt prioritization\"></a>3.5 Interrupt grouping and interrupt prioritization</h4><p>ARM strongly recommends that:<br>    • Group 0 interrupts are always assigned priority values in the lower half of the supported priority value range.<br>    These values correspond to the higher-priority interrupts<br>    • Group 1 interrupts are always assigned priority values in the upper half of the supported priority value range.<br>    These values correspond to the lower-priority interrupts.</p>\n<p>This ensures that every Group 1 interrupt is of lower priority than any Group 0 interrupt.</p>\n<h5 id=\"3-5-1-Software-views-of-interrupt-priority-in-a-GIC-that-includes-the-Security-Extensions\"><a href=\"#3-5-1-Software-views-of-interrupt-priority-in-a-GIC-that-includes-the-Security-Extensions\" class=\"headerlink\" title=\"3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions\"></a>3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions</h5><p>When a processor reads the priority value of a Group 1 interrupt, the GIC returns either the Secure or the Non-secure<br>view of that value, depending on whether the access is Secure or Non-secure.</p>\n<p>This is for a GIC that implements the maximum range of priority values.<br>FixMe [Figure 3-7 Software views of the priorities of Group 1 and Group 0 interrupts]图片 Page55</p>\n<p>FixMe [Table 3-6 Effect of not implementing some priority field bits, with GIC Security Extensions]图片 Page56</p>\n<p><strong>Recommendations for managing priority values</strong><br>ARM strongly recommends that:<br>• for a Group 0 interrupt, software sets bit [7] of the priority value field to 0<br>• if using a Secure write to set the priority of a Group 1 interrupt, software sets bit [7] of the priority value field<br>to 1.</p>\n<h5 id=\"3-5-2-Control-of-preemption-by-Group-1-interrupts\"><a href=\"#3-5-2-Control-of-preemption-by-Group-1-interrupts\" class=\"headerlink\" title=\"3.5.2 Control of preemption by Group 1 interrupts\"></a>3.5.2 Control of preemption by Group 1 interrupts</h5><p>When a GIC implementation supports interrupt grouping, the GICC_BPR is always used to determine whether a<br>Group 0 interrupt is signaled to the processor, for possible preemption.<br>By default, the GICC_ABPR is used to<br>determine whether a Group 1 interrupt is signaled for possible preemption.</p>\n<p>However, when GICC_CTLR.CBPR is set to 1, GICC_BPR is used for determining possible preemption, for both Group 0 and Group 1 interrupts.</p>\n<p>Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0 情况与 [Priority grouping] 类似</p>\n<h4 id=\"3-6-Additional-features-of-the-GIC-Security-Extensions\"><a href=\"#3-6-Additional-features-of-the-GIC-Security-Extensions\" class=\"headerlink\" title=\"3.6 Additional features of the GIC Security Extensions\"></a>3.6 Additional features of the GIC Security Extensions</h4><p>Software can detect support for the GIC Security Extensions by reading the GICD_TYPER.SecurityExtn bit, see<br>Interrupt Controller Type Register, GICD_TYPER on page 4-88.</p>\n<h5 id=\"3-6-1-Access-from-processors-not-implementing-the-ARM-Security-Extensions\"><a href=\"#3-6-1-Access-from-processors-not-implementing-the-ARM-Security-Extensions\" class=\"headerlink\" title=\"3.6.1 Access from processors not implementing the ARM Security Extensions\"></a>3.6.1 Access from processors not implementing the ARM Security Extensions</h5><p>When connecting a processor that does not support the ARM Security Extensions to a GIC that implements the GIC<br>Security Extensions, typically all processor accesses to the GIC are assigned as either Secure or Non-secure:<br>• For a processor making Secure accesses:<br>    — <strong>The processor can control all aspects of the GIC, and therefore can make configuration changes that might affect Secure software running on other processors.</strong><br>    — In a GICv2 implementation, the processor <strong>uses Secure accesses to aliased registers, such as the GICC_AIAR, to process Group 1 interrupts.</strong><br>    — Because GICv1 implementations do not include the aliased registers, if the implementation uses<br>    interrupt grouping the processor might have to use the deprecated GICC_CTLR.AckCtl bit to enable<br>    Group 1 interrupts to be processed using the standard CPU interface registers.</p>\n<p>• For a processor making Non-secure accesses:<br>    — The processor cannot control Group 0 interrupts. For the GIC to be programmed, <strong>the system implementation must include at least one processor that can make Secure accesses.</strong><br>    A system might use a Secure processor to perform Secure accesses on behalf of a Non-secure<br>    processor. This usage model is possible if the GIC or the system provides a method for the Secure<br>    processor to access processor-banked copies of registers that belong to the Non-secure processor.<br>    — To <strong>permit a Non-secure processor to control its own Group 0 interrupts, a GICv2 implementation can implement the GICD_NSACRn registers.</strong> An implementation of these registers might permit a Secure<br>    processor to permit the use of Non-secure accesses from a particular processor to control some aspects<br>    of the operation of some Group 0 SGIs and SPIs.<br>    — A GIC implementation can configure the GICD_IGROUPRn reset value so that interrupts are Group<br>    1 on reset. see GICD_IGROUPR0 reset value on page 4-92 for more information</p>\n<h4 id=\"3-7-Pseudocode-details-of-interrupt-handling-and-prioritization\"><a href=\"#3-7-Pseudocode-details-of-interrupt-handling-and-prioritization\" class=\"headerlink\" title=\"3.7 Pseudocode details of interrupt handling and prioritization\"></a>3.7 Pseudocode details of interrupt handling and prioritization</h4><p>skip, see spec</p>\n<h4 id=\"3-8-The-effect-of-the-Virtualization-Extensions-on-interrupt-handling\"><a href=\"#3-8-The-effect-of-the-Virtualization-Extensions-on-interrupt-handling\" class=\"headerlink\" title=\"3.8 The effect of the Virtualization Extensions on interrupt handling\"></a>3.8 The effect of the Virtualization Extensions on interrupt handling</h4><p>see Chapter 5 GIC Support for Virtualization</p>\n<h4 id=\"3-9-Example-GIC-usage-models\"><a href=\"#3-9-Example-GIC-usage-models\" class=\"headerlink\" title=\"3.9 Example GIC usage models\"></a>3.9 Example GIC usage models</h4><p>FixMe [Figure 3-8 Generic GIC usage model]图片page 68</p>\n<h5 id=\"3-9-1-Using-IRQs-and-FIQs-to-provide-Non-secure-and-Secure-interrupts\"><a href=\"#3-9-1-Using-IRQs-and-FIQs-to-provide-Non-secure-and-Secure-interrupts\" class=\"headerlink\" title=\"3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts\"></a>3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts</h5><p>FixMe [Figure 3-9 Using the GIC to route Secure and Non-secure interrupts]图片page 69</p>\n<p>shows a system that implements the GIC Security Extensions, connected to a processor that<br>implements the ARM processor Security Extensions. This implementation:<br>• uses Group 0 interrupts as Secure interrupts, signaled as FIQs<br>• uses Group 1 interrupts as Non-secure interrupts, signaled as IRQs.<br>This means that, on the processor, FIQ interrupts are never routed to Non-secure software, and IRQ interrupts are<br>never routed to Secure software.</p>\n<p>Note：<br>The use of Group 0 and Group 1 interrupts to signal Secure interrupts as FIQs, and Non-secure interrupts as IRQs,<br>requires the processor to:<br>• <strong>route FIQs to be taken in Secure Monitor mode</strong><br>• <strong>prevent Non-secure software from masking FIQs</strong><br>• <strong>ensure that IRQs are masked whenever it is operating in Secure state.</strong></p>\n<p>On a GIC reset, all interrupts are assigned to Group 0, making them Secure interrupts. Secure software on the<br>processor:<br>• programs the GICD_IGROUPRn registers to indicate which interrupts are Group 1, Non-secure<br>• sets the Secure GICC_CTLR.FIQEn bit to 1 to configure the CPU interface to use FIQ for Group 0 interrupts.<br>• must enable Group 0 interrupts and Group 1 interrupts, independently, in the Distributor: （配置GIC）<br>    — GICD_CTLR.EnableGrp0 enables Group 0 interrupts<br>    — GICD_CTLR.EnableGrp1 enables Group 1 interrupts.<br>• must enable Group 0 interrupts and Group 1 interrupts, independently, in the CPU interface: （配置CPU Interface）<br>    — GICC_CTLR.EnableGrp0 enables Group 0 interrupts<br>    — GICC_CTLR.EnableGrp1 enables Group 1 interrupts.</p>\n<h5 id=\"3-9-2-Supporting-IRQs-and-FIQs-when-not-using-the-processor-Security-Extensions\"><a href=\"#3-9-2-Supporting-IRQs-and-FIQs-when-not-using-the-processor-Security-Extensions\" class=\"headerlink\" title=\"3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions\"></a>3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions</h5><p>FixMe [Figure 3-10 Using interrupt grouping to route IRQs and FIQs] Page70</p>\n<p>On a GIC reset, for a GIC implementation that supports interrupt grouping, all interrupts are assigned to Group 0.<br>Therefore, to use this configuration, software executing on the processor must:<br>• Program the GICD_IGROUPRn registers to assign IRQ interrupts to Group 1.<br>• Set GICC_CTLR.FIQEn to 1, to assign Group 0 interrupts to FIQ.<br>• Set GICC_CTLR.AckCtl to 0, so that both FIQ and IRQ interrupts are acknowledged from the single address<br>space, using:<br>    — the GICC_IAR to acknowledge a Group 0 interrupt<br>    — the GICC_AIAR to acknowledge a Group 1 interrupt<br>    — the GICC_EOIR to indicate completion of a Group 0 interrupt<br>    — the GICC_AEOIR to indicate completion of a Group 1 interrupt.<br>However, GICC_AIAR and GICC_AEOIR are implemented only in a GICv2 implementation. A processor<br>operating with a GICv1 implementation might have to use the deprecated mode of operation with<br>GICC_CTLR.AckCtl set to 1(意味着GRP0 GRP1 都是用GICC_IAR, GICC_EOIR).<br>• Configure the required binary point support model, by either:<br>    — setting GICC_CTLR.CBPR to 0, so that Group 0 uses GICC_BPR, and Group 1 uses GICC_ABPR<br>    — setting GICC_CTLR.CBPR to 1, so that Group 0 and Group 1 use a common binary point register,<br>    GICC_BPR.</p>\n<p>由于没有security, 我们只是人为的将IRQ 分配到GRP1中，将FIQ 分配到GRP0中。因此，并不需要使能GICD_CTLR.EnableGrp0/1 GICC_CTLR.EnableGrp0/1 来让GIC与CPU 支持真正的Group 即security，我们只是使用不同的寄存器</p>\n<ul>\n<li>GICC_IAR &amp;&amp; GICC_AIAR获知ID</li>\n<li>GICC_EOIR &amp;&amp; GICC_AEOIR 结束中断</li>\n<li>GICC_CTLR.CBPR &amp;&amp; GICC_CTLR.ABPR </li>\n</ul>\n<h5 id=\"3-9-3-Supporting-IRQs-and-FIQs-in-a-virtualized-processor-environment\"><a href=\"#3-9-3-Supporting-IRQs-and-FIQs-in-a-virtualized-processor-environment\" class=\"headerlink\" title=\"3.9.3 Supporting IRQs and FIQs in a virtualized processor environment\"></a>3.9.3 Supporting IRQs and FIQs in a virtualized processor environment</h5><p>Fixme [Figure 3-11 Using the GIC in a virtualized system] page72</p>\n<p>• Secure software assigns:<br>    — Secure interrupts to Group 0, signaled to the processor as FIQs<br>    — Non-secure interrupts to Group 1, signaled to the processor as IRQs</p>\n<p>• A hypervisor:<br>    — Implements a virtual distributor, using features of the Virtualization Extension on the GIC. This<br>    virtual distributor can virtualize IRQ interrupts from the GIC as Virtual IRQ and Virtual FIQ<br>    interrupts, that it routes to an appropriate virtual machine.<br>    — Routes physical IRQs to Hyp mode, so they can be serviced by the virtual distributor</p>\n<p>• A Guest OS running on a virtual machine assigns interrupts to Group 0 or Group 1, to assign them as FIQs<br>or IRQs, using the model described in [Supporting IRQs and FIQs when not using the processor Security<br>Extensions]</p>\n<p>When the GIC signals an IRQ to the processor, the interrupt is routed to Hyp mode. The hypervisor determines<br>whether the interrupt is for itself, or for a Guest OS. If it is for a Guest OS it determines:<br>• which Guest OS must handle the interrupt<br>• whether that Guest OS has configured the interrupt as an FIQ or as an IRQ<br>• the interrupt priority, based on the priority configuration by the target Guest OS.</p>\n<p>Note:  (<strong>Guest OS 可能不止一个</strong>)<br>• On receiving an IRQ that cannot be handled by the current Guest OS, the hypervisor can either:<br>— transfer control to a Guest OS that can handle the interrupt<br>— mark the interrupt as pending, as part of the saved context of the appropriate Guest OS.<br>• A system can have some interrupts that can be handled by more that one Guest OS, and other interrupts that<br>must be routed to a specific Guest OS.</p>\n<p>A Guest OS handles a virtual interrupt exactly as it would handle the corresponding physical interrupt. <strong>The Guest OS cannot detect that it is handling a virtual interrupt rather than a physical interrupt.</strong></p>\n<p>Guest OS 并不知道处理的是虚拟中断。</p>\n<h3 id=\"4-Programmers’-Model\"><a href=\"#4-Programmers’-Model\" class=\"headerlink\" title=\"4. Programmers’ Model\"></a>4. Programmers’ Model</h3><h4 id=\"4-1-1-GIC-register-names\"><a href=\"#4-1-1-GIC-register-names\" class=\"headerlink\" title=\"4.1.1 GIC register names\"></a>4.1.1 GIC register names</h4><p>All of the GIC registers have names that provide a short mnemonic for the function of the register. In these names:<br>• the first three letters are GIC, indicating a GIC register<br>• the fourth letter is one of:<br>    — D, indicating a Distributor register<br>    — C, indicating a CPU interface register<br>    — H, indicating a virtual interface control register, typically accessed by a hypervisor<br>    — V, indicating a virtual CPU interface register.</p>\n<p>Note：<br>Chapter 5 GIC Support for Virtualization describes the GICH_<em> and GICV_</em> registers.</p>\n<h4 id=\"4-1-2-Distributor-register-map\"><a href=\"#4-1-2-Distributor-register-map\" class=\"headerlink\" title=\"4.1.2 Distributor register map\"></a>4.1.2 Distributor register map</h4><p>Fixme [Table 4-1 Distributor register map] page74</p>\n<h4 id=\"4-1-3-CPU-interface-register-map\"><a href=\"#4-1-3-CPU-interface-register-map\" class=\"headerlink\" title=\"4.1.3 CPU interface register map\"></a>4.1.3 CPU interface register map</h4><p>For a multiprocessor implementation, the GIC implements a set of CPU interface registers for each CPU interface.<br><strong>ARM strongly recommends that each processor has the same CPU interface base address for the CPU interface that connects it to the GIC. This is the private CPU interface base address for that processor.</strong></p>\n<p>Fixme [Table 4-2 CPU interface register map] page76</p>\n<h4 id=\"4-1-4-GIC-register-access\"><a href=\"#4-1-4-GIC-register-access\" class=\"headerlink\" title=\"4.1.4 GIC register access\"></a>4.1.4 GIC register access</h4><p>Note:<br>In the GIC architecture, all registers that are halfword-accessible or byte-accessible use a little endian memory order model.</p>\n<p>If the GIC implements the GIC Security Extensions these affect register accesses as follows:<br>• some registers are banked, see Register banking<br>• some registers are accessible only using Secure accesses<br>• optionally, the GIC supports lockdown of the values of some registers</p>\n<p><strong>Register banking</strong><br>Register banking refers to providing multiple copies of a register at the same address.</p>\n<p>The GIC banks registers in the following cases:<br>• If the GIC implements the Security Extensions, some registers are banked to provide separate Secure and<br>Non-secure copies of the registers. The Secure and Non-secure register bit assignments can differ. A Secure<br>access to the register address accesses the Secure copy of the register, and a Non-secure access accesses the<br>Non-secure copy. </p>\n<p>• If the GIC is implemented as part of a multiprocessor system:<br>    — Some registers are banked to provide a separate copy for each connected processor. These <strong>include the registers associated with PPIs and SGIs, and the GICD_NSACRn, when implemented.</strong><br>    — The GIC implements the CPU interface registers <strong>independently for each CPU interface</strong>, and each<br>    connected processor accesses these registers for the interface it connects to.</p>\n<h4 id=\"4-1-5-Enabling-and-disabling-the-Distributor-and-CPU-interfaces\"><a href=\"#4-1-5-Enabling-and-disabling-the-Distributor-and-CPU-interfaces\" class=\"headerlink\" title=\"4.1.5 Enabling and disabling the Distributor and CPU interfaces\"></a>4.1.5 Enabling and disabling the Distributor and CPU interfaces</h4><p><strong>Implementations that support interrupt grouping</strong><br>In a GIC that supports interrupt grouping:<br>• the GICD_CTLR.EnableGrp0 bit<br>• the GICD_CTLR.EnableGrp1 bit<br>• the GICC_CTLR.EnableGrp0 bit<br>• the GICC_CTLR.EnableGrp1 bit </p>\n<p>For the Distributor:<br>• If the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits are both 0:<br>    — <strong>the Distributor does not forward pending interrupts to the CPU interfaces</strong><br>    — it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the<br>    pending state.<br>    — <strong>reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID</strong><br>    — software can read or write the Distributor registers<br>    — it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR</p>\n<p>• If either, but not both, of the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits is set to<br>    — GICD_CTLR.EnableGrp0 set to 0 and GICD_CTLR.EnableGrp1 set to 1, and the highest priority<br>    pending interrupt is in group 0<br>    — GICD_CTLR.EnableGrp0 set to 1 and GICD_CTLR.EnableGrp1 set to 0, and the highest priority<br>    pending interrupt is in group 1. (ARM 强烈不推荐这样，这样GRP0 优先级是小于GRP1)</p>\n<p><strong>ARM strongly recommends that all Group 0 interrupts are assigned a higher priority than all Group 1 interrupts.</strong></p>\n<p>For a CPU interface, when GICC_CTLR.AckCtl == 0:<br>• When GICC_CTLR.EnableGrp0 == 0<br>    — Group 0 interrupts forwarded from the Distributor are not signaled to the processor<br>    — any read of GICC_IAR returns a spurious interrupt ID<br>• When GICC_CTLR.EnableGrp0 == 1, Group 0 interrupts forwarded from the Distributor are signaled to the<br>processor.<br>• When GICC_CTLR.EnableGrp1 == 0<br>    — Group 1 interrupts forwarded from the Distributor are not signaled to the processor<br>    — any read of GICC_AIAR returns a spurious interrupt ID<br>• When GICC_CTLR.EnableGrp1 == 1, Group 1 interrupts forwarded from the Distributor are signaled to the<br>processor<br>• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt<br>of sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR<br>returns the ID of that interrupt, or a spurious interrupt ID</p>\n<p>For a CPU interface, when GICC_CTLR.AckCtl == 1:<br>• When GICC_CTLR.EnableGrp1 == 0, any Non-secure read of GICC_IAR returns a spurious interrupt ID<br>• When GICC_CTLR.EnableGrp0 == 0:<br>— if GICC_CTLR.EnableGrp1 == 0, any Secure read of GICC_AIAR returns a spurious interrupt ID<br>— if GICC_CTLR.EnableGrp1 == 1, Group 0 interrupts are ignored and GICC_IAR behaves as<br>GICC_AIAR<br>• When GICC_CTLR.EnableGrp1 == 0, a Secure read of GICC_AIAR always returns a spurious interrupt ID<br>• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt<br>of sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR<br>returns the ID of that interrupt, or a spurious interrupt ID.</p>\n<p>Note:<br><strong>ARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl is set to 0.</strong></p>\n<hr>\n<p><strong>Implementations that do not support interrupt grouping</strong><br>In a GIC that does not support interrupt grouping:<br>• the GICD_CTLR.Enable bit controls the forwarding of interrupts from the Distributor to the CPU interfaces<br>• the GICC_CTLR.Enable bit controls the signaling of interrupts by the CPU interface to the connected processor.</p>\n<p>For the Distributor:<br>• When GICD_CTLR.Enable is set to 1, the Distributor forwards the highest priority pending interrupt for each<br>CPU interface, subject to the prioritization rules.<br>• When GICD_CTLR.Enable is set to 0:<br>    — the Distributor does not forward pending interrupts to the CPU interfaces<br>    — it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the<br>    pending state.<br>    — reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID<br>    — software can read or write the Distributor registers<br>    — it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR.</p>\n<p>For a CPU interface:<br>• When GICC_CTLR.Enable is set to 1, the highest priority pending interrupt forwarded from the Distributor<br>to the CPU interface is signaled to the connected processor<br>• When GICC_CTLR.Enable is set to 0:<br>    — any pending interrupts forwarded from the Distributor are not signaled to the processor<br>    — software can read or write the CPU interface registers<br>    — any read of the GICC_IAR returns a spurious interrupt ID<br>    — if the Distributor is forwarding an interrupt to the CPU interface, that the interface cannot signal<br>    because GICC_CTLR.Enable is set to 0, it is IMPLEMENTATION DEFINED whether a read of<br>    GICC_HPPIR returns the ID of that interrupt, or a spurious interrupt ID.</p>\n<h3 id=\"4-2-Effect-of-the-GIC-Security-Extensions-on-the-programmers’-model\"><a href=\"#4-2-Effect-of-the-GIC-Security-Extensions-on-the-programmers’-model\" class=\"headerlink\" title=\"4.2 Effect of the GIC Security Extensions on the programmers’ model\"></a>4.2 Effect of the GIC Security Extensions on the programmers’ model</h3><p>If the GIC implements the Security Extensions, <strong>the GICD_TYPER.SecurityExtn bit is RAO.</strong>.</p>\n<p>The GIC Security Extensions provide the following features:<br>• The GIC must support interrupt grouping.<br>• Register implementations that are consistent with those on a processor that implements the ARM Security<br>Extensions, with banked.</p>\n<p>The ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition defines the following ARM Security<br>Extensions register types:</p>\n<ul>\n<li><strong>Banked</strong><br>  The device implements Secure and Non-secure copies of the register. The register bit assignments<br>  can differ in the Secure and Non-secure copies of a register. A Secure access always accesses the<br>  Secure copy of the register, and a Non-secure access always accesses the Non-secure copy.<pre><code>Note\nThe GIC can also bank registers when implemented as part of a multiprocessor system, where\nregisters associated with PPIs or SGIs are banked to provide a separate copy for each connected\nprocessor.\n</code></pre></li>\n<li><strong>Secure</strong><br>  The register is accessible only from a Secure access. The address of a Secure register is RAZ/WI to<br>  any Non-secure access.</li>\n<li><strong>Common</strong><br>  The register is accessible from both Secure and Non-secure accesses. The access permissions of<br>  some or all fields in the register might depend on whether the access is Secure or Non-secure.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Register</th>\n<th style=\"text-align:center\">Type</th>\n<th style=\"text-align:center\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">GICD_CTLR</td>\n<td style=\"text-align:center\">Banked</td>\n<td style=\"text-align:center\">Distributor Control Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICD_TYPER</td>\n<td style=\"text-align:center\">Common</td>\n<td style=\"text-align:center\">Interrupt Controller Type Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICD_IGROUPRn</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Interrupt Group Registers</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICD_SGIR</td>\n<td style=\"text-align:center\">Common</td>\n<td style=\"text-align:center\">Software Generated Interrupt Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_CTLR</td>\n<td style=\"text-align:center\">Banked</td>\n<td style=\"text-align:center\">CPU Interface Control Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_BPR</td>\n<td style=\"text-align:center\">Banked</td>\n<td style=\"text-align:center\">Binary Point Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_ABPR</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Aliased Binary Point Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_AIAR</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Aliased Interrupt Acknowledge Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_AEOIR</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Aliased End of Interrupt Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_AHPPIR</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Aliased Highest Priority Pending Interrupt Register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GICC_NSAPRn</td>\n<td style=\"text-align:center\">Secure</td>\n<td style=\"text-align:center\">Non-secure Active Priorities Registers</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"4-2-1-Non-secure-access-to-register-fields-for-Group-0-interrupt-priorities\"><a href=\"#4-2-1-Non-secure-access-to-register-fields-for-Group-0-interrupt-priorities\" class=\"headerlink\" title=\"4.2.1 Non-secure access to register fields for Group 0 interrupt priorities\"></a>4.2.1 Non-secure access to register fields for Group 0 interrupt priorities</h4><p>Non-secure access to a priority field in the GICD_IPRIORITYRn<br>If the priority field corresponds to a Group 1 interrupt, the access operates as defined by the<br>Non-secure view of interrupt priority, see[Software views of interrupt priority in a GIC that includes<br>the Security Extensions]</p>\n<p>Non-secure access to the GICC_PMR and GICC_RPR<br>• If the current priority mask value is in the range 0x00-0x7F:<br>    — a read access returns the value 0x00<br>    — the GIC ignores a write access to the GICC_PMR.<br>• If the current priority mask value is in the range 0x80-0xFF:<br>    — A read access returns the Non-secure view of the current value.<br>    — A write access to the GICC_PMR succeeds, based on the Non-secure view of the<br>    priority mask value written to the register. This means a Non-secure write cannot set<br>    a priority mask value in the rage 0x00-0x7F.</p>\n<h4 id=\"4-2-2-Configuration-lockdown\"><a href=\"#4-2-2-Configuration-lockdown\" class=\"headerlink\" title=\"4.2.2 Configuration lockdown\"></a>4.2.2 Configuration lockdown</h4><p>This provides a control signal that the system can assert to prevent write access to:<br>• the register fields controlling a configured range of SPIs, when those SPIs are configured as Group 0<br>interrupts<br>• some configuration registers.</p>\n<p>When the control signal is asserted, the affected register fields and registers are described as being locked down.<br><strong>Lockdown is controlled by an active HIGH disable signal, CFGSDISABLE</strong>. That is, the system asserts<br>CFGSDISABLE HIGH to disable write access to the register fields and registers.</p>\n<p>The SPIs that can be locked down are called lockable SPIs (LSPIs).<br>• The GICD_TYPER.LSPI field defines the maximum number of LSPIs. If GICD_TYPER.LSPI is greater<br>than 0 then the possible LSPIs have interrupt IDs 32 to (31+(GICD_TYPER.LSPI)).<br>    Note:<br>    GICD_TYPER.LSPI only defines the range of possible LSPIs. The GIC might not support all the interrupts<br>    in this range.</p>\n<p>If GICD_TYPER.LSPI is 0 lockdown is not supported.</p>\n<p>When the SPI control fields and configuration registers are locked down, the GIC prevents write accesses to:<br>• The EnableGrp0 bit of the Secure copy of GICD_CTLR.<br>• The following bits in the Secure copy of GICC_CTLR:<br>    — EOImodeS<br>    — IRQBypDisGrp0<br>    — FIQBypDisGrp0<br>    — CBPR<br>    — FIQEn<br>    — AckCtl<br>    — EnableGrp0<br>• Fields in the GICD_ISENABLERn, GICD_ICENABLERn, GICD_ISPENDRn, GICD_ICPENDRn,<br>GICD_ISACTIVERn, GICD_ICACTIVERn, GICD_IPRIORITYRn, GICD_ITARGETSRn, and<br>GICD_ICFGRn registers that correspond to Lockable SPIs that are configured as Group 0:<br>• Fields in the GICD_IGROUPRn registers that correspond to lockable SPIs that are configured as Group 0. If<br>a lockable SPI is reconfigured from Group 1 to Group 0 while CFGSDISABLE remains HIGH, the GIC<br>prevents any more writes to GICD_IGROUPRn fields that correspond to that SPI, and the SPI becomes<br>locked.    </p>\n<h4 id=\"4-3-Distributor-register-descriptions\"><a href=\"#4-3-Distributor-register-descriptions\" class=\"headerlink\" title=\"4.3 Distributor register descriptions\"></a>4.3 Distributor register descriptions</h4><p>The following sections describe the Distributor registers:<br>• Distributor Control Register, GICD_CTLR on page 4-85<br>• Interrupt Controller Type Register, GICD_TYPER on page 4-88<br>• Distributor Implementer Identification Register, GICD_IIDR on page 4-90<br>• Interrupt Group Registers, GICD_IGROUPRn on page 4-91<br>• Interrupt Set-Enable Registers, GICD_ISENABLERn on page 4-93<br>• Interrupt Clear-Enable Registers, GICD_ICENABLERn on page 4-95<br>• Interrupt Set-Pending Registers, GICD_ISPENDRn on page 4-97<br>• Interrupt Clear-Pending Registers, GICD_ICPENDRn on page 4-99<br>• Interrupt Set-Active Registers, GICD_ISACTIVERn on page 4-102<br>• Interrupt Clear-Active Registers, GICD_ICACTIVERn on page 4-103<br>• Interrupt Priority Registers, GICD_IPRIORITYRn on page 4-104<br>• Interrupt Processor Targets Registers, GICD_ITARGETSRn on page 4-106<br>• Interrupt Configuration Registers, GICD_ICFGRn on page 4-109<br>• Non-secure Access Control Registers, GICD_NSACRn on page 4-111<br>• Software Generated Interrupt Register, GICD_SGIR on page 4-113<br>• SGI Clear-Pending Registers, GICD_CPENDSGIRn on page 4-115<br>• SGI Set-Pending Registers, GICD_SPENDSGIRn on page 4-117<br>• Identification registers on page 4-119.</p>\n<h5 id=\"4-3-1-Distributor-Control-Register-GICD-CTLR\"><a href=\"#4-3-1-Distributor-Control-Register-GICD-CTLR\" class=\"headerlink\" title=\"4.3.1 Distributor Control Register, GICD_CTLR\"></a>4.3.1 Distributor Control Register, GICD_CTLR</h5><p>Enables the forwarding of pending interrupts from the Distributor to the CPU interfaces.</p>\n<p>Fixme [Figure 4-1 GICD_CTLR bit assignments, GICv1 without Security Extensions or Non-secure]图片 Page85</p>\n<p>Fixme [Figure 4-2 GICD_CTLR bit assignments, GICv2, and GICv1 Secure copy]图片 Page85</p>\n<h5 id=\"4-3-2-Interrupt-Controller-Type-Register-GICD-TYPER\"><a href=\"#4-3-2-Interrupt-Controller-Type-Register-GICD-TYPER\" class=\"headerlink\" title=\"4.3.2 Interrupt Controller Type Register, GICD_TYPER\"></a>4.3.2 Interrupt Controller Type Register, GICD_TYPER</h5><p>Provides information about the configuration of the GIC. It indicates:<br>• whether the GIC implements the <strong>Security Extensions</strong><br>• the <strong>maximum number of interrupt IDs</strong> that the GIC supports<br>• the <strong>number of CPU interfaces</strong> implemented<br>• if the GIC implements the Security Extensions, the <strong>maximum number of implemented Lockable Shared Peripheral Interrupts (LSPIs)</strong>.</p>\n<p>Fixme [Figure 4-3 GICD_TYPER bit assignments] 图片Page88</p>\n<p>[15:11]  LSPI             If the GIC implements the Security Extensions, the value of this field is the maximum number of<br>                        implemented lockable SPIs, from 0 (0b00000) to 31 (0b11111). If this field is 0b00000 then the GIC does not implement configuration lockdown. If the GIC does not implement the Security Extensions, this field is reserved.</p>\n<p>[10]      SecurityExtn     Indicates whether the GIC implements the Security Extensions.<br>                            0  Security Extensions not implemented.<br>                            1  Security Extensions implemented.                    </p>\n<p>[7:5]   CPUNumber         Indicates the number of implemented CPU interfaces. The number of implemented CPU interfaces is<br>                        one more than the value of this field, for example if this field is 0b011, there are four CPU interfaces. If<br>                        the GIC implements the Virtualization Extensions, this is also the number of virtual CPU interfaces    </p>\n<p>[4:0]  ITLinesNumber     Indicates the maximum number of interrupts that the GIC supports.If ITLinesNumber=N, the<br>                        maximum number of interrupts is 32 * (N+1). interrupt IDs 1020-1023 are reserved for<br>                        special purposes</p>\n<p>The ITLinesNumber field only indicates the maximum number of SPIs that the GIC might support. This value<br>determines the number of implemented interrupt registers, that is, the number of instances of the following registers:<br>• GICD_IGROUPRn<br>• GICD_ISENABLERn<br>• GICD_ICENABLERn<br>• GICD_ISPENDRn<br>• GICD_ICPENDRn<br>• GICD_ISACTIVERn<br>• GICD_IPRIORITYRn<br>• GICD_ITARGETSRn<br>• GICD_ICFGRn.</p>\n<h5 id=\"4-3-3-Distributor-Implementer-Identification-Register-GICD-IIDR\"><a href=\"#4-3-3-Distributor-Implementer-Identification-Register-GICD-IIDR\" class=\"headerlink\" title=\"4.3.3 Distributor Implementer Identification Register, GICD_IIDR\"></a>4.3.3 Distributor Implementer Identification Register, GICD_IIDR</h5><p>Provides information about the implementer and revision of the Distributor.<br>主要用于记录GIC 的产品ID， 变体ID， 实现公司ID<br>Fixme [Figure 4-4 GICD_IIDR bit assignments] 图片Page90</p>\n<h5 id=\"4-3-4-Interrupt-Group-Registers-GICD-IGROUPRn\"><a href=\"#4-3-4-Interrupt-Group-Registers-GICD-IGROUPRn\" class=\"headerlink\" title=\"4.3.4 Interrupt Group Registers, GICD_IGROUPRn\"></a>4.3.4 Interrupt Group Registers, GICD_IGROUPRn</h5><p>The GICD_IGROUPR registers provide a status bit for each interrupt supported by the GIC.<br>Each bit controls whether the corresponding interrupt is in Group 0 or Group 1.<br>Fixme [Figure 4-5 GICD_IGROUPR bit assignments] 图片Page91</p>\n<p>[31:0] Group status bits， For each bit:<br>    0 The corresponding interrupt is Group 0.<br>    1 The corresponding interrupt is Group 1.</p>\n<p><strong>Reset Value</strong><br>On start-up or reset, each interrupt with ID32 or higher resets as Group 0 and therefore all SPIs are Group 0.</p>\n<h5 id=\"4-3-5-Interrupt-Set-Enable-Registers-GICD-ISENABLERn\"><a href=\"#4-3-5-Interrupt-Set-Enable-Registers-GICD-ISENABLERn\" class=\"headerlink\" title=\"4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn\"></a>4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn</h5><p>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.<br>Writing 1 to a Set-enable bit enables forwarding of the corresponding interrupt from the<br>Distributor to the CPU interfaces. Reading a bit identifies whether the interrupt is enabled.</p>\n<p>These registers are available in all configurations of the GIC. If the GIC implements the<br>Security Extensions these registers are Common</p>\n<p>In a multiprocessor implementation, GICD_ISENABLER0 is banked for each connected<br>processor. This register holds the Set-enable bits for interrupts 0-31.</p>\n<h5 id=\"4-3-6-Interrupt-Clear-Enable-Registers-GICD-ICENABLERn\"><a href=\"#4-3-6-Interrupt-Clear-Enable-Registers-GICD-ICENABLERn\" class=\"headerlink\" title=\"4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn\"></a>4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn</h5><p>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the<br>GIC. Writing 1 to a Clear-enable bit disables forwarding of the corresponding interrupt from<br>the Distributor to the CPU interfaces.</p>\n<p>In a multiprocessor implementation, GICD_ICENABLER0 is banked for each connected<br>processor. This register holds the Clear-enable bits for interrupts 0-31.</p>\n<h5 id=\"4-3-7-Interrupt-Set-Pending-Registers-GICD-ISPENDRn\"><a href=\"#4-3-7-Interrupt-Set-Pending-Registers-GICD-ISPENDRn\" class=\"headerlink\" title=\"4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn\"></a>4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn</h5><p>The GICD_ISPENDRs provide a Set-pending bit for each interrupt supported by the GIC.<br>Writing 1 to a Set-pending bit sets the status of the corresponding peripheral interrupt to<br>pending. Reading a bit identifies whether the interrupt is pending.</p>\n<p>In a multiprocessor implementation, GICD_ISPENDR0 is banked for each connected<br>processor. This register holds the Set-pending bits for interrupts 0-31.</p>\n<p>For SPIs and PPIs<br>Writes<br>0         Has no effect.<br>1         The effect depends on whether the interrupt is edge-triggered or<br>        level-sensitive.</p>\n<p><strong>Edge-triggered</strong><br>Changes the status of the corresponding interrupt to:<br>• pending if it was previously inactive<br>• active and pending if it was previously active.<br>Has no effect if the interrupt is already pendinga.</p>\n<p><strong>Level sensitive</strong><br>If the corresponding interrupt is not pendinga, changes the status<br>of the corresponding interrupt to:<br>• pending if it was previously inactive<br>• active and pending if it was previously active.</p>\n<p>If the interrupt is already pendinga:<br>• because of a write to the GICD_ISPENDR, the write has<br>no effect<br>• because the corresponding interrupt signal is asserted, the<br>write has no effect on the status of the interrupt, but the<br>interrupt remains pendinga if the interrupt signal is<br>deasserted.</p>\n<h5 id=\"4-3-8-Interrupt-Clear-Pending-Registers-GICD-ICPENDRn\"><a href=\"#4-3-8-Interrupt-Clear-Pending-Registers-GICD-ICPENDRn\" class=\"headerlink\" title=\"4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn\"></a>4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn</h5><p>The GICD_ICPENDRs provide a Clear-pending bit for each interrupt supported by the GIC.<br>Writing 1 to a Clear-pending bit clears the pending state of the corresponding peripheral<br>interrupt. Reading a bit identifies whether the interrupt is pending</p>\n<p>In a multiprocessor implementation, GICD_ICPENDR0 is banked for each connected<br>processor. This register holds the Clear-pending bits for interrupts 0-31.</p>\n<h5 id=\"4-3-9-Interrupt-Set-Active-Registers-GICD-ISACTIVERn\"><a href=\"#4-3-9-Interrupt-Set-Active-Registers-GICD-ISACTIVERn\" class=\"headerlink\" title=\"4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn\"></a>4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn</h5><p>The GICD_ISACTIVERs provide a Set-active bit for each interrupt that the GIC supports.<br>Writing to a Set-active bit Activates the corresponding interrupt. <strong>These registers are used when preserving and restoring GIC state</strong></p>\n<p>In a multiprocessor implementation, GICD_ISACTIVER0 is banked for each connected<br>processor. This register holds the Set-active bits for interrupts 0-31.</p>\n<h5 id=\"4-3-10-Interrupt-Clear-Active-Registers-GICD-ICACTIVERn\"><a href=\"#4-3-10-Interrupt-Clear-Active-Registers-GICD-ICACTIVERn\" class=\"headerlink\" title=\"4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn\"></a>4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn</h5><p>The GICD_ICACTIVERs provide a Clear-active bit for each interrupt that the GIC<br>supports. Writing to a Clear-active bit Deactivates the corresponding interrupt. These<br>registers are used when preserving and restoring GIC state.</p>\n<p>In a multiprocessor implementation, GICD_ICACTIVER0 is banked for each connected<br>processor. This register holds the Clear-active bits for interrupts 0-31.</p>\n<h5 id=\"4-3-11-Interrupt-Priority-Registers-GICD-IPRIORITYRn\"><a href=\"#4-3-11-Interrupt-Priority-Registers-GICD-IPRIORITYRn\" class=\"headerlink\" title=\"4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn\"></a>4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn</h5><p>The GICD_IPRIORITYRs <strong>provide an 8-bit priority field for each interrupt</strong> supported by the<br>GIC. This field stores the priority of the corresponding interrupt.</p>\n<p>A GIC might implement fewer than eight priority bits, but must implement at least bits [7:4]<br>of each field. In each field, unimplemented bits are RAZ/WI. see [3.3 Interrupt prioritization]<br>我们可以实现CPU Interface 的Group level.</p>\n<p>In a multiprocessor implementation, GICD_IPRIORITYR0 to GICD_IPRIORITYR7 are<br>banked for each connected processor. These registers hold the Priority fields for interrupts<br>0-31.</p>\n<p>Fixme [Figure 4-13 GICD_IPRIORITYR bit assignments] 图片Page104</p>\n<h5 id=\"4-3-12-Interrupt-Processor-Targets-Registers-GICD-ITARGETSRn\"><a href=\"#4-3-12-Interrupt-Processor-Targets-Registers-GICD-ITARGETSRn\" class=\"headerlink\" title=\"4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn\"></a>4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn</h5><p>The GICD_ITARGETSRs <strong>provide an 8-bit CPU targets field for each interrupt supported</strong><br>by the GIC. <strong>This field stores the list of target processors for the interrupt.</strong> That is, it holds<br>the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and<br>has sufficient priority.</p>\n<p>In a multiprocessor implementation, GICD_ITARGETSR0 to GICD_ITARGETSR7 are<br>banked for each connected processor. These registers hold the CPU targets fields for<br>interrupts 0-31.</p>\n<p>Fixme [Figure 4-14 GICD_ITARGETSR bit assignments] 图片Page106</p>\n<p>Table 4-17 shows how each bit of a CPU targets field targets the interrupt at one of the CPU interfaces.<br>Fixme [Table 4-17 Meaning of CPU targets field bit values] 图片Page107</p>\n<p>Software can write to an GICD_ITARGETSR at any time.  （对Active无效，对pending 的有效）<br>Any change to a CPU targets field value:<br>• Has no effect on any active interrupt. This means that removing a CPU interface from a targets list does not<br>cancel an active state for that interrupt on that CPU interface.<br>• Has an effect on any pending interrupts. This means:<br>    — adding a CPU interface to the target list of a pending interrupt makes that interrupt pending on that<br>    CPU interface<br>    — removing a CPU interface from the target list of a pending interrupt removes the pending state of that<br>    interrupt on that CPU interface<br>• If it applies to an interrupt that is active and pending, does not change the interrupt targets until the active<br>status is cleared.    </p>\n<h5 id=\"4-3-13-Interrupt-Configuration-Registers-GICD-ICFGRn\"><a href=\"#4-3-13-Interrupt-Configuration-Registers-GICD-ICFGRn\" class=\"headerlink\" title=\"4.3.13 Interrupt Configuration Registers, GICD_ICFGRn\"></a>4.3.13 Interrupt Configuration Registers, GICD_ICFGRn</h5><p><strong>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC</strong>.<br>This field identifies whether the corresponding interrupt is <strong>edge-triggered or level-sensitive.</strong></p>\n<p>Fixme [Figure 4-15 GICD_ICFGR bit assignments] 图片Page109</p>\n<p>For SGIs, Int_config fields are read-only, meaning that GICD_ICFGR0 is read-only.<br>Before changing the value of a programmable Int_config field, software must disable the<br>corresponding interrupt, otherwise GIC behavior is UNPREDICTABLE.</p>\n<p>These registers are available in all configurations of the GIC. If the GIC implements the<br>Security Extensions these registers are Common.<br>In a multiprocessor implementation, if bit[1] of the Int_config field for any PPI is<br>programmable then GICD_ICFGR1 is banked for each connected processor. This register<br>holds the Int_config fields for the PPIs, interrupts 16-31.</p>\n<p>BITS        Name                        Function<br>[2F+1:2F]     Int_config, field F         For Int_config[1], the most significant bit, bit [2F+1], the encoding is:<br>                                        0 Corresponding interrupt is level-sensitive.<br>                                        1 Corresponding interrupt is edge-triggered.<br>                                        Int_config[0], the least significant bit, bit [2F], is reserved, but see Table 4-19 for the encoding of<br>                                        this bit on some early implementations of this GIC architecture.</p>\n<pre><code>For SGIs:\nInt_config[1] Not programmable, RAO/WI.\n\nFor PPIs and SPIs:\nInt_config[1] For SPIs, this bit is programmable.a For PPIs it is IMPLEMENTATION DEFINED\nwhether this bit is programmable. A read of this bit always returns the correct value\nto indicate whether the corresponding interrupt is level-sensitive or edge-triggered.\n</code></pre><h5 id=\"4-3-14-Non-secure-Access-Control-Registers-GICD-NSACRn\"><a href=\"#4-3-14-Non-secure-Access-Control-Registers-GICD-NSACRn\" class=\"headerlink\" title=\"4.3.14 Non-secure Access Control Registers, GICD_NSACRn\"></a>4.3.14 Non-secure Access Control Registers, GICD_NSACRn</h5><p>The GICD_NSACRs enable Secure software to permit Non-secure software on a particular<br>processor to create and manage Group 0 interrupts. They provide an access control for each<br>implemented interrupt.</p>\n<p>The GICD_NSACRn registers do not support PPI accesses, meaning that GICD_NSACR0 bits [31:16] are<br>RAZ/WI.</p>\n<p>Fixme [Figure 4-16 GICD_NSACR bit assignments] 图片Page111</p>\n<p>BITS            Name                    Function<br>[2F+1:2F]         NS_access, Field F         If the corresponding interrupt does not support configurable Non-secure access, the field is<br>                                        RAZ/WI. Otherwise, the field is RW and configures the level of Non-secure access permitted<br>                                        when the interrupt is in Group 0. If the interrupt is in Group 1, this field is ignored. The possible<br>                                        values of the field are:</p>\n<pre><code>0b00 No Non-secure access is permitted to fields associated with the corresponding\ninterrupt.\n\n0b01 Non-secure write access is permitted to fields associated with the corresponding\ninterrupt in the GICD_ISPENDRn registers. A Non-secure write access to\nGICD_SGIR is permitted to generate a Group 0 SGI for the corresponding\ninterrupt.\n\n0b10 Adds Non-secure write access permission to fields associated with the\ncorresponding interrupt in the GICD_ICPENDRn registers. Also adds\nNon-secure read access permission to fields associated with the corresponding\ninterrupt in the GICD_ISACTIVERn and GICD_ICACTIVERn registers.\n\n0b11 Adds Non-secure read and write access permission to fields associated with the\ncorresponding interrupt in the GICD_ITARGETSRn registers\n</code></pre><h5 id=\"4-3-15-Software-Generated-Interrupt-Register-GICD-SGIR\"><a href=\"#4-3-15-Software-Generated-Interrupt-Register-GICD-SGIR\" class=\"headerlink\" title=\"4.3.15 Software Generated Interrupt Register, GICD_SGIR\"></a>4.3.15 Software Generated Interrupt Register, GICD_SGIR</h5><p>This register is available in all configurations of the GIC. If the GIC implements the<br>Security Extensions(read GICD_TYPER) this register is Common.<br>The NSATT field, bit [15], is implemented only if the GIC implements the Security<br>Extensions.</p>\n<p>Fixme [Figure 4-17 GICD_SGIR bit assignments] 图片Page113</p>\n<p>Bits         Name                 Function<br>[31:26]     -                     reserved.<br>[25:24]     TargetListFilter     Determines how the distributor must process the requested SGI:<br>                                0b00 Forward the interrupt to the CPU interfaces specified in the CPUTargetList fielda.<br>                                0b01 Forward the interrupt to all CPU interfaces except that of the processor that requested the<br>                                interrupt.<br>                                0b10 Forward the interrupt only to the CPU interface of the processor that requested the<br>                                interrupt.<br>                                0b11 Reserved.<br>[23:16]     CPUTargetList         When TargetList Filter = 0b00, defines the CPU interfaces to which the Distributor must forward the<br>                                interrupt.<br>                                Each bit of CPUTargetList[7:0] refers to the corresponding CPU interface, for example<br>                                CPUTargetList[0] corresponds to CPU interface 0. Setting a bit to 1 indicates that the interrupt must be<br>                                forwarded to the corresponding interface.<br>                                If this field is 0x00 when TargetListFilter is 0b00, the Distributor does not forward the interrupt to any<br>                                CPU interface.<br>[15]         NSATT                 Implemented only if the GIC includes the Security Extensions.<br>                                Specifies the required security value of the SGI:<br>                                0 Forward the SGI specified in the SGIINTID field to a specified CPU interface only if the<br>                                SGI is configured as Group 0 on that interface.<br>                                1 Forward the SGI specified in the SGIINTID field to a specified CPU interfaces only if<br>                                the SGI is configured as Group 1 on that interface.<br>                                This field is writable only by a Secure access. Any Non-secure write to the GICD_SGIR generates an<br>                                SGI only if the specified SGI is programmed as Group 1, regardless of the value of bit[15] of the write.<br>                                See SGI generation when the GIC implements the Security Extensions for more information.<br>                                Note<br>                                If GIC does not implement the Security Extensions, this field is reserved.<br>[3:0]         SGIINTID             The Interrupt ID of the SGI to forward to the specified CPU interfaces. The value of this field is the<br>                                Interrupt ID, in the range 0-15, for example a value of 0b0011 specifies Interrupt ID 3.                        </p>\n<p><strong>SGI generation when the GIC implements the Security Extensions</strong><br>If the GIC implements the Security Extensions, whether an SGI is forwarded to a processor specified in the write<br>to the GICD_SGIR depends on:<br>• whether the write to the GICD_SGIR is Group 0 (Secure) or Group 1 (Non-secure)<br>• for a Secure write to the GICD_SGIR, the value of the GICD_SGIR.NSATT bit<br>• whether the specified SGI is configured as Group 0 (Secure) or Group 1 (Non-secure) on the targeted<br>processor.</p>\n<p>Fixme [Table 4-22 Truth table for sending an SGI to a target processor] Page 114</p>\n<h5 id=\"4-3-16-SGI-Clear-Pending-Registers-GICD-CPENDSGIRn\"><a href=\"#4-3-16-SGI-Clear-Pending-Registers-GICD-CPENDSGIRn\" class=\"headerlink\" title=\"4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn\"></a>4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn</h5><p>The GICD_CPENDSGIRs provide a clear-pending bit for each supported SGI and source<br>processor combination. When a processor writes a 1 to a clear-pending bit, the pending state<br>of the corresponding SGI for the corresponding source processor is removed, and no longer<br>targets the processor performing the write.</p>\n<p>Note<br>• <strong>In a multiprocessor implementation, the processor accessing the register can change the SGI pending status only on the corresponding interface. Changing the pending status of an SGI for one target processor does not affect the status of that SGI on any other processor.</strong><br>• PPIs and SPIs both use the Interrupt Clear-Pending registers, GICD_ICPENDRn</p>\n<p>These registers are present only in GICv2. The register locations are reserved in GICv1.In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.</p>\n<p>Four SGI Clear-Pending registers are implemented.each register contains eight clear-pending bits for each of four SGIs.<br>In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.</p>\n<p>一共四个 GICD_CPENDSGIR寄存器，每个寄存器含有四个8 bits，分别代表了四个SGIs。</p>\n<p>Fixme [Figure 4-18 GICD_CPENDSGIR bit assignments] Page 115</p>\n<p>Bits                         Name                         Function<br>[8y+7:8y], for y=0 to 3     SGI x Clear-pending bits      For each bit:<br>                                                        Reads     0 SGI x from the corresponding processor is not pendinga.<br>                                                                1 SGI x from the corresponding processor is pendinga.<br>                                                        Writes     0 Has no effect.<br>                                                                1 Removes the pending state of SGI x for the corresponding processor<br>                                                        Note<br>                                                        All accesses relate only to SGIs that target the processor making the access.</p>\n<h5 id=\"4-3-17-SGI-Set-Pending-Registers-GICD-SPENDSGIRn\"><a href=\"#4-3-17-SGI-Set-Pending-Registers-GICD-SPENDSGIRn\" class=\"headerlink\" title=\"4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn\"></a>4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn</h5><p>The GICD_SPENDSGIRn registers provide a set-pending bit for each supported SGI and<br>source processor combination. When a processor writes a 1 to a set-pending bit, the pending<br>state is applied to the corresponding SGI for the corresponding source processor.</p>\n<p>Fixme [Figure 4-19 GICD_SPENDSGIR bit assignments] page 117</p>\n<p>Bits Name Function<br>[8y+7:8y], for y=0 to 3   SGI x Set-pending bits    For each bit:<br>                                                    Reads     0 SGI x for the corresponding processor is not pendinga.<br>                                                              1 SGI x for the corresponding processor is pendinga.<br>                                                    Writes     0 Has no effect.<br>                                                            1 Adds the pending state of SGI x for the corresponding processor,<br>                                                            if it is not already pending. If SGI x is already pending for the<br>                                                            corresponding processor then the write has no effect.</p>\n<pre><code>Note\nAll accesses relate only to SGIs that target the processor making the access.\n</code></pre><h5 id=\"4-3-18-Identification-registers\"><a href=\"#4-3-18-Identification-registers\" class=\"headerlink\" title=\"4.3.18 Identification registers\"></a>4.3.18 Identification registers</h5><p>This architecture specification defines offsets 0xFD0-0xFFC in the Distributor register map as a read-only<br>identification register space.</p>\n<p>Fixme [Table 4-25 The GIC identification register space] page119</p>\n<p><strong>Peripheral ID2 Register, ICPIDR2</strong><br>Fixme [Figure 4-20 ICPIDR2 bit assignments] page119</p>\n<p>Bits     Name         Function<br>[7:4]     ArchRev     Revision field for the GIC architecture. The value of this field depends on the GIC architecture version:<br>                    • 0x1 for GICv1<br>                    • 0x2 for GICv2.</p>\n<h4 id=\"4-4-CPU-interface-register-descriptions\"><a href=\"#4-4-CPU-interface-register-descriptions\" class=\"headerlink\" title=\"4.4 CPU interface register descriptions\"></a>4.4 CPU interface register descriptions</h4><h5 id=\"4-4-1-CPU-Interface-Control-Register-GICC-CTLR\"><a href=\"#4-4-1-CPU-Interface-Control-Register-GICC-CTLR\" class=\"headerlink\" title=\"4.4.1 CPU Interface Control Register, GICC_CTLR\"></a>4.4.1 CPU Interface Control Register, GICC_CTLR</h5><p>Enables the signaling of interrupts by the CPU interface to the connected processor, and<br>provides additional top-level control of the CPU interface. In a GICv2 implementation, this<br>includes control of the end of interrupt (EOI) behavior.</p>\n<p>有几种类型的结构：<br><strong>for a GICv1 implementation, for</strong><br>• an implementation that does not include the Security Extensions<br>• the Non-secure copy of the register, in an implementation that includes the Security Extensions.<br>Fixme [Figure 4-22 GICC_CTLR bit assignments, GICv1 without Security Extensions or Non-secure] page 126</p>\n<p><strong>a GIC v2 implementation that includes the Security Extensions, for the Non-secure copy of the register</strong><br>Fixme [Figure 4-23 GICC_CTLR bit assignments, GICv2 with Security Extensions, Non-secure copy] page 126</p>\n<p>Bits         Name             Function<br>[9]         EOImodeNS         Controls the behavior of Non-secure accesses to the GICC_EOIR and GICC_DIR registers:<br>                            0     GICC_EOIR has both priority drop and deactivate interrupt functionality.<br>                                Accesses to the GICC_DIR are UNPREDICTABLE.<br>                            1     GICC_EOIR has priority drop functionality only. The GICC_DIR register has<br>                                deactivate interrupt functionality.</p>\n<p>[6]         IRQBypDisGrp1     When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the<br>                            bypass IRQ signal is signaled to the processor:<br>                            0     Bypass IRQ signal is signaled to the processor<br>                            1     Bypass IRQ signal is not signaled to the processor.</p>\n<p>[5]         FIQBypDisGrp1     When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the<br>                            bypass FIQ signal is signaled to the processor:<br>                            0     Bypass FIQ signal is signaled to the processor<br>                            1     Bypass FIQ signal is not signaled to the processor.</p>\n<p>[0]         EnableGrp1         Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor.<br>                            0 Disable signaling of interrupts<br>                            1 Enable signaling of interrupts.<br>                            Note<br>                            When this bit is set to 0, the CPU interface ignores any pending Group 1 interrupt forwarded to<br>                            it. When this bit is set to 1, the CPU interface starts to process pending Group 1 interrupts that are<br>                            forwarded to it. There is a small but finite time required for a change to take effect.</p>\n<p><strong>Security Extensions, for the Secure copy of the register</strong><br>• a GICv2 implementation, for:<br>— an implementation that does not include the Security Extensions<br>— the Secure copy of the register, in an implementation that includes the Security Extensions<br>• a GICv1 implementation that includes the Security Extensions, for the Secure copy of the register</p>\n<p>Fixme [Figure 4-24 GICC_CTLR bit assignments, GICv2 without Security Extensions or Secure] page 128</p>\n<p>Bits         Name             Function<br>[10]         EOImodeNS         Alias of EOImodeNS from the Non-secure copy of this register, see Table 4-30 on page 4-126.<br>                            In a GICv2 implementation that does not include the Security Extensions, and in a GICv1<br>                            implementation, this bit is reserved.</p>\n<p>[9]         EOImodeS         Controls the behavior of accesses to GICC_EOIR and GICC_DIR registers. In a GIC implementation<br>                            that includes the Security Extensions, this control applies only to Secure accesses, and the EOImodeNS<br>                            bit controls the behavior of Non-secure accesses to these registers:<br>                            0         GICC_EOIR has both priority drop and deactivate interrupt functionality. Accesses to<br>                                    the GICC_DIR are UNPREDICTABLE.<br>                            1         GICC_EOIR has priority drop functionality only. GICC_DIR has deactivate interrupt<br>                                    functionality.<br>                            Note<br>                            This bit is called EOImode in a GIC implementation that does not include the Security Extensions.<br>                            In a GICv1 implementation, this bit is reserved.</p>\n<p>[8]         IRQBypDisGrp1     Alias of IRQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.<br>                            In a GICv1 implementation, this bit is reserved</p>\n<p>[7]         FIQBypDisGrp1    Alias of FIQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.<br>                            In a GICv1 implementation, this bit is reserved.                            </p>\n<p>[6]         IRQBypDisGrp0     When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the bypass<br>                            IRQ signal is signaled to the processor:<br>                            0         Bypass IRQ signal is signaled to the processor<br>                            1         Bypass IRQ signal is not signaled to the processor.<br>                            In a GICv1 implementation, this bit is reserved.</p>\n<p>[5]         FIQBypDisGrp0    When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the bypass<br>                            FIQ signal is signaled to the processor:<br>                            0         Bypass FIQ signal is signaled to the processor<br>                            1         Bypass FIQ signal is not signaled to the processor.<br>                            In a GICv1 implementation, this bit is reserved.</p>\n<p>[4]         CBPR             Controls whether the GICC_BPR provides common control to Group 0 and Group 1 interrupts.<br>                            0         To determine any preemption, use:<br>                                    • the GICC_BPR for Group 0 interrupts<br>                                    • the GICC_ABPR for Group 1 interrupts.<br>                            1         To determine any preemption use the GICC_BPR for both Group 0 and Group 1<br>                                    interrupts.</p>\n<p>[3]         FIQEn             Controls whether the CPU interface signals Group 0 interrupts to a target processor using the FIQ or<br>                            the IRQ signal.<br>                            0         Signal Group 0 interrupts using the IRQ signal.<br>                            1         Signal Group 0 interrupts using the FIQ signal.<br>                            The GIC always signals Group 1 interrupts using the IRQ signal.</p>\n<p>[2]         AckCtl             When the highest priority pending interrupt is a Group 1 interrupt, determines both:<br>                            • whether a read of GICC_IAR acknowledges the interrupt, or returns a spurious interrupt ID<br>                            • whether a read of GICC_HPPIR returns the ID of the highest priority pending interrupt, or<br>                                returns a spurious interrupt ID.</p>\n<pre><code>0         If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR\n        or the GICC_HPPIR returns an Interrupt ID of 1022. A read of the GICC_IAR does\n        not acknowledge the interrupt, and has no effect on the pending status of the interrupt.\n1         If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR\n        or the GICC_HPPIR returns the Interrupt ID of the Group 1 interrupt. A read of\n        GICC_IAR acknowledges and Activates the interrupt.\nIn a GIC implementation that includes the Security Extensions, this control affects only the behavior\nof Secure register accesses.\nFor more information, see:\n• The effect of interrupt grouping on interrupt acknowledgement on page 3-50\n• Interrupt grouping and interrupt prioritization on page 3-53\n• Behavior of writes to GICC_EOIR, GICv1 with Security Extensions on page 4-139\n• Effect of interrupt grouping and the Security Extensions on reads of the GICC_HPPIR on\npage 4-143.\nNote\nARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where\nGICC_CTLR.AckCtl is set to 0. See Enabling and disabling the Distributor and CPU interfaces on\npage 4-77 for more information about the effects of setting this bit.\n</code></pre><p>[1]         EnableGrp1         Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor:<br>                            0         Disable signaling of Group 1 interrupts.<br>                            1         Enable signaling of Group 1 interrupts.</p>\n<p>[0]         EnableGrp0         Enable for the signaling of Group 0 interrupts by the CPU interface to the connected processor:<br>                            0         Disable signaling of Group 0 interrupts.<br>                            1         Enable signaling of Group 0 interrupts.</p>\n<h5 id=\"4-4-2-Interrupt-Priority-Mask-Register-GICC-PMR\"><a href=\"#4-4-2-Interrupt-Priority-Mask-Register-GICC-PMR\" class=\"headerlink\" title=\"4.4.2 Interrupt Priority Mask Register, GICC_PMR\"></a>4.4.2 Interrupt Priority Mask Register, GICC_PMR</h5><p><strong>Provides an interrupt priority filter. Only interrupts with higher priority than the value in this register are signaled to the processor</strong></p>\n<p>Fixme [Figure 4-25 GICC_PMR bit assignments] page131</p>\n<h5 id=\"4-4-3-Binary-Point-Register-GICC-BPR\"><a href=\"#4-4-3-Binary-Point-Register-GICC-BPR\" class=\"headerlink\" title=\"4.4.3 Binary Point Register, GICC_BPR\"></a>4.4.3 Binary Point Register, GICC_BPR</h5><p>The register defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field is used to determine <strong>interrupt preemption.</strong></p>\n<p>Fixme [Figure 4-26 GICC_BPR bit assignments] page133</p>\n<p>see:<br>Table 3-2 Priority grouping by binary point<br>Table 3-7 Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0</p>\n<h5 id=\"4-4-4-Interrupt-Acknowledge-Register-GICC-IAR\"><a href=\"#4-4-4-Interrupt-Acknowledge-Register-GICC-IAR\" class=\"headerlink\" title=\"4.4.4 Interrupt Acknowledge Register, GICC_IAR\"></a>4.4.4 Interrupt Acknowledge Register, GICC_IAR</h5><p>The processor reads this register to obtain the interrupt ID of the signaled interrupt. This<br>read acts as an acknowledge for the interrupt.</p>\n<p>When GICC_CTLR.AckCtl is set to 0 in a GICv2 implementation that does not include the<br>Security Extensions, if the highest priority pending interrupt is in Group 1, the interrupt ID<br>1022 is returned.</p>\n<p>Fixme [Figure 4-27 GICC_IAR bit assignments] page135.</p>\n<p>Bit         Name             Function<br>[31:13]     -                 Reserved.<br>[12:10]     CPUID             <strong>For SGIs in a multiprocessor implementation</strong>, this field identifies the processor that<br>                            requested the interrupt. It returns the number of the CPU interface that made the<br>                            request, for example a value of 3 means the request was generated by a write to the<br>                            GICD_SGIR on CPU interface 3.<br>                            For all other interrupts this field is RAZ.<br>[9:0]         Interrupt ID     The interrupt ID.</p>\n<p>The read returns a spurious interrupt ID of 1023 if any of the following apply:<br>• forwarding of interrupts by the Distributor to the CPU interface is disabled<br>• signaling of interrupts by the CPU interface to the connected processor is disabled<br>• no pending interrupt on the CPU interface has sufficient priority for the interface to signal it to the processor</p>\n<p>A non-spurious interrupt ID returned by a read of the GICC_IAR is called a valid interrupt ID.<br><strong>When the GIC returns a valid interrupt ID to a read of the GICC_IAR it treats the read as an acknowledge of that interrupt and, as a side-effect of the read, changes the interrupt status from pending to active, or to active and pending if the pending state of the interrupt persists.</strong></p>\n<p>Note<br>• For compatibility with possible extensions to the GIC architecture specification, ARM recommends that<br>software preserves the entire register value read from the GICC_IAR, and writes that value back to the<br>GICC_EOIR when it has completed its processing of the interrupt.<br>• Although multiple target processors might attempt to read the GICC_IAR at any time, in GICv2 only one<br>processor can obtain a valid interrupt ID, see Implications of the 1-N model on page 3-41 for more<br>information.</p>\n<p>Fixme [Table 4-35 Effect of interrupt grouping and the Security Extensions on reads of GICC_IAR]Page136</p>\n<h5 id=\"4-4-5-End-of-Interrupt-Register-GICC-EOIR\"><a href=\"#4-4-5-End-of-Interrupt-Register-GICC-EOIR\" class=\"headerlink\" title=\"4.4.5 End of Interrupt Register, GICC_EOIR\"></a>4.4.5 End of Interrupt Register, GICC_EOIR</h5><p>A processor writes to this register to inform the CPU interface either:<br>• that it has completed the processing of the specified interrupt<br>• in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set<br>to 1, to indicate that the interface should perform priority drop for the specified<br>interrupt. See Priority drop and interrupt deactivation on page 3-38 for more information.</p>\n<p>Fixme [Figure 4-28 GICC_EOIR bit assignments]Page138</p>\n<p>Fixme [Table 4-36 GICC_EOIR bit assignments]Page138</p>\n<p>For every read of a valid Interrupt ID from the GICC_IAR, the connected processor must perform a matching write<br>to the GICC_EOIR. The value written to the GICC_EOIR must be the interrupt ID read from the GICC_IAR.<br>If a read of the GICC_IAR returns the ID of a spurious interrupt, software does not have to make a corresponding<br>write to the GICC_EOIR. If software writes the ID of a spurious interrupt to the GICC_EOIR, the GIC ignores that<br>write.</p>\n<p><strong>Behavior of writes to GICC_EOIR, GICv2</strong><br>In a GICv2 implementation, when GICC_CTLR.AckCtl is set to 0:<br>• GICC_EOIR is used for processing Group 0 interrupts<br>• GICC_AEOIR is used for processing Group 1 interrupts.</p>\n<p>In a GICv2 implementation that includes the GIC Security Extensions:<br>• GICC_CTLR.EOImodeS controls the behavior of Secure accesses to GICC_EOIR and GICC_AEOIR<br>• GICC_CTLR.EOImodeNS controls the behavior of Non-secure accesses to GICC_EOIR<br>• when GICC_CTLR.AckCtl is set to 0:<br>    — a Non-secure write to GICC_EOIR must correspond to the most recent Non-secure read of GICC_IAR<br>    — a Secure write to the GICC_AEOIR must correspond to the most recent Secure read of the<br>    GICC_AIAR.</p>\n<h5 id=\"4-4-6-Running-Priority-Register-GICC-RPR\"><a href=\"#4-4-6-Running-Priority-Register-GICC-RPR\" class=\"headerlink\" title=\"4.4.6 Running Priority Register, GICC_RPR\"></a>4.4.6 Running Priority Register, GICC_RPR</h5><p>Indicates the Running priority of the CPU interface</p>\n<p>Fixme [Figure 4-29 GICC_RPR bit assignments] page142</p>\n<h5 id=\"4-4-7-Highest-Priority-Pending-Interrupt-Register-GICC-HPPIR\"><a href=\"#4-4-7-Highest-Priority-Pending-Interrupt-Register-GICC-HPPIR\" class=\"headerlink\" title=\"4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR\"></a>4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR</h5><p>Indicates the Interrupt ID, and processor ID if appropriate, of the <strong>highest priority pending</strong><br>interrupt on the CPU interface.</p>\n<p>Fixme [Figure 4-30 GICC_HPPIR bit assignments] Page143</p>\n<p>Bit            Name         Description<br>[31:13]     -             Reserved.<br>[12:10]     CPUID         On a multiprocessor implementation, if the PENDINTID field returns the ID of an<br>                        SGI, this field contains the CPUID value for that interrupt. This identifies the<br>                        processor that generated the interrupt.<br>[9:0]         PENDINTID     The interrupt ID of the highest priority pending interrupt. See Table 4-42 on<br>                        page 4-144 for more information about the result of Non-secure reads of the<br>                        GICC_HPPIR when the GIC implements the Security Extensions.</p>\n<h5 id=\"4-4-8-Aliased-Binary-Point-Register-GICC-ABPR\"><a href=\"#4-4-8-Aliased-Binary-Point-Register-GICC-ABPR\" class=\"headerlink\" title=\"4.4.8 Aliased Binary Point Register, GICC_ABPR\"></a>4.4.8 Aliased Binary Point Register, GICC_ABPR</h5><h5 id=\"4-4-9-Aliased-Interrupt-Acknowledge-Register-GICC-AIAR\"><a href=\"#4-4-9-Aliased-Interrupt-Acknowledge-Register-GICC-AIAR\" class=\"headerlink\" title=\"4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR\"></a>4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR</h5><h5 id=\"4-4-10-Aliased-End-of-Interrupt-Register-GICC-AEOIR\"><a href=\"#4-4-10-Aliased-End-of-Interrupt-Register-GICC-AEOIR\" class=\"headerlink\" title=\"4.4.10 Aliased End of Interrupt Register, GICC_AEOIR\"></a>4.4.10 Aliased End of Interrupt Register, GICC_AEOIR</h5><h5 id=\"4-4-11-Aliased-Highest-Priority-Pending-Interrupt-Register-GICC-AHPPIR\"><a href=\"#4-4-11-Aliased-Highest-Priority-Pending-Interrupt-Register-GICC-AHPPIR\" class=\"headerlink\" title=\"4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR\"></a>4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR</h5><p>与前面对应相似</p>\n<h5 id=\"4-4-12-Active-Priorities-Registers-GICC-APRn\"><a href=\"#4-4-12-Active-Priorities-Registers-GICC-APRn\" class=\"headerlink\" title=\"4.4.12 Active Priorities Registers, GICC_APRn\"></a>4.4.12 Active Priorities Registers, GICC_APRn</h5><p>主要用于做电源管理时，保存与恢复。<br>provide support for preserving and restoring the active priority in power-management implementations.</p>\n<p>Although the format of these registers is IMPLEMENTATION DEFINED:<br>• because GICv2 guarantees the ability to save and restore all GIC state, the<br>GICC_APRn registers must be present in all GIC implementations<br>• in an implementation that includes the GIC Security Extensions, Non-secure<br>accesses must not affect Secure operation, and the architecture requires that these<br>registers are banked, to provide Secure and Non-secure copies of the registers.</p>\n<h5 id=\"4-4-13-Non-secure-Active-Priorities-Registers-GICC-NSAPRn\"><a href=\"#4-4-13-Non-secure-Active-Priorities-Registers-GICC-NSAPRn\" class=\"headerlink\" title=\"4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn\"></a>4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn</h5><p>provide support for preserving and restoring the active priority in power-management implementation. These are separate registers for Group 1 interrupts.</p>\n<h5 id=\"4-4-14-CPU-Interface-Identification-Register-GICC-IIDR\"><a href=\"#4-4-14-CPU-Interface-Identification-Register-GICC-IIDR\" class=\"headerlink\" title=\"4.4.14 CPU Interface Identification Register, GICC_IIDR\"></a>4.4.14 CPU Interface Identification Register, GICC_IIDR</h5><p>Provides information about the implementer and revision of the CPU interface.</p>\n<p>Fixme [Figure 4-35 GICC_IIDR bit assignments] Page 152</p>\n<p>Fixme [Table 4-48 GICC_IIDR bit assignments] Page 152</p>\n<h5 id=\"4-4-15-Deactivate-Interrupt-Register-GICC-DIR\"><a href=\"#4-4-15-Deactivate-Interrupt-Register-GICC-DIR\" class=\"headerlink\" title=\"4.4.15 Deactivate Interrupt Register, GICC_DIR\"></a>4.4.15 Deactivate Interrupt Register, GICC_DIR</h5><p>When interrupt priority drop is separated from interrupt deactivation, as described in<br>Priority drop and interrupt deactivation on page 3-38, a write to this register <strong>deactivates the specified interrupt.</strong></p>\n<p>Fixme [Figure 4-36 GICC_DIR bit assignments] Page 153</p>\n<p>Fixme [Table 4-49 GICC_DIR bit assignments] Page 153</p>\n<p>Fixme [Table 4-50 Behavior of GICC_DIR writes] Page 154</p>\n<h3 id=\"5-GIC-Support-for-Virtualization\"><a href=\"#5-GIC-Support-for-Virtualization\" class=\"headerlink\" title=\"5 GIC Support for Virtualization\"></a>5 GIC Support for Virtualization</h3><h4 id=\"5-1-About-implementing-a-GIC-in-a-system-with-processor-virtualization\"><a href=\"#5-1-About-implementing-a-GIC-in-a-system-with-processor-virtualization\" class=\"headerlink\" title=\"5.1 About implementing a GIC in a system with processor virtualization\"></a>5.1 About implementing a GIC in a system with processor virtualization</h4><p><strong>Any ARM processor implementation that includes the Virtualization Extensions must also include the Security Extensions.</strong></p>\n<p>Fixme [Figure 5-1 Implementing the GIC with an ARM processor that supports virtualization] Page159</p>\n<h4 id=\"5-2-Managing-the-GIC-virtual-CPU-interface\"><a href=\"#5-2-Managing-the-GIC-virtual-CPU-interface\" class=\"headerlink\" title=\"5.2 Managing the GIC virtual CPU interface\"></a>5.2 Managing the GIC virtual CPU interface</h4><p>The hypervisor, or similar software, manages the GIC virtual interface control registers, consisting of:<br><strong>List registers</strong><br>Used to define the active and pending virtual interrupts for the virtual CPU interface. The current<br>virtual machine accesses these interrupts indirectly, using the virtual CPU interface.</p>\n<p><strong>Management registers</strong><br>Used to manage the virtual CPU interface, and to save and restore settings when switching between<br>virtual machines.</p>\n<p>The hypervisor runs as Non-secure software in Hyp mode. To maintain the 1-N interrupt handling model, a hypervisor might have to migrate an interrupt from one virtual machine to another.</p>\n<p>When it receives a physical IRQ, the hypervisor determines the required destination of the interrupt and then either:<br>• Processes the interrupt itself, for example if the IRQ is <strong>a maintenance interrupt</strong> from the virtual CPU<br>interface. It then deactivates the physical interrupt.<br>• Generates a virtual interrupt. Depending on the interrupt priority and the targeted virtual machine, the<br>hypervisor takes one of the following actions:<br>    — If the interrupt is for the current virtual machine, updates the List registers with details of the interrupt,<br>    redefining the interrupts that are visible to the current virtual machine. If there is no space in the List<br>    registers, it saves the context to memory so the details can be added at a later stage<br>    — Records that the interrupt is for a different virtual machine by saving details of the interrupt as part of<br>    the hypervisor state associated with that virtual machine.<br>    — Switches to a different virtual machine that can handle the interrupt. In doing so it must save the<br>    interrupt state for the current virtual machine, using the information in the List registers, and<br>    reprogram the List registers, to indicate the interrupt state for the new virtual machine, including the<br>    state for the interrupt that has arrived.</p>\n<p>The virtual machine accesses the GIC virtual CPU interface registers. These registers have the same general format<br>as the physical CPU interface registers, and, in a typical implementation the virtual machine believes it is accessing<br>a physical CPU interface.</p>\n<p>When the virtual machine handles a virtual interrupt, it writes to the virtual CPU interface to indicate when it has<br>finished this processing. The virtual CPU interface signals this completion to the physical Distributor and the<br>physical Distributor then deactivates the interrupt.</p>\n<h5 id=\"5-2-1-List-registers-and-virtual-interrupt-handling\"><a href=\"#5-2-1-List-registers-and-virtual-interrupt-handling\" class=\"headerlink\" title=\"5.2.1 List registers and virtual interrupt handling\"></a>5.2.1 List registers and virtual interrupt handling</h5><p>a hypervisor uses List registers to maintain the list of highest priority virtual interrupts.</p>\n<p>记录的数据可以超过List registers数量，多余的数据存储在MEM 中。<br><strong>The total number of interrupts that are either pending, active, or active and pending, can exceed the number of List registers available.</strong><br>If this happens, the hypervisor can save one or more active interrupt entries to memory, and later restore them to the List registers，based on their priority。Therefore:<br>• The List registers might not include all active, or active and pending, interrupts. Virtual CPU interface<br>accesses by the virtual machine update the List registers, and normally an EOI request from the virtual<br>machine deactivates an interrupt in the list. However, the virtual machine can issue an EOI request for an<br>interrupt before the hypervisor restores the associated active interrupt entry into a List register. In this case,<br>the EOI request cannot update the List registers.</p>\n<p>• Although the List registers might include only active interrupts, with the hypervisor maintaining any pending<br>interrupts in memory, a pending interrupt cannot be signaled to the virtual machine until the hypervisor adds<br>it to the List registers. Therefore, to minimize interrupt latency and ensure efficient virtual machine operation,<br><strong>ARM strongly recommends that the List registers contain at least one pending interrupt, provided a List register is available for this interrupt.</strong></p>\n<h5 id=\"5-2-2-Completion-of-virtualized-physical-interrupts\"><a href=\"#5-2-2-Completion-of-virtualized-physical-interrupts\" class=\"headerlink\" title=\"5.2.2 Completion of virtualized physical interrupts\"></a>5.2.2 Completion of virtualized physical interrupts</h5><p>ARM recommends that, for each CPU interface that corresponds to a<br>processor running virtual machines, the GICC_CTLR.EOImodeNS bit is set to 1. This means that hypervisor<br>accesses to the GICC_AEOIR register drops the running priority of the CPU interface but does not deactivate the<br>interrupt. After writing to the EOI register, the running priority level on the CPU interface is lower, so that<br>subsequent interrupts can be signaled to the processor.</p>\n<p>ARM recommends that physical interrupt completion consists of the following separate steps:</p>\n<ol>\n<li>EOI</li>\n<li>interrupt deactivation.</li>\n</ol>\n<p>These steps are explained in more detail as follows:</p>\n<ol>\n<li><p>After receiving a physical interrupt, the hypervisor performs an EOI request for the physical interrupt by<br>writing to the GICC_EOIR or GICC_AEOIR register. After EOI, although the virtual machine has not<br>processed the virtual interrupt, the lower running priority of the CPU interface means that the hypervisor can<br>still receive new physical interrupts.<br> Note<br> The only interrupts that are not signaled to the hypervisor are the physical interrupts most recently subject to<br> EOI. This is because the interrupts have not been deactivated. This prevents the interrupts from being<br> re-signaled to the hypervisor before being processed by the virtual machine.</p>\n</li>\n<li><p>After the virtual machine completes processing the corresponding virtual interrupt, it writes to the<br>GICV_EOIR or GICV_AEOIR to deactivate the interrupt. This deactivates both the virtual interrupt and the<br>corresponding physical interrupt, provided that both of the following conditions are true:<br>• the GICV_CTLR.EOImode bit is set to 0<br>• the GICH_LRn.HW bit is set to 1.</p>\n</li>\n</ol>\n<p>Alternatively, if the GICV_CTLR.EOImode bit is set to 1, the virtual machine writes to the GICV_DIR<br>register to deactivate the interrupt.<br>If the GICH_LRn.HW bit is set to 0, the hypervisor must deactivate the physical interrupt itself. ARM<br>recommends one of the following methods for deactivating physical SGIs that are routed to a virtual machine:<br>• the hypervisor deactivates the SGI by writing to the GICC_DIR register after the virtual machine<br>writes to GICC_EOIR<br>• the hypervisor uses an EOI maintenance interrupt to write to the GICC_DIR register after the virtual<br>machine writes to GICV_EOIR, see Maintenance interrupts on page 5-164 for more information.</p>\n<p>处理大致流程：</p>\n<ol>\n<li>hypervisor 写GICC_AEOIR，让此IRQ 丢掉优先级，能让其他低优先级的中断能被处理</li>\n<li>virtual machine 处理完后，virtual cpu 写GICV_EOIR 或 GICV_AEOIR，再写GICV_DIR （依赖GICV_CTLR.EOImode 设定是否自动完成后一步）</li>\n<li>在virtual machine 写 GICV_EOIR 后，hypervisor 用 EOI maintenance interrupt 写 GICC_DIR （GICH_LRn.HW 设定为1，自动完成此步）</li>\n</ol>\n<h5 id=\"5-2-3-Acknowledgement-and-completion-of-virtual-interrupts\"><a href=\"#5-2-3-Acknowledgement-and-completion-of-virtual-interrupts\" class=\"headerlink\" title=\"5.2.3 Acknowledgement and completion of virtual interrupts\"></a>5.2.3 Acknowledgement and completion of virtual interrupts</h5><p>To ensure system correctness when handling virtual interrupts, one of the following conditions must be true:<br>• All Group 0 interrupts must have a higher priority than any Group 1 interrupt. That is, there is no overlap in<br>the priorities allocated to Group 0 and Group 1 interrupts.<br>• The GICV_CTLR.AckCtl bit must be set to 0.</p>\n<p><strong>ARM deprecates the use of GICC_CTLR.AckCtl and GICV_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl and GICV_CTLR.AckCtl are set to 0.</strong></p>\n<h5 id=\"5-2-4-GIC-virtual-interface-control-interface-requirements\"><a href=\"#5-2-4-GIC-virtual-interface-control-interface-requirements\" class=\"headerlink\" title=\"5.2.4 GIC virtual interface control interface requirements\"></a>5.2.4 GIC virtual interface control interface requirements</h5><p>skip</p>\n<h5 id=\"5-2-5-Maintenance-interrupts\"><a href=\"#5-2-5-Maintenance-interrupts\" class=\"headerlink\" title=\"5.2.5 Maintenance interrupts\"></a>5.2.5 Maintenance interrupts</h5><p><strong>Maintenance interrupts can signal key events in the operation of a GIC that implements the Virtualization Extensions. Typically, these events are processed by the hypervisor.</strong></p>\n<p>Note<br>• Maintenance interrupts are generated only when the global interrupt enable bit, GICH_HCR.En, is set to 1.</p>\n<p>Maintenance interrupts are level-sensitive interrupts. Configuration bits in the GICH_HCR can be set to 1 to enable<br>maintenance interrupt generation when:<br>• Group 0 virtual interrupts are enabled/disabled<br>• Group 1 virtual interrupts are enabled/disabled<br>• There are no pending interrupts in the List registers.<br>• At least one EOI request occurs with no valid List register entry for the corresponding interrupt.<br>• There are no valid entries, or only one valid entry, in the List registers. This is an underflow condition.<br>• At least one List register entry has received an EOI request.</p>\n<h5 id=\"5-2-6-Software-generated-interrupts\"><a href=\"#5-2-6-Software-generated-interrupts\" class=\"headerlink\" title=\"5.2.6 Software-generated interrupts\"></a>5.2.6 Software-generated interrupts</h5><p><strong>Hypervisor-generated interrupts</strong><br>A hypervisor can generate virtual interrupts that do not have a corresponding physical interrupt, by<br>creating an entry in the List registers with the GICH_LRn.HW bit cleared to 0. The hypervisor can<br>control how the interrupt appears to a virtual machine reading the GICV_IAR or GICV_AIAR<br>register to acknowledge the interrupt, by presenting the interrupt as:<br>• an SGI, with a CPUID value provided in addition to the interrupt ID<br>• a PPI or SPI, with the CPUID value set to 0.</p>\n<p>The hypervisor can virtualize the CPUID value, but it must be consistent with the type of interrupt<br>indicated by the GICH_LRn.VirtualID field. When the EOI notification is sent to the virtual CPU<br>interface, only the List registers are affected, and no notification is sent to the Distributor. See List<br>Registers, GICH_LRn on page 5-176 for more information.</p>\n<p>hypervisor 可以产生与硬件中断号不一致的虚拟中断，并且可以控制中断在虚拟机中呈现的形式：SGI，PPI，SPI。</p>\n<p><strong>Distributor-generated interrupts</strong><br>Because the hardware interrupt deactivation mechanism does not support SGIs, the hypervisor must<br>virtualize SGIs originating from the Distributor in the same way as hypervisor-generated interrupts.<br>The hypervisor can virtualize the GICH_LRn.CPUID field, because this field is not required to be<br>the same as that of the original SGI. See Completion of virtualized physical interrupts on page 5-161<br>for more information about deactivating virtualized SGIs.</p>\n<p>虚拟中断分发器 产生的虚拟机之间的SGIs。</p>\n<h5 id=\"5-2-7-GIC-Virtualization-Extensions-register-mapping\"><a href=\"#5-2-7-GIC-Virtualization-Extensions-register-mapping\" class=\"headerlink\" title=\"5.2.7 GIC Virtualization Extensions register mapping\"></a>5.2.7 GIC Virtualization Extensions register mapping</h5><p>The GIC must make these virtual interface control registers accessible in the following ways:<br><strong>Redirection through a common base address</strong><br>The memory map includes a common base address for the virtual interface control registers. Each<br>processor in the system can access its own GIC virtual interface control registers through this base<br>address. The CPUID of the processor requesting access redirects the access to the GIC virtual<br>interface control registers for that processor.</p>\n<p><strong>Processor-specific base addresses</strong><br>In addition to the common base address, the memory map contains, for each processor in the system,<br>a processor-specific base address for the GIC virtual interface control registers. Any processor can<br>use these addresses to access its own GIC virtual interface control registers, or to access the GIC<br>virtual interface control registers of any other processor in the system.</p>\n<p>Fixme [Figure 5-2 GIC virtual interface control register mappings] page166</p>\n<h4 id=\"5-3-GIC-virtual-interface-control-registers\"><a href=\"#5-3-GIC-virtual-interface-control-registers\" class=\"headerlink\" title=\"5.3 GIC virtual interface control registers\"></a>5.3 GIC virtual interface control registers</h4><p>Fixme [Table 5-1 GIC virtual interface control register map] page167</p>\n<h5 id=\"5-3-1-Hypervisor-Control-Register-GICH-HCR\"><a href=\"#5-3-1-Hypervisor-Control-Register-GICH-HCR\" class=\"headerlink\" title=\"5.3.1 Hypervisor Control Register, GICH_HCR\"></a>5.3.1 Hypervisor Control Register, GICH_HCR</h5><p>This register contains control bits for the virtual CPU interface.</p>\n<p>Fixme [Figure 5-3 GICH_HCR bit assignments] page168</p>\n<p>Fixme [Table 5-2 GICH_HCR bit assignments] page168</p>\n<p>Fixme [Table 5-2 GICH_HCR bit assignments] page169</p>\n<h5 id=\"5-3-2-VGIC-Type-Register-GICH-VTR\"><a href=\"#5-3-2-VGIC-Type-Register-GICH-VTR\" class=\"headerlink\" title=\"5.3.2 VGIC Type Register, GICH_VTR\"></a>5.3.2 VGIC Type Register, GICH_VTR</h5><p>This is a read-only register that provides the following information about the<br>implementation of the GIC Virtualization Extensions:<br>• number of priority levels supported<br>• number of preemption levels supported<br>• number of implemented List registers.</p>\n<p>Fixme [Figure 5-4 GICH_VTR bit assignments] page170</p>\n<p>Fixme [Table 5-3 GICH_VTR bit assignments] page170</p>\n<h5 id=\"5-3-3-Virtual-Machine-Control-Register-GICH-VMCR\"><a href=\"#5-3-3-Virtual-Machine-Control-Register-GICH-VMCR\" class=\"headerlink\" title=\"5.3.3 Virtual Machine Control Register, GICH_VMCR\"></a>5.3.3 Virtual Machine Control Register, GICH_VMCR</h5><p>Enables the hypervisor to save and restore the virtual machine view of the GIC state.</p>\n<p>Fixme [Figure 5-5 GICH_VMCR bit assignments] page171</p>\n<p>The GICH_VMCR is a control register that contains read and write aliases of architecture state in the virtual<br>machine view, enabling the hypervisor to save and restore this state with a single read or write, without accessing<br>the GIC virtual CPU interface registers individually.</p>\n<h5 id=\"5-3-4-Maintenance-Interrupt-Status-Register-GICH-MISR\"><a href=\"#5-3-4-Maintenance-Interrupt-Status-Register-GICH-MISR\" class=\"headerlink\" title=\"5.3.4 Maintenance Interrupt Status Register, GICH_MISR\"></a>5.3.4 Maintenance Interrupt Status Register, GICH_MISR</h5><p>Indicates which maintenance interrupts are asserted.</p>\n<p>Fixme [Figure 5-6 GICH_MISR bit assignments] page172</p>\n<p>Fixme [Table 5-5 GICH_MISR bit assignments] page172</p>\n<h5 id=\"5-3-5-End-of-Interrupt-Status-Registers-GICH-EISR0-and-GICH-EISR1\"><a href=\"#5-3-5-End-of-Interrupt-Status-Registers-GICH-EISR0-and-GICH-EISR1\" class=\"headerlink\" title=\"5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1\"></a>5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1</h5><p>When a maintenance interrupt is received, these registers help determine which List<br>registers have outstanding EOI interrupts that require servicing.</p>\n<p>Fixme [Figure 5-7 GICH_EISR0 bit assignments] page173</p>\n<p>Fixme [Table 5-6 GICH_EISR0 bit assignments] page173</p>\n<h5 id=\"5-3-6-Empty-List-Register-Status-Registers-GICH-ELRSR0-and-GICH-ELRSR1\"><a href=\"#5-3-6-Empty-List-Register-Status-Registers-GICH-ELRSR0-and-GICH-ELRSR1\" class=\"headerlink\" title=\"5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1\"></a>5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1</h5><p>These registers can be used to locate a usable List register when the hypervisor is delivering<br>an interrupt to a Guest OS.</p>\n<p>Fixme [Figure 5-8 GICH_ELRSR0 bit assignments] page173</p>\n<p>Fixme [Table 5-7 GICH_ELRSR0 bit assignments] page173</p>\n<h5 id=\"5-3-7-Active-Priorities-Register-GICH-APR\"><a href=\"#5-3-7-Active-Priorities-Register-GICH-APR\" class=\"headerlink\" title=\"5.3.7 Active Priorities Register, GICH_APR\"></a>5.3.7 Active Priorities Register, GICH_APR</h5><p>This register tracks which preemption levels are active in the virtual CPU interface, and is<br>used to determine the current active priority. Corresponding bits are set in this register when<br>an interrupt is acknowledged, based on GICH_LRn.Priority, and the least significant set bit<br>is cleared on EOI.</p>\n<p>Fixme [Figure 5-9 GICH_APR bit assignments] page175</p>\n<p>Fixme [Table 5-8 GICH_APR bit assignments] page175</p>\n<h5 id=\"5-3-8-List-Registers-GICH-LRn\"><a href=\"#5-3-8-List-Registers-GICH-LRn\" class=\"headerlink\" title=\"5.3.8 List Registers, GICH_LRn\"></a>5.3.8 List Registers, GICH_LRn</h5><p>Provides interrupt context information for the virtual CPU interface. <strong>A maximum of 64 List registers can be provided. The GICH_VTR.ListRegs bit defines the actual number implemented.</strong></p>\n<p>Fixme [Figure 5-10 GICH_LR bit assignments] page176</p>\n<p>Fixme [Table 5-9 GICH_LR bit assignments] page176</p>\n<h4 id=\"5-4-The-virtual-CPU-interface\"><a href=\"#5-4-The-virtual-CPU-interface\" class=\"headerlink\" title=\"5.4 The virtual CPU interface\"></a>5.4 The virtual CPU interface</h4><p>A GIC virtual CPU interface signals virtual interrupts to a connected processor, The GIC virtual CPU interface registers have the same general format as the GIC physical CPU interface registers and expected behavior is that a virtual machine cannot distinguish between them.</p>\n<p><strong>In particular, the virtual CPU interface uses the contents of the List registers to determine when to signal virtual interrupts.</strong></p>\n<p>When a processor accesses the virtual CPU interface the List registers are updated.<br>• Virtual interrupts are always handled through the virtual CPU interfaces.<br>• On the connected processor, if the processor is in a Non-secure PL1 or PL0 mode, virtual interrupts are<br>signaled to the current virtual machine.<br>• In addition, a virtual machine can receive virtual IRQs and virtual FIQs signaled directly by the hypervisor.<br>These exceptions are outside the scope of this specification. A virtual machine cannot distinguish:<br>    — A virtual exception signaled by the GIC from a corresponding virtual exception signaled directly by the hypervisor.<br>    — A virtual exception from the corresponding physical exception.<br>• A virtual CPU interface does not require power management support, and therefore GICV_CTLR does not<br>implement the IRQBypDisGrp1, FIQBypDisGrp1, IRQBypDisGrp0, and FIQBypDisGrp0 bits that are<br>supported by GICC_CTLR</p>\n<h4 id=\"5-5-GIC-virtual-CPU-interface-registers\"><a href=\"#5-5-GIC-virtual-CPU-interface-registers\" class=\"headerlink\" title=\"5.5 GIC virtual CPU interface registers\"></a>5.5 GIC virtual CPU interface registers</h4><p>Typically, a virtual machine is unaware of any difference between virtual interrupts and physical interrupts.</p>\n<p><strong>In general, these registers have the same format as the GIC physical CPU interface registers, but they operate on the interrupt view defined primarily by the List registers.</strong></p>\n<p>These registers are memory-mapped, The offset of each GICV_* register is the same as the offset of the corresponding register for the physical CPU interface.</p>\n<p>Fixme [Table 5-10 GIC virtual CPU interface register map] page179</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck915p0ok0000zkgrx3fwk7xk","category_id":"ck915p0ot0004zkgra02sxnhs","_id":"ck915p0p4000ezkgrebwucdmh"},{"post_id":"ck915p0oq0002zkgrs3leobbc","category_id":"ck915p0oz0009zkgr5cp331f7","_id":"ck915p0p9000kzkgrxoihwxih"},{"post_id":"ck915p0ov0006zkgractdnipk","category_id":"ck915p0p5000fzkgrvuisvg6b","_id":"ck915p0pb000qzkgrif1raosw"},{"post_id":"ck915p0ox0007zkgrtvr32g4w","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0ph000wzkgrnvklofn2"},{"post_id":"ck915p0pa000pzkgrvfz43gtn","category_id":"ck915p0oz0009zkgr5cp331f7","_id":"ck915p0pj000zzkgrue2ppkv7"},{"post_id":"ck915p0oy0008zkgrbawfdlgh","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0pl0013zkgrv6avop1i"},{"post_id":"ck915p0p1000czkgrp3ci9jeg","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0po0019zkgrdht3fvwm"},{"post_id":"ck915p0p3000dzkgrfxx395av","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0pr001ezkgrdbk3lo2c"},{"post_id":"ck915p0p6000hzkgrs2tn06t7","category_id":"ck915p0po0018zkgr3gf8lh7x","_id":"ck915p0pv001lzkgra9hswbxp"},{"post_id":"ck915p0pt001jzkgrwnpkoidz","category_id":"ck915p0po0018zkgr3gf8lh7x","_id":"ck915p0py001szkgrxlwrkoio"},{"post_id":"ck915p0p7000jzkgrvid9jyub","category_id":"ck915p0ps001hzkgrytgko452","_id":"ck915p0q0001wzkgri7sceg1z"},{"post_id":"ck915p0pu001kzkgrma99fprh","category_id":"ck915p0po0018zkgr3gf8lh7x","_id":"ck915p0q2001yzkgrxddigk4j"},{"post_id":"ck915p0p9000nzkgry3ykjz24","category_id":"ck915p0pw001nzkgrnh6lxav1","_id":"ck915p0q30023zkgr7n7zttln"},{"post_id":"ck915p0pz001vzkgrutke55rc","category_id":"ck915p0pw001nzkgrnh6lxav1","_id":"ck915p0q50026zkgrxz3w3qn4"},{"post_id":"ck915p0pc000tzkgrzwroo02y","category_id":"ck915p0pz001uzkgrc7188io0","_id":"ck915p0q7002azkgrp8nyq44p"},{"post_id":"ck915p0q1001xzkgrcdb0abep","category_id":"ck915p0pw001nzkgrnh6lxav1","_id":"ck915p0q9002dzkgr8hxk067c"},{"post_id":"ck915p0pf000uzkgr3nbs1ux5","category_id":"ck915p0pz001uzkgrc7188io0","_id":"ck915p0qb002hzkgrte3o1yss"},{"post_id":"ck915p0ph000xzkgru8c0tv88","category_id":"ck915p0pz001uzkgrc7188io0","_id":"ck915p0qd002kzkgr3oe95fqg"},{"post_id":"ck915p0qa002gzkgrja9eke6b","category_id":"ck915p0pw001nzkgrnh6lxav1","_id":"ck915p0qh002pzkgrgsg9i1f9"},{"post_id":"ck915p0pj0011zkgrnxajybqh","category_id":"ck915p0qa002fzkgr3jinuj1s","_id":"ck915p0qj002szkgrrvmb1qk4"},{"post_id":"ck915p0qe002mzkgr6ohvnje1","category_id":"ck915p0pw001nzkgrnh6lxav1","_id":"ck915p0ql002wzkgrc0khyrp0"},{"post_id":"ck915p0qg002ozkgrr4moj0eu","category_id":"ck915p0pw001nzkgrnh6lxav1","_id":"ck915p0qn0030zkgr6848ku47"},{"post_id":"ck915p0pl0015zkgr4jrjnjvm","category_id":"ck915p0po0018zkgr3gf8lh7x","_id":"ck915p0qo0033zkgrbiedr03d"},{"post_id":"ck915p0qk002vzkgr7xgt5gtz","category_id":"ck915p0pw001nzkgrnh6lxav1","_id":"ck915p0qq0037zkgr72l10pv9"},{"post_id":"ck915p0pn0017zkgr7mk9ri09","category_id":"ck915p0po0018zkgr3gf8lh7x","_id":"ck915p0qs003azkgrep0nfnqt"},{"post_id":"ck915p0qm002yzkgrtem0vank","category_id":"ck915p0pw001nzkgrnh6lxav1","_id":"ck915p0qu003dzkgr66nxdmmw"},{"post_id":"ck915p0po001azkgrv10ioxqr","category_id":"ck915p0qa002fzkgr3jinuj1s","_id":"ck915p0qw003hzkgr89ifg5zd"},{"post_id":"ck915p0qr0039zkgr75zmklsk","category_id":"ck915p0pw001nzkgrnh6lxav1","_id":"ck915p0qy003kzkgrt7l9hbpy"},{"post_id":"ck915p0pq001dzkgrqnvy9zj4","category_id":"ck915p0qq0036zkgrsabtwmfb","_id":"ck915p0r0003ozkgrbo4uwd00"},{"post_id":"ck915p0pr001gzkgrs4yibgdb","category_id":"ck915p0qu003ezkgr5airqzmk","_id":"ck915p0r1003qzkgrq45ooh0j"},{"post_id":"ck915p0qx003jzkgr3t0vjb10","category_id":"ck915p0po0018zkgr3gf8lh7x","_id":"ck915p0r3003uzkgrpegejgd5"},{"post_id":"ck915p0pw001pzkgrae83yn75","category_id":"ck915p0qy003lzkgrebv4tvzs","_id":"ck915p0r6003wzkgrnvsmflwj"},{"post_id":"ck915p0r0003pzkgryqjneh3a","category_id":"ck915p0ps001hzkgrytgko452","_id":"ck915p0r80041zkgr2u5bfm0f"},{"post_id":"ck915p0r2003tzkgrmwha9b34","category_id":"ck915p0ps001hzkgrytgko452","_id":"ck915p0rb0044zkgrb5ihmo3j"},{"post_id":"ck915p0r3003vzkgr9jp4xfwl","category_id":"ck915p0pz001uzkgrc7188io0","_id":"ck915p0rd0049zkgrl7g0phjk"},{"post_id":"ck915p0py001rzkgr2n3axnme","category_id":"ck915p0r1003rzkgrak73u2nj","_id":"ck915p0rf004czkgr002mp07z"},{"post_id":"ck915p0r6003xzkgrljf5syww","category_id":"ck915p0po0018zkgr3gf8lh7x","_id":"ck915p0rh004hzkgrza17bhky"},{"post_id":"ck915p0r80042zkgrlt1ll3tk","category_id":"ck915p0pz001uzkgrc7188io0","_id":"ck915p0rj004kzkgrlmp0ed61"},{"post_id":"ck915p0q30022zkgr1jf1fdaw","category_id":"ck915p0r7003yzkgrmp33xqlw","_id":"ck915p0rl004ozkgr8s9140bd"},{"post_id":"ck915p0rb0045zkgr6u5l4k9m","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0rn004szkgr6nbloqdo"},{"post_id":"ck915p0rd004azkgra5v900he","category_id":"ck915p0oz0009zkgr5cp331f7","_id":"ck915p0rp004wzkgr5fjbilxp"},{"post_id":"ck915p0q40025zkgrszucj1t0","category_id":"ck915p0r7003yzkgrmp33xqlw","_id":"ck915p0rx0050zkgrw9ry0aef"},{"post_id":"ck915p0rf004dzkgrvhlmsio5","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0s00054zkgrt9zp1vqh"},{"post_id":"ck915p0rh004izkgr37ppd0ck","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0s20058zkgrd484dd45"},{"post_id":"ck915p0q60029zkgry0n0fhlw","category_id":"ck915p0r7003yzkgrmp33xqlw","_id":"ck915p0s4005czkgre5fswtil"},{"post_id":"ck915p0rl004qzkgrw4lc5zre","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0s6005gzkgr2w1q1u6k"},{"post_id":"ck915p0qc002jzkgrg47azaf7","category_id":"ck915p0rk004mzkgrmy8wrwz6","_id":"ck915p0s8005kzkgr1fvuedyg"},{"post_id":"ck915p0rn004tzkgrnavkcsok","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0sa005ozkgr2g3ov3uu"},{"post_id":"ck915p0rw004yzkgr0a3vzzn4","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0sb005szkgrwfqwyj7i"},{"post_id":"ck915p0qh002qzkgryws7yhoh","category_id":"ck915p0r7003yzkgrmp33xqlw","_id":"ck915p0sd005vzkgrjuf33h1m"},{"post_id":"ck915p0s10055zkgrnreqg3ze","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0se005zzkgr2uvcblkb"},{"post_id":"ck915p0qn0032zkgrxgjj2dd4","category_id":"ck915p0s00052zkgrxufpyo91","_id":"ck915p0sg0062zkgrvoe6lz96"},{"post_id":"ck915p0s20059zkgrurmrgq2q","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0sh0066zkgr6st6xqse"},{"post_id":"ck915p0s4005dzkgrkcu42tv0","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0sj0069zkgrj9ehbtt4"},{"post_id":"ck915p0qp0035zkgrg66wih32","category_id":"ck915p0r7003yzkgrmp33xqlw","_id":"ck915p0sk006czkgrp5hpz5lj"},{"post_id":"ck915p0s6005hzkgrtkuwhqka","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0sl006ezkgr9nomnjgs"},{"post_id":"ck915p0s8005lzkgr9ulqa547","category_id":"ck915p0oz0009zkgr5cp331f7","_id":"ck915p0sl006hzkgr3cja5718"},{"post_id":"ck915p0qt003czkgrqievcv6v","category_id":"ck915p0r7003yzkgrmp33xqlw","_id":"ck915p0sl006jzkgr739ywev8"},{"post_id":"ck915p0sa005pzkgrym66cvbw","category_id":"ck915p0oz0009zkgr5cp331f7","_id":"ck915p0sm006mzkgraj211jgs"},{"post_id":"ck915p0sb005tzkgra5ehurld","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0sm006ozkgr2lrryp1d"},{"post_id":"ck915p0qv003gzkgr3qzuxywo","category_id":"ck915p0r7003yzkgrmp33xqlw","_id":"ck915p0sn006qzkgr6kh38f5k"},{"post_id":"ck915p0sd005xzkgrxp1qp8l2","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0sn006tzkgrucin7zz3"},{"post_id":"ck915p0sf0060zkgr6kqvub10","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0sn006vzkgrpyo7mzsq"},{"post_id":"ck915p0sg0063zkgr28y16oc0","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0so006yzkgrc9as0x1u"},{"post_id":"ck915p0si0067zkgr65w320nh","category_id":"ck915p0p9000lzkgr82v65i4w","_id":"ck915p0so0070zkgrdihwjdlr"},{"post_id":"ck915p101008rzkgrp45b5f4j","category_id":"ck915p0qa002fzkgr3jinuj1s","_id":"ck915p105008wzkgrao75otnl"},{"post_id":"ck915p103008szkgrikrhh4o3","category_id":"ck915p0qa002fzkgr3jinuj1s","_id":"ck915p105008xzkgr5t6gz4xb"}],"PostTag":[{"post_id":"ck915p0ok0000zkgrx3fwk7xk","tag_id":"ck915p0ov0005zkgruergrf4y","_id":"ck915p0p0000bzkgr7y9yxgkk"},{"post_id":"ck915p0oq0002zkgrs3leobbc","tag_id":"ck915p0p0000azkgr9pgq49ei","_id":"ck915p0p7000izkgrwdc5oapg"},{"post_id":"ck915p0ov0006zkgractdnipk","tag_id":"ck915p0p5000gzkgrry4ttcxn","_id":"ck915p0pa000ozkgrmx7j61ud"},{"post_id":"ck915p0ox0007zkgrtvr32g4w","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0pj0010zkgr337k5rpd"},{"post_id":"ck915p0ox0007zkgrtvr32g4w","tag_id":"ck915p0pc000szkgr87r5ydpr","_id":"ck915p0pl0014zkgrj14xa218"},{"post_id":"ck915p0oy0008zkgrbawfdlgh","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0pq001czkgrf41qbnfh"},{"post_id":"ck915p0oy0008zkgrbawfdlgh","tag_id":"ck915p0pc000szkgr87r5ydpr","_id":"ck915p0pr001fzkgrqy5j93ch"},{"post_id":"ck915p0p1000czkgrp3ci9jeg","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0pw001ozkgr3pjdk7d2"},{"post_id":"ck915p0p1000czkgrp3ci9jeg","tag_id":"ck915p0pc000szkgr87r5ydpr","_id":"ck915p0px001qzkgr4ielyzwk"},{"post_id":"ck915p0p3000dzkgrfxx395av","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0q30021zkgryzk285nl"},{"post_id":"ck915p0p3000dzkgrfxx395av","tag_id":"ck915p0pc000szkgr87r5ydpr","_id":"ck915p0q40024zkgriwlwbo06"},{"post_id":"ck915p0p6000hzkgrs2tn06t7","tag_id":"ck915p0q2001zzkgrwzg7b8at","_id":"ck915p0q8002bzkgrmvekn5ux"},{"post_id":"ck915p0p7000jzkgrvid9jyub","tag_id":"ck915p0q60027zkgr5wlff9fr","_id":"ck915p0qc002izkgrwwt8u026"},{"post_id":"ck915p0p9000nzkgry3ykjz24","tag_id":"ck915p0qa002ezkgr4l51wiuu","_id":"ck915p0qj002uzkgrfl3c9c7j"},{"post_id":"ck915p0p9000nzkgry3ykjz24","tag_id":"ck915p0qd002lzkgrmlr5bs4l","_id":"ck915p0ql002xzkgrwe8ef9wx"},{"post_id":"ck915p0pa000pzkgrvfz43gtn","tag_id":"ck915p0qj002tzkgrayfm1hv7","_id":"ck915p0qo0034zkgrt2pess2g"},{"post_id":"ck915p0pc000tzkgrzwroo02y","tag_id":"ck915p0qn0031zkgryudld8eq","_id":"ck915p0qt003bzkgreud40vzl"},{"post_id":"ck915p0pf000uzkgr3nbs1ux5","tag_id":"ck915p0qn0031zkgryudld8eq","_id":"ck915p0qw003izkgr5qtidb0k"},{"post_id":"ck915p0r3003vzkgr9jp4xfwl","tag_id":"ck915p0qn0031zkgryudld8eq","_id":"ck915p0r80040zkgruadgkx7i"},{"post_id":"ck915p0ph000xzkgru8c0tv88","tag_id":"ck915p0qn0031zkgryudld8eq","_id":"ck915p0rb0043zkgrocqc087e"},{"post_id":"ck915p0ph000xzkgru8c0tv88","tag_id":"ck915p0qy003mzkgrwxrbyjwn","_id":"ck915p0rd0048zkgrruwsk9b2"},{"post_id":"ck915p0ph000xzkgru8c0tv88","tag_id":"ck915p0r2003szkgr9mqfc5y0","_id":"ck915p0rf004bzkgr20iu8hqk"},{"post_id":"ck915p0pj0011zkgrnxajybqh","tag_id":"ck915p0r7003zzkgrwe3crhvz","_id":"ck915p0rh004gzkgrw1ddxjp2"},{"post_id":"ck915p0rb0045zkgr6u5l4k9m","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0rj004jzkgrhbviy18z"},{"post_id":"ck915p0rd004azkgra5v900he","tag_id":"ck915p0p0000azkgr9pgq49ei","_id":"ck915p0rl004nzkgrevxvlexu"},{"post_id":"ck915p0pl0015zkgr4jrjnjvm","tag_id":"ck915p0rc0047zkgrxdu6f575","_id":"ck915p0rn004rzkgrqqaizs5h"},{"post_id":"ck915p0rf004dzkgrvhlmsio5","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0rp004vzkgr9yi3yamm"},{"post_id":"ck915p0rh004izkgr37ppd0ck","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0rx004zzkgr5gh1uvbf"},{"post_id":"ck915p0pn0017zkgr7mk9ri09","tag_id":"ck915p0rh004fzkgrx58i2tzd","_id":"ck915p0s00053zkgrqv4t059t"},{"post_id":"ck915p0rl004qzkgrw4lc5zre","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0s20057zkgrcg66br5q"},{"post_id":"ck915p0rn004tzkgrnavkcsok","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0s4005azkgrhxnpk8vf"},{"post_id":"ck915p0rw004yzkgr0a3vzzn4","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0s6005fzkgryv03t5mt"},{"post_id":"ck915p0po001azkgrv10ioxqr","tag_id":"ck915p0r7003zzkgrwe3crhvz","_id":"ck915p0s7005izkgrx6g3llb5"},{"post_id":"ck915p0po001azkgrv10ioxqr","tag_id":"ck915p0rq004xzkgruj3lc5f4","_id":"ck915p0s9005nzkgrzt7mydul"},{"post_id":"ck915p0s10055zkgrnreqg3ze","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0sb005qzkgrfzyjanuc"},{"post_id":"ck915p0s20059zkgrurmrgq2q","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0sd005uzkgrregkhumn"},{"post_id":"ck915p0s4005dzkgrkcu42tv0","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0se005yzkgrqk3et9qe"},{"post_id":"ck915p0s6005hzkgrtkuwhqka","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0sg0061zkgrstotbrlb"},{"post_id":"ck915p0pq001dzkgrqnvy9zj4","tag_id":"ck915p0s10056zkgrzkqyrxob","_id":"ck915p0sh0065zkgr5hm1wjdl"},{"post_id":"ck915p0pq001dzkgrqnvy9zj4","tag_id":"ck915p0s6005ezkgr6f5i6to1","_id":"ck915p0sj0068zkgrxoicp5j1"},{"post_id":"ck915p0sb005tzkgra5ehurld","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0sk006bzkgrfrnf9b93"},{"post_id":"ck915p0sd005xzkgrxp1qp8l2","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0sk006dzkgrhuppj5q4"},{"post_id":"ck915p0sf0060zkgr6kqvub10","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0sl006gzkgrlshvp40i"},{"post_id":"ck915p0sg0063zkgr28y16oc0","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0sl006izkgr40n7oi5k"},{"post_id":"ck915p0si0067zkgr65w320nh","tag_id":"ck915p0p9000mzkgrr7k7asyv","_id":"ck915p0sm006lzkgrmnfu2mi0"},{"post_id":"ck915p0pr001gzkgrs4yibgdb","tag_id":"ck915p0s9005mzkgrnbnobjsc","_id":"ck915p0sm006nzkgrsco03znq"},{"post_id":"ck915p0pr001gzkgrs4yibgdb","tag_id":"ck915p0sd005wzkgr7s7qssoh","_id":"ck915p0sm006pzkgrc9a7pmt2"},{"post_id":"ck915p0pr001gzkgrs4yibgdb","tag_id":"ck915p0sh0064zkgr7ztfknwa","_id":"ck915p0sn006szkgrieyr914g"},{"post_id":"ck915p0pt001jzkgrwnpkoidz","tag_id":"ck915p0rh004fzkgrx58i2tzd","_id":"ck915p0sn006uzkgrurk8yfvs"},{"post_id":"ck915p0pu001kzkgrma99fprh","tag_id":"ck915p0sl006fzkgrl8tdbx6d","_id":"ck915p0so006xzkgrlbgrc2k3"},{"post_id":"ck915p0pw001pzkgrae83yn75","tag_id":"ck915p0sm006kzkgrn2289dh2","_id":"ck915p0so006zzkgr8vdnnu7v"},{"post_id":"ck915p0py001rzkgr2n3axnme","tag_id":"ck915p0sn006rzkgr09pbd34v","_id":"ck915p0sp0072zkgremjt0jvx"},{"post_id":"ck915p0pz001vzkgrutke55rc","tag_id":"ck915p0so006wzkgrknu9rs2f","_id":"ck915p0sp0073zkgr2zemh9jg"},{"post_id":"ck915p0q1001xzkgrcdb0abep","tag_id":"ck915p0so006wzkgrknu9rs2f","_id":"ck915p0sq0075zkgr72atv0h1"},{"post_id":"ck915p0q30022zkgr1jf1fdaw","tag_id":"ck915p0sp0074zkgr5m5bnz6c","_id":"ck915p0sr0078zkgrckypmkiv"},{"post_id":"ck915p0q30022zkgr1jf1fdaw","tag_id":"ck915p0qd002lzkgrmlr5bs4l","_id":"ck915p0sr0079zkgr72jpvk5p"},{"post_id":"ck915p0q40025zkgrszucj1t0","tag_id":"ck915p0sq0077zkgr6vkxffe0","_id":"ck915p0sr007bzkgra1gzmx8r"},{"post_id":"ck915p0q60029zkgry0n0fhlw","tag_id":"ck915p0sr007azkgrkyhdv2p4","_id":"ck915p0ss007dzkgrn7di1vqq"},{"post_id":"ck915p0qa002gzkgrja9eke6b","tag_id":"ck915p0so006wzkgrknu9rs2f","_id":"ck915p0st007fzkgrpx6yqzo6"},{"post_id":"ck915p0qc002jzkgrg47azaf7","tag_id":"ck915p0qd002lzkgrmlr5bs4l","_id":"ck915p0st007hzkgrayxpjubb"},{"post_id":"ck915p0qe002mzkgr6ohvnje1","tag_id":"ck915p0st007gzkgrehfilovr","_id":"ck915p0sw007jzkgr1if6jezt"},{"post_id":"ck915p0qg002ozkgrr4moj0eu","tag_id":"ck915p0st007gzkgrehfilovr","_id":"ck915p0sx007lzkgr7dyfifdu"},{"post_id":"ck915p0qh002qzkgryws7yhoh","tag_id":"ck915p0sw007kzkgrljr06hpa","_id":"ck915p0sx007nzkgr9k0uqxmk"},{"post_id":"ck915p0qk002vzkgr7xgt5gtz","tag_id":"ck915p0sx007mzkgr1rnrwhs9","_id":"ck915p0sy007pzkgryuuizcut"},{"post_id":"ck915p0qm002yzkgrtem0vank","tag_id":"ck915p0sx007ozkgrurpemv89","_id":"ck915p0sz007szkgr2n1s4isr"},{"post_id":"ck915p0qm002yzkgrtem0vank","tag_id":"ck915p0sy007qzkgr7gys3sbw","_id":"ck915p0sz007tzkgryz2xivfo"},{"post_id":"ck915p0qn0032zkgrxgjj2dd4","tag_id":"ck915p0sx007ozkgrurpemv89","_id":"ck915p0t0007wzkgra5739p6y"},{"post_id":"ck915p0qn0032zkgrxgjj2dd4","tag_id":"ck915p0sz007uzkgr58zpv8dn","_id":"ck915p0t0007xzkgr8pu3uveo"},{"post_id":"ck915p0qp0035zkgrg66wih32","tag_id":"ck915p0sp0074zkgr5m5bnz6c","_id":"ck915p0t1007zzkgrwcw4uo22"},{"post_id":"ck915p0qp0035zkgrg66wih32","tag_id":"ck915p0qd002lzkgrmlr5bs4l","_id":"ck915p0t10080zkgrlxcgpult"},{"post_id":"ck915p0qr0039zkgr75zmklsk","tag_id":"ck915p0sx007ozkgrurpemv89","_id":"ck915p0t20082zkgrige4ax5y"},{"post_id":"ck915p0qt003czkgrqievcv6v","tag_id":"ck915p0sp0074zkgr5m5bnz6c","_id":"ck915p0t20084zkgrezpfg7pu"},{"post_id":"ck915p0qt003czkgrqievcv6v","tag_id":"ck915p0qd002lzkgrmlr5bs4l","_id":"ck915p0t20085zkgrz47omi1y"},{"post_id":"ck915p0qv003gzkgr3qzuxywo","tag_id":"ck915p0t20083zkgrt2qxxssi","_id":"ck915p0t30087zkgrmuvf3wg9"},{"post_id":"ck915p0qx003jzkgr3t0vjb10","tag_id":"ck915p0t30086zkgrmprlhshk","_id":"ck915p0t30089zkgr6f387pak"},{"post_id":"ck915p0qz003nzkgrbh1duy0v","tag_id":"ck915p0t30088zkgr0cltwjlz","_id":"ck915p0t4008bzkgryosg220u"},{"post_id":"ck915p0r0003pzkgryqjneh3a","tag_id":"ck915p0t4008azkgrfrbupf1u","_id":"ck915p0t5008ezkgrjvyc99rt"},{"post_id":"ck915p0r0003pzkgryqjneh3a","tag_id":"ck915p0t4008czkgrmhxxs94v","_id":"ck915p0t5008fzkgrd38sx9dc"},{"post_id":"ck915p0r2003tzkgrmwha9b34","tag_id":"ck915p0sd005wzkgr7s7qssoh","_id":"ck915p0t5008hzkgr3p4rcl66"},{"post_id":"ck915p0r6003xzkgrljf5syww","tag_id":"ck915p0t5008gzkgre3mc59vf","_id":"ck915p0t6008jzkgrkjbdztgh"},{"post_id":"ck915p0r6003xzkgrljf5syww","tag_id":"ck915p0q60027zkgr5wlff9fr","_id":"ck915p0t6008kzkgrc5mpvbvy"},{"post_id":"ck915p0r80042zkgrlt1ll3tk","tag_id":"ck915p0qn0031zkgryudld8eq","_id":"ck915p0t7008mzkgrpakdrqor"},{"post_id":"ck915p0r80042zkgrlt1ll3tk","tag_id":"ck915p0t6008izkgrklzsbc0l","_id":"ck915p0t7008nzkgrxico6shy"},{"post_id":"ck915p0s8005lzkgr9ulqa547","tag_id":"ck915p0t6008lzkgrii7gu6x5","_id":"ck915p0t8008pzkgr3j2dgnrv"},{"post_id":"ck915p0sa005pzkgrym66cvbw","tag_id":"ck915p0t7008ozkgr6o4qnmbv","_id":"ck915p0t8008qzkgryr1g68j5"},{"post_id":"ck915p101008rzkgrp45b5f4j","tag_id":"ck915p0r7003zzkgrwe3crhvz","_id":"ck915p104008tzkgrqgd6xxlg"},{"post_id":"ck915p101008rzkgrp45b5f4j","tag_id":"ck915p0rq004xzkgruj3lc5f4","_id":"ck915p105008vzkgroksfytk7"},{"post_id":"ck915p103008szkgrikrhh4o3","tag_id":"ck915p0r7003zzkgrwe3crhvz","_id":"ck915p106008yzkgrl46oi6eb"},{"post_id":"ck915p103008szkgrikrhh4o3","tag_id":"ck915p0rq004xzkgruj3lc5f4","_id":"ck915p106008zzkgrlmuyakrw"},{"post_id":"ck915p103008szkgrikrhh4o3","tag_id":"ck915p105008uzkgr2a3f52jn","_id":"ck915p1060090zkgr3ufusvpa"}],"Tag":[{"name":"UML","_id":"ck915p0ov0005zkgruergrf4y"},{"name":"life","_id":"ck915p0p0000azkgr9pgq49ei"},{"name":"Debug","_id":"ck915p0p5000gzkgrry4ttcxn"},{"name":"bookmarks","_id":"ck915p0p9000mzkgrr7k7asyv"},{"name":"program","_id":"ck915p0pc000szkgr87r5ydpr"},{"name":"Docker","_id":"ck915p0q2001zzkgrwzg7b8at"},{"name":"webserver","_id":"ck915p0q60027zkgr5wlff9fr"},{"name":"flash","_id":"ck915p0qa002ezkgr4l51wiuu"},{"name":"kernel","_id":"ck915p0qd002lzkgrmlr5bs4l"},{"name":"TED","_id":"ck915p0qj002tzkgrayfm1hv7"},{"name":"WebRTC","_id":"ck915p0qn0031zkgryudld8eq"},{"name":"biterate controller","_id":"ck915p0qy003mzkgrwxrbyjwn"},{"name":"congestion control","_id":"ck915p0r2003szkgr9mqfc5y0"},{"name":"arm","_id":"ck915p0r7003zzkgrwe3crhvz"},{"name":"boot_time","_id":"ck915p0rc0047zkgrxdu6f575"},{"name":"optimization","_id":"ck915p0rh004fzkgrx58i2tzd"},{"name":"spec","_id":"ck915p0rq004xzkgruj3lc5f4"},{"name":"bootloader","_id":"ck915p0s10056zkgrzkqyrxob"},{"name":"u-boot","_id":"ck915p0s6005ezkgr6f5i6to1"},{"name":"buildbot","_id":"ck915p0s9005mzkgrnbnobjsc"},{"name":"openwrt","_id":"ck915p0sd005wzkgr7s7qssoh"},{"name":"CI","_id":"ck915p0sh0064zkgr7ztfknwa"},{"name":"zsh","_id":"ck915p0sl006fzkgrl8tdbx6d"},{"name":"hexo","_id":"ck915p0sm006kzkgrn2289dh2"},{"name":"ipv6","_id":"ck915p0sn006rzkgr09pbd34v"},{"name":"cryptographic","_id":"ck915p0so006wzkgrknu9rs2f"},{"name":"memory","_id":"ck915p0sp0074zkgr5m5bnz6c"},{"name":"mm","_id":"ck915p0sq0077zkgr6vkxffe0"},{"name":"cache","_id":"ck915p0sr007azkgrkyhdv2p4"},{"name":"timer","_id":"ck915p0st007gzkgrehfilovr"},{"name":"tlb","_id":"ck915p0sw007kzkgrljr06hpa"},{"name":"tty","_id":"ck915p0sx007mzkgr1rnrwhs9"},{"name":"mtd","_id":"ck915p0sx007ozkgrurpemv89"},{"name":"ubi","_id":"ck915p0sy007qzkgr7gys3sbw"},{"name":"ubifs","_id":"ck915p0sz007uzkgr58zpv8dn"},{"name":"slub","_id":"ck915p0t20083zkgrt2qxxssi"},{"name":"cpu_loading","_id":"ck915p0t30086zkgrmprlhshk"},{"name":"bookmarks reading_notes","_id":"ck915p0t30088zkgr0cltwjlz"},{"name":"ssh","_id":"ck915p0t4008azkgrfrbupf1u"},{"name":"dropbear","_id":"ck915p0t4008czkgrmhxxs94v"},{"name":"Siege","_id":"ck915p0t5008gzkgre3mc59vf"},{"name":"Streaming","_id":"ck915p0t6008izkgrklzsbc0l"},{"name":"programmer","_id":"ck915p0t6008lzkgrii7gu6x5"},{"name":"work life","_id":"ck915p0t7008ozkgr6o4qnmbv"},{"name":"GICv2","_id":"ck915p105008uzkgr2a3f52jn"}]}}