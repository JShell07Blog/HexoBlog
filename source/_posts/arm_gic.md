---
title: arm gicv2
date: 2019-04-20 13:55:44
tags:
    - arm
    - spec
    - GICv2
categories:
    - arm
---

GICv2
<!--more-->
##1. Introduction
About the Generic Interrupt Controller architecture
The Generic Interrupt Controller (GIC) architecture defines:
• the architectural requirements for handling all interrupt sources for any processor connected to a GIC
• a common interrupt controller programming interface applicable to uniprocessor or multiprocessor systems

The architecture describes a GIC designed for use with one or more processors that comply with the ARM A and R
architecture profiles.

The GIC is a centralized resource for supporting and managing interrupts in a system that includes at least one
processor. It provides:
• registers for managing interrupt sources, interrupt behavior, and interrupt routing to one or more processors
• support for:
	— the ARM architecture Security Extensions
	— the ARM architecture Virtualization Extensions
	— enabling, disabling, and generating processor interrupts from hardware (peripheral) interrupt sources
	— Software-generated Interrupts (SGIs)
	— interrupt masking and prioritization
	— uniprocessor and multiprocessor environments
	— wakeup events in power-management environments.


The GIC includes interrupt grouping functionality that supports:
• configuring each interrupt as either Group 0 or Group 1
• signaling Group 0 interrupts to the target processor using either the IRQ or the FIQ exception request
• signaling Group 1 interrupts to the target processor using the IRQ exception request only
• a unified scheme for handling the priority of Group 0 and Group 1 interrupts
• optional lockdown of the configuration of some Group 0 interrupts.

fiq 优先级比 irq 高
fiq 模式下寄存器 比 irq 模式多（R8 ~ R12）
http://blog.chinaunix.net/attachment/201302/21/28458801_1361445566H9Z3.png

### 1.2. Security Extensions support
The ARM processor Security Extensions are an optional extension to the ARMv7-A architecture profile.

ARM Security Extensions facilitate the development of secure applications by:
• integrating hardware security features into the architecture
• providing Secure virtual memory space that is accessed by memory accesses in the Secure state
• providing Non-secure virtual memory space that is accessed by memory accesses in the Non-secure state.


When a GIC that implements the GIC Security Extensions is connected to a processor that implements the ARM
Security Extensions:
• Group 0(IRQ/FIQ) interrupts are Secure interrupts, and Group 1(IRQ) interrupts are Non-secure interrupts.

Processor security state and Secure and Non-secure GIC accesses：
• a processor in Non-secure state can make only Non-secure accesses to a GIC
• a processor in Secure state can make both Secure and Non-secure accesses to a GIC


### 1.3. Virtualization support
The ARM processor Virtualization Extensions are optional extensions to the ARMv7-A architecture profile. The GIC Virtualization Extensions provide mechanisms to minimize the hypervisor overhead of routing interrupts to virtual machines.

The processor Virtualization Extensions provide hardware support for virtualizing the Non-secure state of an
VMSAv7 implementation. The extensions support system use of a virtual machine monitor, known as the
hypervisor, to switch guest operating systems.

Whether implemented in a uniprocessor or in a multiprocessor system, the processor Virtualization Extensions
support running multiple virtual machines on a single processor.

The hypervisor can either handle a physical interrupt itself, or generate a corresponding virtual interrupt that is signaled to a virtual machine. It is also possible for the hypervisor to generate virtual interrupts that do not correspond to physical interrupts.

1) physical interrupt => virtual machine => virtual interrupt （产生与硬件相应的虚拟中断）
2) virtual machine => virtual interrupt （也可以产生与硬件中断没有关的虚拟中断）

### 1.4. Terminology （专用名词）
#### 1.4.1. Interrupt states
Inactive			An interrupt that is not active or pending.

Pending 			An interrupt from a source to the GIC that is recognized as asserted in hardware, or
					generated by software, and is waiting to be serviced by a target processor.

Active 				An interrupt from a source to the GIC that has been acknowledged by a processor, and is
					being serviced but has not completed.

Active and pending 	A processor is servicing the interrupt and the GIC has a pending interrupt from the same
source.


#### 1.4.2. Interrupt types

Peripheral interrupt
		
		Private Peripheral Interrupt (PPI)
		This is a peripheral interrupt that is specific to a single processor.

		Shared Peripheral Interrupt (SPI)
		This is a peripheral interrupt that the Distributor can route to any of a specified
		combination of processors.

		Each peripheral interrupt is either:
		Edge-triggered
			This is an interrupt that is asserted on detection of a rising edge of an interrupt
			signal and then, regardless of the state of the signal, remains asserted until it is
			cleared by the conditions defined by this specification.

		Level-sensitive
			This is an interrupt that is asserted whenever the interrupt signal level is active,
			and deasserted whenever the level is not active.

Software-generated interrupt (SGI)
		This is an interrupt generated by software writing to a GICD_SGIR register in the GIC.The
		system uses SGIs for interprocessor communication.

		When an SGI occurs in a multiprocessor implementation, the CPUID field in the Interrupt
		Acknowledge Register, GICC_IAR, or the Aliased Interrupt Acknowledge Register,
		GICC_AIAR, identifies the processor that requested the interrupt.

		__An SGI has edge-triggered properties__. （边缘触发）

		In an implementation that includes the GIC Virtualization Extensions:
		• when an SGI occurs, management registers in the GIC virtualization Extensions
		enable the requesting processor to be reported to the Guest OS, as required by the
		GIC specifications
		• by writing to the management registers in the GIC Virtualization Extensions, a
		hypervisor can generate a virtual interrupt that appears to a virtual machine as an SGI.

Virtual interrupt 
	In a GIC that implements the GIC Virtualization Extensions, an interrupt that targets a
	virtual machine running on a processor, and is typically signaled to the processor by the
	connected virtual CPU interface.		

Maintenance interrupt
	In a GIC that implements the GIC Virtualization Extensions, a level-sensitive interrupt that
	is used to signal key events, such as a particular group of interrupts becoming enabled or
	disabled. See Maintenance interrupts on page 5-164 for more information.	

#### 1.4.3. Models for handling interrupts

1-N model 常规硬件中断，单个的SPI， PPI
	Only one processor handles this interrupt. The system must implement a mechanism to determine
	which processor handles an interrupt that is programmed to target more than one processor.

N-N model 主要SGI， SPI可能会出现
	All processors receive the interrupt independently. When a processor acknowledges the interrupt,
	the interrupt pending state is cleared only for that processor. The interrupt remains pending for the
	other processors.

#### 1.4.4. Spurious interrupts （假的中断）
It is possible that an interrupt that the GIC has signaled to a processor is no longer required.If this happens, when
the processor acknowledges the interrupt, the GIC returns a special Interrupt ID(1020 ~ 1023) that identifies the interrupt as a
spurious interrupt.

Example reasons for spurious interrupts are:
• prior to the processor acknowledging an interrupt:
— software changes the priority of the interrupt
— software disables the interrupt
— software changes the processor that the interrupt targets
• for a 1-N interrupt, another target processor has previously acknowledged that interrupt.


## 2. GIC Partitioning

### 2.1 About GIC partitioning
The GIC architecture splits logically into a Distributor block and one or more CPU interface blocks. The GIC
Virtualization Extensions add one or more virtual CPU interfaces to the GIC.

GIC 架构有1个GIC Distributor, 一个或多个CPU Interface， 一个或多个virtual CPU interface（GIC Virtualization Extensions support）

Distributor 
	The Distributor block performs interrupt prioritization and distribution to the CPU interface
	blocks that connect to the processors in the system.
	The Distributor block registers are identified by the GICD_ prefix.

CPU interfaces 
	Each CPU interface block performs priority masking and preemption handling for a
	connected processor in the system.

	When describing a GIC that includes the GIC Virtualization Extensions, a CPU interface is
	sometimes called a physical CPU interface, to avoid possible confusion with a virtual CPU
	interface.

	CPU interface block registers are identified by the GICC_ prefix.

Virtual CPU interfaces	
	Each virtual CPU interface is partitioned into the following blocks:
	
	Virtual interface control
		The main component of the virtual interface control block is the GIC virtual
		interface control registers, that include a list of active and pending virtual
		interrupts for the current virtual machine on the connected processor. 
		
		Typically, these registers are managed by the hypervisor that is running on that processor.
		
		Virtual interface control block registers are identified by the GICH_ prefix.
	
	Virtual CPU interface
		Each virtual CPU interface block provides physical signaling of virtual
		interrupts to the connected processor. The ARM processor Virtualization
		Extensions signal these interrupts to the current virtual machine on that
		processor. 

		The GIC virtual CPU interface registers, accessed by the virtual
		machine, provide interrupt control and status information for the virtual
		interrupts. The format of these registers is similar to the format of the physical
		CPU interface registers.
		
		Virtual CPU interface block registers are identified by the GICV_ prefix.

 Note: The virtual CPU interface does not support the power management functionality described


 A GIC can implement up to eight CPU interfaces, numbered from 0-7.
 In a GIC that implements the GIC Virtualization Extensions, virtual CPU interface numbering corresponds to the CPU interface numbering, so that
CPU interface 0 and virtual CPU interface 0 connect to the same processor.

一个GIC 最多支持8个CPU， 而 physical CPU interface 与virtual CPU interface 个数对应一样多。


FixMe： 补上GIC logical partitioning

### 2.2. The Distributor

The Distributor provides a programming interface for:
	• Globally enabling the forwarding of interrupts to the CPU interfaces.
	• Enabling or disabling each interrupt.
	• Setting the priority level of each interrupt.
	• Setting the target processor list of each interrupt.
	• Setting each peripheral interrupt to be level-sensitive or edge-triggered.
	• Setting each interrupt as either Group 0 or Group 1.
	• Forwarding an SGI to one or more target processors.
In addition, the Distributor provides:
	• visibility of the state of each interrupt
	• a mechanism for software to set or clear the pending state of a peripheral interrupt.

#### 2.2.1 Interrupt IDs
GICv2 - The GIC assigns interrupt ID numbers ID0-ID1019 as follows:
	具有唯一标示
	SPI: 32 ~ 1019 

	banked interrupt 可重入或重复的中断， 每个CPU 的中断号可相同
	PPI: 16 ~ 31
	SGI: 0 ~ 15
In any system that implements the ARM Security Extensions, to support a consistent model for message passing
between processors, ARM strongly recommends that all processors reserve:
	• ID0-ID7 for Non-secure interrupts
	• ID8-ID15 for Secure interrupts.

Interrupt numbers ID1020-ID1023	are reserved for special purposes,

### 2.3. CPU interfaces
Each CPU interface block provides the interface for a processor that is connected to the GIC.
	• enabling the signaling of interrupt requests to the processor
	• acknowledging an interrupt
	• indicating completion of the processing of an interrupt
	• setting an interrupt priority mask for the processor
	• defining the preemption policy for the processor
	• determining the highest priority pending interrupt for the processor.

GCI CPU interfaces是否拉起中断信号给处理器流程
Signal interrupt request flow:
	take the highest priorty pending interrupt(read GICC_HPPIR) -> check interrupt priority mask and the preemption settings ->
	signal or ignore interrupt request

CPU获取中断ID
The processor acknowledges the interrupt request by reading the CPU interface Interrupt Acknowledge Register.
This read returns one of:
	• The ID number of the highest priority pending interrupt, if that interrupt is of sufficient priority for it to be
	signaled to the processor. This is the normal response to an interrupt acknowledge.
	• Exceptionally, an ID number that indicates a spurious interrupt(1020 ~ 1023)

中断处理完成后
There are two stages to interrupt completion:
	• priority drop, meaning the priority of the processed interrupt can no longer prevent the signaling of another
	interrupt to the processor
	• interrupt deactivation, meaning the Distributor removes the active state of the interrupt.

In a GICv1 implementation, these two stages always happen together, when the processor writes to the CPU
interface End of Interrupt register.

In a GICv2 implementation, the GICC_CTLR.EOImode bit determines whether:
	• the two stages happen together, when the processor writes to the CPU interface End of Interrupt register
	• the two stages are separated, so that:
		— priority drop happens when the processor writes to the CPU interface End of Interrupt register
		— interrupt deactivation happens later, when the processor writes to the CPU interface Deactivate
		Interrupt register.	

#### 2.3.1 Interrupt signal bypass, and GICv2 bypass disable
In all GIC implementations, a CPU interface optionally includes interrupt signal bypass, so that, when the signaling
of an interrupt by the interface is disabled, a system legacy interrupt signal is passed to the interrupt request input
on the processor, bypassing the GIC functionality.
中断信号旁路，主要支援legacy interrupt 不会受到CPU interface disable的影响，GICv2 must also provide disable bits for the interrupt
signal bypass operation.

FixMe 增加Interrupt signal bypass, GICv1 without Security Extensions 图片

#### 2.3.2 Power management, GIC v2
The GICv2 architecture supports wakeup events in implementations that require power management.
These signals are available even when both interrupt signaling by the GIC, and interrupt bypass, are disabled.

为软件提供预留或回复状态寄存器
the GICC_APRn registers provide support for preserving and restoring state in power-management
applications
However, to ensure that Non-secure accesses do not interfere with Secure operation, Secure and
Non-secure copies of these registers are provided.


### 3 Interrupt Handling and Prioritization
#### 3.1 About interrupt handling and prioritization
Interrupt handling describes:
	• how the GIC recognizes interrupts
	• how software can program the GIC to configure and control interrupts
	• the state machine the GIC maintains for each interrupt on each CPU interface
	• how the exception model of a processor interacts with the GIC.

Prioritization describes:
	• the configuration and control of interrupt priority
	• the order of execution of pending interrupts
	• the determination of when interrupts are visible to a target processor, including:
		— interrupt priority masking
		— priority grouping
		— preemption of an active interrupt.


all implementations of the GIC architecture support interrupt grouping. With interrupt grouping:
	• by default, all interrupts are Group 0 interrupts, and are signaled to a connected processor using the IRQ
	interrupt request
	• each interrupt can be configured as Group 1 interrupt, or as a Group 0 interrupt
	• a CPU interface can be configured to signal Group 0 interrupts to a connected processor using the FIQ
	interrupt request.	


##### 3.1.1 About interrupt handling and prioritization

可以参看 1.4.2. Interrupt types节
中断类型主要有四种：
物理中断：SPI，PPI （可边缘，电平触发）
软中断：SGI
虚拟中断：virtual interrupt
维护中断：maintenance interrupt (电平触发)，用于发送key events(具备virtualization extensions GIC)


参看 1.4.3. Models for handling interrupts 节
SGI 使用GIC N-N模型
物理中断 SPI，PPI 使用GIC 1-N 模型

##### 3.1.2 Identifying the supported interrupts
中断号的分段参看2.2.1 Interrupt IDs节

软件获知enable 中断
Software can use the GICD_ISENABLERns to discover what interrupt IDs are supported by the GIC。

GICD_ISENABLER0 provides the Set-enable bits for both:
	• SGIs, using interrupt IDs 15-0, corresponding to register bits [15:0]
	• PPIs, using interrupt IDs 31-16, corresponding to register bits [31:16].

The remaining GICD_ISENABLERns, from GICD_ISENABLER1, provide the Set-enable bits for the SPIs,
starting at interrupt ID 32.

Software discovers the interrupts that are supported by:
1. Reading the GICD_TYPER. The GICD_TYPER.ITLinesNumber field identifies the number of implemented
GICD_ISENABLERns, and therefore the maximum number of SPIs that might be supported. （获取supported interrupt 总数）
2. Writing to the GICD_CTLR to disable forwarding of interrupts from the distributor to the CPU interfaces.
For more information, see Enabling and disabling the Distributor and CPU interfaces on page 4-77.
3. For each implemented GICD_ISENABLERn, starting with GICD_ISENABLER0:
	• Writing 0xFFFFFFFF to the GICD_ISENABLERn.
	• Reading the value of the GICD_ISENABLERn. Bits that read as 1 correspond to supported interrupt IDs.	

永久使能中断
Software uses the GICD_ICENABLERns to discover the interrupts that are permanently enabled. For each
implemented GICD_ICENABLERn, starting with GICD_ICENABLER0, software:
1. Writes 0xFFFFFFFF to the GICD_ICENABLERn. This disables all interrupts that can be disabled.
2. Reads the value of the GICD_ICENABLERn. Bits that read as 1 correspond to interrupts that are
permanently enabled.
3. Writes 1 to any GICD_ISENABLERn bits corresponding to interrupts that must be re-enabled.	

The GIC implements the same number of GICD_ISENABLERns and GICD_ICENABLERns.

#### 3.2 General handling of interrupts
中断状态分为：(detail see 3.2.4 Interrupt handling state machine)
 - inactive
 - pending
 - active
 - active and pending

Group, security extension 中断参看 3.4 The effect of interrupt grouping on interrupt handling
virtualization extension 中断处理参看 5 GIC Support for Virtualization.

通用中断处理流程：
When the GIC recognizes an interrupt request, it marks its state as pending. Regenerating a pending interrupt does
not affect the state of the interrupt.

The GIC interrupt handling sequence is:
1. The GIC determines the interrupts that are enabled.
2. For each pending interrupt, the GIC determines the targeted processor or processors.
3. For each CPU interface, the Distributor forwards the highest priority pending interrupt that targets that
interface.
4. Each CPU interface determines whether to signal an interrupt request to its processor, and if required, does so.
5. The processor acknowledges the interrupt, and the GIC returns the interrupt ID and updates the interrupt
state.
6. After processing the interrupt, the processor signals End of Interrupt (EOI) to the GIC.

In more detail, these steps are as follows:
1. The GIC determines whether each interrupt is enabled. An interrupt that is not enabled has no effect on the GIC.

2. For each enabled interrupt that is pending, the Distributor determines the targeted processor or processors.

3. For each processor, the Distributor determines the highest priority pending interrupt, based on the priority information it holds for each interrupt, and forwards the interrupt to the targeted CPU interfaces.

4. If the distributor is forwarding an interrupt request to a CPU interface, the CPU interface determines whether the interrupt has Sufficient priority to be signaled to the processor. If the interrupt has sufficient priority, the GIC signals an interrupt request to the processor.

5. When a processor takes the interrupt exception, it reads the GICC_IAR of its CPU interface to acknowledge the interrupt. This read returns an Interrupt ID, and for an SGI, the source processor ID, that the processor uses to select the correct interrupt handler. When it recognizes this read, the GIC changes the state of the interrupt as follows:
	• if the pending state of the interrupt persists when the interrupt becomes active, or if the interrupt is generated again, from pending to active and pending.
	• otherwise, from pending to active

		Note:
		• A level-sensitive peripheral interrupt persists when it is acknowledged by the processor, because the
		interrupt signal to the GIC remains asserted until the Interrupt Service Routine (ISR) running on the
		processor accesses the peripheral asserting the signal.
		• In a multiprocessor implementation, the GIC handles:
			— PPIs and SGIs using the GIC N-N model, where the acknowledgement of an interrupt by one
			processor has no effect on the state of the interrupt on other CPU interfaces
			— SPIs using the GIC 1-N model, where the acknowledgement of an interrupt by one processor
			removes the pending status of the interrupt on any other targeted processors, see Implications
			of the 1-N model on page 3-41.
		• In GICv2, when using a software model with the GICC_CTLR.AckCtl bit set to 0, separate registers
		are used to manage Group 0 and Group 1 interrupts, as follows:
			— GICC_IAR, GICC_EOIR, and GICC_HPPIR for Group 0 interrupts
			— GICC_AIAR, GICC_AEOIR, and GICC_AHPPIR for Group 1 interrupts.
		ARM deprecates the use of GICC_CTLR.AckCtl, and strongly recommends using a software model
		where GICC_CTLR.AckCtl is set to 0, see [3.4.3 The effect of interrupt grouping on interrupt acknowledgement]

6. When the processor has completed handling the interrupt, it must signal this completion to the GIC. As
described in [3.2.1 Priority drop and interrupt deactivation], this: (通知GIC， EOI 并改写状态到inactive)
	• always requires a valid write to an end of interrupt register (EOIR)
	• might also require a subsequent write to the deactivate interrupt register, GICC_DIR.	

写向EOIR 的值是从GICC_IAR 或 GICC_AIAR得到的最近处理的中断号
For each CPU interface, the GIC architecture requires the order of the valid writes to an EOIR to be the
reverse of the order of the reads from the GICC_IAR or GICC_AIAR, so that each valid EOIR write refers
to the most recent interrupt acknowledge.

A CPU interface never signals to the connected processor any interrupt that is active and pending. It only
signals interrupts that are pending and have sufficient priority:
	• For PPIs and SGIs, the active status of particular interrupt ID is banked between CPU interfaces. This
	means that if a particular interrupt ID is active or active and pending on a CPU interface, then no
	interrupt with that same ID is signaled on that CPU interface.
	• For SPIs, the active status of an interrupt is common to all CPU interfaces. This means that if an
	interrupt is active or active and pending on one CPU interface then it is not signaled on any CPU
	interface.


#### 3.2.1 Priority drop and interrupt deactivation
When a processor completes the processing of an interrupt, it must signal this completion to the GIC. Interrupt
completion requires the following changes to the GIC state:

Priority drop 
Priority drop is the drop in the Running priority that occurs on a valid write to an EOIR, either the
GICC_EOIR or the GICC_AEOIR.

Interrupt deactivation
Interrupt deactivation is the change of the state of an interrupt, either:
	• from active and pending, to pending
	• from active, to idle

在GICv1 中Priority drop  与	Interrupt deactivation 是同时的。在GICv2 中可以设定setting GICC_CTLR.EOImode to 1 separates the priority drop and interrupt deactivation operations， and interrupt handling software must:
	1. Perform a valid EOIR write, to cause priority drop on the GIC CPU interface.
	2. Subsequently, write to the GICC_DIR, to deactivate the interrupt.


The GIC architecture specification requires that valid EOIR writes are ordered, so that:
• a valid GICC_EOIR write corresponds to the most recently acknowledged interrupt
• a valid GICC_AEOIR write corresponds to the most recently acknowledged Group 1 interrupt.
• whether a GICC_EOIR write affects Group 0 or Group 1 interrupts depends on both:
	— the value of the GICC_CTLR. AckCtl bit
	— if the GIC implements the GIC Security Extensions, whether the write is Secure or Non-secure.

Note：
In a GICv2 implementation that includes the Security Extensions:
• GICC_AEOIR is an alias of the Non-secure copy of GICC_EOIR
• GICC_AIAR is an alias of the Non-secure copy of GICC_IAR
• GICC_AIAR and GICC_AEOIR are Secure registers, meaning they are accessible only by Secure accesses.

#### 3.2.2 Interrupt controls in the GIC

**Interrupt enables**
For peripheral interrupts, a processor:
• enables an interrupt by writing to the appropriate GICD_ISENABLERn bit
• disables an interrupt by writing to the appropriate GICD_ICENABLERn bit.

**Setting and clearing pending state of an interrupt**
For peripheral interrupts, a processor can:
• set the pending state by writing to the appropriate GICD_ISPENDRn bit
• clear the pending state by writing to the appropriate GICD_ICPENDRn bit.

For a level-sensitive interrupt:
• If the hardware signal of an interrupt is asserted when a processor writes to the corresponding
GICD_ICPENDRn bit then the write to the register has no effect on the pending state of the interrupt.
• If a processor writes a 1 to an GICD_ISPENDRn bit then the corresponding interrupt becomes pending
regardless of the state of the hardware
more detail see [Control of the pending status of level-sensitive interrupts]

For SGIs, the GIC ignores writes to the corresponding GICD_ISPENDRn and GICD_ICPENDRn bits. A processor
cannot change the state of a software-generated interrupt by writing to these registers. 
Typically, an SGI is made pending by writing to the GICD_SGIR. In GICv2, the pending state of SGIs can also be modified directly using the
GICD_SPENDSGIRn and GICD_CPENDSGIRn bits.

**Finding the active or pending state of an interrupt**
A processor can find:
• the pending state of an interrupt by reading the corresponding GICD_ISPENDRn or GICD_ICPENDRn bit
• the active state of an interrupt by reading the corresponding GICD_ISACTIVERn or GICD_ICACTIVERn
bit.

In GICv2, the processor that issues the SGI can also be determined by reading the
corresponding GICD_SPENDSGIRn or GICD_CPENDSGIRn bits.

**Generating an SGI**
A processor generates an SGI by writing to an GICD_SGIR. 
The GICD_SGIR includes optimization for:
• interrupting only the processor that writes to the GICD_SGIR
• interrupting all processors other than the one that writes to the GICD_SGIR.

GICD_SGIR 大致包含:
• interrupt ID
• source processor
• target processor.

SGIs from different processors use the same interrupt IDs. Therefore, any target processor can receive SGIs with
the same interrupt ID from different processors.

Only one interrupt with a specific interrupt ID can be active on a CPU interface at any time. This means that a CPU
interface cannot have two SGIs with the same interrupt ID active at the same time, even if different processors have
signaled SGIs with the same interrupt ID to that processor.

On the CPU interface of the target processor, reading the GICC_IAR for an SGI returns both the interrupt ID and
the CPU ID of the processor that generated the interrupt, the source processor for the interrupt.The combination of
interrupt ID and source CPU ID uniquely identifies the interrupt to the target processor.

In a multiprocessor implementation, the interrupt priority of each SGI interrupt ID is defined independently for each
target processor。
**For each CPU interface, all SGIs with a particular interrupt ID that are pending on that interface have the same priority and must be handled serially.**

##### 3.2.3 Implications of the 1-N model
__when the GIC recognizes an interrupt acknowledge from one of the target processors it clears the pending state of the interrupt on all the other targeted processors.__ A GIC implementation must ensure that any interrupt being handled using the 1-N model is only acknowledged by one CPU interface, and that all other interfaces return a spurious
interrupt ID.

When multiple target processors attempt to acknowledge the interrupt, the following can occur:
• A processor reads the GICC_IAR and obtains the interrupt ID of the interrupt to be serviced.
	Note:  (在多核情况下，通过share memory, lock形式，确保只有一个core 处理中断)
	In GICv1, more than one target processor might have obtained this interrupt ID, if the processors read their
	GICC_IAR registers at very similar times. The system might require software on the target processors to
	ensure that only one processor runs its interrupt service routine. A typical mechanism to achieve this is
	implementing, in shared memory, a lock on the interrupt service routine (ISR).

• __A processor reads the GICC_IAR and obtains the interrupt ID 1023, indicating a spurious interrupt. The processor can return from its interrupt service routine without writing to its GICC_EOIR.__
__The spurious interrupt ID indicates that the original interrupt is no longer pending, typically because another target processor is handling it.__

Note
	• A GICv1 implementation might ensure that only one processor can make a 1-N interrupt active, removing
	the requirement for a lock on the ISR. This is not required by the architecture, and generic GIC code must
	not rely on this behavior.（GICv1 不要求在ISR 中lock）
	• For any processor, if an interrupt is active and pending, the GIC does not signal an interrupt exception request
	for the interrupt to any processor until the active status is cleared. （如果中断是active且pending 状态，GIC 不会触发此中断给任何processor 直到active 状态清除）

##### 3.2.3 Interrupt handling state machine

Fixme 【中断状态机】

**Transition A1 or A2, add pending state**
For an SGI, occurs if either:
• Software writes to a GICD_SGIR that specifies the processor as a target.
• Software on the target processor writes to the GICD_SPENDSGIRn bit that corresponds to
the required source processor and interrupt ID

For an SPI or PPI, occurs if either:
• a peripheral asserts an interrupt request signal
• software writes to an GICD_ISPENDRn

**Transition B1 or B2, remove pending state**
For an SGI, occurs if software on the target processor writes to the relevant bit of the
GICD_CPENDSGIRn.

物理中断
- 电平触发，pending 会一直拉高直到处理
- 边缘触发，写GICD_ICPENDRn 寄存器清pending 状态

For an SPI or PPI, occurs if either:
• the level-sensitive interrupt is pending only because of the assertion of an input signal, and
that signal is deasserted
• the interrupt is pending only because of the assertion of an edge-triggered interrupt signal, or
a write to an GICD_ISPENDRn, and software writes to the corresponding
GICD_ICPENDRn.

**Transition C, pending to active**
If the interrupt is enabled and of Sufficient priority to be signaled to the processor, occurs when
software reads from the GICC_IAR.

**Transition D, pending to active and pending**
For an SGI, this transition occurs in either of the following circumstances:
• If a write to set the SGI state to pending occurs at approximately the same time as a read of
GICC_IAR.
• When two or more pending SGIs with the same interrupt ID originate from the same source
processor and target the same processor. If one of the SGIs follows transition C, the other
SGIs follow transition D

For an SPI or PPI this transition occurs if all the following apply:
• The interrupt is enabled.
• Software reads from the GICC_IAR. This read adds the active state to the interrupt.
• In addition, one of the following conditions applies:
	— For a level-sensitive interrupt, the interrupt signal remains asserted. This is usually the
	case, because the peripheral does not deassert the interrupt until the processor has
	serviced the interrupt.
	— For an edge-triggered interrupt, whether this transition occurs depends on the timing
	of the read of the GICC_IAR relative to the detection of the reassertion of the interrupt.
	Otherwise the read of the GICC_IAR causes transition C, possibly followed by
	transition A2.

**Transition E1 or E2, remove active state**
Occurs when software deactivates an interrupt by writing to either GICC_EOIR or GICC_DIR.In a GIC
implementation the includes the Virtualization Extensions, also occurs if the virtual CPU interface
signals that the corresponding physical interrupt has been deactivated	

#### 3.3 Interrupt prioritization
Software configures interrupt prioritization in the GIC by assigning a priority value to each interrupt source. Priority
values are 8-bit unsigned binary.A GIC supports a minimum of 16 and a maximum of 256 priority levels. If the
GIC implements fewer than 256 priority levels, low-order bits of the priority fields are RAZ/WI.
In the GIC prioritization scheme, lower numbers have higher priority,

| Implemented priority bits | Possible priority field values | Number of priority levels |
|:-:|:-:|:-:|
|[7:0] | 0x00-0xFF (0-255), all values | 256 |
|[7:1] | 0x00-0xFE, (0-254), even values only | 128 |
|[7:2] | 0x00-0xFC (0-252), in steps of 4 | 64 |
|[7:3] | 0x00-0xF8 (0-248), in steps of 8 | 32 |
|[7:4] | 0x00-0xF0 (0-240), in steps of 16 | 16 |

**The GICD_IPRIORITYRn registers hold the priority value for each supported interrupt.**

To determine the number of priority bits implemented, software can write 0xFF to a writable GICD_IPRIORITYRn
priority field, and read back the value stored.
Note:
ARM recommends that, before checking the priority range in this way:
• for a peripheral interrupt, software first disables the interrupt
• for an SGI, software first checks that the interrupt is inactive

##### 3.3.1 Preemption
A CPU interface supports signaling of higher priority pending interrupts to a target processor before an active
interrupt completes. A pending interrupt is only signaled if both:
• Its priority is higher than the priority mask for that CPU interface, see [Priority masking].
• Its group priority is higher than that of the Running priority on the CPU interface, see [Priority grouping] and[
Running Priority Register, GICC_RPR]

For a processor that complies with the ARM architecture:
	— The value of the I or F bit in the CPSR determines whether the processor responds to the signaled
	interrupt by starting the interrupt acknowledge procedure.
	— When processing a preempting interrupt, the processor must save and later restore the context of the
	previously active ISR.

##### 3.3.2 Priority masking
CPU Interface 选择高于中断阀门优先级的中断給处理器。
The GICC_PMR for a CPU interface defines a priority threshold.The GIC only signals
pending interrupts with a higher priority than this threshold value to the target processor. A value of zero, the register
reset value, masks all interrupts from being signaled to the associated processor. The GIC does not use priority
grouping when comparing the priority of a pending interrupt with the priority threshold.

##### 3.3.3 Priority grouping
一组相同优先级的中断。
Priority grouping uses the Binary Point Register, GICC_BPR, to split a priority value into two fields, the group
priority and the subpriority.When determining preemption, all interrupts with the same group priority are
considered to have equal priority, regardless of the subpriority. This means that there can only be one interrupt active
at each group priority. The active group priority is also known as the **Preemption level.**


主要是用过GICC_BPR 0~2 划分出 GICC_PMR 两个部分：Group priority field 和Subpriority field
FixME [Table 3-2 Priority grouping by binary point] 图片page 46

#### 3.4 The effect of interrupt grouping on interrupt handling
A GICv1 implementation that includes the GIC Security Extensions, or any GICv2 implementation, provides two
interrupt output signals for IRQ and FIQ exception requests:
• The CPU interface always uses the IRQ exception request for Group 1 interrupts
• Software can configure the CPU interface to use either IRQ or FIQ exception requests for Group 0 interrupts

##### 3.4.1 GIC interrupt grouping support
The GICD_IGROUPRn registers configure each interrupt as Group 0 or Group 1.

FixMe [CPU interface control of Group 0 and Group 1 interrupts, GICv2] 图片 Page48

In an implementation that includes the GIC Security Extensions, the alias registers:
• typically **represent aliases of the Non-secure copy of the Group 0 registers**, for example GICC_ABPR is an
alias of the Non-Secure copy of GICC_BPR
• are **accessible only by Secure accesses.**

In an implementation that supports interrupt grouping, GICC_CTLR contains additional fields, including fields to
control the handling of the grouped interrupts:
• Separate enable bits to control the signaling of Group 0 and Group 1 interrupts to the connected processor: （是否支持组中断）
	— bit[0], the Enable bit in a GIC that does not support interrupt grouping, becomes the EnableGrp0 bit,
	and controls whether Group 0 interrupts are signaled to the processor
	— the EnableGrp1 bit is added, to control whether Group 1 interrupts are signaled to the processor.
• The FIQEn bit, that controls whether the interface signals Group 0 interrupts to the processor using the IRQ
or FIQ interrupt request. （Group0 是否支持FIQ）
• The CBPR bit, that controls whether GICC_BPR or GICC_ABPR is used when determining possible
interrupt preemption by Group 1 interrupts, see [Control of preemption by Group 1 interrupts] （是否支持抢占）
• The AckCtl bit, that controls whether a read of the GICC_IAR, or the Secure GICC_IAR if the GIC
implements the Security Extensions, can acknowledge a Group 1 interrupt.（是否支持Group1 能从GICC_IAR 读取中断ID，value 0 读到1022保留中断号，否则真实值）

##### 3.4.2 Special interrupt numbers when a GIC supports interrupt grouping

1020-1021 Reserved.

1022 Used only if the GIC supports interrupt grouping.
The GIC returns this value to a processor in response to an interrupt acknowledge only when all of
the following apply:
• the interrupt acknowledge is a read of GICC_IAR
• the highest priority pending interrupt is a Group 1 interrupt
• GICC_CTLR.AckCtl is set to 0
• the priority of the interrupt is sufficient for it to be signaled to the processor.
	Note:
	• Interrupt ID 1022 indicates that there is a Group 1 interrupt of sufficient priority to be
	signaled to the processor, that must be acknowledged by a read of the GICC_AIAR, or in an
	implementation that includes the GIC Security Extensions, by a read of the Non-secure
	GICC_IAR.

1023 This value is returned to a processor, in response to an interrupt acknowledge, if there is no pending
interrupt with sufficient priority for it to be signaled to the processor.
On a processor that supports interrupt grouping, values of 1022 and 1023 are spurious interrupt IDs.

##### 3.4.3 The effect of interrupt grouping on interrupt acknowledgement

**When the GICC_CTLR.AckCtl bit is set to 0, to ensure system correctness, every Group 0 interrupt must have a higher priority than any Group 1 interrupt.**

When the GICC_CTLR.AckCtl bit is set to 1, a read of GICC_IAR acknowledges the highest-priority pending
interrupt on the CPU interface, regardless of whether it is a Group 0 or a Group 1 interrupt. （ARM 极不推荐GICC_CTLR.AckCtl 设定为1）

In a GIC implementation that supports interrupt grouping, ARM strongly recommends setting GICC_CTLR.AckCtl
to 0, meaning:
• for a GICv2 implementation:
	— a group 0 interrupt is acknowledged by a read of GICC_IAR, or a Secure read of GICC_IAR if the
	implementation includes the GIC Security Extensions
	— a group 1 interrupt is acknowledged by a read of GICC_AIAR, or a Non-secure read of GICC_IAR if
	the implementation includes the GIC Security Extensions
• for a GICv1 implementation:
	— a group 0 interrupt must be acknowledged by a read of the Secure GICC_IAR
	— a group 1 interrupt must be acknowledged by a read of Non-secure GICC_IAR.

If the Interrupt Acknowledge register access does not correspond to the highest-priority pending interrupt on the CPU interface then:
• a read of GICC_IAR when the highest-priority pending interrupt is a Group 1 interrupt returns the spurious
interrupt value 1022
• a read of GICC_AIAR when the highest-priority pending interrupt is a Group 0 interrupt returns the spurious
interrupt value 1023.

##### 3.4.4 GIC power on or reset configuration
On power-up, or after a reset, a GIC implementation that supports interrupt grouping is configured with:
• all interrupts assigned to Group 0
• the FIQ exception request disabled.

FixMe [Reset configuration of a GIC that includes the FIQ exception request]  图片 page52

#### 3.5 Interrupt grouping and interrupt prioritization
ARM strongly recommends that:
	• Group 0 interrupts are always assigned priority values in the lower half of the supported priority value range.
	These values correspond to the higher-priority interrupts
	• Group 1 interrupts are always assigned priority values in the upper half of the supported priority value range.
	These values correspond to the lower-priority interrupts.

This ensures that every Group 1 interrupt is of lower priority than any Group 0 interrupt.

##### 3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions
When a processor reads the priority value of a Group 1 interrupt, the GIC returns either the Secure or the Non-secure
view of that value, depending on whether the access is Secure or Non-secure.

This is for a GIC that implements the maximum range of priority values.
FixMe [Figure 3-7 Software views of the priorities of Group 1 and Group 0 interrupts]图片 Page55

FixMe [Table 3-6 Effect of not implementing some priority field bits, with GIC Security Extensions]图片 Page56


**Recommendations for managing priority values**
ARM strongly recommends that:
• for a Group 0 interrupt, software sets bit [7] of the priority value field to 0
• if using a Secure write to set the priority of a Group 1 interrupt, software sets bit [7] of the priority value field
to 1.

##### 3.5.2 Control of preemption by Group 1 interrupts
When a GIC implementation supports interrupt grouping, the GICC_BPR is always used to determine whether a
Group 0 interrupt is signaled to the processor, for possible preemption.
By default, the GICC_ABPR is used to
determine whether a Group 1 interrupt is signaled for possible preemption.

However, when GICC_CTLR.CBPR is set to 1, GICC_BPR is used for determining possible preemption, for both Group 0 and Group 1 interrupts.

Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0 情况与 [Priority grouping] 类似

#### 3.6 Additional features of the GIC Security Extensions
Software can detect support for the GIC Security Extensions by reading the GICD_TYPER.SecurityExtn bit, see
Interrupt Controller Type Register, GICD_TYPER on page 4-88.

##### 3.6.1 Access from processors not implementing the ARM Security Extensions
When connecting a processor that does not support the ARM Security Extensions to a GIC that implements the GIC
Security Extensions, typically all processor accesses to the GIC are assigned as either Secure or Non-secure:
• For a processor making Secure accesses:
	— **The processor can control all aspects of the GIC, and therefore can make configuration changes that might affect Secure software running on other processors.**
	— In a GICv2 implementation, the processor **uses Secure accesses to aliased registers, such as the GICC_AIAR, to process Group 1 interrupts.**
	— Because GICv1 implementations do not include the aliased registers, if the implementation uses
	interrupt grouping the processor might have to use the deprecated GICC_CTLR.AckCtl bit to enable
	Group 1 interrupts to be processed using the standard CPU interface registers.

• For a processor making Non-secure accesses:
	— The processor cannot control Group 0 interrupts. For the GIC to be programmed, **the system implementation must include at least one processor that can make Secure accesses.**
	A system might use a Secure processor to perform Secure accesses on behalf of a Non-secure
	processor. This usage model is possible if the GIC or the system provides a method for the Secure
	processor to access processor-banked copies of registers that belong to the Non-secure processor.
	— To **permit a Non-secure processor to control its own Group 0 interrupts, a GICv2 implementation can implement the GICD_NSACRn registers.** An implementation of these registers might permit a Secure
	processor to permit the use of Non-secure accesses from a particular processor to control some aspects
	of the operation of some Group 0 SGIs and SPIs.
	— A GIC implementation can configure the GICD_IGROUPRn reset value so that interrupts are Group
	1 on reset. see GICD_IGROUPR0 reset value on page 4-92 for more information


#### 3.7 Pseudocode details of interrupt handling and prioritization
skip, see spec


#### 3.8 The effect of the Virtualization Extensions on interrupt handling
see Chapter 5 GIC Support for Virtualization

#### 3.9 Example GIC usage models

FixMe [Figure 3-8 Generic GIC usage model]图片page 68

##### 3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts
FixMe [Figure 3-9 Using the GIC to route Secure and Non-secure interrupts]图片page 69

shows a system that implements the GIC Security Extensions, connected to a processor that
implements the ARM processor Security Extensions. This implementation:
• uses Group 0 interrupts as Secure interrupts, signaled as FIQs
• uses Group 1 interrupts as Non-secure interrupts, signaled as IRQs.
This means that, on the processor, FIQ interrupts are never routed to Non-secure software, and IRQ interrupts are
never routed to Secure software.

Note：
The use of Group 0 and Group 1 interrupts to signal Secure interrupts as FIQs, and Non-secure interrupts as IRQs,
requires the processor to:
• **route FIQs to be taken in Secure Monitor mode**
• **prevent Non-secure software from masking FIQs**
• **ensure that IRQs are masked whenever it is operating in Secure state.**

On a GIC reset, all interrupts are assigned to Group 0, making them Secure interrupts. Secure software on the
processor:
• programs the GICD_IGROUPRn registers to indicate which interrupts are Group 1, Non-secure
• sets the Secure GICC_CTLR.FIQEn bit to 1 to configure the CPU interface to use FIQ for Group 0 interrupts.
• must enable Group 0 interrupts and Group 1 interrupts, independently, in the Distributor: （配置GIC）
	— GICD_CTLR.EnableGrp0 enables Group 0 interrupts
	— GICD_CTLR.EnableGrp1 enables Group 1 interrupts.
• must enable Group 0 interrupts and Group 1 interrupts, independently, in the CPU interface: （配置CPU Interface）
	— GICC_CTLR.EnableGrp0 enables Group 0 interrupts
	— GICC_CTLR.EnableGrp1 enables Group 1 interrupts.

##### 3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions	

FixMe [Figure 3-10 Using interrupt grouping to route IRQs and FIQs] Page70

On a GIC reset, for a GIC implementation that supports interrupt grouping, all interrupts are assigned to Group 0.
Therefore, to use this configuration, software executing on the processor must:
• Program the GICD_IGROUPRn registers to assign IRQ interrupts to Group 1.
• Set GICC_CTLR.FIQEn to 1, to assign Group 0 interrupts to FIQ.
• Set GICC_CTLR.AckCtl to 0, so that both FIQ and IRQ interrupts are acknowledged from the single address
space, using:
	— the GICC_IAR to acknowledge a Group 0 interrupt
	— the GICC_AIAR to acknowledge a Group 1 interrupt
	— the GICC_EOIR to indicate completion of a Group 0 interrupt
	— the GICC_AEOIR to indicate completion of a Group 1 interrupt.
However, GICC_AIAR and GICC_AEOIR are implemented only in a GICv2 implementation. A processor
operating with a GICv1 implementation might have to use the deprecated mode of operation with
GICC_CTLR.AckCtl set to 1(意味着GRP0 GRP1 都是用GICC_IAR, GICC_EOIR).
• Configure the required binary point support model, by either:
	— setting GICC_CTLR.CBPR to 0, so that Group 0 uses GICC_BPR, and Group 1 uses GICC_ABPR
	— setting GICC_CTLR.CBPR to 1, so that Group 0 and Group 1 use a common binary point register,
	GICC_BPR.

由于没有security, 我们只是人为的将IRQ 分配到GRP1中，将FIQ 分配到GRP0中。因此，并不需要使能GICD_CTLR.EnableGrp0/1 GICC_CTLR.EnableGrp0/1 来让GIC与CPU 支持真正的Group 即security，我们只是使用不同的寄存器
- GICC_IAR && GICC_AIAR获知ID
- GICC_EOIR && GICC_AEOIR 结束中断
- GICC_CTLR.CBPR && GICC_CTLR.ABPR 

##### 3.9.3 Supporting IRQs and FIQs in a virtualized processor environment	

Fixme [Figure 3-11 Using the GIC in a virtualized system] page72

• Secure software assigns:
	— Secure interrupts to Group 0, signaled to the processor as FIQs
	— Non-secure interrupts to Group 1, signaled to the processor as IRQs

• A hypervisor:
	— Implements a virtual distributor, using features of the Virtualization Extension on the GIC. This
	virtual distributor can virtualize IRQ interrupts from the GIC as Virtual IRQ and Virtual FIQ
	interrupts, that it routes to an appropriate virtual machine.
	— Routes physical IRQs to Hyp mode, so they can be serviced by the virtual distributor

• A Guest OS running on a virtual machine assigns interrupts to Group 0 or Group 1, to assign them as FIQs
or IRQs, using the model described in [Supporting IRQs and FIQs when not using the processor Security
Extensions]


When the GIC signals an IRQ to the processor, the interrupt is routed to Hyp mode. The hypervisor determines
whether the interrupt is for itself, or for a Guest OS. If it is for a Guest OS it determines:
• which Guest OS must handle the interrupt
• whether that Guest OS has configured the interrupt as an FIQ or as an IRQ
• the interrupt priority, based on the priority configuration by the target Guest OS.

Note:  (__Guest OS 可能不止一个__)
• On receiving an IRQ that cannot be handled by the current Guest OS, the hypervisor can either:
— transfer control to a Guest OS that can handle the interrupt
— mark the interrupt as pending, as part of the saved context of the appropriate Guest OS.
• A system can have some interrupts that can be handled by more that one Guest OS, and other interrupts that
must be routed to a specific Guest OS.


A Guest OS handles a virtual interrupt exactly as it would handle the corresponding physical interrupt. __The Guest OS cannot detect that it is handling a virtual interrupt rather than a physical interrupt.__

Guest OS 并不知道处理的是虚拟中断。

### 4. Programmers’ Model

#### 4.1.1 GIC register names
All of the GIC registers have names that provide a short mnemonic for the function of the register. In these names:
• the first three letters are GIC, indicating a GIC register
• the fourth letter is one of:
	— D, indicating a Distributor register
	— C, indicating a CPU interface register
	— H, indicating a virtual interface control register, typically accessed by a hypervisor
	— V, indicating a virtual CPU interface register.

Note：
Chapter 5 GIC Support for Virtualization describes the GICH_* and GICV_* registers.

#### 4.1.2 Distributor register map
Fixme [Table 4-1 Distributor register map] page74


#### 4.1.3 CPU interface register map
For a multiprocessor implementation, the GIC implements a set of CPU interface registers for each CPU interface.
__ARM strongly recommends that each processor has the same CPU interface base address for the CPU interface that connects it to the GIC. This is the private CPU interface base address for that processor.__

Fixme [Table 4-2 CPU interface register map] page76


#### 4.1.4 GIC register access
Note:
In the GIC architecture, all registers that are halfword-accessible or byte-accessible use a little endian memory order model.

If the GIC implements the GIC Security Extensions these affect register accesses as follows:
• some registers are banked, see Register banking
• some registers are accessible only using Secure accesses
• optionally, the GIC supports lockdown of the values of some registers


__Register banking__
Register banking refers to providing multiple copies of a register at the same address.

The GIC banks registers in the following cases:
• If the GIC implements the Security Extensions, some registers are banked to provide separate Secure and
Non-secure copies of the registers. The Secure and Non-secure register bit assignments can differ. A Secure
access to the register address accesses the Secure copy of the register, and a Non-secure access accesses the
Non-secure copy. 

• If the GIC is implemented as part of a multiprocessor system:
	— Some registers are banked to provide a separate copy for each connected processor. These __include the registers associated with PPIs and SGIs, and the GICD_NSACRn, when implemented.__
	— The GIC implements the CPU interface registers __independently for each CPU interface__, and each
	connected processor accesses these registers for the interface it connects to.

#### 4.1.5 Enabling and disabling the Distributor and CPU interfaces

__Implementations that support interrupt grouping__
In a GIC that supports interrupt grouping:
• the GICD_CTLR.EnableGrp0 bit 
• the GICD_CTLR.EnableGrp1 bit 
• the GICC_CTLR.EnableGrp0 bit
• the GICC_CTLR.EnableGrp1 bit 

For the Distributor:
• If the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits are both 0:
	— __the Distributor does not forward pending interrupts to the CPU interfaces__
	— it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the
	pending state.
	— __reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID__
	— software can read or write the Distributor registers
	— it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR

• If either, but not both, of the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits is set to 
	— GICD_CTLR.EnableGrp0 set to 0 and GICD_CTLR.EnableGrp1 set to 1, and the highest priority
	pending interrupt is in group 0
	— GICD_CTLR.EnableGrp0 set to 1 and GICD_CTLR.EnableGrp1 set to 0, and the highest priority
	pending interrupt is in group 1. (ARM 强烈不推荐这样，这样GRP0 优先级是小于GRP1)

__ARM strongly recommends that all Group 0 interrupts are assigned a higher priority than all Group 1 interrupts.__

For a CPU interface, when GICC_CTLR.AckCtl == 0:
• When GICC_CTLR.EnableGrp0 == 0
	— Group 0 interrupts forwarded from the Distributor are not signaled to the processor
	— any read of GICC_IAR returns a spurious interrupt ID
• When GICC_CTLR.EnableGrp0 == 1, Group 0 interrupts forwarded from the Distributor are signaled to the
processor.
• When GICC_CTLR.EnableGrp1 == 0
	— Group 1 interrupts forwarded from the Distributor are not signaled to the processor
	— any read of GICC_AIAR returns a spurious interrupt ID
• When GICC_CTLR.EnableGrp1 == 1, Group 1 interrupts forwarded from the Distributor are signaled to the
processor
• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt
of sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR
returns the ID of that interrupt, or a spurious interrupt ID

For a CPU interface, when GICC_CTLR.AckCtl == 1:
• When GICC_CTLR.EnableGrp1 == 0, any Non-secure read of GICC_IAR returns a spurious interrupt ID
• When GICC_CTLR.EnableGrp0 == 0:
— if GICC_CTLR.EnableGrp1 == 0, any Secure read of GICC_AIAR returns a spurious interrupt ID
— if GICC_CTLR.EnableGrp1 == 1, Group 0 interrupts are ignored and GICC_IAR behaves as
GICC_AIAR
• When GICC_CTLR.EnableGrp1 == 0, a Secure read of GICC_AIAR always returns a spurious interrupt ID
• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt
of sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR
returns the ID of that interrupt, or a spurious interrupt ID.

Note:
__ARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl is set to 0.__

---

__Implementations that do not support interrupt grouping__
In a GIC that does not support interrupt grouping:
• the GICD_CTLR.Enable bit controls the forwarding of interrupts from the Distributor to the CPU interfaces
• the GICC_CTLR.Enable bit controls the signaling of interrupts by the CPU interface to the connected processor.

For the Distributor:
• When GICD_CTLR.Enable is set to 1, the Distributor forwards the highest priority pending interrupt for each
CPU interface, subject to the prioritization rules.
• When GICD_CTLR.Enable is set to 0:
	— the Distributor does not forward pending interrupts to the CPU interfaces
	— it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the
	pending state.
	— reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID
	— software can read or write the Distributor registers
	— it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR.

For a CPU interface:
• When GICC_CTLR.Enable is set to 1, the highest priority pending interrupt forwarded from the Distributor
to the CPU interface is signaled to the connected processor
• When GICC_CTLR.Enable is set to 0:
	— any pending interrupts forwarded from the Distributor are not signaled to the processor
	— software can read or write the CPU interface registers
	— any read of the GICC_IAR returns a spurious interrupt ID
	— if the Distributor is forwarding an interrupt to the CPU interface, that the interface cannot signal
	because GICC_CTLR.Enable is set to 0, it is IMPLEMENTATION DEFINED whether a read of
	GICC_HPPIR returns the ID of that interrupt, or a spurious interrupt ID.

### 4.2 Effect of the GIC Security Extensions on the programmers’ model
If the GIC implements the Security Extensions, __the GICD_TYPER.SecurityExtn bit is RAO.__.

The GIC Security Extensions provide the following features:
• The GIC must support interrupt grouping.
• Register implementations that are consistent with those on a processor that implements the ARM Security
Extensions, with banked.

The ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition defines the following ARM Security
Extensions register types:
- __Banked__
	The device implements Secure and Non-secure copies of the register. The register bit assignments
	can differ in the Secure and Non-secure copies of a register. A Secure access always accesses the
	Secure copy of the register, and a Non-secure access always accesses the Non-secure copy.
		Note
		The GIC can also bank registers when implemented as part of a multiprocessor system, where
		registers associated with PPIs or SGIs are banked to provide a separate copy for each connected
		processor.
- __Secure__
	The register is accessible only from a Secure access. The address of a Secure register is RAZ/WI to
	any Non-secure access.
- __Common__
	The register is accessible from both Secure and Non-secure accesses. The access permissions of
	some or all fields in the register might depend on whether the access is Secure or Non-secure.

| Register 		| Type 		| Description | 
|:-------------:|:---------:|:-----------:|
| GICD_CTLR 	| Banked 	| Distributor Control Register | 
| GICD_TYPER 	| Common 	| Interrupt Controller Type Register| 
| GICD_IGROUPRn | Secure 	| Interrupt Group Registers | 
| GICD_SGIR 	| Common 	| Software Generated Interrupt Register | 
| GICC_CTLR 	| Banked 	| CPU Interface Control Register | 
| GICC_BPR 		| Banked 	| Binary Point Register | 
| GICC_ABPR 	| Secure 	| Aliased Binary Point Register | 
| GICC_AIAR 	| Secure 	| Aliased Interrupt Acknowledge Register | 
| GICC_AEOIR 	| Secure 	| Aliased End of Interrupt Register | 
| GICC_AHPPIR 	| Secure 	| Aliased Highest Priority Pending Interrupt Register | 
| GICC_NSAPRn 	| Secure 	| Non-secure Active Priorities Registers| 

#### 4.2.1 Non-secure access to register fields for Group 0 interrupt priorities

Non-secure access to a priority field in the GICD_IPRIORITYRn
If the priority field corresponds to a Group 1 interrupt, the access operates as defined by the
Non-secure view of interrupt priority, see[Software views of interrupt priority in a GIC that includes
the Security Extensions]

Non-secure access to the GICC_PMR and GICC_RPR
• If the current priority mask value is in the range 0x00-0x7F:
	— a read access returns the value 0x00
	— the GIC ignores a write access to the GICC_PMR.
• If the current priority mask value is in the range 0x80-0xFF:
	— A read access returns the Non-secure view of the current value.
	— A write access to the GICC_PMR succeeds, based on the Non-secure view of the
	priority mask value written to the register. This means a Non-secure write cannot set
	a priority mask value in the rage 0x00-0x7F.

#### 4.2.2 Configuration lockdown
This provides a control signal that the system can assert to prevent write access to:
• the register fields controlling a configured range of SPIs, when those SPIs are configured as Group 0
interrupts
• some configuration registers.

When the control signal is asserted, the affected register fields and registers are described as being locked down.
__Lockdown is controlled by an active HIGH disable signal, CFGSDISABLE__. That is, the system asserts
CFGSDISABLE HIGH to disable write access to the register fields and registers.

The SPIs that can be locked down are called lockable SPIs (LSPIs).
• The GICD_TYPER.LSPI field defines the maximum number of LSPIs. If GICD_TYPER.LSPI is greater
than 0 then the possible LSPIs have interrupt IDs 32 to (31+(GICD_TYPER.LSPI)).
	Note:
	GICD_TYPER.LSPI only defines the range of possible LSPIs. The GIC might not support all the interrupts
	in this range.

If GICD_TYPER.LSPI is 0 lockdown is not supported.

When the SPI control fields and configuration registers are locked down, the GIC prevents write accesses to:
• The EnableGrp0 bit of the Secure copy of GICD_CTLR.
• The following bits in the Secure copy of GICC_CTLR:
	— EOImodeS
	— IRQBypDisGrp0
	— FIQBypDisGrp0
	— CBPR
	— FIQEn
	— AckCtl
	— EnableGrp0
• Fields in the GICD_ISENABLERn, GICD_ICENABLERn, GICD_ISPENDRn, GICD_ICPENDRn,
GICD_ISACTIVERn, GICD_ICACTIVERn, GICD_IPRIORITYRn, GICD_ITARGETSRn, and
GICD_ICFGRn registers that correspond to Lockable SPIs that are configured as Group 0:
• Fields in the GICD_IGROUPRn registers that correspond to lockable SPIs that are configured as Group 0. If
a lockable SPI is reconfigured from Group 1 to Group 0 while CFGSDISABLE remains HIGH, the GIC
prevents any more writes to GICD_IGROUPRn fields that correspond to that SPI, and the SPI becomes
locked.	

#### 4.3 Distributor register descriptions
The following sections describe the Distributor registers:
• Distributor Control Register, GICD_CTLR on page 4-85
• Interrupt Controller Type Register, GICD_TYPER on page 4-88
• Distributor Implementer Identification Register, GICD_IIDR on page 4-90
• Interrupt Group Registers, GICD_IGROUPRn on page 4-91
• Interrupt Set-Enable Registers, GICD_ISENABLERn on page 4-93
• Interrupt Clear-Enable Registers, GICD_ICENABLERn on page 4-95
• Interrupt Set-Pending Registers, GICD_ISPENDRn on page 4-97
• Interrupt Clear-Pending Registers, GICD_ICPENDRn on page 4-99
• Interrupt Set-Active Registers, GICD_ISACTIVERn on page 4-102
• Interrupt Clear-Active Registers, GICD_ICACTIVERn on page 4-103
• Interrupt Priority Registers, GICD_IPRIORITYRn on page 4-104
• Interrupt Processor Targets Registers, GICD_ITARGETSRn on page 4-106
• Interrupt Configuration Registers, GICD_ICFGRn on page 4-109
• Non-secure Access Control Registers, GICD_NSACRn on page 4-111
• Software Generated Interrupt Register, GICD_SGIR on page 4-113
• SGI Clear-Pending Registers, GICD_CPENDSGIRn on page 4-115
• SGI Set-Pending Registers, GICD_SPENDSGIRn on page 4-117
• Identification registers on page 4-119.

##### 4.3.1 Distributor Control Register, GICD_CTLR
Enables the forwarding of pending interrupts from the Distributor to the CPU interfaces.

Fixme [Figure 4-1 GICD_CTLR bit assignments, GICv1 without Security Extensions or Non-secure]图片 Page85

Fixme [Figure 4-2 GICD_CTLR bit assignments, GICv2, and GICv1 Secure copy]图片 Page85

##### 4.3.2 Interrupt Controller Type Register, GICD_TYPER
Provides information about the configuration of the GIC. It indicates:
• whether the GIC implements the __Security Extensions__
• the __maximum number of interrupt IDs__ that the GIC supports
• the __number of CPU interfaces__ implemented
• if the GIC implements the Security Extensions, the __maximum number of implemented Lockable Shared Peripheral Interrupts (LSPIs)__.

Fixme [Figure 4-3 GICD_TYPER bit assignments] 图片Page88

[15:11]  LSPI 			If the GIC implements the Security Extensions, the value of this field is the maximum number of
						implemented lockable SPIs, from 0 (0b00000) to 31 (0b11111). If this field is 0b00000 then the GIC does not implement configuration lockdown. If the GIC does not implement the Security Extensions, this field is reserved.

[10] 	 SecurityExtn 	Indicates whether the GIC implements the Security Extensions.
							0  Security Extensions not implemented.
							1  Security Extensions implemented.					

[7:5]   CPUNumber 		Indicates the number of implemented CPU interfaces. The number of implemented CPU interfaces is
						one more than the value of this field, for example if this field is 0b011, there are four CPU interfaces. If
						the GIC implements the Virtualization Extensions, this is also the number of virtual CPU interfaces	

[4:0]  ITLinesNumber 	Indicates the maximum number of interrupts that the GIC supports.If ITLinesNumber=N, the
						maximum number of interrupts is 32 * (N+1). interrupt IDs 1020-1023 are reserved for
						special purposes

The ITLinesNumber field only indicates the maximum number of SPIs that the GIC might support. This value
determines the number of implemented interrupt registers, that is, the number of instances of the following registers:
• GICD_IGROUPRn
• GICD_ISENABLERn
• GICD_ICENABLERn
• GICD_ISPENDRn
• GICD_ICPENDRn
• GICD_ISACTIVERn
• GICD_IPRIORITYRn
• GICD_ITARGETSRn
• GICD_ICFGRn.

##### 4.3.3 Distributor Implementer Identification Register, GICD_IIDR
Provides information about the implementer and revision of the Distributor.
主要用于记录GIC 的产品ID， 变体ID， 实现公司ID
Fixme [Figure 4-4 GICD_IIDR bit assignments] 图片Page90

##### 4.3.4 Interrupt Group Registers, GICD_IGROUPRn
The GICD_IGROUPR registers provide a status bit for each interrupt supported by the GIC.
Each bit controls whether the corresponding interrupt is in Group 0 or Group 1.
Fixme [Figure 4-5 GICD_IGROUPR bit assignments] 图片Page91

[31:0] Group status bits， For each bit:
	0 The corresponding interrupt is Group 0.
	1 The corresponding interrupt is Group 1.

__Reset Value__
On start-up or reset, each interrupt with ID32 or higher resets as Group 0 and therefore all SPIs are Group 0.

##### 4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn
The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.
Writing 1 to a Set-enable bit enables forwarding of the corresponding interrupt from the
Distributor to the CPU interfaces. Reading a bit identifies whether the interrupt is enabled.

These registers are available in all configurations of the GIC. If the GIC implements the
Security Extensions these registers are Common

In a multiprocessor implementation, GICD_ISENABLER0 is banked for each connected
processor. This register holds the Set-enable bits for interrupts 0-31.

##### 4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn
The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the
GIC. Writing 1 to a Clear-enable bit disables forwarding of the corresponding interrupt from
the Distributor to the CPU interfaces.

In a multiprocessor implementation, GICD_ICENABLER0 is banked for each connected
processor. This register holds the Clear-enable bits for interrupts 0-31.

##### 4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn
The GICD_ISPENDRs provide a Set-pending bit for each interrupt supported by the GIC.
Writing 1 to a Set-pending bit sets the status of the corresponding peripheral interrupt to
pending. Reading a bit identifies whether the interrupt is pending.

In a multiprocessor implementation, GICD_ISPENDR0 is banked for each connected
processor. This register holds the Set-pending bits for interrupts 0-31.

For SPIs and PPIs
Writes 
0 		Has no effect.
1 		The effect depends on whether the interrupt is edge-triggered or
		level-sensitive.

__Edge-triggered__
Changes the status of the corresponding interrupt to:
• pending if it was previously inactive
• active and pending if it was previously active.
Has no effect if the interrupt is already pendinga.

__Level sensitive__
If the corresponding interrupt is not pendinga, changes the status
of the corresponding interrupt to:
• pending if it was previously inactive
• active and pending if it was previously active.

If the interrupt is already pendinga:
• because of a write to the GICD_ISPENDR, the write has
no effect
• because the corresponding interrupt signal is asserted, the
write has no effect on the status of the interrupt, but the
interrupt remains pendinga if the interrupt signal is
deasserted.

##### 4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn
The GICD_ICPENDRs provide a Clear-pending bit for each interrupt supported by the GIC.
Writing 1 to a Clear-pending bit clears the pending state of the corresponding peripheral
interrupt. Reading a bit identifies whether the interrupt is pending

In a multiprocessor implementation, GICD_ICPENDR0 is banked for each connected
processor. This register holds the Clear-pending bits for interrupts 0-31.

##### 4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn
The GICD_ISACTIVERs provide a Set-active bit for each interrupt that the GIC supports.
Writing to a Set-active bit Activates the corresponding interrupt. __These registers are used when preserving and restoring GIC state__

In a multiprocessor implementation, GICD_ISACTIVER0 is banked for each connected
processor. This register holds the Set-active bits for interrupts 0-31.

##### 4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn
The GICD_ICACTIVERs provide a Clear-active bit for each interrupt that the GIC
supports. Writing to a Clear-active bit Deactivates the corresponding interrupt. These
registers are used when preserving and restoring GIC state.

In a multiprocessor implementation, GICD_ICACTIVER0 is banked for each connected
processor. This register holds the Clear-active bits for interrupts 0-31.

##### 4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn
The GICD_IPRIORITYRs __provide an 8-bit priority field for each interrupt__ supported by the
GIC. This field stores the priority of the corresponding interrupt.

A GIC might implement fewer than eight priority bits, but must implement at least bits [7:4]
of each field. In each field, unimplemented bits are RAZ/WI. see [3.3 Interrupt prioritization]
我们可以实现CPU Interface 的Group level.

In a multiprocessor implementation, GICD_IPRIORITYR0 to GICD_IPRIORITYR7 are
banked for each connected processor. These registers hold the Priority fields for interrupts
0-31.

Fixme [Figure 4-13 GICD_IPRIORITYR bit assignments] 图片Page104

##### 4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn
The GICD_ITARGETSRs __provide an 8-bit CPU targets field for each interrupt supported__
by the GIC. __This field stores the list of target processors for the interrupt.__ That is, it holds
the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
has sufficient priority.

In a multiprocessor implementation, GICD_ITARGETSR0 to GICD_ITARGETSR7 are
banked for each connected processor. These registers hold the CPU targets fields for
interrupts 0-31.

Fixme [Figure 4-14 GICD_ITARGETSR bit assignments] 图片Page106

Table 4-17 shows how each bit of a CPU targets field targets the interrupt at one of the CPU interfaces.
Fixme [Table 4-17 Meaning of CPU targets field bit values] 图片Page107


Software can write to an GICD_ITARGETSR at any time.  （对Active无效，对pending 的有效）
Any change to a CPU targets field value:
• Has no effect on any active interrupt. This means that removing a CPU interface from a targets list does not
cancel an active state for that interrupt on that CPU interface.
• Has an effect on any pending interrupts. This means:
	— adding a CPU interface to the target list of a pending interrupt makes that interrupt pending on that
	CPU interface
	— removing a CPU interface from the target list of a pending interrupt removes the pending state of that
	interrupt on that CPU interface
• If it applies to an interrupt that is active and pending, does not change the interrupt targets until the active
status is cleared.	

##### 4.3.13 Interrupt Configuration Registers, GICD_ICFGRn
__The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC__.
This field identifies whether the corresponding interrupt is __edge-triggered or level-sensitive.__

Fixme [Figure 4-15 GICD_ICFGR bit assignments] 图片Page109

For SGIs, Int_config fields are read-only, meaning that GICD_ICFGR0 is read-only.
Before changing the value of a programmable Int_config field, software must disable the
corresponding interrupt, otherwise GIC behavior is UNPREDICTABLE.

These registers are available in all configurations of the GIC. If the GIC implements the
Security Extensions these registers are Common.
In a multiprocessor implementation, if bit[1] of the Int_config field for any PPI is
programmable then GICD_ICFGR1 is banked for each connected processor. This register
holds the Int_config fields for the PPIs, interrupts 16-31.

BITS        Name                        Function
[2F+1:2F] 	Int_config, field F 		For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
										0 Corresponding interrupt is level-sensitive.
										1 Corresponding interrupt is edge-triggered.
										Int_config[0], the least significant bit, bit [2F], is reserved, but see Table 4-19 for the encoding of
										this bit on some early implementations of this GIC architecture.
										
										For SGIs:
										Int_config[1] Not programmable, RAO/WI.
										
										For PPIs and SPIs:
										Int_config[1] For SPIs, this bit is programmable.a For PPIs it is IMPLEMENTATION DEFINED
										whether this bit is programmable. A read of this bit always returns the correct value
										to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.


##### 4.3.14 Non-secure Access Control Registers, GICD_NSACRn
The GICD_NSACRs enable Secure software to permit Non-secure software on a particular
processor to create and manage Group 0 interrupts. They provide an access control for each
implemented interrupt.

The GICD_NSACRn registers do not support PPI accesses, meaning that GICD_NSACR0 bits [31:16] are
RAZ/WI.

Fixme [Figure 4-16 GICD_NSACR bit assignments] 图片Page111

BITS            Name                    Function
[2F+1:2F] 		NS_access, Field F 		If the corresponding interrupt does not support configurable Non-secure access, the field is
										RAZ/WI. Otherwise, the field is RW and configures the level of Non-secure access permitted
										when the interrupt is in Group 0. If the interrupt is in Group 1, this field is ignored. The possible
										values of the field are:

										0b00 No Non-secure access is permitted to fields associated with the corresponding
										interrupt.

										0b01 Non-secure write access is permitted to fields associated with the corresponding
										interrupt in the GICD_ISPENDRn registers. A Non-secure write access to
										GICD_SGIR is permitted to generate a Group 0 SGI for the corresponding
										interrupt.

										0b10 Adds Non-secure write access permission to fields associated with the
										corresponding interrupt in the GICD_ICPENDRn registers. Also adds
										Non-secure read access permission to fields associated with the corresponding
										interrupt in the GICD_ISACTIVERn and GICD_ICACTIVERn registers.

										0b11 Adds Non-secure read and write access permission to fields associated with the
										corresponding interrupt in the GICD_ITARGETSRn registers


##### 4.3.15 Software Generated Interrupt Register, GICD_SGIR										
This register is available in all configurations of the GIC. If the GIC implements the
Security Extensions(read GICD_TYPER) this register is Common.
The NSATT field, bit [15], is implemented only if the GIC implements the Security
Extensions.

Fixme [Figure 4-17 GICD_SGIR bit assignments] 图片Page113



Bits 		Name 				Function
[31:26] 	- 					reserved.
[25:24] 	TargetListFilter 	Determines how the distributor must process the requested SGI:
								0b00 Forward the interrupt to the CPU interfaces specified in the CPUTargetList fielda.
								0b01 Forward the interrupt to all CPU interfaces except that of the processor that requested the
								interrupt.
								0b10 Forward the interrupt only to the CPU interface of the processor that requested the
								interrupt.
								0b11 Reserved.
[23:16] 	CPUTargetList 		When TargetList Filter = 0b00, defines the CPU interfaces to which the Distributor must forward the
								interrupt.
								Each bit of CPUTargetList[7:0] refers to the corresponding CPU interface, for example
								CPUTargetList[0] corresponds to CPU interface 0. Setting a bit to 1 indicates that the interrupt must be
								forwarded to the corresponding interface.
								If this field is 0x00 when TargetListFilter is 0b00, the Distributor does not forward the interrupt to any
								CPU interface.
[15] 		NSATT 				Implemented only if the GIC includes the Security Extensions.
								Specifies the required security value of the SGI:
								0 Forward the SGI specified in the SGIINTID field to a specified CPU interface only if the
								SGI is configured as Group 0 on that interface.
								1 Forward the SGI specified in the SGIINTID field to a specified CPU interfaces only if
								the SGI is configured as Group 1 on that interface.
								This field is writable only by a Secure access. Any Non-secure write to the GICD_SGIR generates an
								SGI only if the specified SGI is programmed as Group 1, regardless of the value of bit[15] of the write.
								See SGI generation when the GIC implements the Security Extensions for more information.
								Note
								If GIC does not implement the Security Extensions, this field is reserved.
[3:0] 		SGIINTID 			The Interrupt ID of the SGI to forward to the specified CPU interfaces. The value of this field is the
								Interrupt ID, in the range 0-15, for example a value of 0b0011 specifies Interrupt ID 3.						

__SGI generation when the GIC implements the Security Extensions__
If the GIC implements the Security Extensions, whether an SGI is forwarded to a processor specified in the write
to the GICD_SGIR depends on:
• whether the write to the GICD_SGIR is Group 0 (Secure) or Group 1 (Non-secure)
• for a Secure write to the GICD_SGIR, the value of the GICD_SGIR.NSATT bit
• whether the specified SGI is configured as Group 0 (Secure) or Group 1 (Non-secure) on the targeted
processor.

Fixme [Table 4-22 Truth table for sending an SGI to a target processor] Page 114

##### 4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn
The GICD_CPENDSGIRs provide a clear-pending bit for each supported SGI and source
processor combination. When a processor writes a 1 to a clear-pending bit, the pending state
of the corresponding SGI for the corresponding source processor is removed, and no longer
targets the processor performing the write.

Note
• __In a multiprocessor implementation, the processor accessing the register can change the SGI pending status only on the corresponding interface. Changing the pending status of an SGI for one target processor does not affect the status of that SGI on any other processor.__
• PPIs and SPIs both use the Interrupt Clear-Pending registers, GICD_ICPENDRn

These registers are present only in GICv2. The register locations are reserved in GICv1.In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.

Four SGI Clear-Pending registers are implemented.each register contains eight clear-pending bits for each of four SGIs.
In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.

一共四个 GICD_CPENDSGIR寄存器，每个寄存器含有四个8 bits，分别代表了四个SGIs。

Fixme [Figure 4-18 GICD_CPENDSGIR bit assignments] Page 115

Bits 						Name 						Function
[8y+7:8y], for y=0 to 3     SGI x Clear-pending bits  	For each bit:
														Reads 	0 SGI x from the corresponding processor is not pendinga.
																1 SGI x from the corresponding processor is pendinga.
														Writes 	0 Has no effect.
																1 Removes the pending state of SGI x for the corresponding processor
														Note
														All accesses relate only to SGIs that target the processor making the access.



##### 4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn
The GICD_SPENDSGIRn registers provide a set-pending bit for each supported SGI and
source processor combination. When a processor writes a 1 to a set-pending bit, the pending
state is applied to the corresponding SGI for the corresponding source processor.

Fixme [Figure 4-19 GICD_SPENDSGIR bit assignments] page 117

Bits Name Function
[8y+7:8y], for y=0 to 3   SGI x Set-pending bits	For each bit:
													Reads 	0 SGI x for the corresponding processor is not pendinga.
														  	1 SGI x for the corresponding processor is pendinga.
													Writes 	0 Has no effect.
															1 Adds the pending state of SGI x for the corresponding processor,
															if it is not already pending. If SGI x is already pending for the
															corresponding processor then the write has no effect.
													
													Note
													All accesses relate only to SGIs that target the processor making the access.

##### 4.3.18 Identification registers
This architecture specification defines offsets 0xFD0-0xFFC in the Distributor register map as a read-only
identification register space.

Fixme [Table 4-25 The GIC identification register space] page119

__Peripheral ID2 Register, ICPIDR2__
Fixme [Figure 4-20 ICPIDR2 bit assignments] page119


Bits 	Name 		Function
[7:4] 	ArchRev 	Revision field for the GIC architecture. The value of this field depends on the GIC architecture version:
					• 0x1 for GICv1
					• 0x2 for GICv2.

#### 4.4 CPU interface register descriptions

##### 4.4.1 CPU Interface Control Register, GICC_CTLR
Enables the signaling of interrupts by the CPU interface to the connected processor, and
provides additional top-level control of the CPU interface. In a GICv2 implementation, this
includes control of the end of interrupt (EOI) behavior.

有几种类型的结构：
__for a GICv1 implementation, for__
• an implementation that does not include the Security Extensions
• the Non-secure copy of the register, in an implementation that includes the Security Extensions.
Fixme [Figure 4-22 GICC_CTLR bit assignments, GICv1 without Security Extensions or Non-secure] page 126

__a GIC v2 implementation that includes the Security Extensions, for the Non-secure copy of the register__
Fixme [Figure 4-23 GICC_CTLR bit assignments, GICv2 with Security Extensions, Non-secure copy] page 126

Bits 		Name 			Function
[9] 		EOImodeNS 		Controls the behavior of Non-secure accesses to the GICC_EOIR and GICC_DIR registers:
							0 	GICC_EOIR has both priority drop and deactivate interrupt functionality.
								Accesses to the GICC_DIR are UNPREDICTABLE.
							1 	GICC_EOIR has priority drop functionality only. The GICC_DIR register has
								deactivate interrupt functionality.

[6] 		IRQBypDisGrp1 	When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the
							bypass IRQ signal is signaled to the processor:
							0 	Bypass IRQ signal is signaled to the processor
							1 	Bypass IRQ signal is not signaled to the processor.

[5] 		FIQBypDisGrp1 	When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the
							bypass FIQ signal is signaled to the processor:
							0 	Bypass FIQ signal is signaled to the processor
							1 	Bypass FIQ signal is not signaled to the processor.

[0] 		EnableGrp1 		Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor.
							0 Disable signaling of interrupts
							1 Enable signaling of interrupts.
							Note
							When this bit is set to 0, the CPU interface ignores any pending Group 1 interrupt forwarded to
							it. When this bit is set to 1, the CPU interface starts to process pending Group 1 interrupts that are
							forwarded to it. There is a small but finite time required for a change to take effect.
					
__Security Extensions, for the Secure copy of the register__
• a GICv2 implementation, for:
— an implementation that does not include the Security Extensions
— the Secure copy of the register, in an implementation that includes the Security Extensions
• a GICv1 implementation that includes the Security Extensions, for the Secure copy of the register

Fixme [Figure 4-24 GICC_CTLR bit assignments, GICv2 without Security Extensions or Secure] page 128


Bits 		Name 			Function
[10] 		EOImodeNS 		Alias of EOImodeNS from the Non-secure copy of this register, see Table 4-30 on page 4-126.
							In a GICv2 implementation that does not include the Security Extensions, and in a GICv1
							implementation, this bit is reserved.

[9] 		EOImodeS 		Controls the behavior of accesses to GICC_EOIR and GICC_DIR registers. In a GIC implementation
							that includes the Security Extensions, this control applies only to Secure accesses, and the EOImodeNS
							bit controls the behavior of Non-secure accesses to these registers:
							0 		GICC_EOIR has both priority drop and deactivate interrupt functionality. Accesses to
									the GICC_DIR are UNPREDICTABLE.
							1 		GICC_EOIR has priority drop functionality only. GICC_DIR has deactivate interrupt
									functionality.
							Note
							This bit is called EOImode in a GIC implementation that does not include the Security Extensions.
							In a GICv1 implementation, this bit is reserved.

[8] 		IRQBypDisGrp1 	Alias of IRQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.
							In a GICv1 implementation, this bit is reserved

[7] 		FIQBypDisGrp1	Alias of FIQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.
							In a GICv1 implementation, this bit is reserved.							

[6] 		IRQBypDisGrp0 	When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the bypass
							IRQ signal is signaled to the processor:
							0 		Bypass IRQ signal is signaled to the processor
							1 		Bypass IRQ signal is not signaled to the processor.
							In a GICv1 implementation, this bit is reserved.

[5] 		FIQBypDisGrp0	When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the bypass
							FIQ signal is signaled to the processor:
							0 		Bypass FIQ signal is signaled to the processor
							1 		Bypass FIQ signal is not signaled to the processor.
							In a GICv1 implementation, this bit is reserved.

[4] 		CBPR 			Controls whether the GICC_BPR provides common control to Group 0 and Group 1 interrupts.
							0 		To determine any preemption, use:
									• the GICC_BPR for Group 0 interrupts
									• the GICC_ABPR for Group 1 interrupts.
							1 		To determine any preemption use the GICC_BPR for both Group 0 and Group 1
									interrupts.

[3] 		FIQEn 			Controls whether the CPU interface signals Group 0 interrupts to a target processor using the FIQ or
							the IRQ signal.
							0 		Signal Group 0 interrupts using the IRQ signal.
							1 		Signal Group 0 interrupts using the FIQ signal.
							The GIC always signals Group 1 interrupts using the IRQ signal.

[2] 		AckCtl 			When the highest priority pending interrupt is a Group 1 interrupt, determines both:
							• whether a read of GICC_IAR acknowledges the interrupt, or returns a spurious interrupt ID
							• whether a read of GICC_HPPIR returns the ID of the highest priority pending interrupt, or
								returns a spurious interrupt ID.

							0 		If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR
									or the GICC_HPPIR returns an Interrupt ID of 1022. A read of the GICC_IAR does
									not acknowledge the interrupt, and has no effect on the pending status of the interrupt.
							1 		If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR
									or the GICC_HPPIR returns the Interrupt ID of the Group 1 interrupt. A read of
									GICC_IAR acknowledges and Activates the interrupt.
							In a GIC implementation that includes the Security Extensions, this control affects only the behavior
							of Secure register accesses.
							For more information, see:
							• The effect of interrupt grouping on interrupt acknowledgement on page 3-50
							• Interrupt grouping and interrupt prioritization on page 3-53
							• Behavior of writes to GICC_EOIR, GICv1 with Security Extensions on page 4-139
							• Effect of interrupt grouping and the Security Extensions on reads of the GICC_HPPIR on
							page 4-143.
							Note
							ARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where
							GICC_CTLR.AckCtl is set to 0. See Enabling and disabling the Distributor and CPU interfaces on
							page 4-77 for more information about the effects of setting this bit.

[1] 		EnableGrp1 		Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor:
							0 		Disable signaling of Group 1 interrupts.
							1 		Enable signaling of Group 1 interrupts.

[0] 		EnableGrp0 		Enable for the signaling of Group 0 interrupts by the CPU interface to the connected processor:
							0 		Disable signaling of Group 0 interrupts.
							1 		Enable signaling of Group 0 interrupts.


##### 4.4.2 Interrupt Priority Mask Register, GICC_PMR
__Provides an interrupt priority filter. Only interrupts with higher priority than the value in this register are signaled to the processor__

Fixme [Figure 4-25 GICC_PMR bit assignments] page131

##### 4.4.3 Binary Point Register, GICC_BPR
The register defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field is used to determine __interrupt preemption.__

Fixme [Figure 4-26 GICC_BPR bit assignments] page133

see:
Table 3-2 Priority grouping by binary point
Table 3-7 Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0

##### 4.4.4 Interrupt Acknowledge Register, GICC_IAR
The processor reads this register to obtain the interrupt ID of the signaled interrupt. This
read acts as an acknowledge for the interrupt.

When GICC_CTLR.AckCtl is set to 0 in a GICv2 implementation that does not include the
Security Extensions, if the highest priority pending interrupt is in Group 1, the interrupt ID
1022 is returned.

Fixme [Figure 4-27 GICC_IAR bit assignments] page135.

Bit 		Name 			Function
[31:13] 	- 				Reserved.
[12:10] 	CPUID 			__For SGIs in a multiprocessor implementation__, this field identifies the processor that
							requested the interrupt. It returns the number of the CPU interface that made the
							request, for example a value of 3 means the request was generated by a write to the
							GICD_SGIR on CPU interface 3.
							For all other interrupts this field is RAZ.
[9:0] 		Interrupt ID 	The interrupt ID.

The read returns a spurious interrupt ID of 1023 if any of the following apply:
• forwarding of interrupts by the Distributor to the CPU interface is disabled
• signaling of interrupts by the CPU interface to the connected processor is disabled
• no pending interrupt on the CPU interface has sufficient priority for the interface to signal it to the processor


A non-spurious interrupt ID returned by a read of the GICC_IAR is called a valid interrupt ID.
__When the GIC returns a valid interrupt ID to a read of the GICC_IAR it treats the read as an acknowledge of that interrupt and, as a side-effect of the read, changes the interrupt status from pending to active, or to active and pending if the pending state of the interrupt persists.__

Note
• For compatibility with possible extensions to the GIC architecture specification, ARM recommends that
software preserves the entire register value read from the GICC_IAR, and writes that value back to the
GICC_EOIR when it has completed its processing of the interrupt.
• Although multiple target processors might attempt to read the GICC_IAR at any time, in GICv2 only one
processor can obtain a valid interrupt ID, see Implications of the 1-N model on page 3-41 for more
information.


Fixme [Table 4-35 Effect of interrupt grouping and the Security Extensions on reads of GICC_IAR]Page136

##### 4.4.5 End of Interrupt Register, GICC_EOIR
A processor writes to this register to inform the CPU interface either:
• that it has completed the processing of the specified interrupt
• in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set
to 1, to indicate that the interface should perform priority drop for the specified
interrupt. See Priority drop and interrupt deactivation on page 3-38 for more information.

Fixme [Figure 4-28 GICC_EOIR bit assignments]Page138

Fixme [Table 4-36 GICC_EOIR bit assignments]Page138

For every read of a valid Interrupt ID from the GICC_IAR, the connected processor must perform a matching write
to the GICC_EOIR. The value written to the GICC_EOIR must be the interrupt ID read from the GICC_IAR.
If a read of the GICC_IAR returns the ID of a spurious interrupt, software does not have to make a corresponding
write to the GICC_EOIR. If software writes the ID of a spurious interrupt to the GICC_EOIR, the GIC ignores that
write.

__Behavior of writes to GICC_EOIR, GICv2__
In a GICv2 implementation, when GICC_CTLR.AckCtl is set to 0:
• GICC_EOIR is used for processing Group 0 interrupts
• GICC_AEOIR is used for processing Group 1 interrupts.

In a GICv2 implementation that includes the GIC Security Extensions:
• GICC_CTLR.EOImodeS controls the behavior of Secure accesses to GICC_EOIR and GICC_AEOIR
• GICC_CTLR.EOImodeNS controls the behavior of Non-secure accesses to GICC_EOIR
• when GICC_CTLR.AckCtl is set to 0:
	— a Non-secure write to GICC_EOIR must correspond to the most recent Non-secure read of GICC_IAR
	— a Secure write to the GICC_AEOIR must correspond to the most recent Secure read of the
	GICC_AIAR.

##### 4.4.6 Running Priority Register, GICC_RPR
Indicates the Running priority of the CPU interface

Fixme [Figure 4-29 GICC_RPR bit assignments] page142

##### 4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR
Indicates the Interrupt ID, and processor ID if appropriate, of the __highest priority pending__
interrupt on the CPU interface.

Fixme [Figure 4-30 GICC_HPPIR bit assignments] Page143

Bit			Name 		Description
[31:13] 	- 			Reserved.
[12:10] 	CPUID 		On a multiprocessor implementation, if the PENDINTID field returns the ID of an
						SGI, this field contains the CPUID value for that interrupt. This identifies the
						processor that generated the interrupt.
[9:0] 		PENDINTID 	The interrupt ID of the highest priority pending interrupt. See Table 4-42 on
						page 4-144 for more information about the result of Non-secure reads of the
						GICC_HPPIR when the GIC implements the Security Extensions.

##### 4.4.8 Aliased Binary Point Register, GICC_ABPR
##### 4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR
##### 4.4.10 Aliased End of Interrupt Register, GICC_AEOIR
##### 4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR
与前面对应相似

##### 4.4.12 Active Priorities Registers, GICC_APRn
主要用于做电源管理时，保存与恢复。
provide support for preserving and restoring the active priority in power-management implementations.

Although the format of these registers is IMPLEMENTATION DEFINED:
• because GICv2 guarantees the ability to save and restore all GIC state, the
GICC_APRn registers must be present in all GIC implementations
• in an implementation that includes the GIC Security Extensions, Non-secure
accesses must not affect Secure operation, and the architecture requires that these
registers are banked, to provide Secure and Non-secure copies of the registers.

##### 4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn
provide support for preserving and restoring the active priority in power-management implementation. These are separate registers for Group 1 interrupts.

##### 4.4.14 CPU Interface Identification Register, GICC_IIDR
Provides information about the implementer and revision of the CPU interface.

Fixme [Figure 4-35 GICC_IIDR bit assignments] Page 152

Fixme [Table 4-48 GICC_IIDR bit assignments] Page 152

##### 4.4.15 Deactivate Interrupt Register, GICC_DIR
When interrupt priority drop is separated from interrupt deactivation, as described in
Priority drop and interrupt deactivation on page 3-38, a write to this register __deactivates the specified interrupt.__

Fixme [Figure 4-36 GICC_DIR bit assignments] Page 153

Fixme [Table 4-49 GICC_DIR bit assignments] Page 153

Fixme [Table 4-50 Behavior of GICC_DIR writes] Page 154



### 5 GIC Support for Virtualization
#### 5.1 About implementing a GIC in a system with processor virtualization
__Any ARM processor implementation that includes the Virtualization Extensions must also include the Security Extensions.__

Fixme [Figure 5-1 Implementing the GIC with an ARM processor that supports virtualization] Page159

#### 5.2 Managing the GIC virtual CPU interface
The hypervisor, or similar software, manages the GIC virtual interface control registers, consisting of:
__List registers__
Used to define the active and pending virtual interrupts for the virtual CPU interface. The current
virtual machine accesses these interrupts indirectly, using the virtual CPU interface.

__Management registers__
Used to manage the virtual CPU interface, and to save and restore settings when switching between
virtual machines.

The hypervisor runs as Non-secure software in Hyp mode. To maintain the 1-N interrupt handling model, a hypervisor might have to migrate an interrupt from one virtual machine to another.

When it receives a physical IRQ, the hypervisor determines the required destination of the interrupt and then either:
• Processes the interrupt itself, for example if the IRQ is __a maintenance interrupt__ from the virtual CPU
interface. It then deactivates the physical interrupt.
• Generates a virtual interrupt. Depending on the interrupt priority and the targeted virtual machine, the
hypervisor takes one of the following actions:
	— If the interrupt is for the current virtual machine, updates the List registers with details of the interrupt,
	redefining the interrupts that are visible to the current virtual machine. If there is no space in the List
	registers, it saves the context to memory so the details can be added at a later stage
	— Records that the interrupt is for a different virtual machine by saving details of the interrupt as part of
	the hypervisor state associated with that virtual machine.
	— Switches to a different virtual machine that can handle the interrupt. In doing so it must save the
	interrupt state for the current virtual machine, using the information in the List registers, and
	reprogram the List registers, to indicate the interrupt state for the new virtual machine, including the
	state for the interrupt that has arrived.

The virtual machine accesses the GIC virtual CPU interface registers. These registers have the same general format
as the physical CPU interface registers, and, in a typical implementation the virtual machine believes it is accessing
a physical CPU interface.

When the virtual machine handles a virtual interrupt, it writes to the virtual CPU interface to indicate when it has
finished this processing. The virtual CPU interface signals this completion to the physical Distributor and the
physical Distributor then deactivates the interrupt.

##### 5.2.1 List registers and virtual interrupt handling
a hypervisor uses List registers to maintain the list of highest priority virtual interrupts.

记录的数据可以超过List registers数量，多余的数据存储在MEM 中。
__The total number of interrupts that are either pending, active, or active and pending, can exceed the number of List registers available.__
If this happens, the hypervisor can save one or more active interrupt entries to memory, and later restore them to the List registers，based on their priority。Therefore:
• The List registers might not include all active, or active and pending, interrupts. Virtual CPU interface
accesses by the virtual machine update the List registers, and normally an EOI request from the virtual
machine deactivates an interrupt in the list. However, the virtual machine can issue an EOI request for an
interrupt before the hypervisor restores the associated active interrupt entry into a List register. In this case,
the EOI request cannot update the List registers.

• Although the List registers might include only active interrupts, with the hypervisor maintaining any pending
interrupts in memory, a pending interrupt cannot be signaled to the virtual machine until the hypervisor adds
it to the List registers. Therefore, to minimize interrupt latency and ensure efficient virtual machine operation,
__ARM strongly recommends that the List registers contain at least one pending interrupt, provided a List register is available for this interrupt.__

##### 5.2.2 Completion of virtualized physical interrupts
ARM recommends that, for each CPU interface that corresponds to a
processor running virtual machines, the GICC_CTLR.EOImodeNS bit is set to 1. This means that hypervisor
accesses to the GICC_AEOIR register drops the running priority of the CPU interface but does not deactivate the
interrupt. After writing to the EOI register, the running priority level on the CPU interface is lower, so that
subsequent interrupts can be signaled to the processor.

ARM recommends that physical interrupt completion consists of the following separate steps:
1. EOI
2. interrupt deactivation.

These steps are explained in more detail as follows:
1. After receiving a physical interrupt, the hypervisor performs an EOI request for the physical interrupt by
writing to the GICC_EOIR or GICC_AEOIR register. After EOI, although the virtual machine has not
processed the virtual interrupt, the lower running priority of the CPU interface means that the hypervisor can
still receive new physical interrupts.
	Note
	The only interrupts that are not signaled to the hypervisor are the physical interrupts most recently subject to
	EOI. This is because the interrupts have not been deactivated. This prevents the interrupts from being
	re-signaled to the hypervisor before being processed by the virtual machine.

2. After the virtual machine completes processing the corresponding virtual interrupt, it writes to the
GICV_EOIR or GICV_AEOIR to deactivate the interrupt. This deactivates both the virtual interrupt and the
corresponding physical interrupt, provided that both of the following conditions are true:
• the GICV_CTLR.EOImode bit is set to 0
• the GICH_LRn.HW bit is set to 1.

Alternatively, if the GICV_CTLR.EOImode bit is set to 1, the virtual machine writes to the GICV_DIR
register to deactivate the interrupt.
If the GICH_LRn.HW bit is set to 0, the hypervisor must deactivate the physical interrupt itself. ARM
recommends one of the following methods for deactivating physical SGIs that are routed to a virtual machine:
• the hypervisor deactivates the SGI by writing to the GICC_DIR register after the virtual machine
writes to GICC_EOIR
• the hypervisor uses an EOI maintenance interrupt to write to the GICC_DIR register after the virtual
machine writes to GICV_EOIR, see Maintenance interrupts on page 5-164 for more information.

处理大致流程：
1. hypervisor 写GICC_AEOIR，让此IRQ 丢掉优先级，能让其他低优先级的中断能被处理
2. virtual machine 处理完后，virtual cpu 写GICV_EOIR 或 GICV_AEOIR，再写GICV_DIR （依赖GICV_CTLR.EOImode 设定是否自动完成后一步）
3. 在virtual machine 写 GICV_EOIR 后，hypervisor 用 EOI maintenance interrupt 写 GICC_DIR （GICH_LRn.HW 设定为1，自动完成此步）

##### 5.2.3 Acknowledgement and completion of virtual interrupts
To ensure system correctness when handling virtual interrupts, one of the following conditions must be true:
• All Group 0 interrupts must have a higher priority than any Group 1 interrupt. That is, there is no overlap in
the priorities allocated to Group 0 and Group 1 interrupts.
• The GICV_CTLR.AckCtl bit must be set to 0.

__ARM deprecates the use of GICC_CTLR.AckCtl and GICV_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl and GICV_CTLR.AckCtl are set to 0.__

##### 5.2.4 GIC virtual interface control interface requirements
skip

##### 5.2.5 Maintenance interrupts
__Maintenance interrupts can signal key events in the operation of a GIC that implements the Virtualization Extensions. Typically, these events are processed by the hypervisor.__

Note
• Maintenance interrupts are generated only when the global interrupt enable bit, GICH_HCR.En, is set to 1.

Maintenance interrupts are level-sensitive interrupts. Configuration bits in the GICH_HCR can be set to 1 to enable
maintenance interrupt generation when:
• Group 0 virtual interrupts are enabled/disabled
• Group 1 virtual interrupts are enabled/disabled
• There are no pending interrupts in the List registers.
• At least one EOI request occurs with no valid List register entry for the corresponding interrupt.
• There are no valid entries, or only one valid entry, in the List registers. This is an underflow condition.
• At least one List register entry has received an EOI request.

##### 5.2.6 Software-generated interrupts
__Hypervisor-generated interrupts__
A hypervisor can generate virtual interrupts that do not have a corresponding physical interrupt, by
creating an entry in the List registers with the GICH_LRn.HW bit cleared to 0. The hypervisor can
control how the interrupt appears to a virtual machine reading the GICV_IAR or GICV_AIAR
register to acknowledge the interrupt, by presenting the interrupt as:
• an SGI, with a CPUID value provided in addition to the interrupt ID
• a PPI or SPI, with the CPUID value set to 0.

The hypervisor can virtualize the CPUID value, but it must be consistent with the type of interrupt
indicated by the GICH_LRn.VirtualID field. When the EOI notification is sent to the virtual CPU
interface, only the List registers are affected, and no notification is sent to the Distributor. See List
Registers, GICH_LRn on page 5-176 for more information.

hypervisor 可以产生与硬件中断号不一致的虚拟中断，并且可以控制中断在虚拟机中呈现的形式：SGI，PPI，SPI。

__Distributor-generated interrupts__
Because the hardware interrupt deactivation mechanism does not support SGIs, the hypervisor must
virtualize SGIs originating from the Distributor in the same way as hypervisor-generated interrupts.
The hypervisor can virtualize the GICH_LRn.CPUID field, because this field is not required to be
the same as that of the original SGI. See Completion of virtualized physical interrupts on page 5-161
for more information about deactivating virtualized SGIs.

虚拟中断分发器 产生的虚拟机之间的SGIs。

##### 5.2.7 GIC Virtualization Extensions register mapping
The GIC must make these virtual interface control registers accessible in the following ways:
__Redirection through a common base address__
The memory map includes a common base address for the virtual interface control registers. Each
processor in the system can access its own GIC virtual interface control registers through this base
address. The CPUID of the processor requesting access redirects the access to the GIC virtual
interface control registers for that processor.

__Processor-specific base addresses__
In addition to the common base address, the memory map contains, for each processor in the system,
a processor-specific base address for the GIC virtual interface control registers. Any processor can
use these addresses to access its own GIC virtual interface control registers, or to access the GIC
virtual interface control registers of any other processor in the system.

Fixme [Figure 5-2 GIC virtual interface control register mappings] page166

#### 5.3 GIC virtual interface control registers
Fixme [Table 5-1 GIC virtual interface control register map] page167


##### 5.3.1 Hypervisor Control Register, GICH_HCR
This register contains control bits for the virtual CPU interface.

Fixme [Figure 5-3 GICH_HCR bit assignments] page168

Fixme [Table 5-2 GICH_HCR bit assignments] page168

Fixme [Table 5-2 GICH_HCR bit assignments] page169

##### 5.3.2 VGIC Type Register, GICH_VTR
This is a read-only register that provides the following information about the
implementation of the GIC Virtualization Extensions:
• number of priority levels supported
• number of preemption levels supported
• number of implemented List registers.

Fixme [Figure 5-4 GICH_VTR bit assignments] page170

Fixme [Table 5-3 GICH_VTR bit assignments] page170

##### 5.3.3 Virtual Machine Control Register, GICH_VMCR
Enables the hypervisor to save and restore the virtual machine view of the GIC state.

Fixme [Figure 5-5 GICH_VMCR bit assignments] page171

The GICH_VMCR is a control register that contains read and write aliases of architecture state in the virtual
machine view, enabling the hypervisor to save and restore this state with a single read or write, without accessing
the GIC virtual CPU interface registers individually.

##### 5.3.4 Maintenance Interrupt Status Register, GICH_MISR

Indicates which maintenance interrupts are asserted.

Fixme [Figure 5-6 GICH_MISR bit assignments] page172

Fixme [Table 5-5 GICH_MISR bit assignments] page172

##### 5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1
When a maintenance interrupt is received, these registers help determine which List
registers have outstanding EOI interrupts that require servicing.

Fixme [Figure 5-7 GICH_EISR0 bit assignments] page173

Fixme [Table 5-6 GICH_EISR0 bit assignments] page173

##### 5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1
These registers can be used to locate a usable List register when the hypervisor is delivering
an interrupt to a Guest OS.

Fixme [Figure 5-8 GICH_ELRSR0 bit assignments] page173

Fixme [Table 5-7 GICH_ELRSR0 bit assignments] page173

##### 5.3.7 Active Priorities Register, GICH_APR
This register tracks which preemption levels are active in the virtual CPU interface, and is
used to determine the current active priority. Corresponding bits are set in this register when
an interrupt is acknowledged, based on GICH_LRn.Priority, and the least significant set bit
is cleared on EOI.

Fixme [Figure 5-9 GICH_APR bit assignments] page175

Fixme [Table 5-8 GICH_APR bit assignments] page175

##### 5.3.8 List Registers, GICH_LRn
Provides interrupt context information for the virtual CPU interface. __A maximum of 64 List registers can be provided. The GICH_VTR.ListRegs bit defines the actual number implemented.__

Fixme [Figure 5-10 GICH_LR bit assignments] page176

Fixme [Table 5-9 GICH_LR bit assignments] page176

#### 5.4 The virtual CPU interface
A GIC virtual CPU interface signals virtual interrupts to a connected processor, The GIC virtual CPU interface registers have the same general format as the GIC physical CPU interface registers and expected behavior is that a virtual machine cannot distinguish between them.

__In particular, the virtual CPU interface uses the contents of the List registers to determine when to signal virtual interrupts.__

When a processor accesses the virtual CPU interface the List registers are updated.
• Virtual interrupts are always handled through the virtual CPU interfaces.
• On the connected processor, if the processor is in a Non-secure PL1 or PL0 mode, virtual interrupts are
signaled to the current virtual machine.
• In addition, a virtual machine can receive virtual IRQs and virtual FIQs signaled directly by the hypervisor.
These exceptions are outside the scope of this specification. A virtual machine cannot distinguish:
	— A virtual exception signaled by the GIC from a corresponding virtual exception signaled directly by the hypervisor.
	— A virtual exception from the corresponding physical exception.
• A virtual CPU interface does not require power management support, and therefore GICV_CTLR does not
implement the IRQBypDisGrp1, FIQBypDisGrp1, IRQBypDisGrp0, and FIQBypDisGrp0 bits that are
supported by GICC_CTLR

#### 5.5 GIC virtual CPU interface registers
Typically, a virtual machine is unaware of any difference between virtual interrupts and physical interrupts.

__In general, these registers have the same format as the GIC physical CPU interface registers, but they operate on the interrupt view defined primarily by the List registers.__

These registers are memory-mapped, The offset of each GICV_* register is the same as the offset of the corresponding register for the physical CPU interface.

Fixme [Table 5-10 GIC virtual CPU interface register map] page179


